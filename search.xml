<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>词根词缀</title>
      <link href="/2023/07/18/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/"/>
      <url>/2023/07/18/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1>词根词缀</h1><p><a href="https://www.bilibili.com/video/BV1Hi4y1Q7XN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">&lt;词根词缀&gt; 12大前缀+3大词性后缀_哔哩哔哩_bilibili</a></p><p>高考 3800词汇 28词根<br>四级 4500词汇 40词根<br>六级 6000词汇 60词根<br><strong>考研 5500词汇 55词根</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/en/Snipaste_2023-07-18_20-21-01.png" alt=""></p><p>所以学习，12大前缀+3大词性后缀，然后再加上后面学习的词根</p><hr><h2 id="前缀（12）—义">前缀（12）—义</h2><table><thead><tr><th>序</th><th>义</th><th>前缀</th><th>例</th></tr></thead><tbody><tr><td><u>1</u></td><td>外/出</td><td>e<br />ex<br />ef</td><td>export 出口<br />exit 出口<br />evade 逃出<br />escape 逃跑</td></tr><tr><td><u>2</u></td><td>内/进</td><td>in<br />im</td><td>inject 注射<br />invade 入侵</td></tr><tr><td>3</td><td>前</td><td>-</td><td>-</td></tr><tr><td>3.1</td><td>动态-向前</td><td>pro</td><td>promote 升职<br />iphone12 pro<br />progress 进步</td></tr><tr><td>3.2</td><td>静态-在前/预先/提前</td><td>pre</td><td>prepare 准备<br />predict 预测<br />prepay 预付</td></tr><tr><td>4</td><td>回/重新/再次</td><td>re</td><td>return 返回<br />rebuild 重建</td></tr><tr><td><u>5</u></td><td>聚集(一起/共同)</td><td>co<br />con<br />com<br />col</td><td>collaborate 合作<br />cooperate 合作<br />combine 结合<br />connect 联系</td></tr><tr><td><u>6</u></td><td>分散(分开)</td><td>di<br />dis<br />dif</td><td>divorce 离婚<br />divide 分层<br />diffuse 分心</td></tr><tr><td>7</td><td>上/超过</td><td>super<br />over<br />sur</td><td>surrealism 超现实主义<br />surpass 超过</td></tr><tr><td>8</td><td>下/不足</td><td>under<br />de<br />sub<br />sup</td><td>decrease 减少<br />subway 地铁<br />subhealth 亚健康</td></tr><tr><td><u>9</u></td><td>转移/转变</td><td>trans</td><td>transfer 转账 转会 换乘<br />translate 语言转变<br />transport 港口转变<br />transform 形式改变</td></tr><tr><td><u>10</u></td><td>相互之间</td><td>inter</td><td>internet 互联网</td></tr><tr><td>11</td><td>强调/无意义</td><td>a+双写辅音字母</td><td>accompany<br />affirm</td></tr><tr><td>12</td><td>否定前缀</td><td>un<br />in<br />im<br />dis<br />ab<br />il</td><td>unhappy<br />misunderstand<br />impossible<br />informal<br />abnormal</td></tr></tbody></table><hr><h2 id="后缀（3）—性">后缀（3）—性</h2><table><thead><tr><th>序</th><th>性</th><th>后缀</th></tr></thead><tbody><tr><td>1</td><td>动词后缀</td><td>ate(90%可能)<br />ize<br />ify<br />ish</td></tr><tr><td>2</td><td>形容词后缀</td><td>ent<br />ful<br />ous<br />al<br />ive<br />ible<br />able<br />ant</td></tr><tr><td>3</td><td>名词后缀</td><td>ion<br />tion<br />ation<br />ness<br />ity<br />ality<br />ment<br />ence<br />ance<br />ism</td></tr></tbody></table><hr><h2 id="词根">词根</h2><blockquote><p>pose form norm vis leg ceed duce claim verse<br>vade gress vent ject lect spect press</p><p>sence valu sim tain serve view tract nov radi rupt dict<br>fer clude flu scribe dens</p></blockquote><hr><ul><li><strong><u>词根1: radi=根 一下记住7个单词！</u></strong></li></ul><p>1、<strong>radi</strong>c<u>cal</u>adj. 根本的、彻底的<br>2、<u>e</u><strong>radi</strong>c<u>ate</u>v.根除</p><p>3、<strong>radi</strong><u>ate</u>v.辐射、发散；使显现<br>4、<strong>radi</strong><u>ant</u>adj.辐射的；容光焕发的</p><p>5、<strong>radi</strong>on.收音机<br>6、<strong>radi</strong>o<u>active</u>adj.放射性的<br>7、<strong>radi</strong>umn.镭</p><hr><ul><li><strong><u>词根2: pose=摆放 一下记住7个单词！</u></strong></li></ul><p>1、exposev.暴露，揭露，使显露<br>=reveal=disclose=uncover</p><p>2、composev.组成，创造，创作<br>——compositionn.作文，作品<br>——compositeadj.复合的，合成的</p><p>3、proposev.求婚，提名，提议<br>4、disposev.扔掉，处理，安排<br>Man proposes, God disposes —— 尽人事，听天命</p><p>5、opposev.反对<br>=object<br>——opponentn.敌人、对手</p><p>6、deposev.废除，罢免<br>——depositn.沉淀物，定金</p><p>7、imposev.把……强加于<br>——impose A to B</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ggw的单词本</title>
      <link href="/2023/06/17/%E5%8D%95%E8%AF%8D%E6%9C%AC/"/>
      <url>/2023/06/17/%E5%8D%95%E8%AF%8D%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pan.baidu.com/s/1p3DOBsfdou-b0gPcPm6VKw?pwd=m92j">四六级真题</a></p><p>统计：75</p><h1>单词：</h1><h2 id="A">A</h2><ul><li><strong>advent</strong><br>/'ædvent/</li></ul><p>n.出现，到来</p><p>The trend toward rationality and enlightenment was endangered long before the <u>advent</u> of the World Wide Web.</p><hr><ul><li><strong>abuse</strong><br>/əˈbjuːs/</li></ul><p>n.滥用、妄用</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to detect <u>abuses</u> of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.”</p><hr><ul><li><strong>assertion</strong><br>/əˈsɜːʃn/</li></ul><p>n.主张、断言、语气肯定的话</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast <u>assertions</u>, to connect one generalization to another.”</p><hr><ul><li><strong>alternative</strong><br>/ɔːlˈtɜːnətɪv/</li></ul><p>adj.可选择的、可替代的</p><p>They are bent on looking for an <u>alternative</u> space for escape.</p><hr><ul><li><strong>approval</strong><br>/əˈpruːv(ə)l/</li></ul><p>n.赞成、同意；认可</p><p>They are constantly seeking <u>approval</u> from their audience.</p><hr><ul><li><strong>alleviate</strong><br>/əˈliːvieɪt/</li></ul><p>vt.减轻，缓解</p><p>The findings revealed ethical leadership is precisely what <u>alleviates</u> the negative effects of  employee entitlement.</p><hr><ul><li><strong>accommodate</strong><br>/əˈkɒmədeɪt/</li></ul><p>vt.给……提供方便，通融</p><p>This means, when confronted by an entitled team member, an ethical leader is  significantly disinclined to <u>accommodate</u> their demands.</p><hr><h2 id="B">B</h2><hr><h2 id="C">C</h2><ul><li><strong>contrast</strong><br>/ˈkɒntrɑːst/</li></ul><p>vt.对比；对照</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and <u>contrast</u> assertions, to connect one generalization to another.”</p><hr><ul><li><strong>conducive</strong><br>/kənˈdjuːsɪv/</li></ul><p>adj.使容易（或有可能）发生的</p><p>It is <u>conducive</u> to critical thinking.</p><hr><ul><li><strong>celebrity</strong>-celebrition -celebrite<br>/səˈlebrəti/</li></ul><p>n.名人；名流</p><p>It has brought <u>celebrities</u> closer to their lives.</p><hr><ul><li><strong>constantly</strong><br>/ˈkɒnstəntli/</li></ul><p>agv.始终、一直、重复不断地</p><p>They are <u>constantly</u> seeking approval from their audience.</p><hr><ul><li><strong>conduct</strong><br>/kənˈdʌkt/</li></ul><p>n.组织、安排、进行、实施</p><p>It overturned all of  those habits of mind, fundamentally changing our experience of the world, affecting the  <u>conduct</u> of politics, religion, business, and culture.</p><hr><ul><li><strong>confine</strong><br>/kənˈfaɪn/</li></ul><p>vi.限制；限定</p><p>The dominance of television was not <u>confined</u> to our living rooms.</p><hr><ul><li><strong>consistent</strong>-consistently<br>/kənˈsɪstənt/</li></ul><p>adj.一贯的，始终的</p><p>I’m talking about those who <u>consistently</u> believe they deserve special  treatment and generous rewards.</p><hr><ul><li><strong>commit</strong><br>/kəˈmɪt/</li></ul><p>vi.忠于（某个人、机构等）；全心全意投入（工作、活动等）</p><p>They also hold employees  accountable for their behaviors and are genuinely <u>committed</u> to doing the right thing.</p><hr><ul><li><strong>commitment</strong><br>/kəˈmɪtmənts/</li></ul><p>n.承诺，许诺</p><p>Those who can be counted on to fulfill commitments.</p><hr><ul><li><strong>confront</strong><br>/kənˈfrʌnt/</li></ul><p>vt.面对，面临</p><p>This means, when <u>confronted</u> by an entitled team member, an ethical leader is  significantly disinclined to accommodate their demands.</p><hr><ul><li><strong>critical</strong><br>/ˈkrɪtɪkl/</li></ul><p>adj.关键的</p><p>But there’s no denying ethical leadership is at least a <u>critical</u> step in the  right direction.</p><hr><h2 id="D">D</h2><ul><li><strong>detect</strong><br>/dɪˈtekt/</li></ul><p>vt.发现、查明、察觉</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to <u>detect</u> abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.”</p><hr><ul><li><strong>diminish</strong> [*]<br>/dɪˈmɪnɪʃ/</li></ul><p>vt.减少、减弱、降低</p><p>It can lead to workplace dysfunction and  <u>diminish</u> their own job satisfaction.</p><hr><ul><li><strong>deny</strong><br>/dɪˈnaɪ/</li></ul><p>vt.拒绝，拒绝给予</p><p>I’ m not referring to employees who are legitimately  dissatisfied with their employment conditions due to, say, being <u>denied</u> fair pay or flexible  work practices.</p><hr><ul><li>**discrepancy **<br>/dɪsˈkrepənsi/</li></ul><p>n.差异，不符</p><p>As a result of that <u>discrepancy</u> between the privileges they feel they’re owed and their  inflated sense of self-worth, they don’t work as hard for their employer.</p><hr><ul><li><strong>deviate</strong><br>/ˈdiːvieɪt/</li></ul><p>vi.背离；偏离；违背</p><p>They’re also less likely to  <u>deviate</u> in how they treat employees.</p><hr><ul><li><strong>distort</strong><br>/dɪˈstɔːt/</li></ul><p>vt.扭曲，歪曲</p><p>He or she will instead point out,  constructively and tactfully, exactly how their inflated sense of deservingness is somewhat  <u>distorted</u>.</p><hr><ul><li><strong>deliver</strong><br>/dɪˈlɪvə®/</li></ul><p>vt.履行诺言，兑现</p><p>This shift away from unrealistic  expectations is successful because entitled employees feel more confident that ethical  leaders will <u>deliver</u> on their promises.</p><hr><h2 id="E">E</h2><ul><li><strong>enlightenment</strong><br>/ɪnˈlaɪtnmənt/</li></ul><p>n.启迪，指导，教导</p><p>The trend toward rationality and <u>enlightenment</u> was endangered long before the advent of the World Wide Web.</p><hr><ul><li><strong>exposition</strong><br>/ˌekspəˈzɪʃn/</li></ul><p>n.解释，阐述</p><p>As Neil Postman noted in his 1985book Amusing Ourselves to Death, the rise of television introduced not just a new medium but a new discourse: a gradual shift from a typographic culture to a photographic one, which <u>in tum</u> meant a shift from rationality to emotions, <u>exposition</u> to entertainment.</p><hr><ul><li><strong>engage</strong><br>/ɪnˈɡeɪdʒ/</li></ul><p>vt.使从事，使忙于、使参加</p><p>They are forever <u>engaged</u> in hunting for new information.</p><hr><ul><li><strong>emerge</strong><br>/ɪˈmɜːdʒ/</li></ul><p>vi.出现，浮现，露出</p><p>When it <u>emerged</u> towards the end  of the 1980s as a purely text-based medium, it was seen as a tool to pursue knowledge,  not pleasure.</p><hr><ul><li><strong>extent</strong><br>/ɪkˈstent/</li></ul><p>n.程度</p><p>The respondents had to rate the <u>extent</u> of their agreement.</p><hr><h2 id="F">F</h2><ul><li><strong>forum</strong><br>/ˈfɔːrəm/</li></ul><p>n.论坛、讨论会</p><p>It was designed as a discussion <u>forum</u> for university students.</p><hr><ul><li><strong>fulfill</strong><br>/fʊl’fɪl/</li></ul><p>vt.履行，兑现</p><p>Those who can be counted on to <u>fulfill</u> commitments.</p><hr><h2 id="G">G</h2><ul><li><strong>generalization</strong><br>/ˌdʒenrəlaɪˈzeɪʃn/</li></ul><p>n.概括；归纳；泛论</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one <u>generalization</u> to another.”</p><hr><h2 id="H">H</h2><ul><li><strong>host</strong><br>/həʊst/</li></ul><p>vt.（在与互联网连接的计算机上）存贮</p><p>Universities around the world were among the first to connect  to this new medium, which <u>hosted</u> discussion groups, informative personal or group blogs,  electronic magazines, and academic mailing lists and forums.</p><hr><h2 id="I">I</h2><ul><li><strong>initiate</strong><br>/ɪˈnɪʃieɪt/</li></ul><p>vt.开始；发起；创始</p><p>It <u>initiated</u> a change from dominance of reason to supremacy of pleasure.</p><hr><ul><li><strong>industry</strong><br>/ˈɪndəstri/</li></ul><p>n.行业</p><p>It marked a new age in the entertainment <u>industry</u>.</p><hr><ul><li><strong>irrespective</strong><br>/ɪrɪˈspektɪv/</li></ul><p>不考虑…的，不管…的</p><p>It’s an expectation that exists <u>irrespective</u> of their abilities  or levels of performance.</p><hr><h2 id="J">J</h2><hr><h2 id="K">K</h2><hr><h2 id="L">L</h2><ul><li><strong>legitimate</strong>-legitimately<br>/lɪˈdʒɪtɪmət/</li></ul><p>adj.合理的，正当的</p><p>I’ m not referring to employees who are <u>legitimately</u>  dissatisfied with their employment conditions due to, say, being denied fair pay or flexible  work practices.</p><hr><h2 id="M">M</h2><hr><h2 id="N">N</h2><hr><h2 id="O">O</h2><ul><li><strong>overgeneralization</strong><br>/ˌəʊvədʒenrəlaɪˈzeɪʃn/</li></ul><p>n.过分概括；过度泛化</p><p>It is text that enables us to “uncover lies, confusions and <u>overgeneralizations</u>, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.”</p><hr><ul><li><strong>overturn</strong><br>/ˌəʊvəˈtɜːn/</li></ul><p>vt.推翻、颠覆</p><p>It <u>overturned</u> all of  those habits of mind, fundamentally changing our experience of the world, affecting the  conduct of politics, religion, business, and culture.</p><hr><ul><li><strong>over</strong><br>/ˈəʊvə®/</li></ul><p>prep.优先于</p><p>From Facebook to Instagram, the medium refocuses our attention on videos and images,  rewarding emotional appeals - ‘like’ buttons - <u>over</u> rational ones.</p><hr><h2 id="P">P</h2><ul><li><strong>proposition</strong>-propose<br>/ˌprɒpəˈzɪʃn/</li></ul><p>n.见解；主张；观点</p><p>They do not argue with <u>propositions</u>, they argue with good looks, celebrities and  commercials.</p><p>n.提议，建议（尤指业务上的）</p><p>I’d like to put a business proposition to you. 我想向您提个业务上的建议。</p><p><strong>In my propositon</strong></p><hr><ul><li><strong>proposal</strong><br>/prəˈpəʊzl/</li></ul><p>n.提议；建议；动议</p><p>His <u>proposal</u> that the system should be changed was rejected. 他提的关于修改制度的建议被拒绝了。</p><hr><ul><li><strong>purely</strong>-pure<br>/ˈpjʊəli/</li></ul><p>adv.仅仅；完全</p><p>When it emerged towards the end  of the 1980s as a <u>purely</u> text-based medium, it was seen as a tool to pursue knowledge,  not pleasure.</p><hr><ul><li><strong>proportion</strong><br>/prəˈpɔːʃn/</li></ul><p>n.部分，比例</p><p>According to a recent study, a small but growing <u>proportion</u> of the workforce is  affected to some degree by a sense of entitlement.</p><hr><ul><li><strong>practices</strong><br>/ˈpræktɪsɪz/</li></ul><p>n.惯常做法，惯例</p><p>I’ m not referring to employees who are legitimately  dissatisfied with their employment conditions due to, say, being denied fair pay or flexible  work <u>practices</u>.</p><hr><ul><li><strong>privilege</strong><br>/ˈprɪvəlɪdʒ/</li></ul><p>n.特权，特殊待遇</p><p>As a result of that discrepancy between the <u>privileges</u> they feel they’re owed and their  inflated sense of self-worth, they don’t work as hard for their employer.</p><hr><ul><li><strong>perceive</strong><br>/pəˈsiːv/</li></ul><p>vt.将……视为，认为</p><p>This occurs because they’re <u>perceived</u> to be fair and trustworthy.</p><hr><h2 id="Q">Q</h2><ul><li><strong>quest</strong><br>/kwest/</li></ul><p>vi.探求、探索</p><p>It was viewed as a means to <u>quest</u> for knowledge.</p><hr><h2 id="R">R</h2><ul><li><strong>rationality</strong><br>/ˌræʃəˈnæləti/</li></ul><p>n.理性</p><p>The trend toward <u>rationality</u> and enlightenment was endangered long before the advent of the World Wide Web.</p><hr><ul><li><strong>render</strong><br>/ˈrendə®/</li></ul><p>vt.使成为；使变得；使处于某状态</p><p>It has <u>rendered</u> their interactions more superficial.</p><hr><ul><li><strong>religion</strong><br>/rɪˈlɪdʒən/</li></ul><p>n.宗教、宗教信仰</p><p>It overturned all of  those habits of mind, fundamentally changing our experience of the world, affecting the  conduct of politics, <u>religion</u>, business, and culture.</p><hr><ul><li><strong>regime</strong><br>/reɪˈʒiːm/</li></ul><p>n.（尤指未通过公正选举的）统治方式，统治制度，政权，政体</p><p>a <u>fascist/totalitarian/military, etc. regime</u> 法西斯、极权主义、军事等政权</p><p>n.组织方法；管理体制</p><p>Our tax <u>regime</u> is one of the most favourable in Europe. 我们的税收管理体制是欧洲最受欢迎的税收体制之一。</p><hr><ul><li><strong>reveal</strong><br>/rɪˈviːl/</li></ul><p>vt.揭示，揭露，展示</p><p>The findings <u>revealed</u> ethical leadership is precisely what alleviates the negative effects of  employee entitlement.</p><hr><ul><li><strong>rate</strong><br>/reɪt/</li></ul><p>vt.划分等级</p><p>The respondents had to <u>rate</u> the extent of their agreement.</p><hr><ul><li><strong>remedy</strong><br>/ˈremədi/</li></ul><p>n.处理方式，改进措施</p><p>The researchers, however, exercise caution by warning no one single response is the  perfect <u>remedy</u>.</p><h2 id="S">S</h2><ul><li><strong>supremacy</strong><br>/suːˈpreməsi/</li></ul><p>n.至高无上；最大权力；最高权威；最高地位</p><p>It initiated a change from dominance of reason to <u>supremacy</u> of pleasure.</p><hr><ul><li><strong>superficial</strong><br>/ˌsuːpəˈfɪʃl/</li></ul><p>adj.肤浅的</p><p>It has rendered their interactions more <u>superficial</u>.</p><hr><ul><li><strong>slack</strong><br>/slæk/</li></ul><p>adj.懈怠的；不用心的；敷衍了事的；吊儿郎当的</p><p>They prefer instead  to <u>slack</u> off.</p><hr><ul><li><strong>spoil</strong><br>/spɔɪl/</li></ul><p>vt.溺爱；娇惯；宠坏</p><p>This thereby leads them to expect the same kind of <u>spoilt</u>  treatment throughout their adult lives.</p><hr><ul><li><strong>somewhat</strong><br>/ˈsʌmwɒt/</li></ul><p>adv.有点，稍微</p><p>He or she will instead point out,  constructively and tactfully, exactly how their inflated sense of deservingness is <u>somewhat</u>  distorted.</p><hr><h2 id="T">T</h2><ul><li><strong>thesis</strong><br>/ˈθiːsɪs/</li></ul><p>n.毕业论文；学位论文</p><p>It’s telling that, while Google  began life as a PhD <u>thesis</u>, Facebook started as a tool to judge classmates, appearances.</p><hr><ul><li><strong>thereby</strong><br>/ˌðeəˈbaɪ/</li></ul><p>adv.由此，因此</p><p>This <u>thereby</u> leads them to expect the same kind of spoilt  treatment throughout their adult lives.</p><hr><ul><li><strong>timely</strong><br>/ˈtaɪmli/</li></ul><p>adv.适时地，及时地</p><p>Give them <u>timely</u> promotions.</p><h2 id="U">U</h2><ul><li><strong>uncover</strong><br>/ʌnˈkʌvə®/</li></ul><p>vt.发现；揭露；揭发</p><p>It is text that enables us to “<u>uncover</u> lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to weigh ideas, to compare and contrast assertions, to connect one generalization to another.”</p><hr><h2 id="V">V</h2><hr><h2 id="W">W</h2><ul><li><strong>weigh</strong><br>/weɪ/</li></ul><p>vt.认真考虑；权衡；斟酌</p><p>It is text that enables us to “uncover lies, confusions and overgeneralizations, and to detect abuses of logic and common sense. It also means to <u>weigh</u> ideas, to compare and contrast assertions, to connect one generalization to another.”</p><hr><h2 id="X">X</h2><hr><h2 id="Y">Y</h2><hr><h2 id="Z">Z</h2><hr><h1>词组：</h1><h2 id="A-2">A</h2><hr><h2 id="B-2">B</h2><ul><li><strong>bring about</strong></li></ul><p>引起</p><p>It <u>brought about</u> a gradual shift from cinema going to home entertainment.</p><hr><ul><li><strong>be bent on</strong></li></ul><p>专心于，致力于</p><p>They <u>are bent on</u> looking for an alternative space for escape.</p><hr><ul><li><strong>be derivered from</strong></li></ul><p>源自，源于</p><p>Reason and thought were most valued in this garden — <u>all derived</u> from the  project of the Enlightenment.</p><hr><ul><li><strong>by virtue of</strong></li></ul><p>由此，凭借</p><p>And, <u>by virtue of</u> that heightened motivation, to perform well.</p><h2 id="C-2">C</h2><hr><h2 id="D-2">D</h2><hr><h2 id="E-2">E</h2><ul><li><strong>engage in</strong></li></ul><p>从事、参与</p><p>They are forever <u>engaged in</u> hunting for new information.</p><hr><ul><li><strong>exercise caution</strong></li></ul><p>谨慎;小心;当心</p><p>The researchers, however, <u>exercise caution</u> by warning no one single response is the  perfect remedy.</p><p>It is wise to <u>exercise caution</u> in crossing the street. 过马路时采取小心的态度是明智的。</p><hr><h2 id="F-2">F</h2><hr><h2 id="G-2">G</h2><hr><h2 id="H-2">H</h2><hr><h2 id="I-2">I</h2><ul><li><strong>in turn</strong></li></ul><p>转而、轮流</p><p>As Neil Postman noted in his 1985book Amusing Ourselves to Death, the rise of television introduced not just a new medium but a new discourse: a gradual shift from a typographic culture to a photographic one, which <u>in tum</u> meant a shift from rationality to emotions, exposition to entertainment.</p><hr><ul><li><strong>It’s telling that</strong></li></ul><p>尤其说明问题的是、值得一提的是</p><p><u>It’s telling that</u>, while Google  began life as a PhD thesis, Facebook started as a tool to judge classmates, appearances.</p><hr><h2 id="K-2">K</h2><hr><h2 id="L-2">L</h2><hr><h2 id="M-2">M</h2><hr><h2 id="N-2">N</h2><hr><h2 id="O-2">O</h2><hr><h2 id="P-2">P</h2><ul><li><strong>push aganst</strong></li></ul><p>抵抗、抵制</p><p>At first, the web seemed to <u>push against</u> this trend.</p><hr><h2 id="Q-2">Q</h2><hr><h2 id="R-2">R</h2><hr><h2 id="S-2">S</h2><hr><h2 id="T-2">T</h2><hr><h2 id="U-2">U</h2><hr><h2 id="V-2">V</h2><hr><h2 id="W-2">W</h2><hr><h2 id="X-2">X</h2><hr><h2 id="Y-2">Y</h2><hr><h2 id="Z-2">Z</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作业&amp;课件管理系统</title>
      <link href="/2023/06/16/php_hcsystem/"/>
      <url>/2023/06/16/php_hcsystem/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ggw2021/php_hcsystem">ggw2021/php_hcsystem: 作业&amp;课件管理 (github.com)</a></p><h1>项目设计</h1><ol><li>注册、登录<ul><li>学生</li><li>老师</li></ul></li><li>学生功能：<ul><li>上传作业（word）</li><li>下载老师的课件（PPT）</li></ul></li><li>老师功能：<ul><li>下载学生的作业</li><li>上传课件</li></ul></li></ol><p><strong>完全由chatGPT实现代码编写</strong></p><h1>实现</h1><h2 id="数据库设计">数据库设计</h2><p>我们可以设计以下四个表：</p><ol><li><p><code>users</code> 表：用于存储用户信息，包括用户ID、用户名、密码和用户权限等字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  username VARCHAR(255) NOT NULL UNIQUE,</span><br><span class="line">  password VARCHAR(255) NOT NULL,</span><br><span class="line">  role ENUM(&#x27;student&#x27;, &#x27;teacher&#x27;) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>students</code> 表：用于存储学生的信息，包括学生ID、姓名和所属班级等字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE students (</span><br><span class="line">  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(255) NOT NULL,</span><br><span class="line">  class VARCHAR(255) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>teachers</code> 表：用于存储老师的信息，包括老师ID、姓名和所属学院等字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE teachers (</span><br><span class="line">  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(255) NOT NULL,</span><br><span class="line">  college VARCHAR(255) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>homeworks</code> 表：用于存储作业信息，包括作业ID、题目、提交时间、文件路径和提交者等字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE homeworks (</span><br><span class="line">  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  title VARCHAR(255) NOT NULL,</span><br><span class="line">  submit_time DATETIME NOT NULL,</span><br><span class="line">  file_path VARCHAR(255) NOT NULL,</span><br><span class="line">  submitter_id INT UNSIGNED NOT NULL,</span><br><span class="line">  FOREIGN KEY (submitter_id) REFERENCES users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>courses</code> 表：用来存储课件信息，包括课件ID、标题、上传时间、文件路径和上传者等字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE courses (</span><br><span class="line">  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  title VARCHAR(255) NOT NULL,</span><br><span class="line">  upload_time DATETIME NOT NULL,</span><br><span class="line">  file_path VARCHAR(255) NOT NULL,</span><br><span class="line">  uploader_id INT UNSIGNED NOT NULL,</span><br><span class="line">  FOREIGN KEY (uploader_id) REFERENCES users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p>其中，<code>users</code> 表是所有用户的基础表，它包含了所有用户的登录信息。<code>students</code> 和 <code>teachers</code> 表则分别记录学生和老师的具体信息。<code>homeworks</code> 表用于存储作业信息，并且有一个外键关联到 <code>users</code> 表中的用户ID字段，用于表示该作业是由哪个用户提交的。其中，<code>courses</code> 表也需要有一个外键关联到 <code>users</code> 表中的用户ID字段，用于表示该课件是由哪个用户上传的。</p><h2 id="PHP">PHP</h2><p><strong>文件结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">\</span><br><span class="line">│  .htaccess</span><br><span class="line">│  db.php</span><br><span class="line">│  index.php</span><br><span class="line">│  login.php</span><br><span class="line">│  logout.php</span><br><span class="line">│  nginx.htaccess</span><br><span class="line">│  README.md</span><br><span class="line">│  register.php</span><br><span class="line">│  student.php</span><br><span class="line">│  student_download.php</span><br><span class="line">│  student_upload.php</span><br><span class="line">│  teacher.php</span><br><span class="line">│  teacher_download.php</span><br><span class="line">│  teacher_upload.php</span><br><span class="line">│  xpl.sql</span><br><span class="line">│</span><br><span class="line">├─css# 本项目没有做这块内容</span><br><span class="line">├─data</span><br><span class="line">│  ├─courses# 老师上传的课件</span><br><span class="line">│  └─homeworks# 学生上传的作业</span><br><span class="line">└─js# 本项目没有做这块内容</span><br></pre></td></tr></table></figure><p><code>index.php</code>：主页</p><p><code>db.php</code>：用于数据库连接</p><p><code>register.php</code>：注册</p><p><code>login.php</code>：登录</p><p><code>student.php</code>：学生主页</p><ul><li>显示学生信息，修改学生信息</li><li>学生已经提交的作业信息</li><li>提交新文件按钮进入<code>student_upload.php</code></li><li>老师的列表，点击老师的名字，可以进入这个老师相关的<code>student_download.php</code>，让学生下载ppt</li></ul><p><code>logout.php</code>：退出登录</p><p><code>student_upload.php</code>：上传作业，word格式</p><p><code>student_download.php</code>：根据<code>student.php</code>点击的老师，显示该老师上传的文件</p><p><code>teacher.php</code>：老师主页</p><ul><li>显示老师信息</li><li>老师已经上传的课件信息</li><li>提交新文件按钮进入<code>student_upload.php</code></li><li>学生的列表，点击学生的名字，可以进入这个学生相关的<code>teacher_download.php</code>，让老师下载学生的作业</li></ul><p><code>teacher_upload.php</code>：上传课件，ppt格式</p><p><code>teacher_download.php</code>：根据<code>teacher.php</code>点击的学生，显示该学生上传的作业</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程课设</title>
      <link href="/2023/05/31/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/05/31/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<p>使用：直接解压运行 <strong>游戏编程课设.exe</strong> 即可</p><h1>一、游戏策划</h1><p><strong>游戏类型</strong>：2D横版游戏</p><p><strong>画风</strong>：像素风</p><p><strong>游戏概念和设计</strong>：玩家操纵主人公闯关打怪，最终取得游戏胜利</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_15-59-22.png" alt=""></p><p><strong>游戏规则</strong>：</p><ol><li>主角需要杀死所有怪物来获取他们身上的金币，以及收集散落的金币，来打开通往下一关卡的大门；</li><li>主角有初始血量6点，但是血量无法回复；通过当前关卡将会恢复所有血量；</li><li>主角可以左右移动，可以二段跳<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/GIF-2023-05-31-16-12-44.gif" alt=""></li><li>主角具有三种攻击方式：<ul><li>普通攻击：可以打中一定范围内的敌人，攻击频率高，无后摇，可以随意移动，但是伤害较低<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/GIF-2023-05-31-16-21-36.gif" alt=""></li><li>横扫：只有在地面或平台上才能发动，且攻击期间完全无法操作，前摇时间长，限制大，但是伤害较高<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/GIF-2023-05-31-16-19-18.gif" alt=""></li><li>下砸：只有在空中才能发动，且攻击期间完全无法操作，前摇时间长，限制较大，可以利用前端攻击敌人，较灵活，伤害一般<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/GIF-2023-05-31-16-24-00.gif" alt=""></li></ul></li><li>主角收到攻击不会产生僵直，受到攻击后，一段时间内免疫伤害；</li><li>场景内会有固定数量的怪物；击杀怪物必定会掉落金币；怪物一共有两种，Rat 和 Bat，他们在自己的领域范围内随机移动，一旦主角进入他们的察觉范围后，他们会警觉并且追击主角，追击过程中会增加移动速度；主角脱离察觉范围后，怪物会丢失目标，并回到自己的领地；怪物收到攻击会有一定僵直。</li><li>游戏特殊场景：<ul><li>地刺：持续对人物造成伤害。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-32-27.png" alt=""></li><li>移动平台：可以规律移动自身的位置。</li><li>门：需要集齐指定数量的金币才能进入。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-31-05.png" alt=""></li><li>单向平台：从下方可以直接闯过，从上方需要主角操作（按<code>S</code>）才能通过。</li></ul></li><li>选项菜单：<ul><li>开局有主菜单<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-33-41.png" alt=""></li><li>游戏中有暂停菜单<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-33-15.png" alt=""></li></ul></li></ol><p><strong>测试和反馈</strong>：开发者测试游戏，以及内测游戏(alpha)</p><h1>二、实现过程</h1><p><strong>查找素材</strong>：在各大平台上查找一些开源素材</p><p><a href="https://itch.io/game-assets">Top game assets - itch.io</a></p><p><a href="https://www.bilibili.com/video/BV1m7411d7Jb?t=52.3">B站死亡细胞素材</a></p><p><strong>游戏引擎</strong>：Unity3D 2021版LTS</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-06-01_08-16-46.png" alt=""></p><p><strong>主要文件结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Assets</span><br><span class="line">├─Animations动画</span><br><span class="line">│  ├─Bat</span><br><span class="line">│  ├─Coin</span><br><span class="line">│  ├─FontDie</span><br><span class="line">│  ├─FontPoint</span><br><span class="line">│  ├─MainCamera</span><br><span class="line">│  ├─Player</span><br><span class="line">│  ├─Rat</span><br><span class="line">│  └─Soul</span><br><span class="line">├─Fonts字体文件</span><br><span class="line">├─Material材质</span><br><span class="line">├─Prefabs预制件</span><br><span class="line">├─Resources声音资源</span><br><span class="line">├─Scenes游戏场景</span><br><span class="line">├─Scripts游戏脚本</span><br><span class="line">├─Sprites精灵图</span><br><span class="line">│  ├─Enemys</span><br><span class="line">│  ├─Player</span><br><span class="line">│  └─Scences</span><br><span class="line">└─TileMaps瓦片地图</span><br></pre></td></tr></table></figure><p><strong>游戏脚本</strong>：语言C#</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>BackGroungFollow.cs</td><td>背景视差效果</td></tr><tr><td>BloodEffect.cs</td><td>血液粒子效果销毁</td></tr><tr><td>CameraFollow.cs</td><td>摄像机跟随</td></tr><tr><td>CameraShake.cs</td><td>相机抖动</td></tr><tr><td>CoinItem.cs</td><td>吃金币效果</td></tr><tr><td>CoinToDoor.cs</td><td>金币投入门中</td></tr><tr><td>CoinUi.cs</td><td>金币UI部分</td></tr><tr><td>DoorToNextLevel.cs</td><td>传送到下一关的门</td></tr><tr><td>Enemy.cs</td><td>敌人的抽象类</td></tr><tr><td>EnemyBat.cs</td><td>蝙蝠</td></tr><tr><td>EnemyRat.cs</td><td>老鼠</td></tr><tr><td>FloatPointBase.cs</td><td>浮动的文字</td></tr><tr><td>GameController.cs</td><td>游戏控制</td></tr><tr><td>HealthBar.cs</td><td>血条UI部分</td></tr><tr><td>MainMenu.cs</td><td>主菜单</td></tr><tr><td>MovingPlatform.cs</td><td>移动平台</td></tr><tr><td>PauseMenu.cs</td><td>暂停菜单</td></tr><tr><td>PlayerController.cs</td><td>主角操作控制</td></tr><tr><td>PlayerHealth.cs</td><td>主角血量</td></tr><tr><td>PlayerSlam.cs</td><td>主角普通攻击</td></tr><tr><td>PlayerSpin.cs</td><td>主角下砸</td></tr><tr><td>PlayerSweep.cs</td><td>主角横扫</td></tr><tr><td>SoundManager.cs</td><td>游戏音效</td></tr><tr><td>Spike.cs</td><td>地刺</td></tr><tr><td>UIManager.cs</td><td>UI跟随门</td></tr></tbody></table><p><strong>主要部分的具体实现</strong>：</p><ul><li><p><strong>人物</strong></p><ol><li>人物站立：给人物加上钢体组件，设置动画Idle，设置碰撞框，加上地面并设置碰撞框<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-35-59.png" alt=""></li><li>人物左右移动<code>A D</code>：人物具有初始速度属性，按下<code>A</code>或<code>D</code>可以给角色加一个左右的向量，再乘上初始速度来实现移动。设置动画，以及切换动画的转向。</li><li>二段跳<code>Space</code>：设置动画逻辑，在空中可以额外跳跃一次，接触地面可以一段跳，并且允许二段跳。</li><li>攻击<code>J K L</code>：设置攻击子对象，给子对象设置攻击碰撞判定框，并编写脚本来实现判定的出现和消失。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-37-35.png" alt=""><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-38-31.png" alt=""><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-39-38.png" alt=""></li><li>交互<code>E</code>：在门内可以并按下E可以完成投币或者进入门的操作</li></ol></li><li><p><strong>敌人</strong><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-41-56.png" alt=""></p><ol><li>设置动画逻辑</li><li>编写脚本</li><li>调试参数</li></ol></li><li><p><strong>门，金币，地刺</strong><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-42-54.png" alt=""></p><ol><li>设置碰撞判定</li><li>编写脚本</li><li>设置参数</li></ol></li><li><p><strong>声音控制</strong></p><ol><li>编写脚本，将函数暴露</li><li>需要触发声音时，调用播放声音函数。</li></ol></li><li><p><strong>地图绘制</strong><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-47-41.png" alt=""><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-31_16-48-34.png" alt=""></p><ol><li>摆放做好的预制件</li><li>使用瓦片地图绘制</li></ol></li><li><p><strong>动画切换</strong><br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-06-01_08-04-22.png" alt=""></p><ol><li>设置好参数（bool 或者 触发器）</li><li>在脚本中实现动画参数的变化</li></ol></li><li><p><strong>单向平台</strong></p><ol><li>添加组件<code>Platform Effect 2D</code>实现单向穿过</li><li>编写脚本实现按键穿过（暂时修改Player碰撞层级为其他，穿过后修改回来）</li></ol></li><li><p><strong>受伤相机震动</strong></p><ol><li>录制相机抖动动画</li><li>设置好动画控制器</li><li>编写脚本触发</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 2D游戏开发</title>
      <link href="/2023/05/23/Unity%202D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2023/05/23/Unity%202D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1sE411L7kV/?spm_id_from=333.788&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">【Unity 2D游戏开发教程】哔哩哔哩_bilibili</a></p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>shift + 空格</td><td>局部工作区全屏、恢复</td></tr><tr><td>鼠标滚轮滚动</td><td>场景放大缩小</td></tr><tr><td>鼠标滚轮按住</td><td>变成小手，类似ps</td></tr><tr><td>鼠标右键</td><td>移动视角（旋转）</td></tr><tr><td>在场景中选中某个object按delete</td><td>删除</td></tr><tr><td>ctrl + D</td><td>复制对象</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─Assets    </span><br><span class="line">    ├─Animations</span><br><span class="line">    ├─Materials</span><br><span class="line">    ├─Prefabs</span><br><span class="line">    ├─Scripts</span><br><span class="line">    ├─Sences</span><br><span class="line">    └─Sprites</span><br></pre></td></tr></table></figure><p>添加组件rect修改锚定点</p><p>组件：</p><p>Rigidbody 2D钢体</p><p>void FixedUpdate()</p><p>Input.GetAxisRaw(“Horizontal”); -1, 0, 1</p><p>Input.GetAxis(“Horizontal”); 平滑变化</p><p>【Unity 2D游戏开发教程】</p><h2 id="第1课-如何在Unity中快速导入序列帧动画-Aseprite动画帧导出">第1课 如何在Unity中快速导入序列帧动画 Aseprite动画帧导出</h2><p>切割</p><p>画像素动画的软件Aseprite</p><p>多张图片拖入会被识别为动画</p><h2 id="第2课-如何在Unity中实现Player左右移动-2D-Movement">第2课 如何在Unity中实现Player左右移动 2D Movement</h2><p>加钢体Rigidbody 2D：碰撞检测改为连续检测，睡眠模式改成不睡眠，忽略z轴</p><p>加Capsule Collider 2D：</p><p>加Box Collider 2D：设置为可触发</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3课-如何在Unity中实现Player移动时Idle和Run动画切换">第3课 如何在Unity中实现Player移动时Idle和Run动画切换</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Flip();</span><br><span class="line">        Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4课-如何在Unity中实现Player跳跃Jump功能">第4课 如何在Unity中实现Player跳跃Jump功能</h2><p>Project settings -&gt; Input Manager：查看输入</p><p>只有在地面才能跳</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Flip();</span><br><span class="line">        Run();</span><br><span class="line">        Jump();</span><br><span class="line">        CheckGround();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>));</span><br><span class="line">        Debug.Log(isGround);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround &amp;&amp; Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">            myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5课-如何在Unity中实现Player移动跳跃时Jump-Fall-Idle-Run动">第5课 如何在Unity中实现Player移动跳跃时Jump, Fall, Idle, Run动</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Flip();</span><br><span class="line">        Run();</span><br><span class="line">        Jump();</span><br><span class="line">        CheckGround();</span><br><span class="line">        SwitchAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>));</span><br><span class="line">        Debug.Log(isGround);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround &amp;&amp; Input.GetButton(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">            myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第6课-如何在Unity中实现Player二段跳跃Double-Jump">第6课 如何在Unity中实现Player二段跳跃Double Jump</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> doubleJupmSpeed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canDoubleJump;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Flip();</span><br><span class="line">        Run();</span><br><span class="line">        Jump();</span><br><span class="line">        CheckGround();</span><br><span class="line">        SwitchAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>));</span><br><span class="line">        Debug.Log(isGround);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">                canDoubleJump = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (canDoubleJump)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                canDoubleJump = <span class="literal">false</span>;</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, doubleJupmSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;DoubleJump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第7课-如何在Unity中实现人物攻击Player-Attack（动画篇）">第7课 如何在Unity中实现人物攻击Player Attack（动画篇）</h2><p>恢复需要延迟时间，所以不需要置零了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> doubleJupmSpeed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canDoubleJump;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Flip();</span><br><span class="line">        Run();</span><br><span class="line">        Jump();</span><br><span class="line">        Attack();</span><br><span class="line">        CheckGround();</span><br><span class="line">        SwitchAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">                canDoubleJump = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (canDoubleJump)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                canDoubleJump = <span class="literal">false</span>;</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, doubleJupmSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetTrigger(<span class="string">&quot;Attack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;DoubleJump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第8课-如何在Unity中实现人物攻击Player-Attack（Hitbox篇）">第8课 如何在Unity中实现人物攻击Player Attack（Hitbox篇）</h2><p>PlayerAttack.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAttack</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> startTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> disableTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D collider2D;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;Animator&gt;();</span><br><span class="line">        collider2D = GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Attack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetTrigger(<span class="string">&quot;Attack&quot;</span>);</span><br><span class="line">            StartCoroutine(StartAttack());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">StartAttack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">startTime</span>)</span>;</span><br><span class="line">        collider2D.enabled = <span class="literal">true</span>;</span><br><span class="line">        StartCoroutine(DisableHitBox());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DisableHitBox</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">disableTime</span>)</span>;</span><br><span class="line">        collider2D.enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第9课-如何在Unity中实现人物攻击Player-Attack（Enemy篇）">第9课 如何在Unity中实现人物攻击Player Attack（Enemy篇）</h2><p>PlayerAttack.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Enemy&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        other.GetComponent&lt;Enemy&gt;().TakeDamege(damage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy_Bat.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy_Bat</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamege</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第10课-如何在Unity中实现敌人受伤后红色闪烁功能-Enemy-Re">第10课 如何在Unity中实现敌人受伤后红色闪烁功能 Enemy Re</h2><p>Enemy_Bat.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy_Bat</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> flashTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer sr;</span><br><span class="line">    <span class="keyword">private</span> Color oriColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        oriColor = sr.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamege</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        FlashColor(flashTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FlashColor</span>(<span class="params"><span class="built_in">float</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr.color = Color.red;</span><br><span class="line">        Invoke(<span class="string">&quot;ResetColor&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetColor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr.color = oriColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第11课-如何在Unity中实现简单敌人AI功能-Enemy-AI">第11课 如何在Unity中实现简单敌人AI功能 Enemy AI</h2><p>Enemy_Bat.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy_Bat</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> startWaitTime;</span><br><span class="line">    <span class="keyword">public</span> Transform movePose;</span><br><span class="line">    <span class="keyword">public</span> Transform leftDownPos;</span><br><span class="line">    <span class="keyword">public</span> Transform rightUpPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> waitTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        waitTime = startWaitTime;</span><br><span class="line">        movePose.position = GetRandomPos();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Update();</span><br><span class="line"></span><br><span class="line">        transform.position = Vector2.MoveTowards(transform.position, movePose.position, speed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Vector2.Distance(transform.position, movePose.position) &lt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                movePose.position = GetRandomPos();</span><br><span class="line">                waitTime = startWaitTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                waitTime -= Time.deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2 <span class="title">GetRandomPos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 rndPos = <span class="keyword">new</span> Vector2(Random.Range(leftDownPos.position.x, rightUpPos.position.x), Random.Range(leftDownPos.position.y, rightUpPos.position.y));</span><br><span class="line">        <span class="keyword">return</span> rndPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第12课-如何在Unity中实现敌人掉血的粒子特效-Enemy-Blood-Effe">第12课 如何在Unity中实现敌人掉血的粒子特效 Enemy Blood Effe</h2><p>BloodEffect.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BloodEffect</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> timeToDestory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject, timeToDestory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> flashTime;</span><br><span class="line">    <span class="keyword">public</span> GameObject bloodEffect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer sr;</span><br><span class="line">    <span class="keyword">private</span> Color oriColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        oriColor = sr.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamege</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        FlashColor(flashTime);</span><br><span class="line">        Instantiate(bloodEffect, transform.position, Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FlashColor</span>(<span class="params"><span class="built_in">float</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr.color = Color.red;</span><br><span class="line">        Invoke(<span class="string">&quot;ResetColor&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetColor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr.color = oriColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第13课-如何在Unity中实现相机跟随Player功能-Camera-Follow">第13课 如何在Unity中实现相机跟随Player功能 Camera Follow</h2><p>CameraFollow.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) <span class="comment">// 玩家还没死</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transform.position != target.position)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 targetPos = target.position;</span><br><span class="line">                transform.position = Vector3.Lerp(transform.position, targetPos, smoothing);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第14课-如何在Unity中实现相机震动抖动-Camera-Shake">第14课 如何在Unity中实现相机震动抖动 Camera Shake</h2><p>CameraShake.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraShake</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator camAnim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        camAnim.SetTrigger(<span class="string">&quot;Shake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GameController.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CameraShake camShake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamege</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        FlashColor(flashTime);</span><br><span class="line">        Instantiate(bloodEffect, transform.position, Quaternion.identity);</span><br><span class="line">        GameController.camShake.Shake();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CameraFollow.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameController.camShake = GameObject.FindGameObjectWithTag(<span class="string">&quot;CameraShake&quot;</span>).GetComponent&lt;CameraShake&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第15课-如何在Unity中限制相机的移动范围-Camera-Limit">第15课 如何在Unity中限制相机的移动范围 Camera Limit</h2><p>CameraFollow.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothing;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 minPosition;</span><br><span class="line">    <span class="keyword">public</span> Vector2 maxPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameController.camShake = GameObject.FindGameObjectWithTag(<span class="string">&quot;CameraShake&quot;</span>).GetComponent&lt;CameraShake&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) <span class="comment">// 玩家还没死</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transform.position != target.position)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 targetPos = target.position;</span><br><span class="line">                targetPos.x = Mathf.Clamp(targetPos.x, minPosition.x, maxPosition.x);</span><br><span class="line">                targetPos.y = Mathf.Clamp(targetPos.y, minPosition.y, maxPosition.y);</span><br><span class="line">                transform.position = Vector3.Lerp(transform.position, targetPos, smoothing);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCamPosLimit</span>(<span class="params">Vector2 minPos, Vector2 maxPos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        minPosition = minPos;</span><br><span class="line">        maxPosition = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第16课-如何在Unity中实现Player受伤闪烁功能">第16课 如何在Unity中实现Player受伤闪烁功能</h2><p>PlayerHealth.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerHealth</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> blinks;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Renderer myRender;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myRender = GetComponent&lt;Renderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DamagePlayer</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        BlinkPlayer(blinks, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlinkPlayer</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(DoBlink(numBlinks, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DoBlink</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numBlinks * <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myRender.enabled = !myRender.enabled;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myRender.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp; other.GetType().ToString() == <span class="string">&quot;UnityEngine.CapsuleCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (playerHealth != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                playerHealth.DamagePlayer(damage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第17课-如何在Unity中实现Player死亡功能-Player-Death">第17课 如何在Unity中实现Player死亡功能 Player Death</h2><p>解决吸墙，摩擦力导致的</p><p>新建2D材质，摩擦力置零，挂载到Player胶囊碰撞体上</p><p>死亡动画效果</p><p>PlayerHealth.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerHealth</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> blinks;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dieTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Renderer myRender;</span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myRender = GetComponent&lt;Renderer&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DamagePlayer</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetTrigger(<span class="string">&quot;Die&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;KillPlayer&quot;</span>, dieTime);</span><br><span class="line">        &#125;</span><br><span class="line">        BlinkPlayer(blinks, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KillPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlinkPlayer</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(DoBlink(numBlinks, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DoBlink</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numBlinks * <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myRender.enabled = !myRender.enabled;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myRender.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第18课-如何正确理解Unity中的Layer和Sorting-Layer">第18课 如何正确理解Unity中的Layer和Sorting Layer</h2><p>Layer：处理所有碰撞相关的内容</p><p>Sorting Layer：处理显示顺序的内容</p><p>有bug就看看layer碰撞设置</p><h2 id="第19课-如何在Unity中使用2D-TileMap功能">第19课 如何在Unity中使用2D TileMap功能</h2><p>直接加Tilemap Collider 2D效率不高，可以加一个组件Composite Collider 2D，然后钢体Body Type属性改为static静态，最后勾上Tilemap Collider 2D中的Used By Composite</p><h2 id="第20课-如何在Unity中实现Player生命值血条功能-Player-Health-B">第20课 如何在Unity中实现Player生命值血条功能 Player Health B</h2><p>HealthBar.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Text healthText;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> HealthCurrent;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> HealthMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Image healthBar;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthBar = GetComponent&lt;Image&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthBar.fillAmount = (<span class="built_in">float</span>)HealthCurrent / (<span class="built_in">float</span>)HealthMax;</span><br><span class="line">        healthText.text = HealthCurrent.ToString() + <span class="string">&quot;/&quot;</span> + HealthMax.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PlayerHealth.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerHealth</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> blinks;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dieTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Renderer myRender;</span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HealthBar.HealthMax = health;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        myRender = GetComponent&lt;Renderer&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DamagePlayer</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">        <span class="keyword">if</span> (health &lt; <span class="number">0</span>) health = <span class="number">0</span>;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetTrigger(<span class="string">&quot;Die&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;KillPlayer&quot;</span>, dieTime);</span><br><span class="line">        &#125;</span><br><span class="line">        BlinkPlayer(blinks, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KillPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlinkPlayer</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(DoBlink(numBlinks, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DoBlink</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numBlinks * <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myRender.enabled = !myRender.enabled;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myRender.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第21课-如何在Unity中实现Player受伤时屏幕红闪功能-Screen-Flas">第21课 如何在Unity中实现Player受伤时屏幕红闪功能 Screen Flas</h2><p>修改了粒子效果不显示的bug</p><p>ScreenFlash.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScreenFlash</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Image img;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">public</span> Color flashColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color defaultColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        defaultColor = img.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlashScreen</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(Flash());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Flash</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        img.color = flashColor;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">time</span>)</span>;</span><br><span class="line">        img.color = defaultColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改角色死亡还能动的bug</p><p>GameController.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> isGameAlive;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CameraShake camShake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PlayerHealth.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerHealth</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> blinks;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dieTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Renderer myRender;</span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> ScreenFlash sf;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb2d;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HealthBar.HealthMax = health;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        myRender = GetComponent&lt;Renderer&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        sf = GetComponent&lt;ScreenFlash&gt;();</span><br><span class="line">        rb2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DamagePlayer</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sf.FlashScreen();</span><br><span class="line">        health -= damage;</span><br><span class="line">        <span class="keyword">if</span> (health &lt; <span class="number">0</span>) health = <span class="number">0</span>;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rb2d.velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 速度置零</span></span><br><span class="line">            GameController.isGameAlive = <span class="literal">false</span>;</span><br><span class="line">            anim.SetTrigger(<span class="string">&quot;Die&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;KillPlayer&quot;</span>, dieTime);</span><br><span class="line">        &#125;</span><br><span class="line">        BlinkPlayer(blinks, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KillPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlinkPlayer</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(DoBlink(numBlinks, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DoBlink</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numBlinks * <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myRender.enabled = !myRender.enabled;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myRender.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PlayerContraller.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GameController.isGameAlive)</span><br><span class="line">        &#123;</span><br><span class="line">            Flip();</span><br><span class="line">            Run();</span><br><span class="line">            Jump();</span><br><span class="line">            CheckGround();</span><br><span class="line">            SwitchAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第22课-如何在Unity中实现游戏地刺陷阱功能-2D-Platform-Spikes">第22课 如何在Unity中实现游戏地刺陷阱功能 2D Platform Spikes</h2><p>Spikes.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Spikes</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerHealth playerHealth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerHealth = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;PlayerHealth&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp; other.GetType().ToString() == <span class="string">&quot;UnityEngine.PolygonCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            playerHealth.DamagePlayer(damage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PlayerHealth.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerHealth</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> blinks;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dieTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hitBoxCdTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Renderer myRender;</span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> ScreenFlash sf;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb2d;</span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D polygonCollider2D;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HealthBar.HealthMax = health;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        myRender = GetComponent&lt;Renderer&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        sf = GetComponent&lt;ScreenFlash&gt;();</span><br><span class="line">        rb2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        polygonCollider2D = GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DamagePlayer</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sf.FlashScreen();</span><br><span class="line">        health -= damage;</span><br><span class="line">        <span class="keyword">if</span> (health &lt; <span class="number">0</span>) health = <span class="number">0</span>;</span><br><span class="line">        HealthBar.HealthCurrent = health;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rb2d.velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 速度置零</span></span><br><span class="line">            GameController.isGameAlive = <span class="literal">false</span>;</span><br><span class="line">            anim.SetTrigger(<span class="string">&quot;Die&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;KillPlayer&quot;</span>, dieTime);</span><br><span class="line">        &#125;</span><br><span class="line">        BlinkPlayer(blinks, time);</span><br><span class="line">        polygonCollider2D.enabled = <span class="literal">false</span>;</span><br><span class="line">        StartCoroutine(ShowPlayerHitBox());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">ShowPlayerHitBox</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">hitBoxCdTime</span>)</span>;</span><br><span class="line">        polygonCollider2D.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KillPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlinkPlayer</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(DoBlink(numBlinks, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DoBlink</span>(<span class="params"><span class="built_in">int</span> numBlinks, <span class="built_in">float</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numBlinks * <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myRender.enabled = !myRender.enabled;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myRender.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第23课-如何在Unity中实现2D漂浮移动平台功能-Moving-Platform">第23课 如何在Unity中实现2D漂浮移动平台功能 Moving Platform</h2><p>首先如果Player在MovingPlatform下的话，是可以一起移动的，所以将这么修改</p><p>MovingPlatform.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovingPlatform</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="keyword">public</span> Transform[] movePos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> oriWaitTime;</span><br><span class="line">    <span class="keyword">private</span> Transform playerDefTransform;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        oriWaitTime = waitTime;</span><br><span class="line">        playerDefTransform = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).transform.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = Vector2.MoveTowards(transform.position, movePos[i].position, speed * Time.deltaTime);</span><br><span class="line">        <span class="keyword">if</span> (Vector2.Distance(transform.position, movePos[i].position) &lt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitTime &lt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) i = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">                waitTime = oriWaitTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                waitTime -= Time.deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp; other.GetType().ToString() == <span class="string">&quot;UnityEngine.BoxCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            other.gameObject.transform.parent = gameObject.transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp; other.GetType().ToString() == <span class="string">&quot;UnityEngine.BoxCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            other.gameObject.transform.parent = playerDefTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第24课-如何在Unity中实现单向跳跃平台功能-OneWayPlatform">第24课 如何在Unity中实现单向跳跃平台功能 OneWayPlatform</h2><p>画Tilemap的时候按住Shift是删除</p><p>实现下面可以穿过，上面不行穿过：添加组件Platform Effector 2D，Composite Collider 2D组件勾选Used By Effector</p><p>实现按下键通过，可以暂时取消碰撞</p><p>PlayerContraller.cs</p><p>自己修改了在空中也可以跳一次，以及从地面下落的动画切换</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> doubleJupmSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> restoreTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canDoubleJump;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isOnOneWayPlatform;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GameController.isGameAlive)</span><br><span class="line">        &#123;</span><br><span class="line">            Flip();</span><br><span class="line">            Run();</span><br><span class="line">            Jump();</span><br><span class="line">            CheckGround();</span><br><span class="line">            SwitchAnimation();</span><br><span class="line">            OneWayPlatformCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>))</span><br><span class="line">                || myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;MovingPlatform&quot;</span>))</span><br><span class="line">                || myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;OneWayPlatform&quot;</span>));</span><br><span class="line">        isOnOneWayPlatform = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;OneWayPlatform&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround) canDoubleJump = <span class="literal">true</span>;     <span class="comment">// 接触过地面就获得了跳一次的机会</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (canDoubleJump)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                canDoubleJump = <span class="literal">false</span>;</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, doubleJupmSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;DoubleJump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isGround &amp;&amp; !myAnim.GetBool(<span class="string">&quot;Idle&quot;</span>) </span><br><span class="line">            &amp;&amp; !myAnim.GetBool(<span class="string">&quot;DoubleFall&quot;</span>)</span><br><span class="line">            &amp;&amp; !myAnim.GetBool(<span class="string">&quot;DoubleJump&quot;</span>)</span><br><span class="line">            &amp;&amp; !myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)</span><br><span class="line">            &amp;&amp; !myAnim.GetBool(<span class="string">&quot;Attack&quot;</span>)</span><br><span class="line">            &amp;&amp; !myAnim.GetBool(<span class="string">&quot;Run&quot;</span>))   <span class="comment">// 处于站立状态，但是没有接触地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OneWayPlatformCheck</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround &amp;&amp; gameObject.layer != LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">float</span> moveY = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isOnOneWayPlatform &amp;&amp; moveY &lt; <span class="number">-0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;OneWayPlatform&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;RestorePlayerLayer&quot;</span>, restoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RestorePlayerLayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isGround &amp;&amp; gameObject.layer != LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第25课-如何在Unity中实现Player爬梯子功能-2D-Ladder">第25课 如何在Unity中实现Player爬梯子功能 2D Ladder</h2><p>自己修改了代码</p><p>梯子顶部可以和单项木板一起用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerContraller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> doubleJupmSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> climbSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> restoreTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D myFeet;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isGround;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canDoubleJump;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isOnOneWayPlatform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLadder;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isClimbing;</span><br><span class="line">    <span class="comment">//private bool isJumping;</span></span><br><span class="line">    <span class="comment">//private bool isFalling;</span></span><br><span class="line">    <span class="comment">//private bool isDoubleJumping;</span></span><br><span class="line">    <span class="comment">//private bool isDoubleFalling;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> playerGravity;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取组件</span></span><br><span class="line">        myRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        myAnim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        myFeet = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">        playerGravity = myRigidbody.gravityScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GameController.isGameAlive)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//CheckAirStatus();</span></span><br><span class="line">            Flip();</span><br><span class="line">            Run();</span><br><span class="line">            Jump();</span><br><span class="line">            Climb();</span><br><span class="line">            CheckGround();</span><br><span class="line">            CheckLadder();</span><br><span class="line">            SwitchAnimation();</span><br><span class="line">            OneWayPlatformCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右移动，需要翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;</span><br><span class="line">        <span class="keyword">if</span> (playerHasXAxisSpeed)    <span class="comment">// 有速度才需要翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &gt; <span class="number">0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.x &lt; <span class="number">-0.1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckGround</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ground&quot;</span>))</span><br><span class="line">                || myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;MovingPlatform&quot;</span>))</span><br><span class="line">                || myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;OneWayPlatform&quot;</span>));</span><br><span class="line">        isOnOneWayPlatform = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;OneWayPlatform&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckLadder</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isLadder = myFeet.IsTouchingLayers(LayerMask.GetMask(<span class="string">&quot;Ladder&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> moveDir = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        Vector2 playerVel = <span class="keyword">new</span> Vector2(moveDir * runSpeed, myRigidbody.velocity.y);</span><br><span class="line">        myRigidbody.velocity = playerVel;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> playerHasXAxisSpeed = Mathf.Abs(myRigidbody.velocity.x) &gt; Mathf.Epsilon;   <span class="comment">// Mathf.Epsilon,接近于0，但是不等于0</span></span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Run&quot;</span>, playerHasXAxisSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround) canDoubleJump = <span class="literal">true</span>;     <span class="comment">// 接触过地面就获得了跳一次的机会</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, jumpSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (canDoubleJump)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                canDoubleJump = <span class="literal">false</span>;</span><br><span class="line">                Vector2 jumpVel = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, doubleJupmSpeed);</span><br><span class="line">                myRigidbody.velocity = Vector2.up * jumpVel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Climb</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOnOneWayPlatform) isLadder = <span class="literal">false</span>;   <span class="comment">// 两个状态不同时存在。</span></span><br><span class="line">        <span class="keyword">if</span> (isLadder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> moveY = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (moveY &gt; <span class="number">0.5f</span> || moveY &lt; <span class="number">-0.5f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Climbing&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                myRigidbody.gravityScale = <span class="number">0.0f</span>;</span><br><span class="line">                myRigidbody.velocity = <span class="keyword">new</span> Vector2(myRigidbody.velocity.x, moveY * climbSpeed);</span><br><span class="line">                isClimbing = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isClimbing)</span><br><span class="line">                &#123;</span><br><span class="line">                    myRigidbody.velocity = <span class="keyword">new</span> Vector2(myRigidbody.velocity.x, <span class="number">0.0f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if (isJumping || isFalling || isDoubleJumping || isDoubleFalling)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    //myAnim.SetBool(&quot;Climbing&quot;, false);</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                <span class="comment">//else</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    //myAnim.SetBool(&quot;Climbing&quot;, false);</span></span><br><span class="line">                <span class="comment">//    myRigidbody.velocity = new Vector2(myRigidbody.velocity.x, 0.0f);</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            isClimbing = <span class="literal">false</span>;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Climbing&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myRigidbody.gravityScale = playerGravity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;Jump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Jump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Fall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (myAnim.GetBool(<span class="string">&quot;DoubleJump&quot;</span>)) <span class="comment">// 处在跳跃状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myRigidbody.velocity.y &lt; <span class="number">0.0f</span>)  <span class="comment">// 速度为0 = 达到最高点了</span></span><br><span class="line">            &#123;</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isGround)  <span class="comment">// 到地面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;DoubleFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;Idle&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if (!isGround &amp;&amp; !isLadder</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;Idle&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;DoubleFall&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;DoubleJump&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;Jump&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;Attack&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;Climbing&quot;)</span></span><br><span class="line">        <span class="comment">//    &amp;&amp; !myAnim.GetBool(&quot;Run&quot;))   // 处理抽搐的bug</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    myAnim.SetBool(&quot;Idle&quot;, false);</span></span><br><span class="line">        <span class="comment">//    myAnim.SetBool(&quot;Fall&quot;, true);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OneWayPlatformCheck</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGround &amp;&amp; gameObject.layer != LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">float</span> moveY = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isOnOneWayPlatform &amp;&amp; moveY &lt; <span class="number">-0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;OneWayPlatform&quot;</span>);</span><br><span class="line">            Invoke(<span class="string">&quot;RestorePlayerLayer&quot;</span>, restoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RestorePlayerLayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isGround &amp;&amp; gameObject.layer != LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void CheckAirStatus()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    isJumping = myAnim.GetBool(&quot;Jump&quot;);</span></span><br><span class="line">    <span class="comment">//    isFalling = myAnim.GetBool(&quot;Fall&quot;);</span></span><br><span class="line">    <span class="comment">//    isDoubleJumping = myAnim.GetBool(&quot;DoubleJump&quot;);</span></span><br><span class="line">    <span class="comment">//    isDoubleFalling = myAnim.GetBool(&quot;DoubleFall&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第26课-如何在Unity中实现Player捡起金币和怪物金币掉落功能-G">第26课 如何在Unity中实现Player捡起金币和怪物金币掉落功能 G</h2><p>没有sample选项：animation窗口右上角的小按钮 点一下 展开的菜单里 有个 show samples之类的选项 点一下就出来了</p><p>CoinItem.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoinItem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp;</span><br><span class="line">            other.GetType().ToString() == <span class="string">&quot;UnityEngine.CapsuleCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CoinUI.currentCoinQuantity += <span class="number">1</span>;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CoinUI.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoinUI</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> startCoinQuantity;</span><br><span class="line">    <span class="keyword">public</span> Text coinQuantity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> currentCoinQuantity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentCoinQuantity = startCoinQuantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinQuantity.text = currentCoinQuantity.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enemy.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject dropCoin;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(dropCoin, transform.position, Quaternion.identity);</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第27课-如何在Unity中实现Player靠近招牌时显示文字对话框功能">第27课 如何在Unity中实现Player靠近招牌时显示文字对话框功能</h2><p>Sign.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sign</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject dialogBox;</span><br><span class="line">    <span class="keyword">public</span> Text text;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> textContent;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isPlayerInSign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E) &amp;&amp; isPlayerInSign)</span><br><span class="line">        &#123;</span><br><span class="line">            text.text = textContent;</span><br><span class="line">            dialogBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp;</span><br><span class="line">            other.GetType().ToString() == <span class="string">&quot;UnityEngine.CapsuleCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isPlayerInSign = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>) &amp;&amp;</span><br><span class="line">            other.GetType().ToString() == <span class="string">&quot;UnityEngine.CapsuleCollider2D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isPlayerInSign = <span class="literal">false</span>;</span><br><span class="line">            dialogBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改名了Universal RP</p><p>超级bug，不会用</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道计算机组成原理</title>
      <link href="/2023/05/13/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/13/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=2.4&amp;p=2">【王道计算机组成原理】</a></p><h1>第一章 计算机系统概述</h1><h2 id="1-0-你好，我是计算机组成原理">1.0 你好，我是计算机组成原理</h2><ul><li><strong><u>信息化世界</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-04_21-08-48.png" alt=""></p><hr><ul><li><strong><u>大家都熟悉的硬件</u></strong></li></ul><p>CPU、内存、外存、显卡。。。</p><hr><ul><li><strong><u>计算机硬件能识别的数据</u></strong></li></ul><p>用低/高电平分别表示0/1</p><p>计算机硬件唯一能是识别的数据——二进制0/1</p><hr><ul><li><strong><u>什么是低电平/高电平？</u></strong></li></ul><p>字面意思，看划分标准，多大算高，多大算低</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-04_21-16-51.png" alt=""></p><hr><ul><li><strong><u>用电信号传递数据</u></strong></li></ul><p>低电平表示0，高电平表示1</p><hr><ul><li><strong><u>？？？</u></strong></li></ul><p>数字、文字、图像如何用二进制表示?</p><p>CPU如何对二进制数进行加减乘除?</p><p>如何存储这些二进制数的?</p><p>如何从内存中取出想要的数据?</p><p>CPU如何识别和执行我们写的程序?</p><p>to be continue…</p><hr><h2 id="1-1-计算机的发展">1.1 计算机的发展</h2><ul><li><strong><u>什么是计算机系统</u></strong></li></ul><p><em><strong>计算机系统 = 硬件 + 软件</strong></em></p><p>【硬件：计算机的实体，如主机、外设等】<br>【软件：由具有各类特殊功能的程序组成】</p><p>计算机性能的好坏取决于“软”，“硬”件功能的总和。</p><p>软件：</p><ul><li>系统软件：用来管理整个计算机系统<br>Eg：操作系统、数据库管理系统(DBMS)、标准程序库网络软件、语言处理程序、服务程序</li><li>应用软件：按任务需要编制成各个程序<br>Eg：抖音、王者荣耀、迅雷、美图秀秀</li></ul><hr><ul><li><strong><u>计算机硬件的发展</u></strong></li></ul><table><thead><tr><th>发展阶段</th><th>时间</th><th><u>逻辑元件</u></th><th>速度(次/秒)</th><th>内存</th><th>外存</th></tr></thead><tbody><tr><td>第一代</td><td>1946-1957</td><td><strong>电子管</strong></td><td>几千-几万</td><td>汞延迟线、磁鼓</td><td>穿孔卡片、纸袋</td></tr><tr><td>第二代</td><td>1958-1964</td><td><strong>晶体管</strong></td><td>几万-几十万</td><td>磁芯存储器</td><td>磁带</td></tr><tr><td>第三代</td><td>1964-1971</td><td><strong>中小规模集成电路</strong></td><td>几十万-几百万</td><td>半导体存储器</td><td>磁带、磁盘</td></tr><tr><td>第四代</td><td>1972-现在</td><td><strong>大规模、超大规模集成电路</strong></td><td>上千万-万亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td></tr></tbody></table><ul><li><strong>电子管时代</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-04_21-35-33.png" alt=""></p><p>第一台电子数字计算机：ENIAC     （冯·诺依曼是设计顾问）<br>使用机器语言编程，纸带机（0101…），bug（小虫子…）<br>占地面积约170平方米<br>耗电量150千瓦<br>包含了17,468根真空管<br>运算速度: 5000次加法/秒<br>（体积超大，耗电量超大）</p><ul><li><strong>晶体管时代</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-04_21-35-41.png" alt=""></p><p>第一台使用晶体管线路的计算机： TRADIC<br>出现了面向过程的程序设计语言：FORTRAN<br>有了操作系统雏形<br>耗电量30瓦<br>包含了800只晶体管<br>（体积功耗降低）</p><ul><li><strong><u>中小规模集成电路</u></strong></li></ul><p>将元件集成在基片上：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_08-50-04.png" alt=""></p><p>计算机主要用于科学计算等专业用途<br>高级语言迅速发展<br>开始有了分时操作系统</p><ul><li><strong><u>大规模、超大规模集成电路</u></strong></li></ul><p>开始出现微处理器、微型计算机、个人计算机(PC)萌芽<br>操作系统: Windows、MacOs、Linux…<br>新的概念：并行、流水线、高速缓存、虚拟存储器…<br>（苹果A13制造工艺: 7nm(每个元件宽度7nm)拥有85亿个晶体管：）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_08-53-56.png" alt=""></p><hr><ul><li><strong><u>微处理器的发展</u></strong></li></ul><p><strong>微型计算机的发展以微处理器技术为标志</strong></p><p><strong>机器字长</strong>：计算机一次整数运算所能 处理的二进制位数</p><p><strong>操作系统位数</strong>：其 所依赖的指令集的 位数</p><table><thead><tr><th>微处理器</th><th>机器字长</th><th>年份</th><th>晶体管数目</th></tr></thead><tbody><tr><td>8080</td><td>8位</td><td>1974</td><td></td></tr><tr><td>8086</td><td>16位</td><td>1979</td><td>2.9万</td></tr><tr><td>80286</td><td>16位</td><td>1982</td><td>13.4万</td></tr><tr><td>80386</td><td>32位</td><td>1985</td><td>27.5万</td></tr><tr><td>80486</td><td>32位</td><td>1989</td><td>120.0万</td></tr><tr><td>Pentium</td><td>64位(准)</td><td>1993</td><td>310.0万</td></tr><tr><td>Pentium pro</td><td>64位(准)</td><td>1995</td><td>550.0万</td></tr><tr><td>Pentium II</td><td>64位(准)</td><td>1997</td><td>750.0万</td></tr><tr><td>Pentium III</td><td>64位(准)</td><td>1999</td><td>950.0万</td></tr><tr><td>Pentium IV</td><td>64位</td><td>2000</td><td>3200.0万</td></tr></tbody></table><hr><ul><li><strong><u>硬件的发展</u></strong></li></ul><table><thead><tr><th>时间</th><th>事件</th></tr></thead><tbody><tr><td>1947年</td><td>贝尔实验室发明了“<strong>晶体管</strong>”（肖克利，三个发明者之一）</td></tr><tr><td>1955年</td><td>肖克利在硅谷创建肖克利实验室股份有限公司</td></tr><tr><td>1957年</td><td>八叛徒（traitorous eight）创立，后成立仙童半导体公司</td></tr><tr><td>1959年</td><td>仙童半导体公司发明了“<strong>集成电路</strong>”</td></tr><tr><td>1965年</td><td>摩尔等人离开仙童，创立英特尔（Intel）</td></tr><tr><td>1969年</td><td>化童销售部负责人桑德斯离开仙童，创立AMD（Advanced Micro Devices）</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-08-19.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-09-07.png" alt=""></p><hr><ul><li><strong><u>摩尔定律</u></strong></li></ul><p>摩尔定律 （就是“八叛徒”中的摩尔）<br>揭示了信息技术进步的速度<br>集成电路上可容纳的晶体管数目，约每隔<strong>18</strong>个月便会增加一倍，整体性能也将提升一倍</p><p>半导体存储器的发展 （也符合摩尔定律）<br>1970年，仙童公司生产出第一个较大容量的半导体存储器<br>半导体存储器单芯片容量：1KB、4KB、16KB、 64KB、256KB、1MB、4MB、16MB、64MB、 256MB、1GB…</p><hr><ul><li><strong><u>软件的发展</u></strong></li></ul><p>编程语言：机器语言、汇编语言、FORTRAN、PASCAL、C++、Java</p><p>操作系统：DOS、Unix、Windows</p><hr><ul><li><strong><u>目前的发展趋势</u></strong></li></ul><p>“两极”分化:</p><p>一极是微型计算机向更微型化、网络化、高性能、多用途方向发展（智能手机）</p><p>另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展（神威·太湖之光）</p><hr><h2 id="1-2-1-计算机硬件的基本组成">1.2.1 计算机硬件的基本组成</h2><ul><li><strong><u>早期冯诺依曼机</u></strong></li></ul><p>ENIAC(手动接线来控制计算)（冯诺依曼是顾问）</p><p>“<strong>存储程序</strong>”的概念是指<strong>将指令以二进制代码的形式事先输入计算机的主存储器</strong>，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。【冯诺依曼首次提出“<strong>存储程序</strong>”的概念】</p><p>→ 第一台采用冯诺依曼结构的计算机EDVAC( Electronic Discrete Variable Automatic Computer)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-28-55.png" alt=""></p><p>输入设备：将信息转换成机器能识别的形式<br>运算器：算术运算逻辑运算<br>存储器：存放数据和程序<br>输出设备：将结果转换成人们熟悉的形式<br>控制器：指挥程序运行</p><p>在计算机系统中，<strong>软件和硬件在逻辑上是等效的</strong><br>Eg：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算；也可以用软件的方式，执行多次加法运算来实现</p><p><strong>特点</strong>：</p><ol><li>计算机由五大部件组成</li><li>指令和数据以<strong>同等地位</strong>存于存储器，可按<strong>地址</strong>寻访</li><li>指令和数据用<strong>二进制</strong>表示</li><li>指令由<strong>操作码</strong>和<strong>地址码</strong>组成</li><li><strong>存储程序</strong>：程序执行之前，数据和指令都会提前存到主存中</li><li><strong>以运算器为中心</strong>【输入/输出设备与存储器之间的数据传送通过运算器完成】</li></ol><hr><ul><li><strong><u>现代计算机的结构</u></strong></li></ul><p><strong>以存储器为中心</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-40-39.png" alt=""></p><p>CPU = 运算器 + 控制器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-44-26.png" alt=""></p><p>概念：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-45-23.png" alt=""></p><p>【辅存：eg：磁盘大小】</p><hr><h2 id="1-2-2-各个硬件的工作原理">1.2.2 各个硬件的工作原理</h2><ul><li><strong><u>主存储器的基本组成</u></strong></li></ul><p>主存储器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-18-54.png" alt=""></p><p>Memory <strong>Address</strong> Register（存储<strong>地址</strong>寄存器）<br>Memory <strong>Data</strong> Register（存储<strong>数据</strong>寄存器)<br>注：现在的计算机通常把MAR、MDR也集成在CPU内</p><p>存储体：数据在存储体内按地址存储；下图中，每个地址对应一个存储单元</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-24-48.png" alt=""></p><p><strong>存储单元</strong>：每个存储单元存放一串二进制代码<br><strong>存储字</strong>(<strong>word</strong>)：存储单元中二进制代码的组合；<strong>存储字长</strong>：存储单元中二进制代码的位数<br><strong>存储元</strong>：即存储二进制的电子元件，每个存储元可存 1bit</p><p>→ MAR位数反映存储单元的个数<br>→ MDR位数 = 存储字长</p><p>eg：MAR = 4位  → 总共有2^4个存储单元<br>MDR =16位 → 每个存储单元可存放16bit，1个<strong>字</strong>(<strong>word</strong>) = 16bit</p><table><thead><tr><th>易混淆</th></tr></thead><tbody><tr><td>1个<strong>字节</strong> (<strong>Byte</strong>) = 8bit</td></tr><tr><td>1<strong>B</strong> = 1个字节</td></tr><tr><td>1<strong>b</strong> = 1个bit</td></tr></tbody></table><hr><ul><li><strong><u>运算器的基本组成</u></strong></li></ul><p>运算器：用于实现算术运算 (如: 加减乘除)、逻辑运算(如: 与或非）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-39-26.png" alt=""></p><p>ACC：累加器，用于存放操作数，或运算结果。Accumulator<br>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。Multiple-Quotient Register<br>X：通用的操作数寄存器，用于存放操作数。<br><strong>ALU</strong>：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算。Arithmetic and Logic Unit</p><table><thead><tr><th></th><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th></tr></thead><tbody><tr><td>ACC</td><td style="text-align:center">被加数、和</td><td style="text-align:center">被减数、差</td><td style="text-align:center">乘积高位</td><td style="text-align:center">被除数、余</td></tr><tr><td>MQ</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">乘数、乘积低位</td><td style="text-align:center">商</td></tr><tr><td>X</td><td style="text-align:center">加数</td><td style="text-align:center">减数</td><td style="text-align:center">被乘数</td><td style="text-align:center">除数</td></tr></tbody></table><hr><ul><li><strong><u>控制器的基本组成</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-49-01.png" alt=""></p><p>CU：控制单元，分析指令，给出控制信号 Control Unit<br>IR：指令寄存器，存放当前执行的指令 Instruction Register<br>PC：程序计数器，存放下一条指令地址，有自动加1功能 Program Counter</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-52-38.png" alt=""></p><hr><ul><li><strong><u>计算机的工作过程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-56-16.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-00-02.png" alt=""></p><p>如上图：<br>初：(PC)=0，指向第一条指令的存储地址</p><p>#1：(PC) → MAR，导致(MAR)=0<br>#3：M(MAR) → MDR，导致(MDR)=<u>000001</u> 0000000101<br>#4：(MDR) → IR，导致(IR)=<u>000001</u> 0000000101<br>#5：OP(IR) → CU，指令的操作码送到CU，CU分析后得知，这是“<strong>取数</strong>”指令<br>#6: Ad(IR) → MAR，指令的地址码送到MAR，导致(MAR)=5<br>#8：M(MAR) → MDR，导致(MDR)=0000000000000010=2<br>#9：(MDR) → ACC，导致(ACC)=0000000000000010=2</p><p>取指令(#1~#4)；分析指令(#5)；执行取数指令(#6~#9)</p><p>上一条指令取指后PC自动+1，(PC)=1；执行后，(ACC)=2</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-08-02.png" alt=""></p><p>#1：(PC) → MAR，导致(MAR)=1<br>#3：M(MAR) → MDR，导致(MDR)=<u>000100</u> 0000000110<br>#4：(MDR) → IR，导致(IR)= <u>000100</u> 0000000110<br>#5：OP(IR) → CU，指令的操作码送到CU，CU分析后得知，这是“<strong>乘法</strong>”指令<br>#6：Ad(IR) → MAR，指令的地址码送到MAR，导致(MAR)=6<br>#8：M(MAR) → MDR，导致(MDR)=0000000000000011=3<br>#9：(MDR) → MQ，导致(MQ)=0000000000000011=3<br>#10：(ACC) → X，导致(X)=2<br>#11：MQ * (X) → ACC，由ALU实现乘法运算，导致(ACC)=6，如果乘积太大，则需要MQ辅助存储</p><p>取指令(#1~#4)；分析指令(#5)；执行乘法指令(#6~#11)</p><p>上一条指令取指后PC自动+1，(PC)=2；执行后，(ACC)=6</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-18-04.png" alt=""></p><p>#1：(PC) → MAR，导致(MAR)=2<br>#3：M(MAR) → MDR，导致(MDR)= <u>000011</u> 0000000111<br>#4：(MDR) → IR，导致(IR)= <u>000011</u> 0000000111<br>#5：OP(IR) → CU，指令的操作码送到CU， CU分析后得知，这是“<strong>加法</strong>”指令<br>#6：Ad(IR) → MAR，指令的地址码送到MAR，导致(MAR)=7<br>#8：M(MAR) → MDR，导致(MDR)=000000000000001=1<br>#9：(MDR) → X，导致(X)=0000000000000001=1<br>#10：(ACC)+(X) → ACC，导致(ACC)=7，由ALU实现加法运算</p><p>取指令(#1~#4)；分析指令(#5)；执行加法指令(#6~#10)</p><p>上一条指令取指后PC自动+1，(PC)=3；执行后，(ACC)=7</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-23-14.png" alt=""></p><p>#1：(PC) → MAR，导致(MAR)=3<br>#3：M(MAR) → MDR，导致(MDR)=<u>000010</u> 0000001000<br>#4：(MDR) → IR，导致(IR)= <u>000010</u> 0000001000<br>#5：OP(IR) → CU，指令的操作码送到CU，CU分析后得知，这是“<strong>存数</strong>”指令<br>#6：Ad(IR) → MAR，指令的地址码送到MAR，导致(MAR)=8<br>#7：(ACC) → MDR，导致(MDR)=7<br>#9：(MDR) → 地址为8的存储单元，导致y=7</p><p>取指令(#1~#4)；分析指令(#5)；执行存数指令(#6~#9)</p><p>上一条指令取指后PC自动+1，(PC)=4</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-28-07.png" alt=""></p><p>#1：(PC) → MAR，导致(MAR)=4<br>#3：M(MAR) → MDR，导致(MDR)=<u>000110</u> 0000000101<br>#4：(MDR) → IR，导致(IR)=<u>000110</u> 0000000101<br>#5：OP(IR) → CU，指令的操作码送到CU，CU分析后得知，这是“<strong>停机</strong>”指令<br>(利用中断机制通知操作系统终止该进程)</p><p>取指令(#1~#4)；分析指令(#5)；执行<strong>停机</strong>指令</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_10-36-12.png" alt=""></p><p><strong>CPU区分指令和数据依据：指令周期的不同阶段</strong></p><hr><h2 id="1-2-3-计算机系统的层次结构">1.2.3 计算机系统的层次结构</h2><ul><li><strong><u>计算机系统的层次结构</u></strong></li></ul><p><strong>下层是上层的基础，上层是下层的扩展</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_13-04-07.png" alt=""></p><p>【微指令：上一节中的#1、#2…这些小步骤】</p><p>【汇编语言指令和机器语言指令一一对应，“助记符”】</p><hr><ul><li><strong><u>三种级别的语言</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_13-19-59.png" alt=""></p><p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序(<strong>只需翻译一次</strong>)</p><p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(<strong>每次执行都要翻译</strong>)</p><hr><ul><li><strong><u>计算机体系结构 vs 计算机组成原理</u></strong></li></ul><p>计算机体系结构——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）<br>【如何设计硬件与软件之间的接口，eg：有无乘法指令】</p><p>计算机组成原理一一实现计算机体系结构所体现的属性，对程序员“透明”（具体指的实现）<br>【如何用硬件实现所定义的接口，eg：如何实现乘法指令】</p><p>本专业说的”透明“，都是指看不见</p><hr><h2 id="1-3-计算机的性能指标">1.3 计算机的性能指标</h2><ul><li><u><strong>存储器的性能指标</strong></u></li></ul><p><strong>总容量 = 存储单元个数x存储字长 bit</strong><br><strong>= 存储单元个数x存储字长/8 Byte</strong></p><p>Eg：MAR为32位，MDR为8位 → 总容量 = 2^32*8 bit =4 GB</p><p>ps:</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td><td>256</td><td>512</td><td>1024</td><td>2048</td><td>4096</td><td>8192</td><td>16384</td><td>32768</td><td>65536</td></tr></tbody></table><p>2^10:<strong>K</strong>    2^20:<strong>M</strong>    2^30:<strong>G</strong>    2^40:<strong>T</strong></p><hr><ul><li><strong><u>CPU的性能指标</u></strong></li></ul><p><strong>CPU主频</strong>：CPU内数字脉冲信号振荡的频率。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_13-39-04.png" alt=""></p><p><strong>CPU时钟周期</strong>：单位微秒，纳秒</p><p><strong>CPU主频</strong>（<strong>时钟频率</strong>）= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>时钟周期</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{CPU时钟周期}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback mtight">时钟周期</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>；单位：赫兹，Hz</p><p><strong>CPI</strong>(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数。【不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化】</p><p><strong>执行一条指令的耗时</strong> = CPI * CPU时钟周期</p><p>Eg：某CPU主频为 1000Hz，某程序包含100条指令，平均来看指令的CPI=3，该程序在该CPU上执行需要多久?</p><p>Answer：100 * 3 * (1/100) = 0.3s</p><p><strong>CPU执行时间</strong>（<strong>整个程序的耗时</strong>）= CPU时钟周期数 / 主频 = (指令条数 * CPI) / 主频</p><p><strong>IPS</strong> (Instructions Per Second )：每秒执行多少条指令。<br>IPS = 主频 / 平均CPI【主频：1s有多少时钟周期，平均CPI：每条指令需要多少时钟周期】</p><p><strong>FLOPS</strong> (Floatingpoint Operations Per Second)：每秒执行多少次浮点运算</p><p>KIPS、MIPS；KFLOPS、MFLOPS、GFLOPS、TFLOPS</p><p>注：此处K、G、T为数量单位：<br>K=Kilo=千 = 10^3<br>M=Million=百万=10^6<br>G=Giga=十亿=10^9<br>T=Tera=万亿= 10^12</p><hr><ul><li><strong><u>系统整体的性能指标</u></strong></li></ul><p><strong>数据通路带宽</strong>：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_13-54-42.png" alt=""></p><p><strong>吞吐量</strong>：指系统在单位时间内处理请求的数量。<br>它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</p><p><strong>响应时间</strong>：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。<br>通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间)。</p><hr><ul><li><strong><u>系统整体的性能指标（动态测试）</u></strong></li></ul><p><strong>基准程序</strong>是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p><p>【跑分软件】</p><hr><ul><li><strong><u>思考</u></strong></li></ul><p><strong>问</strong>：主频高的CPU一定比主频低的CPU快吗?<br>不一定，如两个CPU，A的主频为2GHz，平均CPI=10；B的主频1GHz，平均CPI=1…<br>IPS(A) &lt; IPS(B)</p><p><strong>问</strong>：若A、B两个CPU的平均CPI相同(主频和上面相同)，那么A一定更快吗?<br>也不一定，还要看指令系统，如 A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。</p><p><strong>问</strong>：基准程序执行得越快说明机器性能越好吗?<br>基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p><hr><h1>第二章 数据的表示和运算</h1><blockquote><p>数据如何在计算机中表示?<br>运算器如何实现数据的算数、逻辑运算?</p></blockquote><h2 id="2-1-1-进位计数制">2.1.1 进位计数制</h2><ul><li><strong><u>最古老的计数方法</u></strong></li></ul><p><strong>符号反映权重</strong></p><p>罗马数字的几种符号与对应权重：</p><table><thead><tr><th>符号</th><th>相应的阿拉伯数字</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>基于“加法”思想的计数方法，eg：Ⅳ、Ⅷ、Ⅸ……</p><hr><ul><li><strong><u>十进制计数法</u></strong></li></ul><p>古印度人发明的阿拉伯数字：0，1，2，3，4，5，6，7，8，9</p><p>符号所在的位置也反映权重：985 = 9 * 10^2 + 8 * 10^1 + 5 * 10^0</p><p><strong>十进制</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>…</mo><msub><mi>K</mi><mn>1</mn></msub><msub><mi>K</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_n…K_1K_0.K_{-1}…K_{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mn>1</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">K_n * 10^n+ …+K_1 * 10^1 + K_0*10^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">+K_{-1} * 10^{-1}+…+K_{-m} * 10^{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord">+</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>位权</strong>：eg：上面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mtext>、</mtext><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">10^1、10^n……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">……</span></span></span></span></p><p>进位计数制：”<strong>逢十进一</strong>“</p><hr><ul><li><strong><u>推广：r进制计数法</u></strong></li></ul><p><strong>r进制</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>…</mo><msub><mi>K</mi><mn>1</mn></msub><msub><mi>K</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_n…K_1K_0.K_{-1}…K_{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>∗</mo><msup><mi>r</mi><mi>n</mi></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mn>1</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>1</mn></msup><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">K_n * r^n+ …+K_1 * r^1 + K_0*r^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">+K_{-1} * r^{-1}+…+K_{-m} * r^{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord">+</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>基数</strong>：每个数码位所用到的不同符号的个数，r进制的基数为r</p><p>二进制：0，1：</p><ul><li>可使用两个稳定状态的物理器件表示</li><li>0，1 正好对应逻辑值 假、真。方便实现逻辑运算</li><li>可很方便地使用逻辑门电路实现算术运算</li></ul><hr><ul><li><strong><u>任意进制 → 十进制</u></strong></li></ul><p>二进制： 101.1 → 1 × 2^2 + 0 × 2^1 + 1 × 2^0 + 1 × 2^−1 = 5.5<br>四进制： 11.2 → 1 × 4^1 + 1 × 4^0 + 2 × 4^−1 = 5.5<br>八进制： 5.4 → 5 × 8^0 + 4 × 8^−1 = 5.5<br>十进制： 5.5 → 5 × 10^0 + 5 × 10^−1 = 5.5<br>十六进制： 5.8 → 5 × 16^0 + 8 × 16^−1 = 5.5</p><p>二进制位权：</p><table><thead><tr><th>-3</th><th>-2</th><th>-1</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>0.125</td><td>0.25</td><td>0.5</td><td>0</td><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td><td>256</td><td>512</td><td>1024</td><td>2048</td><td>4096</td><td>8192</td><td>16384</td><td>32768</td><td>65536</td></tr></tbody></table><hr><ul><li><strong><u>二进制 ↔ 八进制、十六进制</u></strong></li></ul><p>如：1111000010.01101</p><p>二进制 → 八进制：<br>3位一组，毎组转换成对应进制的符号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-11-39.png" alt=""></p><p>二进制 → 十六进制：<br>4位一组，毎组转换成对应进制的符号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-11-54.png" alt=""></p><p>注意：补位（上面的蓝色部分）</p><p>八进制、十六进制 → 二进制：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>C</mi><mn>2.68</mn><mi>H</mi><mo>=</mo><mn>1111000010.01101</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">3C2.68H = 1111000010.01101B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">2.68</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1111000010.01101</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mi>C</mi><mn>2.68</mn><msub><mo stretchy="false">)</mo><mn>16</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1111000010.01101</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(3C2.68)_{16} = (1111000010.01101 )_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">2.68</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1111000010.01101</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><hr><ul><li><strong><u>各种进制的常见书写方式</u></strong></li></ul><p>二进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1111000010.01101</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(1111000010.01101)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1111000010.01101</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、1111000010.01101<strong>B</strong></p><p>八进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>332.68</mn><msub><mo stretchy="false">)</mo><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">(332.68)_{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">332.68</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>十六进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>332.68</mn><msub><mo stretchy="false">)</mo><mn>16</mn></msub></mrow><annotation encoding="application/x-tex">(332.68)_{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">332.68</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、332.68<strong>H</strong>、<strong>0x</strong>332.68</p><p>十进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>332.68</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">(332.68)_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">332.68</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、332.68<strong>D</strong></p><hr><ul><li><strong><u>十进制 → 任意进制</u></strong></li></ul><p>十进制 → r进制</p><p>如：75.3</p><ul><li><strong>整数部分</strong>：</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-24-24.png" alt=""></p><p>假设r = 2:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-25-59.png" alt=""></p><p>简化：短除法</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-27-14.png" alt=""></p><p>r 取其他值时，类似</p><ul><li><strong>小数部分</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-30-55.png" alt=""></p><p>假设r = 2:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-29-46.png" alt=""></p><p>简化：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-32-05.png" alt=""></p><p>注意：<strong>有的十进制小数无法用二进制精确表示</strong>，如上图的案例</p><hr><ul><li><strong><u>十进制 → 二进制（拼凑法）</u></strong></li></ul><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=2094.0&amp;p=8">王道视频链接</a>32:33</p><p>感觉这个没必要</p><hr><ul><li><strong><u>真值、机器数</u></strong></li></ul><p>真值：符合人类习惯的数字</p><p>机器数：数字实际存到机器里的形式，正负号需要被“数字化”</p><hr><ul><li><strong><u>中国古代的二进制系统</u></strong></li></ul><p>太极生两仪，两仪生四象，四象生八卦</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_10-41-17.png" alt=""></p><hr><h2 id="2-1-2-BCD码">2.1.2 BCD码</h2><blockquote><p>BCD : Binary-Coded Decimal，用二进制编码的十进制</p></blockquote><ul><li><strong><u>BCD码</u></strong></li></ul><p>背景：二进制 十进制之间的转换比较麻烦</p><p>解决：快速转换:一一对应 → BCD : Binary-Coded Decimal</p><p>4位二进制（可以表示16个数）表示一位十进制数（10个），冗余16 - 10 = 6</p><p><strong>8421码</strong>的映射关系：【<strong>有权</strong>码】</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td></tr></tbody></table><p>手算方法：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-27-23.png" alt=""></p><p>机算方法：（修正： +6）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-28-55.png" alt=""></p><p>超出的数：1010~1 0010（9+9）</p><p>注：若相加结果在合法范围内，则无需修正</p><p><strong>余3码</strong>：8421码 + 0011B【+3】【<strong>无权</strong>码】</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td></tr></tbody></table><p><strong>2421码</strong>：改变权值定义【<strong>有权</strong>码】</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><u>0</u>000</td><td><u>0</u>001</td><td><u>0</u>010</td><td><u>0</u>011</td><td><u>0</u>100</td><td><u>1</u>011</td><td><u>1</u>100</td><td><u>1</u>101</td><td><u>1</u>110</td><td><u>1</u>111</td></tr></tbody></table><p>为了避免歧义：0~4的首位一定是0；5~9的首位一定是1</p><hr><h2 id="2-1-3-无符号整数的表示和运算">2.1.3 无符号整数的表示和运算</h2><ul><li><strong><u>无符号整数在计算机中的应用</u></strong></li></ul><p>无符号整数，即“自然数”，0，1，2……</p><p>C语言中的无符号整数：（位数不同，可表示数值范围不同）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">1</span>;<span class="comment">// 无符号整数 短整型 2B</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">2</span>;<span class="comment">// 无符号整数 整型 4B</span></span><br></pre></td></tr></table></figure><p>无符号整数，在计算机硬件内，如何表示?</p><p>无符号整数的加法、减法运算是怎么用硬件实现的 ?</p><hr><ul><li><strong><u>无符号整数的表示</u></strong></li></ul><p>该计算机硬件能支持的无符号整数位数有上限，如下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-48-59.png" alt=""></p><p>Tips：现在的个人计算机机器字长通常是64位或至少32位</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-52-53.png" alt=""></p><p><strong>无符号整数</strong>:</p><ol><li>全部二进制位都是数值位，没有符号位，第i位的位权是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li><li>n bit 无符号整数表示范围 0~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，超出则溢出，意味着该计算机无法一次处理这么多</li><li>可以表示的最小的数 全0，可以表示的最大的数 全1.</li></ol><hr><ul><li><strong><u>无符号整数的加法运算</u></strong></li></ul><p>计算机硬件如何做无符号整数的加法：从最低位开始，<strong>按位相加</strong>，并<strong>往更高位进位</strong></p><p>【溢出的直接丢掉】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-57-24.png" alt=""></p><hr><ul><li><strong><u>无符号整数的减法运算</u></strong></li></ul><p>计算机硬件如何做无符号整数的减法：</p><ol><li>“被减数”不变，“<strong>减数</strong>”全部位<strong>按位取反</strong>、<strong>末位+1</strong>，<strong>减法变加法</strong>【不要纠结为什么，这需要数论的知识】</li><li>从最低位开始，<strong>按位相加</strong>，并<strong>往更高位进位</strong></li></ol><p>Tips：加法电路造价便宜，减法电路造价昂贵，若可将减法转变为加法，省钱!</p><p>eg：变形如下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_13-05-21.png" alt=""></p><p>进行加法：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_13-05-24.png" alt=""></p><hr><h2 id="2-1-4-带符号整数的表示和运算——原反补">2.1.4 带符号整数的表示和运算——原反补</h2><ul><li><strong><u>带符号整数在计算机中的应用</u></strong></li></ul><p>带符号整数，即“整数”，-2，-1，0，1，2……</p><p>C语言中的无符号整数：（位数不同，可表示数值范围不同）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">1</span>;<span class="comment">// 带符号整数 短整型 2B</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;<span class="comment">// 带符号整数 整型 4B</span></span><br></pre></td></tr></table></figure><p>带符号整数，在计算机硬件内，如何表示?</p><p>带符号整数的加法、减法运算是怎么用硬件实现的 ?</p><hr><ul><li><strong><u>带符号整数的表示</u></strong></li></ul><p>该计算机硬件能支持的带符号整数位数有上限，如下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_12-48-59.png" alt=""></p><hr><ul><li><strong><u>原码表示</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_19-57-27.png" alt=""></p><p>常见的书面写法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> = -19<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1, 0010011【“,”隔开】<br>若未指明机器字长，也可以写作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1, 10011</p><p><strong>原码</strong>：</p><ol><li>符号位“0/1”对应“正/负”，剩余的数值位表示真值的绝对值</li><li>若机器字长n+1位，<strong>带符号整数的原码表示范围</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≤</mo><mi>x</mi><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-(2^n-1)\le x \le2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li><strong>真值0有两种形式</strong>: +0 和 -0 ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>+</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[+0]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">+</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0, 0000000；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>0</mn><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[-0]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1, 0000000</li></ol><hr><ul><li><strong><u>原码的缺点</u></strong></li></ul><p>若按照上一节无符号整数的方法按位相加，结果并不是正确的。</p><p>原码的<strong>缺点</strong>：符号位不能参与运算，需要设计复杂的硬件电路才能处理，<strong>费钱! 贵!</strong></p><p><strong>解决</strong>：用<strong>补码</strong>表示真值——<strong>符号位可以参与运算</strong></p><hr><ul><li><strong><u>原码→反码→补码的转换 (机算)</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_20-03-19.png" alt=""></p><hr><ul><li><strong><u>原码、补码 快速转换技巧 (手算)</u></strong></li></ul><p>对于负数：<strong>补码→反码</strong>，可以直接减一，逆回来；<strong>补码→原码</strong>，即符号位不变，数值位取反，末尾+1；<br><strong>但是</strong>我们现在用下面的方法，先转回原码，在变成反码，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_20-13-44.png" alt=""></p><hr><ul><li><strong><u>补码的加法运算（例）</u></strong></li></ul><p><strong>补码数值位不能解读为“位权“</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-07_20-18-03.png" alt=""></p><p>计算机硬件如何做<strong>补码</strong>的<strong>加法</strong>：从最低位开始，<strong>按位相加</strong>(<em><strong>符号位参与运算</strong></em>)，<strong>并往更高位进位</strong></p><p><strong>结果补码是负数</strong>，<strong>就转回原码</strong>；整数就不需要转了，因为是长一样的</p><hr><ul><li><strong><u>补码的减法运算（例）</u></strong></li></ul><p>对比上一节无符号整数的减法运算</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>−</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>+</mo><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[A]_补 - [B]_补 = [A]_补 + [-B]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>接下来要解决的问题：已知“减数”的补码，如何求其负值的补码表示?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_14-24-05.png" alt=""></p><p>之后：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_14-26-20.png" alt=""></p><p>优点：用同一套电路即可处理所有的加减法，<strong>省钱</strong>!</p><p>计算机硬件如何做<strong>带符号数补码</strong>的减法：</p><ol><li>“被减数”不变，&quot;<strong>减数</strong>“<strong>全部位按位取反</strong>、<strong>末位+1</strong>，<strong>减法变加法</strong></li><li>从最低位开始，<strong>按位相加</strong>，并往更高位<strong>进位</strong>。</li></ol><hr><ul><li><strong><u>知识点回顾与重要考点</u></strong></li></ul><p>Tips：计算机内部，所有进行<strong>带符号整数</strong>的加减法都要<strong>先转化为补码</strong></p><p>【<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub><mo>→</mo><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[B]_补 \to[-B]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>快速转换技巧：从右往左找到第一个1，这个1左边的全部位按位取反】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_14-33-20.png" alt=""></p><hr><h2 id="2-1-5-原反补码的特性对比">2.1.5 原反补码的特性对比</h2><blockquote><p>小题考点</p><ul><li>n + 1 bit 的合法表示范围</li><li>最大的数怎么表示、最小的数怎么表示</li><li>真值0的表示</li></ul></blockquote><ul><li><strong><u>各种码的特性总结</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_14-47-04.png" alt=""></p><p><strong>原码</strong>和<strong>反码</strong>的合法表示范围完全相同，都有两种方法表示真值0</p><p><strong>补码</strong>的合法表示范围比原码<strong>多一个负数</strong>，只有一种方法表示真值0</p><p>常见考点：两个数A和B进行某种运算后，是否发生溢出? 手算做题可以带入十进制验证，是否超出合法范围<br>比如，n + 1 = 8时，带符号整数原码表示范围[-127, 127]，补码表示范围[-128, 127]，对于-64 + (-64) = -128，如果两个-64都是用原码表示，则-128超出范围了，如果是用补码表示则没有超出。</p><hr><h2 id="2-1-6-移码">2.1.6 移码</h2><ul><li><strong><u>原、反、补、移码的转换</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-01-38.png" alt=""></p><hr><ul><li><strong><u>移码</u></strong></li></ul><p><strong>移码</strong>：<strong>补码</strong>的基础上将<strong>符号位取反</strong>。<br>注意：移码<strong>只能用于表示整数</strong></p><p>移码表示的<strong>规律</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-07-32.png" alt=""></p><p>移码表示的整数很方便用硬件电路对比大小</p><p>在下面<code>2.3.2 IEEE 754</code>中<strong>补充</strong>说明了移码的内容</p><hr><ul><li><strong><u>各种码的特性总结</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-00-29.png" alt=""></p><p><strong>原码</strong>和<strong>反码</strong>的合法表示范围完全相同，都有两种方法表示真值0</p><p><strong>补码</strong>的合法表示范围比原码<strong>多一个负数</strong>，<strong>只有一种方法表示真值0</strong></p><p><strong>移码</strong>的合法表示范围比原码<strong>多一个负数</strong>，<strong>只有一种方法表示真值0</strong></p><hr><h2 id="2-1-7-定点小数">2.1.7 定点小数</h2><ul><li><strong><u>定点整数、定点小数</u></strong></li></ul><p>定点数：定点整数（即：带符号整数）、定点小数</p><ul><li><strong>定点整数</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-12-21.png" alt=""></p><p>定点整数的编码表示：<strong>原码、反码、补码</strong>、<u>移码</u></p><ul><li><strong>定点小数</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-13-24.png" alt=""></p><p>定点小数的编码表示：<strong>原码、反码、补码</strong></p><hr><ul><li><strong><u>原码</u></strong></li></ul><p>各个bit“位权”不一样</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-17-10.png" alt=""></p><hr><ul><li><strong><u>定点小数原/反/补码的转换</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-19-44.png" alt=""></p><p>和定点整数是一样的：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_14-33-20.png" alt=""></p><hr><ul><li><strong><u>定点小数加/减运算</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-19-44.png" alt=""></p><p>对两个定点小数A、B进行加法/减法时，需要先转换为补码</p><p>计算机硬件如何做<strong>定点小数补码</strong>的<strong>加法</strong>：从最低位开始，<strong>按位相加</strong>(<em><strong>符号位参与运算</strong></em>)，<strong>并往更高位进位</strong></p><p>计算机硬件如何做<strong>定点小数补码</strong>的减法：</p><ol><li>“被减数”不变，&quot;<strong>减数</strong>“<strong>全部位按位取反</strong>、<strong>末位+1</strong>，<strong>减法变加法</strong></li><li>从最低位开始，<strong>按位相加</strong>，并往更高位<strong>进位</strong>。</li></ol><hr><ul><li><strong><u>定点整数 VS 定点小数</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-32-37.png" alt=""></p><p>特别注意：位数扩展时，拓展位置不一样</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-34-49.png" alt=""></p><hr><ul><li><strong><u>定点小数补码的加法运算（例）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-19-44.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-37-45.png" alt=""></p><p>计算机硬件如何做<strong>补码</strong>的<strong>加法</strong>：从最低位开始，<strong>按位相加</strong>(<em><strong>符号位参与运算</strong></em>)，<strong>并往更高位进位</strong></p><hr><ul><li><strong><u>定点小数补码的减法运算（例）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-19-44.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-40-22.png" alt=""></p><p>计算机硬件如何做<strong>带符号数补码</strong>的减法：</p><ol><li>“被减数”不变，&quot;<strong>减数</strong>“<strong>全部位按位取反</strong>、<strong>末位+1</strong>，<strong>减法变加法</strong></li><li>从最低位开始，<strong>按位相加</strong>，并往更高位<strong>进位</strong>。</li></ol><hr><h2 id="2-2-0-奇偶校验码（大纲已删）">2.2.0 奇偶校验码（大纲已删）</h2><blockquote><p>为了发现错误</p></blockquote><p><a href="https://gxblogs.netlify.app/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">王道计算机网络 | ggw和xpl的博客 (gxblogs.netlify.app)</a>第三章 数据链路层中 3、差错控制（检错编码）有提到</p><ul><li><strong><u>奇偶校验码</u></strong></li></ul><p>奇校验码：整个校验码(有效信息位和校验位)中“1”的个数为奇数</p><p>偶校验码：整个校验码(有效信息位和校验位)中“1”的个数为偶数</p><p>【就是看有效信息位1的个数，看在校验位补0，还是补1，能让整体变成奇数或者偶数】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_15-45-56.png" alt=""></p><p>【例2-3】给出两个编码1001101和1010111的奇校验码和偶校验码；设最高位为校验位，余7位是信息位，则对应的奇偶校验码为:</p><p>奇校验：<u>1</u>1001101<u>0</u>1010111<br>偶校验：<u>0</u>1001101    <u>1</u>1010111</p><p>偶校验的<strong>硬件实现</strong>：各信息进行异或（模2加）运算，得到的结果即为偶校验位<br>对于上面的题目：</p><p>求偶校验位：1⊕0⊕0⊕1⊕1⊕0⊕1 = 0    1⊕0⊕1⊕0⊕1⊕1⊕1 = 1</p><p>偶校验码进行偶校验（所有位进行异或，若结果为1说明出错，准确的说是出现<strong>奇数个错误</strong>)：<br>0⊕1⊕0⊕0⊕1⊕1⊕0⊕1 = 0<br>1⊕1⊕0⊕1⊕0⊕1⊕1⊕1 = 0<br>1⊕1⊕0⊕1⊕0⊕1⊕1⊕<u>0</u> = 1错<br>1⊕1⊕0⊕1⊕0⊕1⊕<u>0</u>⊕<u>0</u> = 0对（其实是错的）</p><p>奇偶校验码特点：<br>只能检查出奇数个比特错误，检错能力为50%（奇数个比特位出错，才能检验出来）</p><p>相同的：<br>奇校验码进行奇校验（所有位进行异或，若结果为0说明出错，准确的说是出现<strong>奇数个错误</strong>)：</p><hr><h2 id="2-2-1-电路的基本原理、加法器的设计">2.2.1 电路的基本原理、加法器的设计</h2><ul><li><strong><u>算术逻辑单元ALU</u></strong><br>Arithmetic Logic Unit</li></ul><p><strong>功能</strong>：</p><ol><li>算术运算：加、减、乘、除等</li><li>逻辑运算：与、或、非、异或等</li><li>辅助功能：移位，求补等</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_16-09-34.png" alt=""></p><p>ALU如下图【图中看不清的是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mtext>、</mtext><msub><mi>B</mi><mi>i</mi></msub><mtext>、</mtext><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i、B_i、F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>】，控制信号由控制单元CU发出</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_16-11-18.png" alt=""></p><p>实例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_16-16-35.png" alt=""></p><hr><ul><li><strong><u>最基本的逻辑运算</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_16-22-21.png" alt=""></p><p>门电路的输入/输出信号本质上是高电平或者低电平</p><p><strong><u>优先级：与 &gt; 或</u></strong>（类比乘除，加减）</p><p>eg：AB + CD 先算与，再算或</p><p>A(C +D) = AC + AD —— 分配率<br>(AB)C = A(BC) —— 结合律<br>(A + B) + C = A + (B + C) —— 结合律<br>这样可以简化表达式，在硬件实现时可以用更少的门电路单元实现相同的效果。</p><p>Tips：本质上<strong>逻辑表达式是对电路的数学化描述</strong>，简化逻辑表达式，就是在简化电路，就是在省钱</p><hr><ul><li><strong><u>复合逻辑</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_16-29-54.png" alt=""></p><p>【上图中门电路看不清的符号是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&amp;</mi><mtext>、</mtext><mo>≥</mo><mtext>、</mtext><mo>=</mo><mn>1</mn><mtext>、</mtext><mo>=</mo><mtext> </mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\&amp;、\ge、=1、=\,=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">&amp;</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>】</p><p>反演律：（离散数学：德摩根律）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A+B} = \overline{A}·\overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9667em;vertical-align:-0.0833em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0833em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo separator="true">⋅</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A·B} = \overline{A}+\overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9667em;vertical-align:-0.0833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></p><p>异或门可用与、或、非 组合实现：<br>A和B不同<br>→ A = 0 且 B = 1 或 A = 1 且 B = 0<br>→ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo separator="true">⋅</mo><mi>B</mi><mo>+</mo><mi>A</mi><mo separator="true">⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A}·B+ A·\overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9667em;vertical-align:-0.0833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-14-25.png" alt=""></p><p><strong>异或的天然逻辑“加法”、“奇偶校验”</strong></p><hr><ul><li><strong><u>门电路实现奇偶校验位</u></strong></li></ul><p>回忆 2.2.0 奇偶校验码</p><p><strong>异或门</strong>实现奇偶校验如下：</p><p>求偶校验位：<br>1⊕0⊕0⊕1⊕1⊕0⊕1 = 0</p><p><strong>逻辑表达式是对电路的数学化描述</strong></p><p>((1⊕0)⊕(0⊕1))⊕((1⊕0)⊕1) = 0:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-20-21.png" alt=""></p><p>((((((1⊕0)⊕0)⊕1)⊕1)⊕0)⊕1) = 0:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-21-22.png" alt=""></p><hr><ul><li><strong><u>一位全加器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-26-36.png" alt=""></p><p>分析:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-26-55.png" alt=""></p><p>硬件实现：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-28-30.png" alt=""></p><p>抽象出来：<strong>一位全加器</strong>（<strong>FA，full adder</strong>）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-30-01.png" alt=""></p><hr><ul><li><strong><u>串行加法器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-32-12.png" alt=""></p><p><strong>串行加法器</strong>：只有一个全加器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。</p><p>如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器。【这样的效率较低】</p><hr><ul><li><strong><u>并行加法器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-35-42.png" alt=""></p><p><strong>串行进位的并行加法器</strong>：把n个全加器串接起来，就可进行两个n位数的相加。【这样其实也要等前一位算完，才能算出后一位的结果】</p><p>串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</p><hr><h2 id="2-2-2-并行进位的加法器">2.2.2 并行进位的加法器</h2><blockquote><p>不是考试的重点，大致了解即可</p></blockquote><ul><li><strong><u>串行进位的并行加法器</u></strong></li></ul><p>如上一小节所说，运算速度很大程度的受到进位速度的影响。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_18-35-42.png" alt=""></p><hr><ul><li><strong><u>并行加法器的优化</u></strong></li></ul><p><strong>并行进位的并行加法器</strong>：各级进位信号同时形成，又称为先行进位、同时进位</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_19-03-28.png" alt=""></p><p>说明如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mi>B</mi><mi>i</mi></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>B</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mi>B</mi><mi>i</mi></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>B</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊕</mo><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mi>B</mi><mi>i</mi></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>B</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊕</mo><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>⊕</mo><msub><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo fence="true">)</mo></mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>3</mn></mrow></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>…</mo><mo>…</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}C_{i}=A_{i} B_{i}+\left(A_{i} \oplus B_{i}\right) C_{i-1} \\C_{i}=A_{i} B_{i}+\left(A_{i} \oplus B_{i}\right)\left(A_{i-1} B_{i-1}+\left(A_{i-1} \oplus B_{i-1}\right) C_{i-2}\right) \\C_{i}=A_{i} B_{i}+\left(A_{i} \oplus B_{i}\right)\left(A_{i-1} B_{i-1}+\left(A_{i-1} \oplus B_{i-1}\right)\left(A_{i-2} B_{i-2}+\left(A_{i-2} \oplus B_{i-2}\right) C_{i-3}\right)\right)\\……\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">……</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>最终可以展开到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>记：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">G</mi><mi mathvariant="normal">i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mi>B</mi><mi>i</mi></msub><mspace linebreak="newline"></mspace><msub><mi mathvariant="normal">P</mi><mi mathvariant="normal">i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{G}_{\mathrm{i}}=A_{i} B_{i} \\\mathrm{P}_{\mathrm{i}}=A_{i} \oplus B_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>化简：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><mo>+</mo><msub><mi>P</mi><mn>1</mn></msub><msub><mi>C</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><msub><mi>G</mi><mn>2</mn></msub><mo>+</mo><msub><mi>P</mi><mn>2</mn></msub><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><msub><mi>G</mi><mn>2</mn></msub><mo>+</mo><msub><mi>P</mi><mn>2</mn></msub><msub><mi>G</mi><mn>1</mn></msub><mo>+</mo><msub><mi>P</mi><mn>2</mn></msub><msub><mi>P</mi><mn>1</mn></msub><msub><mi>C</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><msub><mi>G</mi><mn>3</mn></msub><mo>+</mo><msub><mi>P</mi><mn>3</mn></msub><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><msub><mi>G</mi><mn>3</mn></msub><mo>+</mo><msub><mi>P</mi><mn>3</mn></msub><msub><mi>G</mi><mn>2</mn></msub><mo>+</mo><msub><mi>P</mi><mn>3</mn></msub><msub><mi>P</mi><mn>2</mn></msub><msub><mi>G</mi><mn>1</mn></msub><mo>+</mo><msub><mi>P</mi><mn>3</mn></msub><msub><mi>P</mi><mn>2</mn></msub><msub><mi>P</mi><mn>1</mn></msub><msub><mi>C</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>C</mi><mn>4</mn></msub><mo>=</mo><msub><mi>G</mi><mn>4</mn></msub><mo>+</mo><msub><mi>P</mi><mn>4</mn></msub><msub><mi>C</mi><mn>3</mn></msub><mo>=</mo><msub><mi>G</mi><mn>4</mn></msub><mo>+</mo><msub><mi>P</mi><mn>4</mn></msub><msub><mi>G</mi><mn>3</mn></msub><mo>+</mo><msub><mi>P</mi><mn>4</mn></msub><msub><mi>P</mi><mn>3</mn></msub><msub><mi>G</mi><mn>2</mn></msub><mo>+</mo><msub><mi>P</mi><mn>4</mn></msub><msub><mi>P</mi><mn>3</mn></msub><msub><mi>P</mi><mn>2</mn></msub><msub><mi>G</mi><mn>1</mn></msub><mo>+</mo><msub><mi>P</mi><mn>4</mn></msub><msub><mi>P</mi><mn>3</mn></msub><msub><mi>P</mi><mn>2</mn></msub><msub><mi>P</mi><mn>1</mn></msub><msub><mi>C</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>…</mo><mo>…</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l} C_{1}=G_{1}+P_{1} C_{0} \\C_{2}=G_{2}+P_{2} C_{1}=G_{2}+P_{2} G_{1}+P_{2} P_{1} C_{0} \\C_{3}=G_{3}+P_{3} C_{2}=G_{3}+P_{3} G_{2}+P_{3} P_{2} G_{1}+P_{3} P_{2} P_{1} C_{0} \\C_{4}=G_{4}+P_{4} C_{3}=G_{4}+P_{4} G_{3}+P_{4} P_{3} G_{2}+P_{4} P_{3} P_{2} G_{1}+P_{4} P_{3} P_{2} P_{1} C_{0}\\……\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">……</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>但是继续套娃会导致电路越来越复杂；经典的做法是适可而止：由4个FA和一些新的线路、运算逻辑组成加法器，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-09_19-02-46.png" alt=""></p><hr><h2 id="2-2-3-补码加减运算器">2.2.3 补码加减运算器</h2><ul><li><strong><u>加法器原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_15-43-51.png" alt=""></p><p>例1：A=1000，B=0111，Cin=0<br>则 F=1111， Cout=0</p><p>例2：A=1000，B=0111，Cin=1<br>则 F=0000，Cout=1</p><hr><ul><li><strong><u>补码加/减法运算方法</u></strong></li></ul><p>n bit补码 X + Y，按位相加即可；</p><p>n bit补码 <strong>X - Y</strong>，将补码<strong>Y全部按位取反，末位加1</strong>，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>Y</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-Y]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，减法变加法。</p><p>例1：4 bit补码，X=-8，Y=7。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1000， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0111<br>X+Y = 1111B<br>X-Y = 1000 + (1000+1) = <s>1</s>0001 = 运算结果只保留低四位，最高位进位丢弃(发生溢出)，答案是错的</p><p>例2：4 bit补码，X=3，Y=4。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0011， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0100<br>X+Y = 0111B<br>X-Y = 0011 + (1011+1) = 1111B</p><p>给硬件加上减法的逻辑如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_15-57-14.png" alt=""></p><p>例1：4 bit补码，X=-8，Y=7。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1000， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0111<br>X+Y = 1111B = <strong>-1D</strong>✔<br>X-Y = 1000 + (<strong>1000+1</strong>) = <s>1</s>0001 = <strong>1D</strong>✘运算结果只保留低四位，最高位进位丢弃(发生溢出)，答案是错的</p><p>例2：4 bit补码，X=3，Y=4。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0011， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0100<br>X+Y = 0111B = <strong>7D</strong>✔<br>X-Y = 0011 + (<strong>1011+1</strong>) = 1111B = <strong>-1D</strong>✔</p><p><strong>无符号整数的加法/减法也可用该电路实现</strong></p><p>例1：无符号数X=8，Y=7；用4bit表示，X=1000B， Y=0111B<br>X+Y =1111B = <strong>15D</strong>✔<br>X-Y =1000 + (1000+1)= <s>1</s>0001= <strong>1D</strong>✔ 运算结果只保留低四位，最高位进位丢弃，这里却是对的【是因为有符号数和无符号数判断溢出的方式不同，看下一节标志位的生成】</p><p>例2：无符号数X=3，Y=4；用4bit表示，X=0011B， Y=0100B<br>X+Y = 0111B = <strong>7D</strong>✔<br>X-Y = 0011 +(1011+1) = 1111B = <strong>15D</strong>✘</p><hr><h2 id="2-2-4-标志位的生成">2.2.4 标志位的生成</h2><p>对上一节加法器进行补充：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-15-53.png" alt=""></p><table><thead><tr><th style="text-align:center">标志位</th><th>英文全称</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">OF</td><td>Overflow Flag</td><td>溢出标志。溢出时为1，否则置0</td></tr><tr><td style="text-align:center">SF</td><td>Sign Flag</td><td>符号标志。运算结果为负数时SF位置1，否则置0</td></tr><tr><td style="text-align:center">ZF</td><td>Zero Flag</td><td>零标志。运算结果为0时ZF位置1，否则置0</td></tr><tr><td style="text-align:center">CF</td><td>Carry Flag</td><td>进位/借位标志。进位/借位时置1，否则置0</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-31-07.png" alt=""></p><p>对于上一节的例子：</p><p>例1：4 bit补码，X=-8，Y=7。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1000， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0111<br>X+Y = 1111B = <strong>-1D</strong>✔<br>X-Y = 1000 + (<strong>1000+1</strong>) = <s>1</s>0001 = <strong>1D</strong>✘运算结果只保留低四位，最高位进位丢弃(发生溢出)，答案是错的<br>X-Y：<strong>OF = 1；SF = 0；ZF = 0；CF = 1</strong></p><p>例2：4 bit补码，X=3，Y=4。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">X_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0011， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">Y_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0100<br>X+Y = 0111B = <strong>7D</strong>✔<br>X-Y = 0011 + (<strong>1011+1</strong>) = 1111B = <strong>-1D</strong>✔<br>X-Y：<strong>OF = 0；SF = 1；ZF = 0；CF = 0</strong></p><p>例1：无符号数X=8，Y=7；用4bit表示，X=1000B， Y=0111B<br>X+Y =1111B = <strong>15D</strong>✔<br>X-Y =1000 + (1000+1)= <s>1</s>0001= <strong>1D</strong>✔ 运算结果只保留低四位，最高位进位丢弃，这里却是对的<br>X-Y：<strong>OF = 1；SF = 0；ZF = 0；CF = 0</strong></p><p>例2：无符号数X=3，Y=4；用4bit表示，X=0011B， Y=0100B<br>X+Y = 0111B = <strong>7D</strong>✔<br>X-Y = 0011 +(1011+1) = 1111B = <strong>15D</strong>✘<br>X-Y：<strong>OF = 0；SF = 1；ZF = 0；CF = 1</strong></p><hr><h2 id="2-2-5-定点数的移位运算">2.2.5 定点数的移位运算</h2><ul><li><strong><u>算数移位</u></strong></li></ul><p><strong>r进制</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>…</mo><msub><mi>K</mi><mn>1</mn></msub><msub><mi>K</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_n…K_1K_0.K_{-1}…K_{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>∗</mo><msup><mi>r</mi><mi>n</mi></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mn>1</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>1</mn></msup><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">K_n * r^n+ …+K_1 * r^1 + K_0*r^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">+K_{-1} * r^{-1}+…+K_{-m} * r^{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord">+</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></p><p>对于数：985.211</p><p>9852.11 小数点<strong>后移1位</strong>相当于 × 10<strong>¹</strong><br>98521.1 小数点<strong>后移2位</strong>相当于 × 10<strong>²</strong></p><p>98.5211 小数点<strong>前移1位</strong>相当于 ÷ 10<strong>¹</strong><br>9.85211 小数点<strong>前移2位</strong>相当于 ÷ 10<strong>²</strong></p><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法</p><p>先看后面的详细描述，以下是<strong>总结</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_21-45-58.png" alt=""></p><p>左移相当于 × 2；右移相当 ÷ 2<br>由于位数有限，因此有时候无法用算数移位精确地等效乘除法</p><hr><ul><li><strong><u>原码的算数移位</u></strong></li></ul><p>原码的算数移位–符号位保持不变，仅对数值位进行移位。</p><p>右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会<strong>丢失精度</strong></p><p>左移：低位补0，高位舍弃。若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现<strong>严重误差</strong></p><p>例：原码如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-44-44.png" alt=""></p><p>右移：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-45-22.png" alt=""></p><p>左移：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-45-09.png" alt=""></p><p>定点小数同理：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-19-44.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-47-52.png" alt=""></p><hr><ul><li><strong><u>反码的算数移位</u></strong></li></ul><p><strong>反码</strong>的算数移位一一<strong>正数</strong>的反码与原码相同，因此对<strong>正数反码的移位运算也和原码相同</strong>。<br>右移：高位补0，低位舍弃。<br>左移:低位补0，高位舍弃。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-53-32.png" alt=""></p><p><strong>反码</strong>的算数移位一一<strong>负数</strong>的反码数值位与原码相反，因此<strong>负数反码的移位运算</strong>规则如下：<br>右移：高位补1，低位舍弃。<br>左移：低位补1，高位舍弃</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-53-38.png" alt=""></p><hr><ul><li><strong><u>补码的算数移位</u></strong></li></ul><p><strong>补码</strong>的算数移位一一<strong>正数</strong>的补码与原码相同，因此对<strong>正数补码的移位运算也和原码相同</strong>。<br>右移：高位补0，低位舍弃。<br>左移：低位补0，高位舍弃。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-56-21.png" alt=""></p><p><strong>补码</strong>的算数移位一一<strong>负数</strong>补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。<br><strong>规律一一负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码</strong>。<br><strong>负数补码</strong>的算数移位规则如下:<br>右移(同反码)：高位补1，低位舍弃<br>左移(同原码)：低位补0，高位舍弃</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-10_16-56-33.png" alt=""></p><hr><ul><li><strong><u>算数移位的应用举例</u></strong></li></ul><p>乘法【后面会进一步探讨乘法】：</p><p>Eg：-20 × 7</p><p>7D = 111B = 2º + 2¹ + 2²</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_21-53-58.png" alt=""></p><hr><ul><li><strong><u>逻辑移位</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_21-58-09.png" alt=""></p><p>逻辑右移：高位补0，低位舍弃</p><p>逻辑左移：低位补0，高位舍弃</p><hr><ul><li><strong><u>逻辑移位的应用举例</u></strong></li></ul><p>RGB颜色值的存储：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_21-59-44.png" alt=""></p><p>如图PaleTurquoise4的RGB值为(R=102, G=139, B=139)，如果用3B来存储：</p><ol><li>用3B存储无符号数102，并逻辑左移16位</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-06-42.png" alt=""></p><ol start="2"><li>用3B存储无符号数139，并逻辑左移8位</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-06-57.png" alt=""></p><ol start="3"><li>用3B存储无符号数139</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-07-49.png" alt=""></p><ol start="4"><li>相加得3B的RGB值:</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-08-02.png" alt=""></p><hr><ul><li><strong><u>循环移位</u></strong></li></ul><p><code>ROL</code>(向左循环移位)、<code>ROR</code>(向右循环移位)、<code>RCL</code>(向左循环移位并带进位)和<code>RCR</code>(向右循环移位并带进位)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-18-04.png" alt=""></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy Code; 以16位无符号整数0xABCD为例</span><br><span class="line">mov ax, 0xABCD    ; AX = 1010 1011 1100 1101</span><br><span class="line">rol ax, 1         ; AX = 0101 0111 1001 1011，CF = 1</span><br><span class="line">rol ax, 2         ; AX = 0011 1100 1101 1110，CF = 1</span><br><span class="line">rol ax, 3         ; AX = 0111 1001 1011 1100，CF = 0</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>循环移位的应用举例</u></strong></li></ul><p><strong>大端存储 ↔ 小端存储</strong></p><p>大端存储：先存高字节，再存低字节；小端存储：先存低字节，再存高字节</p><p>假设一个单位用2B来存储，则循环位移8位可以实现大端存储 ↔ 小端存储的转换。</p><hr><h2 id="加减法运算和溢出判断（补自2019版视频）">加减法运算和溢出判断（补自2019版视频）</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1BE411D7ii?t=13.0&amp;p=22">视频链接——直接空降</a></p></blockquote><ul><li><strong><u>符号扩展</u></strong></li></ul><p>原码：补0</p><p>0,1111 → 0,<u>000</u>1111<br>1,11000 → 1,<u>00</u>11000</p><p>补码：正数补0，负数补1</p><p>0,1111 → 0,<u>000</u>1111<br>1,01000 → 1,<u>11</u>01000</p><hr><ul><li><strong><u>溢出判断</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_13-05-54.png" alt=""></p><p>设机器字长为8位(含1位符号位)，A=15，B=-24，C=124，求求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>C</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[A+C]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>B</mi><mo>−</mo><mi>C</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[B-C]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p><p><strong>方法一</strong>：采用<strong>一位符号位</strong>设A的符号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">A_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，B的符号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">B_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，运算结果的符号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">S_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则溢出逻辑表达式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mo>=</mo><msub><mi>A</mi><mi mathvariant="normal">S</mi></msub><msub><mi>B</mi><mi mathvariant="normal">S</mi></msub><mover accent="true"><msub><mi>S</mi><mi mathvariant="normal">S</mi></msub><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><msub><mi>A</mi><mi mathvariant="normal">S</mi></msub><mo stretchy="true">‾</mo></mover><mtext> </mtext><mover accent="true"><msub><mi>B</mi><mi mathvariant="normal">S</mi></msub><mo stretchy="true">‾</mo></mover><msub><mi>S</mi><mi mathvariant="normal">s</mi></msub></mrow><annotation encoding="application/x-tex">V=A_{\mathrm{S}} B_{\mathrm{S}} \overline{S_{\mathrm{S}}}+\overline{A_{\mathrm{S}}} \,\overline{B_{\mathrm{S}}} S_{\mathrm{s}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0333em;vertical-align:-0.15em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>若V=0，表示无溢出;<br>若V=1，表示有溢出。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_11-39-22.png" alt=""></p><p><strong>方法二</strong>：采用<strong>一位符号位</strong>，根据数据位进位情况判断溢出；符号位的进位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">C_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，最高数位的进位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><table><thead><tr><th></th><th>符号位的进位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">C_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th>最高数位的进位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td>正溢出</td><td>0</td><td>1</td></tr><tr><td>负溢出</td><td>1</td><td>0</td></tr></tbody></table><p>即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">C_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不同时有溢出</p><p><strong>方法三</strong>：采用<strong>双符号位</strong>正数符号为<strong>00</strong>，负数符号为<strong>11</strong>；<br>结果的符号位为<u>10</u>（负溢出）、<u>01</u>（正溢出），表示溢出</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>C</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[A+C]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <strong>00</strong>,0001111 + <strong>00</strong>,1111100 = <u>01</u>,0001011 —— 正溢出<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>B</mi><mo>−</mo><mi>C</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[B-C]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <strong>11</strong>,1101000 + <strong>11</strong>,0000100 = <u>10</u>,1101100 —— 负溢出</p><p>采用双符号位的移位运算：低位符号位参与移位，高位符号位代表真正的符号</p><p>实际存储的时候双符号位只存一位。</p><hr><h2 id="2-2-6-1、原码的乘法运算">2.2.6 1、原码的乘法运算</h2><ul><li><strong><u>手算乘法（二进制）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-50-51.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_22-49-18.png" alt=""></p><p>考虑用机器实现：</p><ol><li>实际数字有正负，符号位如何处理?</li><li>乘积的位数扩大一倍，如何处理?</li><li>4个位积都要保存下来最后统一相加?</li></ol><hr><ul><li><strong><u>原码一位乘法</u></strong></li></ul><p>设机器字长为n+1=5位(含1位符号位)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[y]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0.1011，采用原码一位乘法求x·y</p><ul><li>符号单独处理：符号位 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">x_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ⊕ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">y_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>数值位取绝对值进行乘法计算：<strong>0.1101 × 0.1011</strong>（和手算那个例子相同，看一下上面那个图）</li></ul><p>【回顾知识】：运算器的基本组成</p><table><thead><tr><th></th><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th></tr></thead><tbody><tr><td>ACC</td><td style="text-align:center">被加数、和</td><td style="text-align:center">被减数、差</td><td style="text-align:center"><strong>乘积高位</strong></td><td style="text-align:center">被除数、余</td></tr><tr><td>MQ</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>乘数、乘积低位</strong></td><td style="text-align:center">商</td></tr><tr><td>X</td><td style="text-align:center">加数</td><td style="text-align:center">减数</td><td style="text-align:center"><strong>被乘数</strong></td><td style="text-align:center">除数</td></tr></tbody></table><p><strong>实现方法：先加法再移位，重复n次</strong>【数值位为n位，本例中是4】</p><ol><li>加法：[ACC] + [x] = [ACC]，当前位【看图】是1才执行，否则 + 0</li><li>移位：[ACC, MQ]，一起<strong>逻辑右移</strong></li><li><strong>最后加上符号位</strong></li></ol><p>【图中<strong>红色部分（表中粗体）称为部分积</strong>】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_23-01-22.png" alt=""></p><table><thead><tr><th>过程[ACC, MQ]</th></tr></thead><tbody><tr><td>1. [<strong>00000</strong>, 0101<u>1</u>]，初始ACC置0</td></tr><tr><td>2. [<strong>01101</strong>, 0101<u>1</u>]，当前位1，+[x]<br />3. [<strong>00110, 1</strong>010<u>1</u>]，移位</td></tr><tr><td>4. [<strong>10011, 1</strong>010<u>1</u>]，当前位1，+[x]<br />5. [<strong>01001, 11</strong>01<u>0</u>]，移位</td></tr><tr><td>6. [<strong>01001, 11</strong>01<u>0</u>]，当前位0，+0<br />7. [<strong>00100, 111</strong>0<u>1</u>]，移位</td></tr><tr><td>8. [<strong>10001, 111</strong>0<u>1</u>]，当前位1，+[x]<br />9. [<strong>01000, 1111</strong><u>0</u>]，移位</td></tr><tr><td>10. [<strong>01000, 1111</strong><u>0</u>]，当前位是原来的符号位，不参与运算<br />11. [<strong>1.1000, 1111</strong><u>0</u>]，小数点其实是隐藏的，再加上符号位</td></tr></tbody></table><hr><ul><li><strong><u>原码一位乘法（手算模拟)</u></strong></li></ul><p>设机器字长为5位(含1位符号位，n=4)，x=-0.1101，y=+0.1011，采用原础一位乘法求x·y<br>解：|x| = 00.1101，|y| = 00.1011，原码一位乘法的求解过程如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-16_23-33-04.png" alt=""></p><p>符号位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">P_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">x_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ⊕ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">y_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1 ⊕ 0 = 1，得到x·y = -0.1000, 1111</p><p>Tips:</p><ul><li>乘数的符号位不参与运算，可以省略</li><li><strong>原码</strong>一位乘可以<strong>只用单符号位</strong>，图中<strong>00</strong>. ……，这是双符号位</li><li>答题时最终结果最好写为原码机器数</li></ul><p>原码一位乘法：机器字长n+1，数值部分占n位</p><ul><li>符号位通过<strong>异或</strong>确定；</li><li>数值部分通过被乘数和乘数绝对值的<strong>n轮</strong>加法、移位完成根据当前乘数中参与运算的位确定(ACC)加什么。若当前运算位=1，则(ACC)+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[|x|]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；若=0，则(ACC)+0。</li><li>每轮加法后ACC、MQ的内容统一<strong>逻辑右移</strong></li></ul><hr><h2 id="2-2-6-2、补码的乘法运算">2.2.6 2、补码的乘法运算</h2><ul><li><strong><u>补码一位乘法</u></strong></li></ul><p>设机器字长为5位(含1位符号位，n=4)，x=-0.1101，y=+0.1011，采用Booth算法求x·y</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1.0011，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[y]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0.1011</p><p><strong>原码</strong>一位乘法：</p><ul><li><p>进行n轮加法、移位</p></li><li><p>每次加法可能是 <strong>+0、+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[|x|]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></p><p>根据当前MQ中的<strong>最低位</strong>来确定加什么</p><ul><li>MQ中最低位 = 1时，(ACC)+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>原</mtext></msub></mrow><annotation encoding="application/x-tex">[|x|]_原</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>MQ中最低位 = 0时，(ACC)+0</li></ul></li><li><p>每次移位是“<strong>逻辑右移</strong>”</p></li><li><p>符号位<strong>不</strong>参与运算</p></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-06-18_12-27-54.png" alt=""></p><p><strong>补码</strong>一位乘法：</p><ul><li><p>进行n轮加法、移位，<strong>最后再多一次加法</strong></p></li><li><p>每次加法可能是 <strong>+0、+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></p><p>根据当前MQ中的<strong>最低位</strong>、<strong>辅助位</strong>来确定加什么</p><ul><li>辅助位 - MQ中“最低位” = 1时，(ACC) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>辅助位 - MQ中”最低位“ = 0时，(ACC) + 0</li><li>辅助位 - MQ中“最低位” = -1时，(ACC) + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>【实际上最低位就是辅助位，但是我们原码用的那个最低位，我们保持一致，所以这里最低位指的是下图中的灰色部分】</p></li><li><p>每次移位是“<strong>补码的算数右移</strong>”</p></li><li><p><strong>符号位参与运算</strong>【因为最后多一次加法，加什么用到了符号位，就是辅助位 - MQ中最低位（这时是符号位），看下面手算的那个图】</p></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_12-51-51.png" alt=""></p><hr><ul><li><strong><u>补码一位乘法（手算模拟）</u></strong></li></ul><p>设机器字长为5位(含1位符号位，n=4)，x=-0.1101，y=+0.1011，采用Booth算法求x·y</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 1.0011，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-x]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[y]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0.1011</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_13-00-41.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">⋅</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[x·y]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 11.01110001<br>即x·y = -0.10001111</p><hr><h2 id="2-2-7-1、原码的除法运算">2.2.7 1、原码的除法运算</h2><ul><li><strong><u>手算除法（二进制）</u></strong></li></ul><p>设机器字长为5位（含1位符号位，n=4），x=0.1011，y=0.1101，求x/y</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_13-15-25.png" alt=""></p><p>x/y结果为0.1101，余数为0.00000111</p><p>规律：忽略小数点，每确定一位商，进行一次减法，得到4位余数，在余数末尾补0，再确定下一位商。确定5位商即可停止（机器字长为5位）</p><hr><ul><li><strong><u>原码除法：恢复余数法</u></strong></li></ul><p>【知识回顾】：运算器的基本组成</p><table><thead><tr><th></th><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th></tr></thead><tbody><tr><td>ACC</td><td style="text-align:center">被加数、和</td><td style="text-align:center">被减数、差</td><td style="text-align:center">乘积高位</td><td style="text-align:center"><strong>被除数、余</strong></td></tr><tr><td>MQ</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">乘数、乘积低位</td><td style="text-align:center"><strong>商</strong></td></tr><tr><td>X</td><td style="text-align:center">加数</td><td style="text-align:center">减数</td><td style="text-align:center">被乘数</td><td style="text-align:center"><strong>除数</strong></td></tr></tbody></table><p>设机器字长为5位（含1位符号位，n=4），x=0.1011，y=0.1101，求x/y<br>|x|=0.1011，|y|=0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =1.0011</p><ul><li>符号单独处理：符号位 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">x_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ⊕ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">y_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>数值位取绝对值进行除法计算：<strong>0.1011 ÷ 0.1101</strong>（和手算那个例子相同，看一下上面那个图）</li></ul><p><strong>实现方法：上商0/1，得到余数，余数末尾补0</strong></p><p>手算时，每一位商取0/1是通过判断当前余数和除数的大小确定的；<br>计算机很傻，会<strong>先默认上商1</strong>，如果搞错了再改上商0。并“<strong>恢复余数</strong>”</p><ol><li>先商1，ACC + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = ACC</li><li>判断余数是否为负数，即符号位是否为1，是负数要恢复余数ACC + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = ACC，并且商0</li><li>逻辑左移，补0</li><li><strong>最后加上符号位</strong></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_13-39-07.png" alt=""></p><p>后面手算的例子又是看余数，再上商，这块看看题怎么考吧，问题不大</p><table><thead><tr><th>过程[ACC, MQ]</th></tr></thead><tbody><tr><td>1. [01011, 0000<u>0</u>]，初始MQ置0</td></tr><tr><td>2. [<strong>1</strong>1110, 0000<u>1</u>]，先上商1，减去除数<br />3. [01011, 0000<u>0</u>]，发现余数（ACC）是负数，恢复余数（加上除数），商0<br />4. [10110, 0000<u>0</u>]，逻辑左移</td></tr><tr><td>5. [<strong>0</strong>1001, 0000<u>1</u>]，先上商1，减去除数<br />6. [10010, 0001<u>0</u>]，逻辑左移</td></tr><tr><td>7. [<strong>0</strong>0101, 0001<u>1</u>]，先上商1，减去除数<br />8. [01010, 0011<u>0</u>]，逻辑左移</td></tr><tr><td>9. [<strong>1</strong>1101, 0011<u>1</u>]，先上商1，减去除数<br />10. [01010, 0011<u>0</u>]，发现余数（ACC）是负数，恢复余数 （加上除数），商0<br />11. [10100, 0110<u>0</u>]，逻辑左移</td></tr><tr><td>12. [<strong>0</strong>0111, 0110<u>1</u>]，先上商1，减去除数<br />左移n次，上商n+1次，最后不用左移了，但是如果这里是负数，是需要恢复一下的</td></tr><tr><td>13. [<strong>0</strong>0111, 0.110<u>1</u>]，小数点其实是隐藏的，再加上符号位<br />商=0.1101<br />余数=0.0111 * 2^-n<br />注：余数的正负性与商相同</td></tr></tbody></table><hr><ul><li><strong><u>原码除法：恢复余数法（手算模拟）</u></strong></li></ul><p>设机器字长为5位（含1位符号位，n=4），x=0.1011，y=0.1101，求x/y<br>|x|=0.1011，|y|=0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=0.1101，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[-|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =1.0011</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_13-43-14.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_13-44-34.png" alt=""></p><p>左移n次，上商n+1次<br>最后一次上商余数不左移</p><hr><ul><li><strong><u>原码除法：加减交替法</u></strong><br>又称：<strong>不恢复余数法</strong></li></ul><p>【思考】能否不恢复余数</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt="img"></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_14-13-10.png" alt=""></p><p>若余数为负，则可直接商0，并让余数左移1位再加上|除数|，a → 2a + b</p><ul><li><strong>若余数为负，则可直接商0，让余数左移1位再加上|除数|，得到下一个新余数</strong></li><li><strong>若余数为正，则商1，让余数左移1位再减去|除数|，得到下一个新余数</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_14-23-09.png" alt=""></p><p>但是如果最后是负值，是需要恢复 + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><msub><mo stretchy="false">]</mo><mtext>补</mtext></msub></mrow><annotation encoding="application/x-tex">[|y|]_补</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一下的，所以也是需要恢复的。</p><p>注：余数的正负性与商相同</p><p>加减法：n+1次，每次加减确定一位商；<br>左移n次（最后一次加减完不移位）最终可能还要再多一次加减法</p><hr><h2 id="2-2-7-2、补码的除法运算">2.2.7 2、补码的除法运算</h2><ul><li><strong><u>补码除法：加减交替法</u></strong></li></ul><p>补码除法：</p><ul><li>符号位参与运算</li><li>被除数/余数、除数采用双符号位</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_14-40-02.png" alt=""></p><p>初始：</p><ul><li><strong>被除数</strong>和除数<strong>同号</strong>，则被除数<strong>减去</strong>除数；</li><li>异号则被除数<strong>加上</strong>除数。</li></ul><p>每产生一次余数：</p><ul><li>余数和除数<strong>同号</strong>，商1，余数<strong>左移一位减去除数</strong></li><li>余数和除数<strong>异号</strong>，商0，余数<strong>左移一位加上除数</strong></li><li>重复n次</li></ul><p>最后末尾恒置为1</p><hr><ul><li><strong><u>除法运算总结回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_14-46-02.png" alt=""></p><hr><h2 id="2-2-8-C语言类型转换">2.2.8 C语言类型转换</h2><ul><li><u><strong>强制类型转换</strong></u></li></ul><p>注：C语言中定点整数是用“<strong>补码</strong>”存储的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">short</span> x = <span class="number">-4321</span>;<span class="comment">// short型占用2个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> y = (<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    无符号数与有符号数：不改变数据内容，改变解释方式。 </span></span><br><span class="line"><span class="comment">    x: 1110 1111 0001 1111 (补码)</span></span><br><span class="line"><span class="comment">    y: 1110 1111 0001 1111 (原码) 真值61215</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">165537</span>，b = <span class="number">-34991</span>;<span class="comment">// int型占用4个字节</span></span><br><span class="line">    <span class="type">short</span> c = (<span class="type">short</span>)a, d = (<span class="type">short</span>)b;<span class="comment">// short型占用2个字节</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    长整数变短整数：高位截断，保留低位</span></span><br><span class="line"><span class="comment">    a: 0x000286a1</span></span><br><span class="line"><span class="comment">    c: 0x86a1真值-31071</span></span><br><span class="line"><span class="comment">    b: 0xfF7751</span></span><br><span class="line"><span class="comment">    d:0x7751真值30545</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> x = <span class="number">-4321</span>;</span><br><span class="line">    <span class="type">int</span> m = x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> n = (<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p = n;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    短整数变长整数：符号扩展。</span></span><br><span class="line"><span class="comment">    x: 1110 1111 0001 1111 —— 0xef1f</span></span><br><span class="line"><span class="comment">    m: 1111 1111 1111 1111 1110 1111 0001 1111 —— 0xffffef1f 真值-4321</span></span><br><span class="line"><span class="comment">    n: 1110 1111 0001 1111 —— 0xef1f 真值61215</span></span><br><span class="line"><span class="comment">    p: 0000 0000 0000 0000 1110 1111 0001 1111 —— 0x0000ef1f 真值61215</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-9-数据的存储和排列">2.2.9 数据的存储和排列</h2><ul><li><strong><u>大小端模式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_15-48-21.png" alt=""></p><p>多字节数据在内存里一定是占连续的几个字节。</p><p>大端模式：便于人类阅读<br>小端模式：便于机器处理</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_15-52-02.png" alt=""></p><hr><ul><li><strong><u>边界对齐</u></strong></li></ul><p>现代计算机通常是按字节编址，即每个字节对应1个地址</p><p>通常也支持按字、按半字、按字节寻址。</p><p>假设存储字长为32位，则1个字=32bit，半字=16bit。</p><p>假设：每次访存只能读/写1个字，则存储分为如下两种：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_15-58-27.png" alt=""></p><p>访问一个字/半字，都只需一次访存。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_15-59-23.png" alt=""></p><p>访问一个字/半字，需要1~2次访存。<br>例如：上图2.11半字1，首先访存一个字，读到半字1-1，再访存一次，读到半字1-2，这样才读完整个半字1</p><hr><h2 id="2-3-1-浮点数的表示">2.3.1 浮点数的表示</h2><blockquote><ul><li>浮点数的作用和基本原理</li><li>浮点数规格化</li><li>浮点数的表示范围（大纲已删）</li></ul></blockquote><ul><li><strong><u>定点数的局限性</u></strong></li></ul><p>定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度。</p><p>如何在位数不变的情况下增加数据表示范围?</p><hr><ul><li><strong><u>从科学计数法理解浮点数</u></strong></li></ul><p>普通计数法:<br>+302657264526</p><p>科学计数法:<br>+3.026 * 10^11</p><p>→+11（阶码） +3.026（尾数）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_16-15-50.png" alt=""></p><hr><ul><li><strong><u>浮点数的表示</u></strong></li></ul><p><strong>r进制</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>…</mo><msub><mi>K</mi><mn>1</mn></msub><msub><mi>K</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_n…K_1K_0.K_{-1}…K_{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><mo>∗</mo><msup><mi>r</mi><mi>n</mi></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mn>1</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>1</mn></msup><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><mo>∗</mo><msup><mi>r</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">K_n * r^n+ …+K_1 * r^1 + K_0*r^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">+K_{-1} * r^{-1}+…+K_{-m} * r^{-m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord">+</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>定点数</strong>：如纯小数0.1011和纯整数11110</p><p><strong>浮点数</strong>:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_16-15-50.png" alt=""></p><p><strong>阶码</strong>: 常用补码或移码表示的定点整数</p><p><strong>尾数</strong>: 常用原码或补码表示的定点小数</p><p><strong>浮点数的真值</strong>：<strong>N = r^E × M</strong>（N：真值，r：阶码的底，通常为2，E：阶码，M：尾数）</p><p>阶码E反映浮点数的表示范围及小数点的实际位置；<br>尾数M的数值部分的位数n反映浮点数的精度。</p><p>尾数给出一个小数，阶码指明了小数点要向前/向后移动几位</p><p>【例】：阶码、尾数均用补码表示，求a、b的真值<br>a = 0,01; 1.1001<br>b = 0,10; 0.01001<br>这里用, ; .作符号位、阶码、尾数的分割。</p><p>【答】：a的真值 = 2^1 x (-0.0111) = -0.111【这里2^1，相当于尾数表示的定点小数算数左移一位，或小数点右移一位】<br>b的真值 =2^2 x (+0.01001) = +1.001</p><p>这里用1B存储b，发现存不下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_22-59-55.png" alt=""></p><p>→浮点数尾数规格化</p><hr><ul><li><strong><u>浮点数尾数规格化</u></strong></li></ul><p>对于上面的例子：</p><p>b = 2^2 x (+0.01001) = 2^1 x (+0.10010)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_23-03-49.png" alt=""></p><p>尾数算数左移1位，阶码减1。<strong>直到尾数最高位是有效值</strong> (<strong>左规</strong>)，【右移就是<strong>右规</strong>】</p><p>规格化浮点数：规定<strong>尾数的最高数值位必须是一个有效值</strong>。</p><ul><li><strong>左规</strong>：当浮点数运算的结果为非规格化时要进行规格化处理，<br>将<strong>尾数算数左移一位，阶码减1</strong>。</li><li><strong>右规</strong>：当浮点数运算的结果尾数出现溢出(双符号位为<strong>01</strong>或<strong>10</strong>) 时，<br>将<strong>尾数算数右移一位，阶码加1</strong>。</li></ul><p>【例】：a = 010;00.1100，b = 010;00.1000，求a+b<br>a = 2^2 x 00.1100，b = 2^2 x 00.1000<br>a+b = 2^2 x 00.1100 + 2^2 x 00.1000<br>= 2^2 x (00.1100 + 00.1000) =<br>2^2 x 01.0100 —— (右规)<br>= 2^3 x 00.1010</p><p>注：采用“双符号位”，当<strong>溢出</strong>发生时，可以挽救。更高的符号位是正确的符号位。</p><hr><ul><li><strong><u>规格化浮点数的特点</u></strong></li></ul><ol><li><p>用原码表示的尾数进规格化：</p><ul><li>正数为<strong>0.1</strong>X……X的形式，其最大值表示为0.11…1；最小值表示为0.10…0<br>尾数的表示范围为1/2 ≤  M ≤  (1 - 2^-n)。</li><li>负数为<strong>1.1</strong>X……X的形式，其最大值表示为1.10…0；最小值表示为1.11…1<br>尾数的表示范围为-(1 - 2^-n) ≤ M ≤ -1/2。</li></ul><p>规格化的原码尾数，最高数值位一定是1</p></li><li><p>用补码表示的尾数进行规格化:</p><ul><li>正数为<strong>0.1</strong>x x…的形式，其最大值表示为0.11…1；最小值表示为0.10…0。<br>尾数的表示范围为1/2 ≤ M ≤ (1 - 2^-n)。</li><li>负数为<strong>1.0</strong>X x…的形式，其最大值表示为1.01…1；最小值表示为1.00…0。<br>尾数的表示范围为-1≤ M ≤ -(1/2 + 2^-n)。</li></ul><p>规格化的补码尾数，符号位与最高数值位一定<strong>相反</strong></p></li></ol><p>eg：若某浮点数的阶码、尾数用补码表示，共4+8位:<br>0.110;1.1110100如何规格化?<br>注：补码算数左移，低位补0；补码算数右移，高位补1</p><hr><ul><li><strong><u>浮点数的表示范围</u></strong></li></ul><p>下图内容大纲已删：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-18_23-44-30.png" alt=""></p><p>抛出异常 (中断)</p><hr><h2 id="2-3-2-IEEE-754">2.3.2 IEEE 754</h2><blockquote><p>浮点数标准：IEEE 754（读作：I trible E 754）</p></blockquote><ul><li><strong><u>移码</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-08_15-07-32.png" alt=""></p><p>移码的<strong>定义</strong>：移码 = 真值 + <strong>偏置值</strong></p><p>此处8位移码的偏置值 = 128D =  <u>1000 0000</u>B，即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>偏置值一般此取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，此时移码 = 补码符号位取反</strong></p><table><thead><tr><th>例子</th></tr></thead><tbody><tr><td>真值 =  -127 = -1111111B<br />移码 = -1111111 <u>+ 10000000</u> = 0000 0001</td></tr><tr><td>真值 = -3 = -11B<br />移码 = -11 <u>+ 10000000</u> = 0111 1101</td></tr><tr><td>真值 = +0 = +0<br />移码 = +0 + 10000000 = 1000 0000</td></tr><tr><td>真值 = +3 = +11B<br />移码 = +11 <u>+ 10000000</u> = 1000 0011</td></tr><tr><td>真值 = +127 = +1111111B<br />移码 = +1111111 <u>+ 10000000</u> = 1111 1111</td></tr></tbody></table><p><strong>偏置值也可以取其他值，IEEE 754阶码用移码表示，其中移码的偏置值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1</strong></p><p>令偏置值=127D=0111 1111B，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1</p><table><thead><tr><th>例子</th></tr></thead><tbody><tr><td>真值 = -128 = -10000000B<br />移码 = -1000 0000 <u>+ 01111111</u> = 1111 1111</td></tr><tr><td>真值 = -127 = -111 1111B<br />移码 = -111 1111 <u>+ 01111111</u> = 0000 0000</td></tr><tr><td>真值 = -126 = -1111110B<br />移码 = -111 1110 <u>+ 01111111</u> = 0000 0001</td></tr><tr><td>真值 = +0 = +0<br />移码 = +0 <u>+01111111</u> = 0111 1111</td></tr><tr><td>真值 = +127 = +1111111B<br />移码 = +111 1111 <u>+ 01111111</u> = 1111 1110</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_09-19-11.png" alt=""></p><hr><ul><li><strong><u>IEEE 754标准</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_09-28-08.png" alt=""></p><p><strong>阶码全1、全0用作特殊用途</strong><br><strong>尾数实际上是</strong><code>1.M</code></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_09-32-00.png" alt=""></p><p>float:<br><strong>1</strong><u>000 0001 1</u>000 1010 0101 0000 1000 0000<br>double:<br><strong>1</strong><u>000 0001 1100</u> 0010 0101 0000 1000 0000 0000 0000 0001 1111 0000 0000 0000 0000</p><p><strong>阶码真值 = 移码 - 偏移量</strong></p><p>规格化的短浮点数的值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msub><mo stretchy="false">)</mo><mi>s</mi></msub><mo>×</mo><mn>1.</mn><mi>M</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>127</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)_s \times 1.M \times 2^{E-127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1.</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">127</span></span></span></span></span></span></span></span></span></span></span></span><br>规格化长浮点数的真值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msub><mo stretchy="false">)</mo><mi>s</mi></msub><mo>×</mo><mn>1.</mn><mi>M</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>1023</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)_s \times 1.M \times 2^{E-1023}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1.</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">1023</span></span></span></span></span></span></span></span></span></span></span></span></p><table><thead><tr><th>例题</th></tr></thead><tbody><tr><td>例：将十进制数-0.75转换为IEEE 754的单精度点数格式表示</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>0.75</mn><msub><mo stretchy="false">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>0.11</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1.1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(-0.75)_{10}=(-0.11)_2 =(-1.1)_2\times2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">0.75</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">0.11</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1.1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><br />数符 = <strong>1</strong><br />尾数部分 = <strong>.1000000…</strong>(隐含最位1)<br/>阶码真值 = -1<br />单精度浮点型偏移量 =127D<br />移码 = 阶码真值 + 偏移量 = -1 + 1111111= <strong>0111 1110</strong> (凑足8位)<br />→ <strong>1</strong> <u>01111110</u> 10000000000000000000000</td></tr><tr><td>例：IEEE 754的单精度浮点数 C0 A0 00 00 H的值时多少</td></tr><tr><td>(阶码不是全0也不是全1）<br />C0 A0 00 00 H → <strong>1</strong><u>100 0000 1</u>010 0000 0000 0000 0000 0000<br />数符 = <strong>1</strong> → 是个负数<br/>尾数部分 = <strong>.0100…</strong>(隐含最高位1) → 尾数真值 = 1.01B<br />移码 = <strong>10000001，若看作无符号数 = 129D</strong><br />阶码真值 = 移码 - 偏移量 = 1000 0001 - 1111111 = 0000 0010B = 2D<br />→ 浮点数真值 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1.01</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mo>−</mo><mn>1.25</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mo>−</mo><mn>5.0</mn></mrow><annotation encoding="application/x-tex">(-1.01)_2 \times 2^2= -1.25 \times 2^2 =-5.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1.01</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1.25</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">5.0</span></span></span></span></td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_09-54-24.png" alt=""></p><p>若要表示的数绝对值还要更小，怎么办?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p><strong>只有1 ≤ E ≤ 254时，真值=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msub><mo stretchy="false">)</mo><mi>s</mi></msub><mo>×</mo><mn>1.</mn><mi>M</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>127</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)_s \times 1.M \times 2^{E-127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1.</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">127</span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul><li>当<strong>阶码E全为0，尾数M不全为0</strong>时，表示<strong>非规格化小数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0.</mn><mi>x</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>126</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(0.xx...x)_2\times2^{-126}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0.</span><span class="mord mathnormal">xx</span><span class="mord">...</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">126</span></span></span></span></span></span></span></span></span></span></span></span></strong><br>【隐含最高位变为0，阶码真值固定视为 -126】</li><li>当<strong>阶码E全为0，尾数M全为0</strong>时，表示<strong>真值 ±0</strong></li><li>当<strong>阶码E全为1，尾数M全为0</strong>时，表示<strong>无穷大 ±∞</strong></li><li>当<strong>阶码E全为1，尾数M不全为0</strong>时，表示<strong>非数值“NaN”(Not a Number)</strong><br>【如: 0/0、∞-∞。等非法运算的结果就是 NaN】</li></ul><hr><h2 id="2-3-3-浮点数的运算">2.3.3 浮点数的运算</h2><ul><li><strong><u>浮点数的加减运算</u></strong></li></ul><table><thead><tr><th>浮点数的加减运算步骤：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.85211</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mo>+</mo><mn>9.96007</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.85211\times10^{12} + 9.96007 \times 10^{10}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.85211</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.96007</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></th></tr></thead><tbody><tr><td>二进制需要<strong>真值到机器数的转换</strong>，这个例子用十进制来解释，这里不需要</td></tr><tr><td>① <strong>对阶</strong><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.85211</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mo>+</mo><mn>0.0996007</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.85211\times10^{12} + 0.0996007 \times 10^{12}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.85211</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.0996007</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></td></tr><tr><td>② <strong>尾数加减</strong><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.9517107</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.9517107\times10^{12}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.9517107</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></td></tr><tr><td>③ <strong>规格化</strong><br />如果尾数加减出现类似<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.0099517</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">0.0099517 \times 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.0099517</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>时，需要“左规”；<br />如果尾数加减出现类似<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>99.517107</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">99.517107 \times 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">99.517107</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>时，需要“右规”<br />【右规时就会面临舍入的问题】</td></tr><tr><td>④ <strong>舍入</strong><br />若规定只能保6位有效尾数，则：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.9517107</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mo>→</mo><mn>9.95171</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.9517107 \times 10^{12} → 9.95171 \times10^{12}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.9517107</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.95171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span> —— (多余的直接砍掉)<br />或者，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.9517107</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mo>→</mo><mn>9.95172</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.9517107 \times 10^{12} → 9.95172 \times10^{12}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.9517107</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.95172</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span> —— (若砍部分非0，则入1)<br />或者，也可以采用四舍五入的原则，当舍弃位≥5时，高位入1<br />【可以有不同的舍入规则】</td></tr><tr><td>⑤ <strong>判断溢出</strong><br />若规定阶码不能超过两位，则运算后阶码超出范围，则溢出<br />如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.85211</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>99</mn></msup><mo>+</mo><mn>9.96007</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>99</mn></msup><mo>=</mo><mn>19.81218</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>99</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9.85211\times10^{99} + 9.96007 \times10^{99}=19.81218\times 10^{99}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.85211</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">99</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9.96007</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">99</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">19.81218</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">99</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span> <br />规格化并用四舍五入的原则保留6位尾数，得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>198122</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>100</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">198122 \times 10^{100}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">198122</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span> <br /><strong>阶码超过两位，发生溢出</strong>（注：<strong>尾数溢出未必导致整体溢出</strong>，也许可以通过③④两来)</td></tr></tbody></table><p>【思考】<strong>对阶的时候为什么小阶向大阶对齐</strong>？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>计算机内部尾数是定点小数实现的，例如：0.1122334，如果向小阶对齐可能会变成1122.334，这对计算机来说是不合适的</p><p><strong>例</strong>：已知十进制数X=-5/256、Y=+59/1024，按机器补码浮点运算规则计算X-Y，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位<br>【IEEE 754最少都32位，所以考试一般像这题一样这么考】</p><p><strong>答</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_10-50-47.png" alt=""></p><hr><ul><li><strong><u>浮点数的加减运算-舍入</u></strong></li></ul><p><strong>”0“舍“1”入法</strong> ：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_10-58-29.png" alt=""></p><p><strong>恒置“1”法</strong> ：尾数右移时，不论的最高数值位是“1”还是“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_10-59-35.png" alt=""></p><p>有的计算机可能会把浮点数的尾数部分单独拆出去计算(24bit→32bit)，算完了经过舍入(32bit→24bit)再拼回浮点数</p><hr><ul><li><strong><u>强制类型转换</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_11-03-34.png" alt=""></p><p>由于大部分教材按照32位机器编写，考试通常也是32位机器来考察</p><p>范围、精度从小到大，转换过程没有损失：</p><ul><li>char → int → long → double；【这里long是32位，64位就错了】</li><li>float → double</li></ul><p>【<strong>常考</strong>】：</p><ul><li><p>int：表示整数，范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{31}, 2^{31}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，有效数字32位<br>float：表示整数及小数，范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mo stretchy="false">[</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>126</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>127</mn></msup><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">(</mo><mn>2</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>23</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">±[2^{-126}, 2^{127}]\times(2-2^{-23})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">±</span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">126</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">127</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">23</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，有效数字23+1=24位</p></li><li><p><strong>int → float：可能损失精度</strong><br><strong>float → int：可能溢出及损失精度</strong></p></li></ul><hr><h1>第三章 存储系统</h1><h2 id="3-1-存储系统基本概念">3.1 存储系统基本概念</h2><ul><li><strong><u>存储器的层次化结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-25-22.png" alt=""></p><p>注：有的教材把安装在电脑内部的磁盘称为“辅存”，把U、光盘等称为“外存”；也有的教材把磁盘、U盘、光盘等统为“辅存”或“外存”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-31-54.png" alt=""></p><p>如上图，辅存中的数据要调入主存后，才能被CPU访问</p><p>主存—辅存：实现虚拟存储系统，<strong>解决了主存容量不够的问题</strong><br>Cache—主存：<strong>解决了主存与CPU速度不匹配的问题</strong></p><hr><ul><li><strong><u>存储器的分类——层次</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-40-49.png" alt=""></p><hr><ul><li><strong><u>存储器的分类——存储介质</u></strong></li></ul><p>存储器的功能：存放二进制信息</p><p>按存储介质分：</p><ol><li><strong>半导体储器</strong>（主存、Cache)<br>以半导体器件存储信息</li><li><strong>磁表面存储器</strong>：磁盘、磁带<br>以磁性材料存储信息</li><li><strong>光存储器</strong><br>以光介质存储信息</li></ol><hr><ul><li><strong><u>存储器的分类——存取方式</u></strong></li></ul><ol><li><strong>随机存取存储器</strong>（Random Access Memory, <strong>RAM</strong>)<br>读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关。如下图：</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-46-01.png" alt=""></p><ol start="2"><li><strong>顺序存取存储器</strong>（Sequential Access Memory，<strong>SAM</strong>)<br>读写一个存储单元所需时间取决于存储单元所在的物理位置。如下图：</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-46-13.png" alt=""></p><ol start="3"><li><strong>直接存取存储器</strong>（Direct Access Memory，<strong>DAM</strong>)<br>既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。如下图：</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-07-19.png" alt=""></p><p>串行访问存储器：（SAM和DAM是串行访问存储器）<br>读写某个存储单元所需时间与存储单元的物理位置有关。</p><ol start="4"><li><strong>相联存储器</strong>（Associative Memory)，即可以按内容访问的存储器 (Content Addressed Memory，<strong>CAM</strong>）<br>可以按照内容检索到存储位置进行读，“快表”就是一种相联存储器。</li></ol><hr><ul><li><strong><u>存储器的分类——信息的可更改性</u></strong></li></ul><ol><li><p><strong>读写存储器</strong>（Read/Write Memory) —— 即可读、也可写（如: 磁盘、内存、Cache)</p></li><li><p><strong>只读存储器</strong>（Read Only Memory，<strong>ROM</strong>) —— 只能读，不能写（如：实体音乐专辑通常采用CD-ROM，实体电影采用蓝光光碟，BIOS通常写在ROM中)</p><p>事实上很多ROM也可多次读写，只是比较麻烦</p></li></ol><hr><ul><li><strong><u>存储器的分类一一信息的可保存性</u></strong></li></ul><p>断电后，存储信息消失的存储器一一<strong>易失性存储器</strong>(主存、Cache)<br>断电后，存储信息依然保持的存储器一一<strong>非易失性存储器</strong>(磁盘、光盘)</p><p>信息读出后，原存储信息被破坏一一<strong>破坏性读出</strong>(如DRAM芯片，读出数据后要进行重写)<br>信息读出后，原存储信息不被破坏一一<strong>非破坏性读出</strong>(如SRAM芯片、磁盘、光盘)</p><hr><ul><li><strong><u>存储器的性能指标</u></strong></li></ul><ol><li><strong>存储容量</strong>：存储字数 × 字长（如1M × 8位）<br>【MDR位数反映存储字长】</li><li><strong>单位成本</strong>：每位价格 = 总成本 / 总容量。</li><li><strong>存储速度</strong>：<strong>数据传输率</strong> = 数据的宽度 / 存储周期<br>【数据的宽度即存储字长，这里是说因为一个周期处理一个存储字长】</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_17-44-42.png" alt=""></p><p>①存取时间（Ta）：存取时间是指从启动一次到完成该操作所经历的时间，分为读出时间和写入时间。<br>②存取周期（Tm）：存取周期又称为读周期或访周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。</p><p><strong>主存带宽</strong> （Bm）：<strong>主存带宽</strong>又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒(B/s)或位/秒(b/s)。【和上面数据传输率一样，按上面的算就好】</p><hr><h2 id="3-2-1-主存储器的基本组成">3.2.1 主存储器的基本组成</h2><ul><li><strong><u>基本的半导体元件及原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-18-54.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-31-15.png" alt=""></p><p>存储体由多个存储单元构成，每个存储单元又由多个<strong>存储元</strong>（存储元件）构成。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-27-13.png" alt=""></p><p>注：MOS管可理解为一种电控开关，输入电压达到某个闽值时，MOS管就可以接通。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-30-19.png" alt=""></p><hr><ul><li><strong><u>存储芯片的基本原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-45-26.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>S</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{CS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>：chip select，芯片选择信号<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>E</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{CE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">CE</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>：chip enable，芯片使能信号<br>注：头上划线表示该信号低电平有效</p><p>抽象出来，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-48-36.png" alt=""></p><p>上图中，每根线都对应一个金属引脚：（另外，还有供电引脚、接地引脚)<br>【常考判断引脚个数】：地址线 + 数据线 +片选线 + 读/写控制线（1/2根）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-49-39.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_18-50-47.png" alt=""></p><table><thead><tr><th>描述</th></tr></thead><tbody><tr><td>n位地址 → <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个存储单元<br/>总容量 = 存储单元个数 × 存储字长 = 2³ × 8bit = 2³ × 1Byte = 8B<br />8 × 8位的存储芯片</td></tr><tr><td>常见的描述: <br />8K × 8位，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">2^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span>×8bit<br />8K × 1位，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">2^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span>×1bit<br/>64K × 16位，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>×16bit</td></tr><tr><td>2^10:<strong>K</strong>    2^20:<strong>M</strong>    2^30:<strong>G</strong>    2^40:<strong>T</strong></td></tr></tbody></table><hr><ul><li><strong><u>寻址</u></strong></li></ul><p>总容量为1KB<br>按字节寻址：1K个单元，每个单元1B<br>按字寻址：256个单元，每个单元4B<br>按半字寻址: 512个单元，每个单元2B<br>按双字寻址: 128个单元，每个单元8B</p><p>若按字节寻址：1K个单元对应10根地址线：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_19-06-46.png" alt=""></p><p>若按字寻址：字地址到字节地址的转换，字地址左移两位，相当于×4，其他转换类似</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_19-10-28.png" alt=""></p><hr><h2 id="3-2-2-SRAM和DRAM">3.2.2 SRAM和DRAM</h2><blockquote><p>Dynamic Random Access Memory，即动态RAM<br>Static Random Access Memory，即静态RAM<br>DRAM用于主存、SRAM用于Cache<br>高频考点: DRAM和SRAM的对比</p></blockquote><ul><li><strong><u>DRAM芯片</u></strong></li></ul><p>DRAM芯片:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_20-52-58.png" alt=""></p><p>DRAM芯片: 使用<strong>栅极电容</strong>存储信息<br>SRAM芯片: 使用<strong>双稳态触发器</strong>存储信息<br>核心区别: 存储元不一样</p><hr><ul><li><strong><u>栅极电容 v.s. 双稳态触发器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-02-45.png" alt=""></p><p>存储时：1: 电容内存储了电荷；0: 电容内未存储电荷</p><p>读取时：读出1: MOS管接通，<u>电容放电</u>，数据线上产生电流；读出0: MOS管接通后，数据线上无电流<br>【电容放电信息被破坏，是<strong>破坏性读出</strong>。读出后应有<strong>重写</strong>操作，也称“再生“，→ <strong>读写速度更慢</strong>】</p><p>每个存储元制造成本更低，集成度高，功耗低</p><p>电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失 → 需要刷新【2ms之内必须“刷新”一次（给电容充电)】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-08-07.png" alt=""></p><p>读出时：如上图，只会在一边输出低电平，不是左边就是右边<br>【读出数据，触发器状态保持稳定，是<strong>非破坏性读出，无需重写</strong>，→ <strong>读写速度更快</strong>】</p><p>存储时：<strong>双稳态</strong>：1: A高B低；0:A低B高【即左边数据线高电平，右边低电平就写入了1；左边数据线低电平，右边高电平就写入了0】</p><p>每个存储元制造成本更高，集成度低，功耗大</p><p>只要不断电触发器的状态就不会改变</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-22-05.png" alt=""></p><p>现在DRAM已经过时了，现在的主存通常采用SDRAM芯片【买电脑时候看到的DDR3,DDR4都属于SDRAM】</p><hr><ul><li><strong><u>DRAM的刷新</u></strong></li></ul><p>“刷新”由存储器独立完成，不需要CPU控制</p><ol><li><strong>多久需要刷新一次</strong>?</li></ol><p>刷新周期: 一般为2ms</p><ol start="2"><li><strong>每次刷新多少存储单元</strong>?</li></ol><p>以行为单位，每次刷新一行存储单元</p><p>——<strong>为什么要用行列地址</strong>?</p><p>减少选通线的数量</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-37-00.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-37-35.png" alt=""></p><p>对于地址：0000 0000如图选择</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-39-35.png" alt=""></p><p>所以：如：2^8=256根选通线，2^4+2^4=32根选通线</p><ol start="3"><li><strong>如何刷新</strong>?</li></ol><p>有硬件支持，读出一行的信息后重新写入，占用1个读/写周期</p><ol start="4"><li><strong>在什么时刻刷新</strong>?【常考选择题】</li></ol><p>假设DRAM内部结构排列成128 × 128的形式，读/写周期（存取周期）0.5us<br>2ms 共 2ms/0.5us = 4000 个周期</p><p>思路一：每次读写完都刷新一行<br>→ 系统的存取周期变为1us<br>前0.5us时间用于正常读写<br>后0.5us时间用于刷新某行</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-46-17.png" alt=""></p><p>思路二：2ms内集中安排时间全部刷新<br>→ 系统的存取周期还是0.5us<br>有一段时间专门用于刷新，无法访问存储器，称为访存“死区”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-46-30.png" alt=""></p><p>思路三：2ms内每行刷新1次即可<br>→ 2ms内需要产生128次刷新请求<br>每隔2ms/128 =15.6us<br>一次每15.6us内有0.5us的“死时间“<br>【实际可以利用cpu不需要访问的时候进行刷新，如下图译码阶段】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-46-43.png" alt=""></p><hr><ul><li><strong><u>DRAM的地址线复用技术</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_15-49-53.png" alt=""></p><p>行、列地址分两次送，可使地址线更少，芯片引脚更少</p><hr><h2 id="3-2-3-只读存储器ROM">3.2.3 只读存储器ROM</h2><blockquote><p>RAM芯片——易失性，断电后数据消失<br>ROM芯片——非易失性，断电后数据不会丢失</p><p>ROM:</p><ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>闪存</li><li>SSD</li></ul></blockquote><ul><li><strong><u>了解各种ROM</u></strong></li></ul><p><strong>MROM</strong> (Mask Read-Only Memory)——掩模式只读存储器<br>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<strong>任何人不可重写</strong>(只能读出)<br>可靠性高、灵活性差、生产周期长、只适合批量定制</p><p><strong>PROM</strong> (Programmable Read-Only Memory)——可编程只读存储器<br>用户可用专门的PROM写入器写入信息，<strong>写一次之后就不可更改</strong></p><p><strong>EPROM</strong>(Easable Programmable Read-Only Memory)——可擦除可编程只读存储器<br>允许用户写入信息，之后用某种方法擦除数据，<strong>可进行多次重写</strong><br><strong>UVEPROM</strong>(ultraviolet rays)——用紫外线照射8~20分钟，擦除<strong>所有</strong>信息<br><strong>EEPROMY</strong>也常记为E²PROM，第一个E是Electrically) ——可用“电擦除”的方式，擦除<strong>特定的字</strong></p><p><strong>Flash Memory</strong> ——闪速存储器(注:U盘SD卡就是闪存)<br>在EEPROM 基础上发展而来，断电后也能保存信息，且<strong>可进行多次快速擦除重写</strong><br>注意:由于闪存需要先擦除在写入，因此闪存的“<strong>写”速度要比“读”速度更慢</strong><br>【每个存储元只需单个MOS管，位密度比RAM高】</p><p><strong>SSD</strong> (Solid state Drives)——固态硬盘<br>由控制单元+存储单元(Flash 芯片)构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<strong>可进行多次快速擦除重写</strong>。SSD速度快、功耗低、价格高。目前个人电脑上常。用SSD取代传统的机械硬盘</p><p>拓：手机辅存也使用Flash芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_17-35-45.png" alt=""></p><hr><ul><li><strong><u>计算机内的重要ROM</u></strong></li></ul><p>CPU的任务：到主存中取指令并执行指令<br>断电后RAM内数据全部丢失</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_17-39-27.png" alt=""></p><p>操作系统安装在辅存</p><p>一开始cpu中啥也没有，就需要从主板上的一块ROM芯片读取开机所需要的那些指令：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_17-42-06.png" alt=""></p><p>主板上的BIOS芯片 (ROM)存储了“自举装入程序”，负责引导装入操作系统 (开机)</p><p>所以主存逻辑上，由RAM+ROM组成，且二者常统一编址</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_17-46-31.png" alt=""></p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p>很多ROM芯片虽然名字是“Read-Only”，但<strong>很多ROM也可以“写”</strong></p><p><strong>闪存的写速度一般比读速度更慢</strong>，因为写入前要先擦除</p><p>RAM芯片是易失性的，ROM芯片是非易失性的。<strong>很多ROM也具有“随机存取”的特性</strong></p><hr><h2 id="3-2-4-双端口RAM和多模块存储器">3.2.4 双端口RAM和多模块存储器</h2><blockquote><p><strong>好消息!好消息!</strong></p><p>本小节涉及两种内存优化技术，分别是“双端口RAM和“多模块存储器<br>其中，“<strong>双端口RAM</strong>”<strong>已从408大纲删除</strong>，但由于部分自命题院校依然会考这个概念，所以仍然保留了这部分内容</p><ul><li>408考生<strong>简要了解“双端口RAM”即可</strong>，408考试不考</li><li>408考生<strong>重点掌握“多模块存储器”</strong> ，这是考试重点。建议自命题考生认真学习“双端口RAM”，掌握基本概念即可，这个考点大概率以概念型选择题的形式考</li></ul></blockquote><ul><li><strong><u>存取周期</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_17-44-42.png" alt=""></p><p><strong>存取周期：可以连续读/写的最短时间间隔</strong></p><p>注：DRAM芯片的恢复时间比较长，有可能是存取时间的几倍 (SRAM的恢复时间较短)</p><p>【问】：<br>多核CPU都要访存，怎么办?<br>CPU的读写速度比主存快很多，主存恢复时间太长怎么办?</p><hr><ul><li><strong><u>知识总览</u></strong></li></ul><p>提升主存速度：</p><ul><li>双端口RAM</li><li>多模块存储器<ul><li>单体多字存储器</li><li>多体并行存储器<ul><li>高位交叉编址</li><li>低位交叉编址</li></ul></li></ul></li><li>实际应用：如何让你的电脑变成“双通道内存?</li></ul><hr><ul><li><strong><u>双端口RAM</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-04-00.png" alt=""></p><p>作用：优化多核CPU访问一根内存条的速度</p><p>需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路</p><p>两个端口对同一主存操作有以下4种情况:</p><ol><li>两个端口同时对不同的地址单元存取数据。✔</li><li>两个端口同时对同一地址单元读出数据。✔</li><li>两个端口同时对同一地址单元写入数据。✘</li><li>两个端口同时对同一地址单元，一个写入数据，另一个读出数据。✘</li></ol><p>解决方法：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口(即被延时) ，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-06-09.png" alt=""></p><p>对比操作系绞<strong>读者-写者</strong>问题</p><hr><ul><li><strong><u>多体并行存储器</u></strong></li></ul><p>高位交叉编址的多体存储器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-16-02.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-23-51.png" alt=""></p><p>低位交叉编址的多体存储器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-16-09.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-25-30.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-28-40.png" alt=""></p><p>思考: 为什么要探讨“连续访问”的情况?</p><hr><ul><li><strong><u>应该取几个“体”?</u></strong></li></ul><p>低位交叉编址的多体存储器应该取几个“体”?</p><p>采用“<strong>流水线</strong>”的方式并行存取(宏观上并行，微观上串行)<br>宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍。</p><p>两种常见描述：<br>存取周期为T，<strong>存取时间为r</strong>，为了使流水线不间断，应保证模块数m≥T/r<br>存取周期为T，<strong>总线传输周期为r</strong>（把数据传给cpu），为了使流水线不间断，应保证模块数 m≥T/r</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-36-11.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-36-23.png" alt=""></p><p>所以完美衔接的是模块数m=T/r，即上面的例子</p><p>思考: 给定一个地址x，如何确定它属于第几个存储体?</p><hr><ul><li><strong><u>多模块存储器</u></strong></li></ul><p>多体并行存储器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-16-09.png" alt=""></p><p>每个模块都有相同的容量和存取速度。<br>各模块都有独立的读写控制电路、地址寄存器和数据寄存器它们既能并行工作，又能交叉工作。</p><p>单体多字存储器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-46-21.png" alt=""></p><p>相当于将多体并行存储器的几个体合并，用一套控制电路、地址寄存器和数据寄存器<br>每个存储单元存储m个字<br>总线宽度也为m个字<br>一次并行读出m个字<br>每次只能同时取m个字，不能单独取其中某个字<br>指令和数据在主存内必须是连续存放的</p><hr><ul><li><strong><u>同学，你学计算机的? 那…</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_18-58-34.png" alt=""></p><p>如何插入内存条，实现<strong>高位交叉</strong>的多体存储器(相当于单纯的扩容)?<br>如何插入内存条，实现<strong>低位交叉</strong>的多体存储器(俗称“双通道”)?【插图中相同颜色部分】<br>Tips：买内存条时，可挑选<strong>相同主频</strong>、<strong>相同容量</strong>的两根来组成双通道</p><p>所以很多商家两个一起卖</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_19-00-37.png" alt=""></p><p>我的电脑的内存情况：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_19-01-31.png" alt=""></p><hr><h2 id="3-3-1-主存储器与CPU的连接">3.3.1 主存储器与CPU的连接</h2><blockquote><ul><li><strong><u>知识总览</u></strong></li></ul><p>存储器与CPU的连接：</p><ul><li>单块存储芯片与CPU的连接</li><li>多块存储芯片与CPU的连接<ul><li>位扩展法</li><li>字扩展法<ul><li>线选法</li><li>片选法</li></ul></li><li>字位扩展法</li></ul></li><li>关于译码器知识的补充</li></ul></blockquote><ul><li><strong><u>单块存储器与CPU的连接</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_20-52-58.png" alt=""></p><p>如上图是8×8位的存储芯片</p><p>想要扩展主存字数怎么办?——<strong>字扩展</strong></p><p>数据总线宽度&gt;存储芯片字长,怎么办? ——<strong>位扩展</strong></p><p>注：现在的计算机MAR、MDR通常集成在CPU内部。存储芯片只需要一个普通的寄存器（暂存输入、输出数据）</p><hr><ul><li><strong><u>现在的计算机</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_20-51-11.png" alt=""></p><p>主存中包含多块存储芯片</p><hr><ul><li><strong><u>包含多块存储芯片</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_20-49-38.png" alt=""></p><hr><ul><li><strong><u>存储器芯片的输入输出信号</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-00-32.png" alt=""></p><hr><ul><li><strong><u>增加主存的存储字长-位扩展</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-04-53.png" alt=""></p><p>如下图：<strong>8片8K x 1位的存储芯片 → 1个8K x 8位的存储器，容量8KB</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-05-51.png" alt=""></p><hr><ul><li><strong><u>增加主存的存储字数-字扩展</u></strong></li></ul><p>线选法：</p><p>如下图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>14</mn></msub></mrow><annotation encoding="application/x-tex">A_{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>13</mn></msub></mrow><annotation encoding="application/x-tex">A_{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>只能为01或10<br>n条线 → n个选片信号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-17-22.png" alt=""></p><p>译码片选法: n条线 → <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个选片信号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-20-38.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-22-27.png" alt=""></p><p>低电平有效加小圆圈，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-25-49.png" alt=""></p><p>考试中可能会考察你，然后将上图改成：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-27-12.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>14</mn></msub></mrow><annotation encoding="application/x-tex">A_{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>完全不影响选择，但是合法地址变多了一倍，取0取1都对应到同一块存储器，所以这是不合理的。所以现实中完全不会这么做，这只是考试故意的。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-31-23.png" alt=""></p><hr><ul><li><strong><u>主存容量扩展-字位同时扩展</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-35-27.png" alt=""></p><hr><ul><li><strong><u>补充：译码器</u></strong></li></ul><p>下图译码器型号74ls138</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-43-08.png" alt=""></p><p>注：CPU可使用译码器的使能端控制片选信号的生效时间</p><p>RAM的读周期：【灰色是无效】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-06_21-45-20.png" alt=""></p><hr><h2 id="3-4-1-磁盘存储器">3.4.1 磁盘存储器</h2><blockquote><ul><li><strong><u>本节总览</u></strong></li></ul><p>外部存储器：</p><ul><li>磁盘存储器——Key：磁盘存取时间的计算</li><li>固态硬盘(SSD)</li></ul></blockquote><ul><li><strong><u>外存储器</u></strong></li></ul><p>计算机的<strong>外存储器</strong>又称为<strong>辅助存储器</strong>，目前主要使用磁表面存储器。<br>所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_09-41-18.png" alt=""></p><p>磁表面存储器的<strong>优点</strong>:<br>①存储容量大，位价格低；<br>②记录介质可以重复使用；<br>③记录信息可以长期保存而不丢失，甚至可以脱机存档；<br>④非破坏性读出，读出时不需要再生。</p><p>磁表面存储器的<strong>缺点</strong>:<br>①存取速度慢；<br>②机械结构复杂；<br>③对工作环境要求较高。</p><p>外存储器既可以作为输入设备，也可以作为输出设备(既可以存数据，也可以读数据)</p><hr><ul><li><strong><u>磁盘存储器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_09-46-02.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_09-46-32.png" alt=""></p><p><strong>1、磁盘设备的组成</strong></p><p><strong>①存储区域</strong>：<br>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区(也称块)是磁盘读写的最小单位，也就是说磁盘按块存取。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_09-57-06.png" alt=""></p><p>磁头数：即记录面数，表示硬盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。</p><p>柱面数：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号(位置)的诸磁道构成一个圆柱面。</p><p>扇区数：表示每一条磁道上有多少个扇区。</p><p><strong>②硬盘存储器</strong>：硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件，温彻斯特是一种可移动头固定盘片的硬盘存储器。<br>磁盘控制器：是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</p><p>值得一提的是每个磁盘，可以在正反两面涂上磁性材质：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-00-02.png" alt=""></p><p><strong>2、磁盘的性能指标</strong></p><p><strong>①磁盘的容量</strong>：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。</p><p>非格式化容量是指磁记录表面可以利用的磁化单元总数。<br>格式化容量是指按照某种特定的记录格式所能存储信息的总量。</p><p><strong>②记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</p><p>道密度是沿磁盘半径方向单位长度上的磁道数;<br>位密度是磁道单位长度上能记录的二进制代码位数;<br>面密度是位密度和道密度的乘积。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-03-26.png" alt=""></p><p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-04-16.png" alt=""></p><p><strong>③平均存取时间</strong>:【常考】</p><p>平均存取时间 =<br>寻道时间(磁头移动到目的磁道) +<br>旋转延迟时间(磁头定位到所在扇区) +<br>传输时间(传输数据所花费的时间)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-07-37.png" alt=""></p><p><strong>④数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。</p><p>假设磁盘转数为r(转/秒)，每条磁道容量为N个字节，则数据传输率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">D_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=rN【理论最大值】</p><p><strong>3、磁盘地址结构</strong></p><p>主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-13-30.png" alt=""></p><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-14-19.png" alt=""></p><p><strong>4、磁盘的工作过程</strong></p><p>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制第二步是执行控制字。<br>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p><p>所以如下设计：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-16-25.png" alt=""></p><hr><ul><li><strong><u>磁盘阵列</u></strong></li></ul><p>RAID ( Redundant Array of lnexpensive Disks，廉价余磁盘阵列)是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p><p>RAID的分级如下所示。在RAID1~RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。</p><p>RAID0：无冗余余和无校验的磁盘阵列。<br>RAID1：镜像磁盘阵列。<br>RAID2：采用纠错的海明码的磁盘阵列。<br>RAID3：位交叉奇偶校验的磁盘阵列。<br>RAID4：块交叉奇偶校验的磁盘阵列。<br>RAID5：无独立校验的奇偶校验磁盘阵列</p><p><strong>RAID0</strong>：逻辑上相邻的两个扇区在物理上存到两个磁盘，类比第三章“低位交叉编址的多体存储器”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-22-59.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-23-28.png" alt=""></p><p><strong>RAID1</strong>：很粗暴，存两份数据【冗余，并行访问，对比校验】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-25-05.png" alt=""></p><p><strong>RAID2</strong>：逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位一可纠正一位错</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-27-42.png" alt=""></p><ul><li>RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong></li><li><strong>RAID1</strong>是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong></li></ul><p>RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，可以提高安全可靠性;通过数据校验，可以提供容错能力。</p><ul><li>RAID0：条带化，提高存取速度，没有容错能力</li><li>RAID1：镜像磁盘互为备份</li><li>RAID2~5：通过数据校验提高容错能力</li></ul><hr><h2 id="3-4-2-固态硬盘SSD">3.4.2 固态硬盘SSD</h2><blockquote><p>计组，操作系统考研大纲<strong>新考点</strong></p><p>操作系统：<br>固态硬盘；读写性能特性，磨损均衡</p><p>计算机组成原理：固态硬盘(SSD)</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-39-25.png" alt=""></p><hr><ul><li><strong><u>机械硬盘 vs 固态硬盘</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-40-55.png" alt=""></p><hr><ul><li><strong><u>固态硬盘的结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-47-12.png" alt=""></p><p>每个闪存芯片由若干块组成，比如块大小:16KB~512KB</p><p>每个块再拆解为一个一个页，比如页大小，512B~4KB</p><p>系统读写以 页 为单位，磁盘中则是块（扇区），这里作区分</p><hr><ul><li><strong><u>理想情况下，固态硬盘的寿命</u></strong></li></ul><p>某固态硬盘采用磨损均衡技术，大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span></span></span></span>B=1TB，闪存块的擦写寿命只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>=1K次。某男子平均每天会对该固态硬盘写<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>37</mn></msup></mrow><annotation encoding="application/x-tex">2^{37}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">37</span></span></span></span></span></span></span></span></span></span></span></span>B=128GB数据。在最理想的情况下，这个固态硬盘可以用多久?</p><p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。</p><p>1TB/128GB =8<br>因此，平均每8天，每个闪存块需要擦除一次。每个闪存块可以被擦除1K次，因此，经过8K天，约23年后，该固态硬盘被男子玩坏</p><p>所以没那么容易坏</p><hr><h2 id="3-5-1-Cache的基本概念和原理">3.5.1 Cache的基本概念和原理</h2><ul><li><strong><u>存储系统存在的问题</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-07-31.png" alt=""></p><hr><ul><li><strong><u>Cache工作原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-13-59.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-14-56.png" alt=""></p><p>下图中Cache比内存快60倍</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-11-37.png" alt=""></p><p>注:实际上, Cache被集成在CPU内部；Cache用SRAM实现，速度快，成本高</p><hr><ul><li><strong><u>局部性原理</u></strong></li></ul><p>程序A:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i，j,sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++) </span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            sum += a[il[j];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-22-12.png" alt=""></p><p><strong>空间局部性</strong>：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的<br>Eg: 数组元素、顺序执行的指令代码</p><p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息<br>Eg: 循环结构的指令代码</p><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到cache中</p><p>程序B:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i，j,sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++) </span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            sum += a[il[j];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序B按“列优先”访问二维数组，空间局部性更差</p><hr><ul><li><strong><u>性能分析</u></strong></li></ul><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">t_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次Cache所需时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次主存所需时间<br><strong>命中率 H</strong>：CPU欲访问的信息已在Cache中的比率<br><strong>缺失(未命中)率 M</strong> =1- H</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_11-43-54.png" alt=""></p><p>Cache一主存系统的平均访问时间 t 为：（先访问Cache，若Cache未命中再访问主存）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><msub><mi>t</mi><mi>m</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">t=H t_{c}+(1-H)\left(t_{c}+t_{m}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></p><p>或：（同时访问 Cache和主存，若cache命中则立即停止访问主存）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t=H t_{c}+(1-H) t_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>【例3-2】 假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后存储器性能提高多少(设Cache和主存同时被访问，若Cache命中则中断访问主存)?</p><p>设Cache的存取周期为t，则主存的存取周期为5t</p><p><strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t<br>平均访问时间为 0.95 × t + 0.05 × 5t=1.2t</p><p>故性能为原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>5</mn><mi>t</mi></mrow><mrow><mn>1.2</mn><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{5t}{1.2t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.2</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ≈ 4.17倍</p><p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为 t+5t<br>平均访问时间为 0.95 × t+ 0.05 × 6t = 1.25t</p><p>故性能为原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>5</mn><mi>t</mi></mrow><mrow><mn>1.25</mn><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{5t}{1.25t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.25</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> = 4倍</p><hr><ul><li><strong><u>有待解决的问题</u></strong></li></ul><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到Cache中。如何界定“周围”?</p><p>将主存的 <strong>存储空间“分块”</strong> ，如: 每1KB为一块。!<strong>主存与Cache之间以“块”为单位进行数据交换</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_12-04-07.png" alt=""></p><p>假设主存的地址共22位：4M=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span>，1K=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>，整个主存被分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> =4096块</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_12-05-07.png" alt=""></p><p>注:操作系统中通常将主存中的“一个<strong>块</strong>”也称为”一个<strong>页/页面/页框</strong>”<br>Cache中的“<strong>块</strong>”也称为“<strong>行</strong>”</p><p><strong>注意: 每次被访问的主存块定会被立即调入Cache</strong></p><ul><li><p>如何区分 Cache与主存的数据块对应关系?</p><p>——Cache和主存的映射方式</p></li><li><p>Cache和主存的映射方式替换算法Cache 很小，主存很大。如果cache满了怎么办?</p><p>——替换算法</p></li><li><p>CPU修改了cache中的数据副本，如何确保主存中数据母本的一致性?</p><p>——Cache写策略</p></li></ul><hr><h2 id="3-5-2-Cache和主存的映射方式">3.5.2 Cache和主存的映射方式</h2><ul><li><strong><u>本节总览</u></strong></li></ul><p><strong>全相联映射</strong>：</p><p>主存块可以放在Cache的任意位置</p><p>优点: Cache存储空间利用充分，命中率高;<br>缺点: 查找“标记”最慢，有可能需要对比所有行的标记</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_14-52-49.png" alt=""></p><p><strong>直接映射</strong>：</p><p>每个主存块只能放到一个特定的位置:</p><p>Cache块号 = 主存块号 % Cache总块数</p><p>优点: 对于任意一个地址，只需对比一个“标记”，速度最快;<br>缺点: Cache 存储空间利用不充分，命中率低</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_14-52-45.png" alt=""></p><p><strong>组相联映射</strong>：</p><p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置</p><p>组号 = 主存块号 % 分组数</p><p>优点: 另外两种方式的折中，综合效果较好</p><p>术语：n路组相联映射——每n个Cache行为一组</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_14-52-38.png" alt=""></p><ul><li><p>如何区分Cache中存放的是哪个主存块?</p><p>给每个Cache块增加一个“<strong>标记</strong>”，记录对应的主存块号</p></li><li><p>有“标记”就够了？</p><p>还要增加“<strong>有效位</strong>”</p></li></ul><p>标记、有效位的二进制表示初始都为0</p><p>Cache中存储的信息：</p><ul><li>有效位(0/1) + 标记 + 整块数据</li><li>其中“标记”用于指明对应的内存块，不同映射方式，“标记”的位数不同</li></ul><hr><ul><li><strong><u>全相联映射（随意放）</u></strong></li></ul><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行（即Cache块，与主存块的大小相等），行长为64B</p><p>256M = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>28</mn></msup></mrow><annotation encoding="application/x-tex">2^{28}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span></span></span></span>主存的地址共28位:</p><table><thead><tr><th style="text-align:center">主存块号</th><th style="text-align:center">块内地址</th></tr></thead><tbody><tr><td style="text-align:center">22位</td><td style="text-align:center">6位</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-04-18.png" alt=""></p><hr><ul><li><strong><u>全相联映射”如何访存?</u></strong></li></ul><p>CPU 访问主存地址1…1101 <u>001110</u>:<br>①主存地址的前22位，对比Cache中所有块的标记;<br>②若标记匹配且有效位=1，则Cache命中，访问块内地址为001110 的单元。<br>③若未命中或有效位=0，则正常访问主存</p><hr><ul><li><strong><u>直接映射（只能放固定位置）</u></strong></li></ul><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行（即Cache块，与主存块的大小相等），行长为64B</p><p>256M = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>28</mn></msup></mrow><annotation encoding="application/x-tex">2^{28}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span></span></span></span>主存的地址共28位:</p><table><thead><tr><th style="text-align:center">主存块号</th><th style="text-align:center">块内地址</th></tr></thead><tbody><tr><td style="text-align:center">22位</td><td style="text-align:center">6位</td></tr></tbody></table><p>能否<strong>优化标记</strong>?</p><p>直接映射，<strong>主存块在Cache中的位置 = 主存块号 % Cache总块数</strong><br>主存块号%2³相当于留下最后三位二进制数</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-07-52.png" alt=""></p><p>若Cache总块数 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，则主存块号末尾n位直接反映它在Cache中的位置<br>将主存块号的其余位作为标记即可</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-14-05.png" alt=""></p><hr><ul><li><strong><u>&quot;直接映射”如何访存?</u></strong></li></ul><p>CPU 访问主存地址0…01<strong>000</strong> <u>001110</u> :<br>①根据主存块号的<strong>后3位</strong>确定Cache行<br>②若主存块号的<strong>前19位</strong>与Cache标记匹配且有效位=1，则Cache命中，访问块内地址为001110的单元。<br>③若未中或有效位=0，则正常访问主存</p><hr><ul><li><strong><u>组相联映射（可放到特定分组）</u></strong></li></ul><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行（即Cache块，与主存块的大小相等），行长为64B</p><p>256M = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>28</mn></msup></mrow><annotation encoding="application/x-tex">2^{28}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span></span></span></span>主存的地址共28位:</p><table><thead><tr><th style="text-align:center">主存块号</th><th style="text-align:center">块内地址</th></tr></thead><tbody><tr><td style="text-align:center">22位</td><td style="text-align:center">6位</td></tr></tbody></table><p>能否<strong>优化标记</strong>?</p><p>组相联映射，<strong>所属分组 = 主存块号 % 分组数组相联映射</strong><br>主存块号%2²相当于留下最后两位二进制数</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-18-02.png" alt=""></p><p>若Cache总组数 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，则主存块号末尾n位直接反映它在Cache中所属组的位置<br>将主存块号的其余位作为标记即可</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-23-15.png" alt=""></p><hr><ul><li><strong><u>“组相联映射”如何访存</u></strong></li></ul><p>CPU 访问主存地址1…11<strong>01</strong> <u>001110</u>:<br>①根据主存块号的后2位确定所属分组号<br>②若主存块号的前20位与分组内的某个标记匹配且有效位=1, 则Cache命中，访问块内地址为001110的单元。<br>③若未命中或有效位=0，则正常访问主存</p><hr><h2 id="3-5-3-Cache替换算法">3.5.3 Cache替换算法</h2><ul><li><strong><u>替换算法解决的问题</u></strong></li></ul><p><strong>对于全相联映射</strong>：</p><p>Cache<strong>完全满了</strong>才需要替换需要在<strong>全局选择</strong>替换哪一块</p><p><strong>对于直接映射</strong>：</p><p>如果对应位置非空，则毫无选择地直接替换；所以无需考虑算法</p><p><strong>对于组相联映射</strong>：</p><p><strong>分组内满了</strong>才需要替换需要在<strong>分组内</strong>选择替换哪一块</p><p>下面以全相联映射为例子说明四种替换算法：</p><ul><li>随机算法(RAND)</li><li>先进先出算法(FIFO)</li><li>近期最少使用(LRU)</li><li>最近不经常使用(LFU)</li></ul><hr><ul><li><strong><u>随机算法(RAND)</u></strong></li></ul><p>随机算法 (RAND,Random)——若Cache已满，则随机选择一块替换</p><p>设总共有4个cache块，初始整个Cache为空。采用全相联映射，依次访问主存块 {1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-38-23.png" alt=""></p><p>随机算法一一实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定</p><hr><ul><li><strong><u>先进先出算法(FIFO)</u></strong></li></ul><p>先进先出算法(FIFO,First In First Out)——若Cache已满，则替换最先被调入Cache 的块</p><p>设总共有4个cache块，初始整个Cache为空。采用全相联映射，依次访问主存块 {1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_15-42-59.png" alt=""></p><p>先进先出算法——实现简单，最开始按#0#1#2#3放入Cache，之后轮流替换 #0#1#2#3<br>FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的</p><p><strong>抖动现象</strong>：频繁的换入换出现 (刚被替换的块很快又被调入)</p><hr><ul><li><strong><u>近期最少使用(LRU)</u></strong></li></ul><p>近期最少使用算法(LRu,Least Recently Used )——为每一个Cache块设置个“<strong>计数器</strong>”，用于记录每个Cache块已经有多久没被访问了。当Cache满后<strong>替换“计数器”最大的</strong></p><p>①命中时，所命中的行的计数器清零，<strong>比其低的计数器加1，其余不变</strong>;<br>【Cache块的总数 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>,则计数器只需n位。且Cache装满后所有计数器的值一定不重复】<br>②未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1;<br>③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1.</p><p>设总共有4个cache块，初始整个Cache为空。采用全相联映射，依次访问主存块 {1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_16-08-29.png" alt=""></p><p>LRU算法——基于“<strong>局部性原理</strong>”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果<strong>优秀</strong>，Cache命中率高。【所以考试常考】</p><p>若被频繁访问的主存块数量 &gt;Cache行的数量，则有可能发生“抖动“，如: {1,2,3,4,5, 1,2,3,4,5, 1,2…}</p><hr><ul><li><strong><u>最近不经常使用(LFU)</u></strong></li></ul><p>最不经常使用算法(LFU,Least Frequently Used )——为每一个Cache块设置一个“<strong>计数器</strong>“，用于记录每个Cache块被访问过几次。当Cache满后<strong>替换“计数器”最小的</strong></p><p>新调入的块计数器 = 0，之后每被访问一次计数器+1。需要替换时，选择计数器最小的一行<br>若有多个计数器最小的行可按行号递增或FIFO策略进行选择</p><p>设总共有4个cache块，初始整个Cache为空。采用全相联映射，依次访问主存块 {1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_16-43-00.png" alt=""></p><p>LFU算法——曾经被经常访问的主存块在未来不一定会用到（如:微信视频聊天相关的块）<br>【比如之前的某个块一直被访问，导致计数器增加到一个很大的值，进而导致未来不用了，但是很难淘汰它】<br>并没有很好地遵循局部性原理，因此实际运行效果不如 LRU</p><hr><h2 id="3-5-4-Cache写策略">3.5.4 Cache写策略</h2><ul><li><strong><u>本节总览</u></strong></li></ul><p>Cache 写策略：</p><ul><li><p>写命中</p><ul><li>全写法</li><li>写回法</li></ul></li><li><p>写不命中</p><ul><li>写分配法</li><li>非写分配法</li></ul></li></ul><p>为何不讨论读命中、读不命中的情况?<br>读操作不会导致Cache和主存的数据不一致</p><hr><ul><li><strong><u>写命中</u></strong></li></ul><p><strong>写回法</strong>(write-back)——当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存</p><p>减少了访存次数，但存在<strong>数据不一致</strong>的隐患</p><p>添加一个脏位，表示是否被修改过</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_16-51-01.png" alt=""></p><p><strong>全写法</strong>(写直通法，write-through)——当CPU对Cache写命中时，必须把数据同时写入Cache和主存。</p><p>访存次数增加，速度变慢，但更能保证数据一致性</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_16-53-24.png" alt=""></p><p>所以全写法一般使用<strong>写缓冲</strong>(write buffer)<br>SRAM实现的FIFO队列；<br>在专门的控制电路控制下逐一写回。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_16-55-45.png" alt=""></p><p>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞</p><hr><ul><li><strong><u>写不命中</u></strong></li></ul><p><strong>写分配法</strong>(write-allocate)——当CPU对Cache写不命中时，把主存中的块调入Cache，在Cach中修改。通常<strong>搭配写回法</strong>使用。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-01-57.png" alt=""></p><p><strong>非写分配法</strong>(not-write-allocate)——当CPU对Cache写不命中时只写入主存，不调入Cache。<strong>搭配全写法</strong>使用。<br>不调入Cache，只有“读”未命中时才调入Cache</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-04-40.png" alt=""></p><hr><ul><li><strong><u>多级Cache</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-08-19.png" alt=""></p><p>现代计算机常采用多级Cache<br>离CPU越近的速度越快，容量越小<br>离CPU越远的速度越慢，容量越大</p><hr><h2 id="3-6-1-页式存储器">3.6.1 页式存储器</h2><blockquote><p>和操作系统第三章高度重合，经常作为<strong>综合考点</strong></p></blockquote><ul><li><strong><u>页式存储</u></strong></li></ul><p>4KB的程序被分为4个“页”每个页面的大小和“物理块”的大小相同</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-14-08.png" alt=""></p><p>页式存储系统：一个程序(进程)在逻辑上被分为若干个大小相等的“<strong>页面</strong>/页“，“<strong>页面</strong>”大小与“<strong>块</strong>”的<strong>大小相同</strong>。每个页面可以离散地放入不同的主存块中。</p><hr><ul><li><strong><u>虚地址 vs 实地址</u></strong></li></ul><p>逻辑地址 (虚地址)：程序员视角看到的地址<br>物理地址 (实地址)：实际在主存中的地址</p><p>取变量x至ACC存器机器指令: 000001 <u>00</u>1000000011操作码+地址码(使用逻辑地址)</p><p>操作系统将<strong>程序</strong>分“页“<br>所以现在要做的就是把<strong>逻辑地址转化为物理地址</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-34-30.png" alt=""></p><hr><ul><li><strong><u>页表: 逻辑页号→主存块号</u></strong></li></ul><p>取变量x至ACC存器机器指令: 000001 <u>00</u>1000000011操作码+地址码(使用逻辑地址)</p><p>页表数据存放在主存里</p><p>CPU执行的机器指令中，使用的是“逻辑地址”，因此需要通“页表”将逻辑地址转为物理地址<br>页表的作用：记录了每个逻辑页面存放在哪个主存块中</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-38-35.png" alt=""></p><hr><ul><li><strong><u>地址变换过程</u></strong></li></ul><p>取变量x至ACC存器机器指令: 000001 <u>00</u>1000000011操作码+地址码(使用逻辑地址)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-42-11.png" alt=""></p><p>CPU访问某个主存地址：这个块的数据可能在Cache中【局部性】；同理 → 快表TLB</p><hr><ul><li><strong><u>地址变换过程（增加TLB）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-48-54.png" alt=""></p><p>注意区别：快表中存储的是页表项的副本; Cache中存储的是主存块的副本</p><p><strong>CPU查快表为什么比慢表快</strong>？<br>快表使用SRAM，慢表使用DRAM；快表是一种“<strong>相联存储器</strong>”可以按内容寻访【3.1小节提到相联存储器】</p><hr><ul><li><strong><u>知识回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_17-25-33.png" alt=""></p><hr><h2 id="3-6-2-虚拟存储器">3.6.2 虚拟存储器</h2><blockquote><p>这部分主要还是看操作系统第三章</p></blockquote><ul><li><strong><u>套娃警告: 虚拟存储系统</u></strong></li></ul><p>微信(1GB)，需要全部调入内存?<br>——调入部分即可</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-42-22.png" alt=""></p><p>思考: 打游戏时候的“Loading”界面背后是在干嘛?<br>——将游戏地图相关数据调入内存</p><p>如何界定一部分？——分页</p><hr><ul><li><strong><u>页式虚拟存储器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-44-15.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-45-49.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-46-26.png" alt=""></p><p>有效位: 这个页面是否已调入主存<br>脏位: 这个页面是否被修改过<br>引用位: 用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次<br>物理页: 即主存块号<br>磁盘地址: 即这个页面的数据在磁盘中的存放位置</p><hr><ul><li><strong><u>存储器的层次化结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-25-22.png" alt=""></p><p>注：有的教材把安装在电脑内部的磁盘称为“辅存”，把U、光盘等称为“外存”；也有的教材把磁盘、U盘、光盘等统为“辅存”或“外存”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-20_15-31-54.png" alt=""></p><p>如上图，辅存中的数据要调入主存后，才能被CPU访问</p><p>主存—辅存：实现虚拟存储系统，<strong>解决了主存容量不够的问题</strong>【操作系统决定，哪些页面调入主存】<br>Cache—主存：<strong>解决了主存与CPU速度不匹配的问题</strong>【硬件决定主存块调入Cache】</p><hr><ul><li><strong><u>段式虚拟存储器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-51-16.png" alt=""></p><p>段式虚拟存储器一一按照功能模块拆分。如上图: #0段是自己的代码，#1段是库函数代码，#2段是变量</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_19-53-24.png" alt=""></p><p>装入位字段用来指示该段是否已经调入主存，“1”表示已装入，“0”表示未装入</p><hr><ul><li><strong><u>段页式虚拟存储器</u></strong></li></ul><p>把程序按逻辑结构分段，每段再划分为固定大小的页主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。<br>每个程序对应一个段表，每段对应一个页表。</p><p>虚拟地址 = 段号 + 段内页号 + 页内地址</p><hr><h1>第四章 指令系统</h1><h2 id="4-1-1-指令格式">4.1.1 指令格式</h2><ul><li><strong><u>现代计算机</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-44-26.png" alt=""></p><p>本章重点探讨控制器支持的指令如何设计</p><hr><ul><li><strong><u>回忆计算机的工作过程</u></strong></li></ul><p>1.2.2 各个硬件的工作原理</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-56-16.png" alt=""></p><p>操作码：指明了“做什么“<br>地址码：指明了“对谁动手”</p><p>有的指令不需要地址码(停机)</p><hr><ul><li><strong><u>本节总览</u></strong></li></ul><p>指令格式：</p><ul><li>操作码、地址码 的概念</li><li>根据地址码数目不同分类</li><li>根据指令长度分类</li><li>根据操作码的长度不同分类</li><li>根据操作类型分类</li></ul><hr><ul><li><strong><u>指令的定义</u></strong></li></ul><p><strong>指令(又称机器指令) :</strong><br>是指示计算机执行某种操作的命令, 是计算机运行的最小功能单位。</p><p>一台计算机的所有指令的集合构成该机的<strong>指令系统</strong>，也称为<strong>指令集</strong>。</p><p>注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-09-14.png" alt="Snipaste_2023-07-07_20-09-14"></p><p>Eg：x86架构、ARM架构</p><hr><ul><li><strong><u>指令格式</u></strong></li></ul><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。</p><p>一条指令通常要包括操作码字段和地址码字段两部分:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-11-36.png" alt=""></p><p>一条指令可能包含 0个、1个、2个、3个、4个 地址码…<br>根据地址码数目不同，可以将指令分为 零地址指令、一地址指令、二地址指令……</p><hr><ul><li><strong><u>零地址指令</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-15-22.png" alt=""></p><p>1、不需要操作数，如空操作、停机、关中断等指令</p><p>2、堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶【并不是不需要】</p><hr><ul><li><strong><u>一地址指令</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-15-36.png" alt=""></p><p>1、只需要单操作数，如加1、减1、取反、求补等<br>指令含义:OP(A1)→A1，<br>完成一条指令需要3次访存: 取指→读A1→写A1</p><p>2、需要两个操作数，但其中一个操作数隐含在某个寄存器(如隐含在ACC)<br>指令含义: (ACC)OP(A1)→ACC，<br>完成一条指令需要2次访存: 取指→读A1</p><p>注: <strong>A1指某个主存地址，(A1)表示A1所指的地址中的内容</strong><br>类比: c语言指针、指针所指位置的内容</p><hr><ul><li><u><strong>二、三地址指令</strong></u></li></ul><p><strong>二地址指令</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-20-26.png" alt=""></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令<br>指令含义: (A1)OP(A2)→A<br>完成一条指令需要访存4次，取指→读A1→读A2→写A1</p><p><strong>三地址指令</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-20-36.png" alt=""></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令<br>指令含义: (A1)OP(A2)→A3<br>完成一条指令需要访存4次，取指→读A1→读A2→写A3</p><hr><ul><li><strong><u>四地址指令</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-24-29.png" alt=""></p><p>指令含义:(A1)OP(A2)→A3，A4=下一条将要执行指令的地址<br>完成一条指令需要访存4次，取指→读A1→读A2→写A3</p><p>正常情况下: 取指令之后 PC+1，指向下一条指令<br>四地址指令: 执行指令后，将PC的值修改为 A4所指地址</p><p>地址码的位数有什么影响?<br>n位地址码的直接寻址范围 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>,<br>若指令总长度固定不变，则地址码数量越多，寻址能力越差</p><hr><ul><li><strong><u>指令-按地址码数目分类</u></strong></li></ul><p>零地址指令、一地址指令、二地址指令、三地址、四地址。</p><hr><ul><li><strong><u>指令-按指令长度分类</u></strong></li></ul><p><strong>指令字长</strong>：一条指令的总长度 (可能会变)</p><p>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关)</p><p>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同)</p><p>半字长指令、单字长指令、双字长指令 一一 指令长度是机器字长的多少倍</p><p>指令字长会影响取指令所需时间。如: 机器字长 = 存储字长 = 16bit，则取一条双字长指令需要两次访存</p><p><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等<br><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</p><hr><ul><li><strong><u>指令-按操作码长度分类</u></strong></li></ul><p><strong>定长操作码</strong>：指令系统所有指令的操作码长度都相同</p><p>操作码n位→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>条指令</p><p>控制器的译码电路设计简单,但灵活性较低</p><p><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变</p><p>控制器的译码电路设计复杂，但灵活性较高</p><p><strong>下一小节</strong>会有：</p><p>定长指令字结构 + 可变长操作码 → 扩展操作码指令格式</p><p>不同地址数的指令使用不同长度的操作码</p><hr><ul><li><strong><u>指令-按操作类型分类</u></strong></li></ul><p><strong>数据传送</strong>：</p><p>LOAD 作用：把存储器中的数据放到寄存器中<br>STORE作用：把寄存器中的数据放到存储器中</p><p><strong>算术逻辑操作</strong>：</p><p>算术：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算<br>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</p><p><strong>移位操作</strong>：</p><p>算术移位、逻辑移位、循环移位(带进位和不带进位)</p><p><strong>转移操作</strong>：改变PC</p><p>无条件转移JMP<br>程序条件转移 JZ:结果为0；JO: 结果溢出；JC: 结果有进位<br>调用和返回 CALL和RETURN<br>陷阱(Trap)与陷阱指令</p><p><strong>输入输出操作</strong>：</p><p>CPU寄存器与I/O端口之间的数据传送（端口即I/O接口中的寄存器)</p><p>分类：</p><ol><li><p><strong>数据传送类</strong>: 进行主存与CPU之间的数据传送</p><p>——数据传送</p></li><li><p><strong>运算类</strong></p><p>——算术逻辑操作、移位操作</p></li><li><p><strong>程序控制类</strong>：改变程序执行的顺序</p><p>——转移操作</p></li><li><p><strong>输入输出类 (I/O)</strong> : 进行CPU和I/O设备之间的数传送</p><p>——输入输出操作</p></li></ol><hr><h2 id="4-1-2-扩展操作码指令格式">4.1.2 扩展操作码指令格式</h2><ul><li><strong><u>本节总览</u></strong></li></ul><p>指令由操作码和若干个地址码组成。</p><p><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等<br><strong>变长指令字结构</strong>：指令系统中各种指令的长度不等</p><p><strong>定长操作码</strong>：指令系统所有指令的操作码长度都相同<br><strong>可变长操作码</strong>：指令系统中各指令的操作码长度可变</p><p>↓<br>定长指令字结构 + 可变长操作码 → <strong>扩展操作码指令格式</strong><br>不同地址数的指令使用不同长度的操作码</p><hr><ul><li><strong><u>扩展操作码</u></strong></li></ul><p>扩展操作码<strong>举例1</strong>：</p><p>三地址指令：指令字长为16位，每个地址码占4位：前4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2和A3。</p><p>4位基本操作码若全部用于三地址指令，则有16条。但至少须将1111留作扩展操作码之用，即三地址指令为15条;</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-58-51.png" alt=""></p><p>1111 1111留作扩展操作码之用，二地址指令为15条；</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-59-06.png" alt=""></p><p>1111 1111 1111留作扩展操作码之用，一地址指令为15条；</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-59-20.png" alt=""></p><p>零地址指令为16条；</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_20-59-32.png" alt=""></p><p>以上是一种设计方法还有其他扩展操作码设计方法。</p><p>在<strong>设计扩展操作码</strong>指令格式时，<strong>必须注意</strong>以下两点：（对比哈夫曼树前缀编码）</p><ol><li><strong>不允许短码是长码的前缀</strong>，即短操作码不能与长操作码的前面部分的代码相同。</li><li>各指令的操作码一定不能重复。</li></ol><p>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p><p>扩展操作码<strong>举例2</strong>：</p><p>设指令字长固定为16位，试设计一套指令系统满足:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_21-08-55.png" alt=""></p><p>设地址长度为n，上一层留出m种状态，下一层可扩展出m×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>种状态，如上图蓝字部分</p><hr><ul><li><strong><u>指令操作码</u></strong></li></ul><p>操作码指出指令中该指令应该执行什么性质的操作和具有何种功能。</p><p>操作码是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。例如：指出是算术加运算，还是减运算；是程序转移，还是返回操作。</p><p>操作码分类：</p><p>定长操作码：在指令字的最高位部分分配固定的若干位（定长）表示操作码。</p><ul><li>一般n位操作码字段的指令系统最大能够表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>条指令。</li><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利;</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul><p>扩展操作码(不定长操作码)：全部指的操作码字段的位数不固定，且分散地放在指令字的不同位置上。</p><ul><li>最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</li><li>优：在指令字长有限的前提下仍保持比较丰富的指令种类;</li><li>缺：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul><hr><h2 id="4-2-1-指令寻址">4.2.1 指令寻址</h2><ul><li><strong><u>知识总览</u></strong></li></ul><p>指令寻址：</p><ul><li>顺序寻址</li><li>跳跃寻址</li></ul><p>指令寻址：如何确定下一条指令的存放地址?</p><p>一条指令的结构：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_21-16-12.png" alt=""></p><hr><ul><li><strong><u>回忆计算机的工作过程</u></strong></li></ul><p>1.2.2 各个硬件的工作原理</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-56-16.png" alt=""></p><p><strong>程序计数器PC</strong>：指明下一条指令的存放地址</p><p>对于上图主存地址只有一位：下一条指令的地址: (PC) + 1 → PC</p><p>↓</p><p>按字节编址怎么办?<br>采用变长指令字结构怎么办?</p><hr><ul><li><strong><u>指令寻址</u></strong></li></ul><p>指令寻址 → <strong>下一条</strong> 欲执行 <strong>指令</strong> 的 <strong>地址</strong> → （始终由程序计数器PC给出)</p><p><strong>顺序寻址</strong>：(PC) + “1” → PC<br>这里的 1 理解为1个指令字长，实际加的值会因指令长度、编址方式而不同。若指令nB，则+n。</p><p><strong>跳跃寻址</strong>：由转移指令指出</p><p>如下图：该系统采用定长指令字结构，指令字长=存储字长=16bit=2B，主存按字编址</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_21-32-09.png" alt=""></p><p>JMP：无条件转移把PC中的内容改成7【无条件转移指令，类似c语言的 goto】</p><p>注：每一条指令的执行都分为“取指令”、“执行指令”两个阶段</p><hr><h2 id="4-2-2-数据寻址">4.2.2 数据寻址</h2><ul><li><strong><u>指令寻址 v.s.数据寻址</u></strong></li></ul><p>寻址方式：</p><ul><li>指令寻址：<strong>下一条</strong> 欲执行 <strong>指令</strong> 的 <strong>地址</strong> → （始终由程序计数器PC给出)<ul><li>顺序寻址</li><li>跳跃寻址</li></ul></li><li>数据寻址：确定 <strong>本条指令</strong> 的 <strong>地址码指明的真实地址</strong></li></ul><hr><ul><li><strong><u>知识总览</u></strong></li></ul><p>增加<strong>寻址方式位</strong></p><p>一地址指令：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-17-57.png" alt=""></p><p>二地址指令：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-19-54.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-18-12.png" alt=""></p><p>求出操作数的真实地址，称为有效地址(EA)</p><p><strong>接下来</strong>假设指令字长=机器字长=存储字长，且以一地址指令为例，<br>并且假设操作数为3【要找到的数为3】</p><hr><ul><li><strong><u>直接寻址</u></strong></li></ul><p>直接寻址：指令字中的形式地址A就是操作数的真实地址EA，即EA=A</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-22-02.png" alt=""></p><p>一条指令的执行：<br>取指令 访存1次<br>执行指令 访存1次<br>暂不考虑存结果<br>共访存2次</p><p>优点：<br>简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。<br>缺点：<br>A的位数决定了该指令操作数的寻址范围操作数的地址不易修改。</p><hr><ul><li><strong><u>间接寻址</u></strong></li></ul><p>间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。</p><p>一次间接寻址：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-39-47.png" alt=""></p><p>一条指令的执行:<br>取指令 访存1次<br>执行指令 访存2次<br>暂不考虑存结果<br>共访存3次</p><p>两次间接寻址：（注意存储字最高位）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-26-00.png" alt=""></p><p>优点：<br>可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）<br>便于编制程序（用间接寻址可以方便地完成子程序返回)。<br>缺点:<br>指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。</p><hr><ul><li><strong><u>寄存器寻址</u></strong></li></ul><p>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其操作数在由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指的寄存器内。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-29-14.png" alt=""></p><p>一条指令的执行:<br>取指令 访存1次<br>执行指令 访存0次（访问寄存器，不是访存）<br>暂不考虑存结果<br>共访存1次</p><p>优点:<br>指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。<br>缺点:<br>寄存器价格昂贵，计算机中寄存器个数有限。</p><hr><ul><li><strong><u>寄存器间接寻址</u></strong></li></ul><p>寄存器间接寻址：寄存器R中给出的不是一个操作数，而是操作数所在主存单元的地址即EA=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-30-59.png" alt=""></p><p>一条指令的执行:<br>取指令 访存1次<br>执行指令 访存1次<br>暂不考虑存结果<br>共访存2次</p><p>特点:<br>与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。</p><hr><ul><li><strong><u>隐含寻址</u></strong></li></ul><p>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-32-42.png" alt=""></p><p>优点:<br>有利于缩短指令字长<br>缺点:<br>需增加存储操作数或隐含地址的硬件。</p><hr><ul><li><strong><u>立即寻址</u></strong></li></ul><p>立即寻址：形式地址A就是操作数本身，又称为立即数，一般采用补码形式。<br>#表示立即寻址特征。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-33-59.png" alt=""></p><p>一条指令的执行:<br>取指令 访存1次<br>执行指令 访存0次<br>暂不考虑存结果<br>共访存1次</p><p>优点:<br>指令执行阶段不访问主存，指令执行时间最短<br>缺点：<br>A的位数限制了立即数的范围。<br>如A的位数为n，且立即数采用补码时，可表示的数据范围为-2^(n-1)~2^(n-1) -1</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-44-50.png" alt=""></p><p>个人觉得隐含寻址这里错了，应该有一次访存</p><p>总共10中，剩下的后面介绍</p><hr><h2 id="4-2-3-数据寻址2-偏移寻址">4.2.3 数据寻址2_偏移寻址</h2><ul><li><strong><u>知识总览</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-48-13.png" alt=""></p><hr><ul><li><strong><u>偏移寻址</u></strong></li></ul><p>基址寻址：以程序的起始存放地址作为“起点”<br>EA=(BR)+A</p><p>变址寻址：程序员自已决定从哪里作为“起点”<br>EA=(IX)+A</p><p>相对寻址：以程序计数器PC所指地址作为“起点“<br>EA=(PC)+A</p><p>区别在于偏移的不一样“起点”</p><hr><ul><li><strong><u>基址寻址</u></strong></li></ul><p>基址寻址：将CPU中 <strong>基址寄存器(BR)</strong> 的内容加上指令格式中的形式地址A，而形成操作数的有效地址，<br>即<strong>EA=(BR)+A</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-55-57.png" alt=""></p><p>注：<br>BR——base address register<br>EA——effective address<br>Tips：可对比操作系统第三章第一节学习OS课中的“重定位存器”就是“基址寄存器”</p><p>有的计算机<strong>没有专门设置基址寄存器</strong>：</p><p>在指令中指明，要将哪个通用寄存器作为基址寄存器使用，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_09-58-07.png" alt=""></p><p>那么要用几个bit指明寄存器?<br>——根据通用寄存器总数判断</p><p>注：基址寄存器是<strong>面向操作系统的</strong>，其<strong>内容由操作系统或管理程序确定</strong>。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量)。<br>当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong></p><p><strong>优点</strong>:<br>可扩大寻址范围（基址寄存器的位数大于形式地址A的位数) ；<br>用户不必考虑自己的程序存于主存的哪一空间区域，故<strong>有利于多道程序设计</strong>，以及可用于<strong>编制浮动程序（整个程序在内存里边的浮动)</strong></p><hr><ul><li><strong><u>基址寻址的作用</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-04-40.png" alt=""></p><p>如上图，当程序在主存中的位置变化时，采用基址寻址无需修改指令中的地址</p><p><strong>优点：便于程序“浮动”，方便实现多道程序并发运行形式地址</strong></p><p>拓展：程序运行前，CPU将BR的值修改为该程序的起始地址（存在操作系统PCB中)</p><hr><ul><li><strong><u>变址寻址</u></strong></li></ul><p>变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，<br>即<strong>EA= (IX)+A</strong>，其中<strong>IX可为变址寄存器(专用)，也可用通用存器作为变址寄存器</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-14-59.png" alt=""></p><p>注: IX——index register</p><p>这和基址寻址又有什么不呢？</p><p>——注：变址寄存器是<strong>面向用户</strong>的，在程序执行过程中，<strong>变址寄存器的内容可由用户改变</strong>（<strong>IX作为偏移量</strong>)，形式地址<strong>A不变(作为基地址</strong>)<br>【基址寻址中，BR保持不变作为基地址，A作为偏移量，正好相反】</p><p><strong>优点</strong>:<br>在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别<strong>适合编制循环程序</strong></p><hr><ul><li><strong><u>变址寻址的作用</u></strong></li></ul><p>对于程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    sun += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未引入变址寻址：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-21-19.png" alt=""></p><p>引入变址寻址：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-22-42.png" alt=""></p><p>对于图中“比较10-(IX)”，后面再说</p><p>在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合<strong>编制循环程序</strong>。</p><hr><ul><li><strong><u>基址&amp;变址复合寻址</u></strong></li></ul><p>基址寻址: EA=(BR)+A<br>变址寻址: EA=(IX)+A<br>先基址后变址寻址: EA=((BR) + A) + (IX)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-28-06.png" alt=""></p><p>注：实际应用中往往需要多种寻址方式复合使用（可理解为复合函数)</p><hr><ul><li><strong><u>相对寻址</u></strong></li></ul><p>相对寻址：把<strong>程序计数器PC</strong>的内容加上指令格式中的形 式地址A而形成操作数的有效地址，<br>即EA=(PC)+A，其中<strong>A是相对于PC</strong>所指地址的<strong>位移量</strong>，可正可负，<strong>补码表示</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-30-37.png" alt=""></p><p>如上图：<br>当前指令存放地址=1000<br>若当前指令字长=2B，则PC+2<br>若当前指令字长=4B，则PC+4<br>因此取出当前指令后PC可能为1002 or 1004</p><p>注：王道书的小错误一一“A是相对当前指令地址的位移量” ✘，因为当前指令取出后，PC会自动+“1”<br>所以相对寻址是相对于下一条指令的偏移</p><p><strong>优点</strong>:<br>操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此<strong>便于程序浮动</strong>(一段代码在程序内部的浮动) 。相对寻址<strong>广泛应用于转移指令</strong>。</p><hr><ul><li><strong><u>相对寻址的作用</u></strong></li></ul><p>对于之前的for循环例子</p><p>问题：随着代码越写越多，你想挪动for循环的位置？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-41-25.png" alt=""></p><p><strong>优点: 这段代码在程序内浮动时不用更改跳转指令的地址码</strong></p><p>拓展：ACC加法指令的地址码，可采用“分段”方式解决，即可采用程序段、数据段分开。</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_10-49-55.png" alt=""></p><p>注意: 取出当前指令后，PC会指向下一条指令，相对寻址是相对于下一条指令的偏移</p><hr><ul><li><strong><u>硬件如何实现数的“比较”</u></strong></li></ul><p>解释之前的“比较10-(IX)”</p><p>高级语言视角：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬件视角：</p><ul><li>通过”cmp指令”比较a和 b(如cmp a,b)，实质上是用a-b</li><li>相减的结果信息会记录在程序状态字寄存器中(PSW)</li><li>根据PSW的某几个标志位（CF、ZF、SF、OF）进行条件判断，来决定是否转移</li></ul><p>有的机器把PSW称为“标志寄存器”</p><p>注：无条件转移指令jmp 2，就不会管PSW的各种标志位</p><p>汇编语言中，条件跳转指令有很多种，如je 2 表示当比较结果为a=b时跳转到2<br>jg 2表示当比较结果为a&gt;b时跳转到2</p><hr><h2 id="4-2-3-数据寻址3-堆栈寻址">4.2.3 数据寻址3_堆栈寻址</h2><ul><li><strong><u>堆栈寻址</u></strong></li></ul><p>堆栈寻址：操作数存放在中，隐含使用堆指针(SP)作为操作数地址。</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出 (LIFO)“原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针 (SP)</p><p>注: SP —— Stack Pointer</p><p><strong>硬堆栈</strong>：用寄存器实现，所以不用访存，成本高</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_11-59-22.png" alt=""></p><p>假设SP指向栈顶元素，R0为栈顶<br>现在要完成一次加法：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_12-06-01.png" alt=""></p><p>注意：栈顶在小地址方向 和 栈顶在大地址方向，SP的变化，上图是在小地址方向，大地址与之相反</p><p><strong>软堆栈</strong>：从主存中划分区域，所以每次操作需要一次访存，成本低</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_11-59-26.png" alt=""></p><p>堆栈可用函数调用时，保存当前函数的相关信息（可参考数据结构，算法空间复杂度）</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_12-07-35.png" alt=""></p><hr><h2 id="4-3-1-高级语言与机器级代码之间的对应">4.3.1 高级语言与机器级代码之间的对应</h2><blockquote><p>高级语言 → 汇编语言 → 机器语言</p><p>机器级代码：汇编语言和机器语言一一对应，都属于机器级代码</p><p>2022年开始要求掌握机器级代码</p><p>考试要求：</p><ul><li>只需关注<strong>x86</strong>汇编语言，若考察其他汇编语言题目会详细注释</li><li>题目给出某段<strong>简单程序</strong>的C语言、汇编语言、机器语言表示。能<strong>结合C语言</strong>看懂<strong>汇编语言的关键语句 (看懂常见指令、选择结构、循环结构、函数调用)</strong></li><li>汇编语言、机器语言一一对应，要能<strong>结合汇编语言分析机器语言指令的格式、寻址方式</strong></li><li>不会考：将C语言人工翻译为汇编语言或机器语言</li></ul></blockquote><ul><li><strong><u>x86汇编语言指令基础</u></strong></li></ul><p>起源：Intelx86架构CPU（代号8086的CPU）</p><p>指令：</p><ul><li>作用：<ul><li>改变程序执行流</li><li>处理<strong>数据</strong></li></ul></li><li>格式：操作码 + 地址码<ul><li>操作码：说明去怎么处理？</li><li>地址码：说明数据在哪？<ul><li>在寄存器：在指令中给出“寄存器名”，x86架构的CPU有哪些寄存器?</li><li>在主存里：在指令中给出“主存地址“，怎么在指令中指明读写长度?</li><li>在指令里：直接在指令中给出要操作的数也就是“立即寻址”</li></ul></li></ul></li></ul><hr><ul><li><strong><u>以 mov 指令为例</u></strong></li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov 目的操作数d, 源操作数s</span><br><span class="line"># mov指令功能: 将源操作数s复制到目的操作数d所指的位置</span><br></pre></td></tr></table></figure><p><strong>d</strong>estination: 目的地<br><strong>s</strong>ource: 来源、发源地</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx# 将寄存器 ebx 的值复制到寄存器 eax</span><br><span class="line">mov eax, 5# 将立即数 5 复制到寄存器 eax</span><br><span class="line">mov eax, dword ptr [af996h]# 将内存地址 af996h 所指的32bit值复制到寄存器 eax</span><br><span class="line">mov byte ptr [af996h], 5# 将立即数 5 复制到内存地址 af996h 所指的一字节中</span><br></pre></td></tr></table></figure><p>x86架构<strong>不允许两个操作数都来自主存</strong></p><p>如何指明内存的读写长度:<br>dword ptr——双字，32bit<br>word ptr——单字，16bit<br>byte ptr一一字节，8bit<br>不加修饰符，默认32位</p><hr><ul><li><strong><u>x86架构CPU，有哪些寄存器?</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_13-27-15.png" alt=""></p><p>【奔腾】</p><p>变址寄存器可用于线性表、字符串的处理<br>堆栈寄存器用于实现函数调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx# 寄存器→寄存器</span><br><span class="line">mov eax, dword ptr [af996h]# 主存→寄存器</span><br><span class="line">mov eax,5# 立即数→寄存器</span><br></pre></td></tr></table></figure><p>对于通用寄存器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_13-33-55.png" alt=""></p><p>两个变址寄存器只能固定使用32bit<br>两个堆栈寄存器只能固定使用32bit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bx# 寄存器→寄存器</span><br><span class="line">mov ax, word ptr [af996h]# 主存→寄存器</span><br><span class="line">mov ax,5# 立即数→寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_13-41-07.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, bl# 寄存器→寄存器</span><br><span class="line">mov al, byte ptr [af996h]# 主存→寄存器</span><br><span class="line">mov al,5# 立即数→寄存器</span><br></pre></td></tr></table></figure><p>考试常见的是使用32位的寄存器</p><hr><ul><li><strong><u>更多的例子</u></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [ebx]# 将 ebx 所指主存地址的32bit 复制到 eax 寄存器中</span><br><span class="line">mov dword ptr [ebx], eax# 将 eax 的内容复制到 ebx 所指主存地址的 32bit</span><br><span class="line">mov eax, byte ptr [ebx]# 将 ebx 所指的主存地址的 8bit 复制到 eax</span><br><span class="line">mov eax, [ebx]# 若未指明主存读写长度，默认 32 bit</span><br><span class="line">mov [af996h], eax# 将 eax 的内容复制到 af996h 所指的地址(未指明长度默认32bit</span><br><span class="line">mov eax, dword ptr [ebx+8]# 将 ebx+8 所指主存地址的32bit 复制到eax 寄存器中所指主存地址的 32bit 复制到eax 寄存器中</span><br><span class="line">mov eax, dword ptr [af996h-12h]# 将 af996h-12h 所指主存地址的32bit 复制到eax 寄存器中所指主存地址的 32bit 复制到eax 寄存器中</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>总结</u></strong></li></ul><p>指令：</p><ul><li><p>作用：</p><ul><li>改变程序执行流</li><li>处理<strong>数据</strong></li></ul></li><li><p>格式：操作码 + 地址码</p><ul><li><p>操作码：说明去怎么处理？</p></li><li><p>地址码：说明数据在哪？</p><ul><li><p>在寄存器：</p><p>在汇编指令中，给出<strong>寄存器名</strong><br>通用寄存器: <strong>eax、ebx、ecx、edx</strong><br>变址寄存器: <strong>esi、edi</strong><br>堆栈寄存器: <strong>ebp、esp</strong></p></li><li><p>在主存里：</p><p>在汇编增令中，给出<strong>读写长度、主存地址</strong><br><strong>dword ptr [地址]#32bit</strong><br><strong>word ptr [地址]#16bit</strong><br><strong>byte ptr [地址]#8bit</strong></p></li><li><p>在指令里：</p><p>在汇编指令中，直接给出<strong>常量</strong>, 即“立即寻址”可用十进制表示、也可用十六进制(常以<strong>h</strong>结尾)</p></li></ul></li></ul></li></ul><hr><h2 id="4-3-2-常用的x86汇编指令">4.3.2 常用的x86汇编指令</h2><ul><li><strong><u>本节总览</u></strong></li></ul><p>指令格式：操作码 + 地址码</p><ul><li><p><strong>操作码</strong>：说明去<strong>怎么处理</strong>？</p><p>①<strong>算数运算</strong>：加、减、乘、除、取负数、自增++、自减–</p><p>②<strong>逻辑运算</strong>：与、或、非、异或、左移、右移<br>③<strong>其他</strong></p></li><li><p>地址码：说明数据在哪？</p></li></ul><hr><ul><li><strong><u>常见的算数运算指令</u></strong></li></ul><p><strong>d</strong>estination: 目的地(<strong>d</strong> 目的操作数)<br><strong>s</strong>ource: 来源地 (<strong>s</strong> 源操作数)<br>目的操作数 d 不可以是常量【显而易见的】</p><table><thead><tr><th>功能</th><th>英文</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>加</td><td>add</td><td><code>add d, s</code></td><td># 计算d+s，结果存入d</td></tr><tr><td>减</td><td>subtract</td><td><code>sub d, s</code></td><td># 计算d-s，结果存入d</td></tr><tr><td>乘</td><td>multiply</td><td><code>mul d, s</code><br /><code>imul d, s</code></td><td># 无符号数d*s，乘积存入d<br /># 有符号数d*s，乘积存入d</td></tr><tr><td>除</td><td>divide</td><td><code>div s</code><br /><code>idiv s</code></td><td># 无符号数除法 edx:eax/s，商存入eax，余数存入edx<br /># 有符号数除法 edx:eax/s，商存入eax，余数存入edx</td></tr><tr><td>取负数</td><td>negative</td><td><code>neg d</code></td><td># 将d取负数，结果存入d</td></tr><tr><td>自增++</td><td>increase</td><td><code>inc d</code></td><td># 将d++，结果存入d</td></tr><tr><td>自减–</td><td>decrease</td><td><code>dec d</code></td><td># 将d–，结果存入d</td></tr></tbody></table><p>上面的除，因为除数是32位，所以计算前需要先把被除数扩展为64位</p><hr><ul><li><strong><u>关于王道书的解释</u></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add &lt;reg&gt;,&lt;reg&gt; / sub &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;mem&gt; / sub &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;reg&gt; / sub &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;con&gt; / sub &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;con&gt; / sub &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure><p>&lt;reg&gt; 寄存器 register<br>&lt;mem&gt; 内存 memory<br>&lt;con&gt; 常数 constant</p><p>x86架构<strong>不允许两个操作数都来自主存</strong></p><hr><ul><li><strong><u>常见的逻辑运算指令</u></strong></li></ul><table><thead><tr><th>功能</th><th>英文</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>与</td><td>and</td><td><code>and d, s</code></td><td># 将 d、s 逐位相与，结果放回d</td></tr><tr><td>或</td><td>or</td><td><code>or d, s</code></td><td># 将 d、s 逐位相或，结果放回d</td></tr><tr><td>非</td><td>not</td><td><code>not d</code></td><td># 将 d 逐位取反，结果放回d</td></tr><tr><td>异或</td><td>exclusive or</td><td><code>xor d, s</code></td><td># 将 d、s 逐位异或，结果放回d</td></tr><tr><td>左移</td><td>shift left</td><td><code>shl d, s</code></td><td># 将d逻辑左移s位，结果放回d (通常s是常量)</td></tr><tr><td>右移</td><td>shift right</td><td><code>shr d, s</code></td><td># 将d逻辑右移s位，结果放回d (通常s是常量)</td></tr></tbody></table><hr><ul><li><strong><u>其他指令</u></strong></li></ul><p>用于实现<strong>分支</strong>结构、<strong>循环</strong>结构的指令: cmp、test、jmp、jxxx</p><p>用于实现<strong>函数调用</strong>的指令: push、pop、call、ret</p><p>用于实现<strong>数据转移</strong>的指令: mov</p><hr><h2 id="4-3-3-AT-T格式和Intel格式">4.3.3 AT&amp;T格式和Intel格式</h2><ul><li><strong><u>AT&amp;T格式 v.s. Intel格式</u></strong></li></ul><p>之前学的是Intel格式，往年408考的都是这个格式</p><p>AT&amp;T格式——Unix、Linux的常用格式</p><p>Intel格式——Windows的常用格式</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-02-52.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-03-55.png" alt=""></p><hr><h2 id="4-3-4-选择语句的机器级表示">4.3.4 选择语句的机器级表示</h2><ul><li><strong><u>无条件跳转指令</u></strong></li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp &lt;地址&gt;# PC 无条件转移至&lt;地址&gt;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp 128# &lt;地址&gt;可以用常数给出</span><br><span class="line">jmp eax# &lt;地址&gt;可以来自于寄存器</span><br><span class="line">jmp [999]# &lt;地址&gt;可以来自于主存</span><br></pre></td></tr></table></figure><p>特别的：跳转到标号的位置<br>特征——有冒号名字可以自己取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp NEXT# &lt;地址&gt;可以用“标号”锚定</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,7</span><br><span class="line">mov ebx,6</span><br><span class="line">jmp NEXT</span><br><span class="line">mov ecx,ebx</span><br><span class="line">NEXT:# 用”标号”锚定位置</span><br><span class="line">mov ecx,eax</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>条件转移指令——jxxx</u></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp a, b# 比较a和b两个数</span><br></pre></td></tr></table></figure><p>a、b两个数可能来自寄存器/主存/常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je &lt;地址&gt;# jump when equal，若a==b则跳转</span><br><span class="line">jne &lt;地址&gt;# jump when not equal，若a!=b则跳转</span><br><span class="line">jg &lt;地址&gt;# jump when greater than，若a&gt;b则跳转</span><br><span class="line">jge &lt;地址&gt;# jump when greater than or equal to，若a&gt;=b则跳转</span><br><span class="line">jl &lt;地址&gt;# jump when less than，若a&lt;b则跳转</span><br><span class="line">jle &lt;地址&gt;# jump when less than or equal to，若a&lt;=b则跳转</span><br></pre></td></tr></table></figure><p>条件转移指令一般要和 cmp 指令一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp eax,ebx# 比较寄存器eax和ebx里的值</span><br><span class="line">jg NEXT# 若 eax &gt; ebx，则跳转到 NEXT:</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>示例: 选择语句的机器级表示</u></strong></li></ul><p>原程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; b) &#123;</span><br><span class="line">c = a;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成汇编1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov eax,7# 假设变量a=7，存入eax</span><br><span class="line">mov ebx,6# 假设变量b=6，存入ebx</span><br><span class="line">cmp eax,ebx# 比较变量a和b</span><br><span class="line">jg NEXT# 若a&gt;b，转移到NEXT :</span><br><span class="line">mov ecx,ebx# 假设用ecx存储变量c，令c=b</span><br><span class="line">jmp END# 无条件转移到END :</span><br><span class="line">NEXT:</span><br><span class="line">mov ecx,eax# 假设用ecx存储变量c，令c=a</span><br><span class="line">END:</span><br></pre></td></tr></table></figure><p>翻译成汇编2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov eax,7# 假设变量a=7，存入eax</span><br><span class="line">mov ebx,6# 假设变量b=6，存入ebx</span><br><span class="line">cmp eax,ebx# 比较变量a和b</span><br><span class="line">jle NEXT# 若a≤b，转移到NEXT :</span><br><span class="line">mov ecx,eax# 假设用ecx存储变量c，令c=a</span><br><span class="line">jmp END# 无条件转移到END:</span><br><span class="line">NEXT:</span><br><span class="line">mov ecx,ebx# 假设用ecx存储变量c，令c=b</span><br><span class="line">END:</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>历年真题</u></strong></li></ul><p>【2019 统考真题】已知f(n)=n!=n×(n-1)×(n-2)×…×2×1，计算f(n)的C语言函数 f1的源程序(阴影部分) 及其在 32 位计算机 M上的部分机器级代码如下:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-29-01.png" alt=""></p><p>其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址，int 型数据占32 位。请回答下列问题:<br>……</p><p>写汇编语言代码时，一般会<strong>以函数名作为“标号</strong>”，标注该函数指令的起始地址</p><hr><ul><li><strong><u>扩展: cmp 指令的底层原理</u></strong></li></ul><p>cmp指令本质上是进行 a-b 减法运算，并生成标志位OF、ZF、CF、SF</p><p>ALU每次运算的标志位都自动存入PSW 程序状态字寄存器 (Intel称其为“标志寄存器”）【每次计算都会覆盖标志位】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-36-43.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-37-01.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je &lt;地址&gt;# 若a==b则跳转，ZF==1 ?</span><br><span class="line">jne &lt;地址&gt;# 若a!=b则跳转，ZF==0 ?</span><br><span class="line">jg &lt;地址&gt;# 若a&gt;b则跳转，ZF==0 &amp;&amp; SF==OF ?</span><br><span class="line">jge &lt;地址&gt;# 若a&gt;=b则跳转，SF==OF ?</span><br><span class="line">jl &lt;地址&gt;# 若a&lt;b则跳转，SF!=OF ?</span><br><span class="line">jle &lt;地址&gt;# 若a&lt;=b则跳转，SF!=OF || ZF==1 ?</span><br></pre></td></tr></table></figure><hr><h2 id="4-3-5-循环语句的机器级表示">4.3.5 循环语句的机器级表示</h2><ul><li><strong><u>用条件转移指令实现循环</u></strong></li></ul><p>原程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 1 + 2 + 3 + …… + 100</span></span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成汇编语言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># --- ①循环前的初始化 ---</span><br><span class="line">mov eax, 0# 用 eax 保存 result，初值为0</span><br><span class="line">mov edx, 1# 用 edx 保存 i，初始值为1</span><br><span class="line"></span><br><span class="line"># --- ②是否直接跳过循环? ---</span><br><span class="line">cmp edx, 100# 比较 i 和 100</span><br><span class="line">jg L2# 若i&gt;100，转跳到 L2 执行#循环主体</span><br><span class="line"></span><br><span class="line"># --- ③循环主体 ---</span><br><span class="line">L1:</span><br><span class="line">add eax, edx# 实现 result +=i #若 i&lt;=100，转跳到 L1 执行</span><br><span class="line">inc edx# inc 自增指令，实现 i++</span><br><span class="line"></span><br><span class="line"># --- ④是否继续循环? ---</span><br><span class="line">cmp edx, 100# 比较 i 和 100</span><br><span class="line">jle L1</span><br><span class="line"></span><br><span class="line">L2:# 跳出循环主体</span><br></pre></td></tr></table></figure><p>用条件转移指令实现循环，需要4个部分构成:<br><strong>①循环前的初始化</strong><br><strong>②是否直接跳过循环?</strong><br><strong>③循环主体</strong><br><strong>④是否继续循环?</strong></p><p><strong>个人觉得</strong>：就三步<br>①初始化<br>②判断<br>③循环体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># --- ①初始化 ---</span><br><span class="line">mov eax, 0# 用 eax 保存 result，初值为0</span><br><span class="line">mov edx, 1# 用 edx 保存 i，初始值为1</span><br><span class="line"></span><br><span class="line"># --- ②判断 ---</span><br><span class="line">L1:</span><br><span class="line">cmp edx, 100# 比较 i 和 100</span><br><span class="line">jg L2# 若i&gt;100，转跳到 L2 执行#循环主体</span><br><span class="line"></span><br><span class="line"># --- ③循环体 ---</span><br><span class="line">add eax, edx # 实现 result +=i #若 i&lt;=100，转跳到 L1 执行</span><br><span class="line">inc edx# inc 自增指令，实现 i++</span><br><span class="line">jmp L1# 循环</span><br><span class="line"></span><br><span class="line">L2:# 跳出循环主体</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>用loop指令实现循环</u></strong></li></ul><p>原程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">500</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    某些处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, 500# 用ecx作为循环计数器</span><br><span class="line">Looptop:# 循环的开始</span><br><span class="line">……</span><br><span class="line">某些处理</span><br><span class="line">……</span><br><span class="line">loop Looptop# eCX--，若ecx!=0，跳转到Looptop</span><br></pre></td></tr></table></figure><p><code>loop Looptop</code>等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dec ecx</span><br><span class="line">cmp ecx, 0</span><br><span class="line">jne Looptop</span><br></pre></td></tr></table></figure><p><strong>理论上，能用 loop 指令实现的功能一定能用条件转移指令实现</strong></p><p><strong>使用 loop 指令可能会使代码更清晰简洁</strong></p><p>补充：loopx 指令——如loopnz,loopz<br>loopnz——当 ecx!=0 &amp;&amp; ZF==0 时，继续循环<br>loopz一一当 ecx!=0 &amp;&amp; ZF==1 时，继续循环</p><hr><h2 id="4-3-6-1-Call和ret指令（函数调用的机器级表示）">4.3.6.1 Call和ret指令（函数调用的机器级表示）</h2><ul><li><strong><u>高级语言的函数调用</u></strong></li></ul><p>函数的<strong>栈帧</strong> (<strong>Stack Frame</strong>) : 保存函数大括号内定义的局部变量、保存函数调用相关的信息</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_18-38-24.png" alt=""></p><hr><ul><li><strong><u>x86汇编语言的函数调用</u></strong></li></ul><p>函数调用指令：<code>call &lt;函数名&gt;</code><br>函数返回指令：<code>ret</code></p><p>通常用函数名作为函数起始地址的&lt;标号&gt;</p><hr><ul><li><strong><u>call、ret指令</u></strong></li></ul><p>注：x86处理器中程序计数器 PC (Program Counter)通常被称为IP (Instruction Pointer)</p><p>call 指令的作用：<br>①将<strong>IP旧值</strong>压栈保存(保存在函数的栈顶部)<br>②设置<strong>IP新值</strong>无条件转移至被调用函数的第一条指令</p><p>ret 指令的作用:<br>从函数的<strong>栈帧顶部</strong>找至<strong>IP旧值</strong>将其出栈并恢复IP寄存器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_18-44-13.png" alt=""></p><hr><ul><li><strong><u>总结：函数调用的机器级表示</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_18-46-29.png" alt=""></p><hr><ul><li><strong><u>小朋友，你是否有很多问号 ?</u></strong></li></ul><p>如何传递调用参数、返回值?</p><p>如何访问栈帧里的数据?</p><p>栈帧内可能包含哪些内容?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_18-48-12.png" alt=""></p><p>为什么倒过来了?</p><hr><h2 id="4-3-6-2-如何访问栈帧（函数调用的机器级表示）">4.3.6.2 如何访问栈帧（函数调用的机器级表示）</h2><ul><li><strong><u>函数调用栈在内存中的位置</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-01-21.png" alt=""></p><p>所以注：大多数教材的图示，通常栈底在上，栈顶在下</p><hr><ul><li><strong><u>标记栈帧范围: EBP、ESP寄存器</u></strong></li></ul><p>ebp：指向当前栈帧的”底部“<br>esp：指向当前栈帧的“顶部“</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-07-11.png" alt=""></p><p>注：x86 系统中，默认以<strong>4字节</strong>为栈的操作单位</p><hr><ul><li><strong><u>访问栈帧数据: push、pop 指令</u></strong></li></ul><p>push、pop 指令实现入栈、出栈操作，x86 默认以4字节为单位。指令格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Push ♦// 先让esp减4，再将♦压入</span><br><span class="line">Pop♠// 栈顶元素出栈写入♠，再让 esp加4</span><br></pre></td></tr></table></figure><p>注1: ♦可以是立即数、寄存器、主存地址<br>注2: ♠可以是寄存器、主存地址</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push eax# 将寄存器eax的值(211)压栈</span><br><span class="line">push 985# 将立即数985压栈</span><br><span class="line">push [ebp+8]# 将主存地址[ebp+8]里的数据(666)压栈</span><br><span class="line"></span><br><span class="line">pop eax# 栈顶元素出栈，写入寄存器eax</span><br><span class="line">pop [ebp+8]# 栈顶元素出栈，写入主存地址[ebp+8]</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-15-47.png" alt=""></p><hr><ul><li><strong><u>访问栈帧数据: mov 指令</u></strong></li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sub esp, 12# 栈顶指针-12</span><br><span class="line">mov[esp+8], eax# 将eax的值复制到主存[esp+8]</span><br><span class="line">mov[esp+4], 958# 将985复制到主存[esp+4]</span><br><span class="line">mov eax, [ebp+8]# 将主存[ebp+8]的值复制到eax</span><br><span class="line">mov [esp], eax# 将eax的值复制到主存[esp]</span><br><span class="line">add esp, 8# 栈顶指针+8</span><br></pre></td></tr></table></figure><p>可以用 <strong>mov 指令，结合 esp、ebp 指针访问栈帧数据</strong></p><p>可以用减法/加法指令，即 sub/add 修改栈顶指针 esp 的值</p><hr><ul><li><strong><u>总结: 如何仿问栈帧?</u></strong></li></ul><p>方法一：push、pop</p><p>方法二：<strong>mov 指令</strong>，结合 esp、ebp 指针访问栈帧数据</p><hr><h2 id="4-3-6-3-如何切换栈帧（函数调用的机器级表示）">4.3.6.3 如何切换栈帧（函数调用的机器级表示）</h2><blockquote><p>怎么切换？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-26-10.png" alt=""></p></blockquote><ul><li><strong><u>函数调用时，如何切换栈帧?</u></strong></li></ul><p>call 指令的作用：<br>①将<strong>IP旧值</strong>压栈保存（效果相当于<code>push IP</code>）<br>②设置<strong>IP新值</strong>无条件转移至被调用函数的第一条指令（效果相当于<code>jmp add</code>）</p><p>ret 指令的作用:<br>从函数的<strong>栈帧顶部</strong>找至<strong>IP旧值</strong>将其出栈并恢复IP寄存器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-52-38.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-52-52.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-52-59.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-45-27.png" alt=""></p><p>注:每个<strong>栈帧底部</strong>，用于保存<strong>上一层栈帧的基址</strong></p><hr><ul><li><strong><u>总结：函数调用的机器级表示</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-41-45.png" alt=""></p><hr><ul><li><strong><u>历年真题</u></strong></li></ul><p>【2019 统考真题】已知f(n)=n!=n×(n-1)×(n-2)×…×2×1，计算f(n)的C语言函数 f1的源程序(阴影部分) 及其在 32 位计算机 M上的部分机器级代码如下:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_17-29-01.png" alt=""></p><p>其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址，int 型数据占32 位。请回答下列问题:<br>……</p><p>【2017年真题】44.(10 分)在按字节编址的计算机M上，题43 中f1 的部分源程序（阴影影部分）与对应的机器级代码(包括指令的虚拟地址) 如下:<br>其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。请回答下列问题。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_19-58-13.png" alt=""></p><hr><h2 id="4-3-6-4-如何传递参数和返回值（函数调用的机器级表示）">4.3.6.4 如何传递参数和返回值（函数调用的机器级表示）</h2><ul><li><strong><u>一个栈帧内可能包含哪些内容?</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp1 = <span class="number">125</span>;</span><br><span class="line">    <span class="type">int</span> temp2 = <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> sum = add(temp1, temp2);</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> add(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_20-12-11.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_20-12-59.png" alt=""></p><table><thead><tr><th>内容</th><th>是否存在</th></tr></thead><tbody><tr><td><strong>栈帧最底部</strong>一定是<strong>上一层栈帧基址</strong>(ebp旧值)</td><td>一定存在。用于恢复上一层函数的栈帧</td></tr><tr><td>通常将<strong>局部变量</strong>集中存储在<strong>栈帧底部区域</strong></td><td>不一定存在。有些函数可能不定义局部变量</td></tr><tr><td>gcc 编译器将每个栈帧大小设置为 16B 的整数倍 (当前函数的栈除外)因此栈帧内可能出现<strong>空闲未使用</strong>的区域</td><td>不一定存在。如果其他部分刚好是16B整数倍，则不会留下“零头</td></tr><tr><td>通常将<strong>调用参数</strong>集中存储在<strong>栈帧顶部区域</strong></td><td>不一定存在。有些函数调用不需要传参数</td></tr><tr><td><strong>栈帧最顶部</strong>一定是<strong>返回地址</strong>(当前函数的栈帧除外 )</td><td>一定存在 (发生调用时 )。但凡调用其他函数，就必须记录返回地址</td></tr></tbody></table><hr><ul><li><strong><u>汇编代码实战</u></strong></li></ul><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=917.8&amp;p=59">点击空降</a> 8:36~15:17</p><p>直接看视频吧</p><hr><ul><li><strong><u>总结: 函数调用的机器级表示</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_20-28-53.png" alt=""></p><hr><ul><li><strong><u>拓展: 一个栈帧内可能包含哪些内容?</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_20-23-24.png" alt=""></p><p>不一定存在。如果这些寄存器值不是运算的中间结果，则可以不保存</p><hr><ul><li><strong><u>总结</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_20-26-27.png" alt=""></p><hr><h2 id="4-4-CISC和RISC">4.4 CISC和RISC</h2><ul><li><strong><u>本章总览</u></strong></li></ul><p>指令系统：</p><ul><li>指令格式<br>——如何用二进制代码表示指令</li><li>指令寻址方式<br>——给出下一条指令的地址<br>——给出要操作的对象的地址</li><li><strong>CISC和RISC</strong><br>——<strong>两种设计方向</strong></li></ul><hr><ul><li><strong><u>CISC和RISC</u></strong></li></ul><table><thead><tr><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>Complex Instruction Set Computer</td><td>Reduced Instruction Set Computer</td></tr><tr><td>设计思路: 一条指令完成一个复杂的基本功能</td><td>设计思路: 一条指令完成一个基本“动作”；<br />多条指令组合完成一个复杂的基本功能</td></tr><tr><td>代表：x86架构，主要用于笔记本、台式机等</td><td>代表：ARM架构，主要用于手机、平板等</td></tr></tbody></table><p><strong>80-20规律: 典型程序中 80% 的语句仅仅使用处理机中 20% 的指令</strong></p><table><thead><tr><th>比如设计一套能实现整数、矩阵加/减/乘运算的指令集:</th></tr></thead><tbody><tr><td>CISC的思路：除了提供整数的加减乘指令除之外，还提供矩阵的加法指令、矩阵的减法指令、矩阵的乘法指令<br /><br />一条指令可以由一个专门的电路完成<br /><br />有的复杂指令用纯硬件实现很困难<br/>→采用“存储程序”的设计思想，由一个比较通用的电路配合存储部件完成一条指令</td></tr><tr><td>RISC思路：只提供整数的减乘指令<br /><br />一条指令一个电路，电路设计相对简单，功耗更低<br /><br />这些特性可以方便实现“并行”、“流水线”</td></tr></tbody></table><p><strong>总结</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_21-26-11.png" alt=""></p><p>回忆：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-06_09-56-16.png" alt=""></p><p><strong>乘法指令可以访存，一定是CISC</strong></p><hr><h1>第五章 中央处理器</h1><h2 id="5-0-回忆过去">5.0 回忆过去</h2><p><strong>1.2.2 各个硬件的工作原理：</strong></p><ul><li><p><strong><u>运算器的基本组成</u></strong></p></li><li><p><strong><u>控制器的基本组成</u></strong></p></li><li><p><strong><u>计算机的工作过程</u></strong></p></li></ul><hr><ul><li><strong><u>本章总览</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_21-32-11.png" alt=""></p><hr><h2 id="5-1-CPU的功能和基本结构">5.1 CPU的功能和基本结构</h2><ul><li><strong><u>CPU的功能</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_23-38-44.png" alt=""></p><p>1、<strong>指令控制</strong>。完成取指令、分析指令和执行指令的操作，即程序的顺序控制</p><p>2、<strong>操作控制</strong>。一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</p><p>3、<strong>时间控制</strong>。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</p><p>4、<strong>数据加工</strong>。对数据进行算术和逻辑运算</p><p>5、<strong>中断处理</strong>。对计算机运行过程中出现的异常情况和特殊请求进行处理</p><hr><ul><li><strong><u>运算器和控制器的功能</u></strong></li></ul><p><strong>运算器</strong>：对数据进行加工</p><p><strong>控制器</strong>：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令</p><ol><li>取指令：自动形成指令地址；自动发出取指令的命令。</li><li>分析指令：操作码译码(分析本条指令要完成什么操作)；产生操作数的有效地址。</li><li>执行指令：根据分析指令得到的“操作命令”和“操作数地址”形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。</li><li>中断处理：管理总线及输入输出；处理异常情况(如掉电)和特殊请求(如打印机请求打印一行字符)。</li></ol><hr><ul><li><strong><u>运算器的基本结构</u></strong></li></ul><ol><li>算术逻辑单元：主要功能是进行算术/逻辑运算。</li><li>通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数 (包括源操作数、目的操作数及中间结果)和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</li><li>暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容</li><li>累加寄存器：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。</li><li>程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志 (SF)、零标志 (ZF)、进位标志(CF)等。PSW中的这些位参与并决定微操作的形成</li><li>移位器：对运算结果进行移位运算。</li><li>计数器：控制乘除运算的操作步数。</li></ol><ul><li><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_23-45-36.png" alt=""></p><p>问题：如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据</p><p>解决方法1.使用<strong>多路选择器</strong>根据控制信号选择一路输出</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_23-47-05.png" alt=""></p><p>解决方法2.使用<strong>三态门</strong>可以<strong>控制每一路是否输出</strong>，如: R0out为1时，R0中的数据输出到A端; R0out为0时，R0中的数据无法输出到<s>B端</s>A端（感觉这里错了，说的是A端吧）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-08_23-53-03.png" alt=""></p><p><strong>性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。</strong></p><ul><li><strong>CPU内部单总线方式</strong>：将所有寄存器的输入端和输出端都连接到一条公共的通路上。</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-01-12.png" alt=""></p><p><strong>结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。</strong></p><hr><ul><li><strong><u>控制器的基本结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-09-27.png" alt=""></p><ol><li>程序计数器PC：用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令 (通常) 是顺序执行的，所以PC有自增功能。</li><li>指令寄存器IR：用于保存当前正在执行的那条指令</li><li>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。</li><li>微操作信号发生器：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li><li>时序系统：用于产生各种时序信号，它们都是由统一时钟 (CLOCK)分频得到。</li><li>存储器地址寄存器：用于存放所要访问的主存单元的地址。</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。</li></ol><hr><ul><li><strong><u>CPU的基本结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-14-16.png" alt=""></p><p>图中MDRinE中的E表示从外部来<br>用户可见的寄存器(可编程)：图中褐色框；<br>不可见：图中灰色框</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-15-46.png" alt=""></p><p>本章主要探讨CU</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p>管理多条通路: 多路选择器MUX与三态门</p><p>用户可见的寄存器：通用寄存器组、程序状态字寄存器PSW、程序计数器PC<br>用户不可见的寄存器：MAR、MDR、IR、暂存寄存器</p><hr><h2 id="5-2-指令周期的数据流">5.2 指令周期的数据流</h2><ul><li><strong><u>指令周期</u></strong></li></ul><p><strong>指令周期</strong>：CPU从主存中每取出并执行一条指令所需的全部时间。<br><strong>指令周期</strong>常常用若干<strong>机器周期</strong>来表示，机器周期又叫<strong>CPU周期</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-20-20.png" alt=""></p><p>一个<strong>机器周期</strong>又包含若<strong>时钟周期</strong> (也称<strong>节拍</strong>、<strong>T周期</strong>或<strong>CPU时钟周期</strong>，它是CPU操作的<strong>最基本单位</strong>)。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-21-38.png" alt=""></p><p>每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等，举例如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-09-28.png" alt=""></p><hr><ul><li><strong><u>指令周期流程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-10-47.png" alt=""></p><p>CPU又是如何区分处于哪个时期？设置触发器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-13-56.png" alt=""></p><p>四个工作周期都有CPU访存操作，只是访存的目的不同。 <strong>取指周期FE=1</strong>是为了<strong>取指令</strong>，<strong>间址周期IND=1</strong>是为了<strong>取有效地址</strong>，<strong>执行周期EX=1</strong>是为了<strong>取操作数</strong>，<strong>中断周期INT=1</strong>是为了<strong>保存程序断点</strong>。</p><hr><ul><li><strong><u>指令周期的数据流-取指周期</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-20-20.png" alt=""></p><ol><li>当前指令地址送至存储器地址寄存器，记做：(PC) → MAR</li><li>CU发出控制信号，经控制总线传到主存，这里是<strong>读信号</strong>，记做：1 → R</li><li>将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR) → MDR 【M(MAR) 即：MEM(MAR)】</li><li>将MDR中的内容(此时是指令)送入IR， 记做：(MDR) → IR</li><li>CU发出控制信号，形成下一条指令地 址，记做：(PC)+1 → PC</li></ol><hr><ul><li><strong><u>指令周期的数据流-间址周期</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-32-10.png" alt=""></p><ol><li>将指令的地址码送入MAR， 记做：Ad(IR) → MAR 或Ad(MDR) → MAR 【因为从取值周期可以知道，IR是从MDR中复制一份的】</li><li>CU发出控制信号，启动主存做<strong>读操作</strong>， 记做：1 → R</li><li>将MAR所指主存中的内容经数据总线 送入MDR，记做：M(MAR) → MDR</li><li>将<strong>有效地址</strong>送至指令的地址码字段， 记做：MDR→ Ad(IR)</li></ol><hr><ul><li><strong><u>指令周期的数据流-执行周期</u></strong></li></ul><p>执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。 不同指令的执行周期操作不同，因此没有统一的数据流向。</p><hr><ul><li><strong><u>指令周期的数据流-中断周期</u></strong></li></ul><p>中断：暂停当前任务去完成其他任务。 为了能够恢复当前任务，需要<strong>保存断点</strong>。 一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设<strong>SP指向栈顶元素</strong>，进栈操作是<strong>先修改指针</strong>，<strong>后存入数据</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_10-42-54.png" alt=""></p><ol><li><p>CU控制将SP减1，修改后的地址送入MAR，记做： (SP)-1 → SP，(SP) → MAR<br>本质上是将断点存入某个存储单元，假设其地址为a，故可记做：a → MAR</p></li><li><p>CU发出控制信号，启动主存做<strong>写操作</strong>， 记做：1 → W</p></li><li><p>将断点(PC内容) 送入MDR， 记做：(PC) → MDR</p></li><li><p>CU控制将中断服务程序的入口地址 (由向量地址形成部件产生)送入PC， 记做：向量地址→ PC</p></li></ol><hr><ul><li><strong><u>指令执行方案</u></strong></li></ul><p>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成 指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_00-21-38.png" alt=""></p><ul><li>方案1．<strong>单指令周期</strong></li></ul><p>对所有指令都选用相同的执行时间来完成 。<br>指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。<br>缺点：对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。</p><ul><li>方案2．<strong>多指令周期</strong></li></ul><p>对不同类型的指令选用不同的执行步骤来完成 。<br>指令之间串行执行；可选用不同个数的时钟周期来完成不同指令的执行过程 。<br>缺点：需要更复杂的硬件设计。</p><ul><li>方案3．<strong>流水线方案</strong></li></ul><p>在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中 。<br>指令之间并行执行。</p><hr><h2 id="5-3-1-数据通路-单总线结构">5.3.1 数据通路-单总线结构</h2><blockquote><p>大题高频考点</p></blockquote><ul><li><strong><u>指令周期的数据流</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_11-40-22.png" alt=""></p><hr><ul><li><strong><u>数据通路</u></strong></li></ul><p>数据通路：数据在功能部件之间传送的路径。</p><p>信息从哪里开始，中间经过哪些部件，最后传到哪里</p><p>由控制部件（下图中的微操作信号发生器）产生的控制信号建立数据通路</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_13-33-20.png" alt=""></p><p>数据通路的基本结构:</p><ol><li>CPU内部单总线方式。如上图，本小节主要探讨这部分内容</li><li>CPU内部多总线方式。</li><li>专用数据通路方式。5.1 CPU的功能和基本结构 中 运算器的基本结构中提到</li></ol><hr><ul><li><strong><u>数据通路-CPU内部单总线方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_13-45-39.png" alt=""></p><p>图中的寄存器信号（PCin、IRin……）都是由CU发出</p><p><strong>内部总线</strong>是指同一部件，如CPU内部连接各寄存器及运算部 件之间的总线；<br><strong>系统总线</strong>是指同一台计算机系统的各部件，如CPU、内存、 通道和各类I/O接口间互相连接的总线。</p><ol><li><strong>寄存器之间数据传送</strong></li></ol><p>比如把PC内容送至MAR，实现传送操作的流程及控制信号为：</p><p>(PC)→Bus ———— PCout有效，PC内容送总线（Bus）<br>Bus→MAR ———— MARin有效，总线内容送MAR</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_13-52-18.png" alt=""></p><p>也可写为：(PC)→Bus→MAR<br>也有的教材写为：PC→Bus→MAR</p><p>所以加不加括号看题，<strong>重要的是描述清楚数据流向</strong>，建议都加上，或者与题目示例保持一致</p><ol start="2"><li><strong>主存与CPU之间的数据传送</strong></li></ol><p>比如CPU从主存读取指令，实现传送操作的流程及控制信号为：</p><p>(PC)→Bus→MAR ———— PCout和MARin有效，现行指令地址→MAR<br>1 → R —— ——CU发读命令(通过控制总线发出，图中未画出(补上了))<br>MEM(MAR)→MDR ———— <s>MDRin</s>MDRinE有效【加上E表示来自外部】<br>MDR→Bus→IR ———— MDRout和IRin有效，现行指令→IR</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-17-16.png" alt=""></p><ol start="3"><li><strong>执行算术或逻辑运算</strong></li></ol><p>比如一条加法指令，微操作序列及控制信号为：</p><p>Ad(IR)→Bus→MAR ———— MDRout和MARin有效 或 AdIRout和MARin有效<br>1 → R —— ——CU发读命令(通过控制总线发出，图中未画出(补上了))<br>MEM(MAR)→MDR ———— <s>MDRin</s>MDRinE有效【加上E表示来自外部】<br>MDR→Bus→Y ———— MDRout和Yin有效，操作数→Y<br>(ACC)+(Y)→Z ———— ACCout和ALUin有效，CU向ALU发送加命令<br>Z→ACC ———— Zout和ACCin有效，结果→ACC<br>【Y和Z是暂存寄存器】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-28-21.png" alt=""></p><hr><ul><li><strong><u>CPU内部单总线方式-例题</u></strong></li></ul><p>设有如图所示的单总线结构，分析指令 ADD (R0),R1 的指令流程和控制信号。【出过两年大题】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-43-50.png" alt=""></p><ol><li>分析指令功能和指令周期<br>功能： ((R0))+(R1)→(R0)<br>取指周期、间址周期、执行周期</li><li>写出各阶段的指令流程</li></ol><p><strong>取指周期</strong>：公共操作</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-44-39.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-43-04.png" alt=""></p><p>或者</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-43-09.png" alt=""></p><p><strong>间址周期</strong>：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。<br>【发现这里和之前介绍的有所不同，这是由于教材不同导致的，主要还是看题目。<br>之前：访存，将间接地址转化成直接地址，然后写回IR中<br>本题：直接访存找到了操作数，放到MDR中】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-51-04.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-50-59.png" alt=""></p><p><strong>执行周期</strong>：完成取数操作，被加数在主存中，加数 已经放在寄存器R1中。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-57-04.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_14-57-09.png" alt=""></p><p>为什么第三步是MARout？<br>——因为要写回(R0)这个地址，但是在间址周期还存有地址(R0)，所以直接控制MAR输出即可</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p>区别内部总线与系统总线</p><p>学会各阶段的微操作序列和控制信号</p><p>CPU内部总线：</p><ul><li>单总线<br>ALU需要配合暂存器使用</li><li>多总线<br>ALU不需要</li></ul><hr><h2 id="5-3-2-数据通路-专用通路结构">5.3.2 数据通路-专用通路结构</h2><ul><li><strong><u>专用数据通路</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_17-34-52.png" alt=""></p><hr><ul><li><strong><u>专用数据通路方式-取指周期</u></strong></li></ul><ol><li>(PC)→MAR ———— C0有效</li><li>(MAR)→主存 ———— C1有效</li><li>1→R ———— 控制单元向主存发送读命令</li><li>M(MAR)→MDR ———— C2有效</li><li>(MDR)→IR ———— C3有效</li><li>(PC)+1→PC ———— (图中没有就不写)</li><li>Op(IR)→CU ———— C4有效</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_17-41-05.png" alt=""></p><hr><ul><li><strong><u>专用数据通路方式-例题</u></strong></li></ul><p>下图是一个简化了的CPU与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器和其他4个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。 要求：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_17-48-03.png" alt=""></p><p>（1）请写出图中a、b、c、d 4个寄存器的名称。<br>（2）简述图中取指令的数据通路。<br>（3）简述数据在运算器和主存之间进行存/取访问的数据通路。<br>（4）简述完成指令LDA X的数据通路（X为主存地址，LDA的功能为(X)→ACC）。<br>（5）简述完成指令ADD Y的数据通路（Y为主存地址，ADD的功能为(ACC)+(Y)→ACC）。<br>（6）简述完成指令STA Z的数据通路（Z为主存地址，STA的功能为(ACC)→Z）。</p><p><strong>解</strong>：（1）<br>d 能自动“+1”，是PC<br>PC内容是地址，送MAR，故c是MAR<br>b 与微操作信号发生器相连，是IR<br>与主存相连的寄存器是MAR和MDR，c是MAR， 则a是MDR</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_17-45-00.png" alt=""></p><p>（2）<br>(PC)→MAR<br>M(MAR)→MDR<br>(MDR)→IR<br>不放心可以加上：<br>OP(IR)→微操作信号发生器 （译码，OP(IR)表示IR中的操作码）<br>(PC) + 1 = PC</p><p>（3）<br>存/取的数据放到ACC中<br>设数据地址已放入MAR<br>取：<br>M(MAR) → MDR<br>MDR → ALU → ACC【由于ALU不是寄存器，所以不加括号】<br>存：<br>(ACC) → MDR<br>(MDR) → M(MAR)</p><p>（4）<br>X → MAR 或者Ad(IR) → MAR【X是一个数，所以不加“()”】<br>M(MAR) → MDR<br>(MDR) → ALU → ACC</p><p>（5）<br>Y → MAR 或者Ad(IR) → MAR【Y是一个数，所以不加“()”】<br>M(MAR) → MDR<br>(MDR) → ALU, (ACC) → ALU<br>ALU → ACC 【应该要有个暂存寄存器，等电路稳定再输出结果，图中没有就不管了】</p><p>（6）<br>Z → MAR 或者Ad(IR) → MAR【Z是一个数，所以不加“()”】<br>(ACC) → MDR<br>(MDR) → M(MAR)</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p>对于一个部件有多个输入，可以采用多路选择器或者三态门</p><hr><h2 id="5-4-1-硬布线控制器设计">5.4.1 硬布线控制器设计</h2><blockquote><p>控制器的设计：</p><ul><li>硬布线控制器</li><li>微程序控制器</li></ul></blockquote><ul><li><strong><u>内容回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_18-22-00.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_18-23-04.png" alt=""></p><p>CPU发出一个微命令，可完成对应微操作。<br>如: 微命令1 使得 PCout、MARin 有效。完成对应的微操作1(PC) → MAR</p><p>一个节拍内可以<strong>并行</strong>完成多个“<strong>相容的</strong>”<strong>微操作</strong></p><p>同一个微操作可能在不同指令的不同阶段被使用，如图</p><p>不同指令的执行周期所需节拍数各不相同。为了简化设计，选择<strong>定长的机器周期</strong>，以可能出现的最大节拍数为准（通常<strong>以访存所需节拍数作为参考</strong>)</p><p>若实际所需节拍数较少，可将微操作安排在机器周期末尾几个节拍上进行（如上图执行周期和中断周期，微操作放在T1、T2，而不放在T0）</p><p>根据 <strong>指令操作码</strong>、<strong>目前的机器周期</strong>、<strong>节拍信号</strong>、<strong>机器状态条件</strong>，即可确定现在这个<strong>节拍下应该发出哪些“微命令</strong>”</p><hr><ul><li><strong><u>硬布线控制器</u></strong></li></ul><p>控制单元CU采用硬布线方式设计就是硬布线控制器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_19-41-10.png" alt=""></p><p>那么什么时候CU发出C1微操作命令？</p><p>——所有指令的取指周期并且处于T0节拍下，一定要完成(PC)→MAR。则可知 <code>C1=FE·T0</code>，所以如下设计</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_19-43-31.png" alt=""></p><p>Tips：逻辑表达式是电路的数学化描述</p><p>这只是个简单的</p><hr><ul><li><strong><u>颤抖吧! 感受恐惧!</u></strong></li></ul><p>M (MAR)→MDR 微操作命令的逻辑表达式:<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>E</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mi>I</mi><mi>N</mi><mi>D</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>S</mi><mi>T</mi><mi>A</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo>+</mo><mi>J</mi><mi>M</mi><mi>P</mi><mo>+</mo><mi>B</mi><mi>A</mi><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mi>X</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FE·T_1+IND·T_1(ADD+STA+LDA+JMP+BAN)+EX·T_1(ADD+LDA)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">FE</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_19-48-56.png" alt=""></p><p>上图中蓝色线接到操作码译码器</p><p>首先这么复杂考试肯定不考</p><p>注: 一般<strong>不考</strong>电路，莫慌~</p><hr><ul><li><strong><u>硬布线控制器的设计</u></strong></li></ul><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列（取值、间址、<strong>执行</strong>、中断 四个阶段)<br>——确定哪些指令在什么阶段、在什么条件下会使用到的微操作<br>——主要还是执行阶段，其他三个都差不多</li><li>选择CPU的控制方式<br>——采用定长机器周期还是不定长机器周期? 每个机器周期安排几个节拍?<br>——假设采用同步控制方式（定长机器周期），一个机器周期内安排3个节拍。</li><li>安排微操作时序<br>——如何用3个节拍完成整个机器周期内的所有微操作?</li><li>电路设计<br>——确定每个微操作命令的逻辑表达式并用电路实现</li></ol><p>首先还好<strong>不考</strong>电路设计</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-06-17_23-51-16.png" alt=""></p><hr><ul><li><strong><u>分析每个阶段的微操作序列</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-07-14.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-07-19.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-08-54.png" alt=""></p><p>罗列出所有指令在各个阶段的微操作序列，就可以知道在什么情况下需要使用这个微操作</p><p>注：中断周期内的微操作序列就不分析了，原理类似</p><hr><ul><li><strong><u>安排微操作时序的原则</u></strong></li></ul><p>原则一 微操作的 <strong>先后顺序不得</strong> 随意 <strong>更改</strong></p><p>前：(PC)→MAR<br>后：M(MAR)→MDR</p><p>原则二 <strong>被控对象不同</strong> 的微操作，尽量安排在 <strong>一个节拍</strong> 内完成</p><p>(PC)→MAR —— 被控对象：寄存器<br>1 → R —— 被控对象：主存</p><p>原则三 占用 <strong>时间较短</strong> 的微操作，尽量 安排在 <strong>一个节拍</strong> 内完成，并 <strong>允许有先后顺序</strong></p><hr><ul><li><strong><u>安排微操作时序-取指周期</u></strong></li></ul><p>分析：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-18-39.png" alt=""></p><p>安排：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-18-54.png" alt=""></p><p>因为（4）（5）两个微操作占用时间较短，根据原则三安排在一个节拍</p><p>为什么（3）（4）不能安排在一起？<br>——M(MAR)→MDR 从主存取数据，用时较长，因此必须一个时钟周期才能保证微操作的完成</p><p>为什么（4）（5）可以安排在一起？<br>——MDR→IR 是CPU内部寄存器的数据传送，速度很快，因此在一个时钟周期内可以紧接着完成 OP(IR)→ID<br>也就是可以一次同时发出两个微命令。</p><hr><ul><li><strong><u>安排微操作时序-间址周期</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-23-38.png" alt=""></p><hr><ul><li><strong><u>安排微操作时序-执行周期</u></strong></li></ul><p>非访存指令和访存指令——是否有间址周期</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-30-09.png" alt=""></p><hr><ul><li><strong><u>组合逻辑设计</u></strong></li></ul><p>设计步骤:</p><ol><li>列出操作时间表<br>——列出在取指、间址、执行、中断周期，T0、T1、T2 节拍内有可能用到的所有微操作（王道书 表5.1）</li><li>写出微操作命令的最简表达式</li><li>画出逻辑图</li></ol><p>第一步：列出操作时间表</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-38-36.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-41-25.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_20-41-30.png" alt=""></p><p>把上面三个表的M (MAR)→MDR 挑出来，其微操作命令的逻辑表达式:<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>E</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mi>I</mi><mi>N</mi><mi>D</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>S</mi><mi>T</mi><mi>A</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo>+</mo><mi>J</mi><mi>M</mi><mi>P</mi><mo>+</mo><mi>B</mi><mi>A</mi><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mi>X</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FE·T_1+IND·T_1(ADD+STA+LDA+JMP+BAN)+EX·T_1(ADD+LDA)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">FE</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">{</mo><mi>F</mi><mi>E</mi><mo>+</mo><mi>I</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>S</mi><mi>T</mi><mi>A</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo>+</mo><mi>J</mi><mi>M</mi><mi>P</mi><mo>+</mo><mi>B</mi><mi>A</mi><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mi>X</mi><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T_1\{FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05764em;">FE</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mclose">)}</span></span></span></span></p><hr><ul><li><strong><u>画出逻辑图</u></strong></li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>E</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mi>I</mi><mi>N</mi><mi>D</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>S</mi><mi>T</mi><mi>A</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo>+</mo><mi>J</mi><mi>M</mi><mi>P</mi><mo>+</mo><mi>B</mi><mi>A</mi><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mi>X</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FE·T_1+IND·T_1(ADD+STA+LDA+JMP+BAN)+EX·T_1(ADD+LDA)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">FE</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span><br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">{</mo><mi>F</mi><mi>E</mi><mo>+</mo><mi>I</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>S</mi><mi>T</mi><mi>A</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo>+</mo><mi>J</mi><mi>M</mi><mi>P</mi><mo>+</mo><mi>B</mi><mi>A</mi><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mi>X</mi><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mi>D</mi><mo>+</mo><mi>L</mi><mi>D</mi><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T_1\{FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05764em;">FE</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">A</span><span class="mclose">)}</span></span></span></span></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_19-48-56.png" alt=""></p><hr><ul><li><strong><u>硬布线控制器的设计</u></strong></li></ul><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列</li><li>选择CPU的控制方式</li><li>安排微操作时序</li><li>电路设计<br>（1）列出操作时间表<br>（2）写出微操作命令的最简表达式<br>（3）画出逻辑图</li></ol><p>硬布线控制器的<strong>特点</strong>：<br>指令越多，设计和实现就越复杂，因此一般用于 RISC(精简指令集系统)<br>如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。<br>由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生</p><hr><h2 id="5-4-2-微程序控制器的基本原理">5.4.2 微程序控制器的基本原理</h2><ul><li><strong><u>硬布线控制器的设计思路</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_19-48-56.png" alt=""></p><p>硬布线控制器：<strong>微操作控制信号</strong>由组合逻辑电路根据当前的指令码、状态和时序，即时产生<br>时序信息包含机器周期、节拍</p><hr><ul><li><strong><u>微程序控制器的设计思路</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-05-24.png" alt=""></p><p>采用“存储程序”的思想，CPU出厂前将所有指令的“微程序“存入“控制器存储器”中</p><p><strong>程序</strong>：由指令序列组成<br><strong>微程序</strong>：由微指令序列组成，<strong>每一种指令对应一个微程序</strong></p><p><strong>指令</strong>是对程序执行步骤的描述<br><strong>微指令</strong>是对指令执行步骤的描述</p><p><strong>微命令</strong>与<strong>微操作</strong>一一对应<br><strong>微指令</strong>中可能<strong>包含多个微命令</strong></p><p><strong>指令周期</strong>：从主存取出并执行一条机器指令所需的时间<br><strong>微周期</strong> (微指令周期)：从控制器存储器取出一条微指令并执行相应微操作所需的时间</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-08-53.png" alt=""></p><p>顺序控制：指明下一务微指令的地址</p><hr><ul><li><strong><u>微程序控制器的基本结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-27-44.png" alt=""></p><p>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。</p><p>顺序逻辑：根据某些机器标志和时序信息确定下一条微指令的存放地址</p><p>标志：根据指令地址码的寻址特征位判断<strong>是否要跳过间址周期</strong></p><p>CLK：根据中断信号判断<strong>是否进入中断周期</strong></p><p>CMAR：别名: <strong>μPC</strong>，微地址寄存器，接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。</p><p>地址译码：将地址码转化为存储单元控制信号。</p><p>控制存储器CM：用于存放各指令对应的微程序，控制存储器可用只读存储器<strong>ROM</strong>构成</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-29-25.png" alt=""></p><p>CMDR：别名: <strong>μIR</strong>，用于存放从CM中取出的微指令，&quot;它的位数同微指令字长相等。</p><p>思考：所有指令的取指周期、间址周期、中断周期所对应的微指令序列都一样，是否可以共享使用?</p><hr><ul><li><strong><u>微程序控制器的工作原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-37-22.png" alt=""></p><p>实际中，取指周期的微指令序列固定从CM的#0开始存放</p><p>标志：根据指令地址码的寻址特征位判断<strong>是否要跳过间址周期</strong><br>CLK：根据中断信号判断<strong>是否进入中断周期</strong></p><p>举例：取数指令 LDA X<br>取指周期: #0、#1、#2<br>间址周期: #3、#4 … #7<br>执行周期: #13、#14、#15<br>中断周期: #8、#9 … #12</p><p>【高频选择题考点】：<br>通常是公用的，故如果某指令系统中有n条机器指令，则CM中微程序段的个数至少是n+1个（n个执行周期微程序段 + 1个取值周期微程序段）</p><p>为什么不加上间址周期微程序和中断周期微程序？<br>——一些早期的CPU、物联网设备的CPU可以不提供间接寻址和中断功能，因此这类CPU可以不包含间址周期中断周期的微程序段</p><p>Tips：物理上，取指周期、执行周期看起来像是两个微程序，但逻辑上应该把它们看作一个整体，因此，“<strong>一条指令对应一个微程序</strong>“的说法是正确的，所以上面说微程序n个也是对的</p><hr><h2 id="5-4-3-微指令设计">5.4.3 微指令设计</h2><ul><li><strong><u>微程序控制器的工作原理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-27-44.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-09_21-08-53.png" alt=""></p><p>微指令的具体格式应该怎么设计?<br>如何根据微指令发出相应的<strong>微命令</strong>?</p><p>微命令与微操作一一对应，一个微命令对应一根输出线<br>有的微命令可以并行执行，因此一条微指令可以包含多个微命令</p><hr><ul><li><strong><u>微指令的格式</u></strong></li></ul><p>相容性微命令：可以并行完成的微命令。<br>互斥性微命令：不允许并行完成的微命令。</p><ol><li>水平型微指令</li></ol><p><strong>一条微指令能定义 多个 可并行的微命令</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-11-26.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-14-32.png" alt=""></p><p>优点：微程序短，执行速度快;<br>缺点：微指令长，编写微程序较麻烦。</p><ol start="2"><li>垂直型微指令</li></ol><p><strong>一条微指令只能定义 一个 微命令，由微操作码字段规定具体功能</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-14-55.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-14-14.png" alt=""></p><p>优点：微指令短、简单、规整，便于编写微程序；<br>缺点：微程序长，执行速度慢，工作效率低</p><ol start="3"><li>混合型微指令</li></ol><p><strong>在垂直型的基础上增加一些不太复杂的并行操作</strong>。</p><p>微指令较短，仍便于编写；微程序也不长，执行速度加快。</p><hr><ul><li><strong><u>微指令的编码方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-11-26.png" alt=""></p><p>微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段（上图左半边部分）进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长</p><p>（1）<strong>直接编码（直接控制）方式</strong><br>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong>，某位为“<strong>1</strong>”表示该控制信号有效</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-21-51.png" alt=""></p><p><strong>优点</strong>：简单、直观，执行速度快，操作并行性好。<br><strong>缺点</strong>：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存CM容量极大。</p><p>（2）<strong>字段直接编码方式</strong><br>将微指令的控制字段分成若干“段”，<strong>每段经译码后发出控制信号</strong></p><p>微命令字段分段的原则:<br>①<strong>互斥性</strong>微命令分在<strong>同一段</strong>内，<strong>相容性</strong>微命令分在<strong>不同段</strong>内<br>②<strong>每个小段</strong>中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和译码时间。<br>③一般<strong>每个小段还要留出一个状态</strong>，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，<strong>通常用000表示不操作</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-25-37.png" alt=""></p><p><strong>优点</strong>：可以缩短微指令字长。<br><strong>缺点</strong>：要通过译码电路后再发出微命令，因此比直接编码方式慢</p><p>【例题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用<strong>字段直接编码法</strong>，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?</p><p>第1个互斥类有7个微命令，<strong>要留出1个状态表示不操作</strong>，所以需要表示8种不同的状态，故需要3个二进制位。以此类推，后面4个互斥类各需要表示4、13、6、7种不同的状态，分别对应2、4、3、3个二进制位。<br>故操作控制字段的总位数为 3 + 2 + 4 + 3 + 3 = 15位</p><p>Tips：若采用 直接编码 方式，则控制字段需要33位</p><p>（3）<strong>字段间接编码方式</strong><br>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码又称<strong>隐式编码</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-34-21.png" alt=""></p><p><strong>优点</strong>：可进一步缩短微指令字长<br><strong>缺点</strong>：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。</p><p>【常考前两种】</p><hr><ul><li><strong><u>微指令的地址形成方式</u></strong></li></ul><p>【常考1、3】</p><ol><li>微指令的 <strong>下地址字段</strong> 指出<br>—— 微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为<strong>断定方式</strong></li><li>根据机器指令的 <strong>操作码</strong> 形成<br>—— 当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</li><li>增量<strong>计数器法</strong><br>—— (CMAR)+1→CMAR</li><li>分支转移<br>—— 转移方式：指明判别条件；转移地址：指明转移成功后的去向。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-41-35.png" alt=""></li><li>通过测试网络<br>—— 其实就是之前提到的微程序控制器的基本结构的顺序逻辑<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-42-41.png" alt=""></li><li>由硬件产生微程序入口地址<br><strong>第一条微指令地址</strong> 由专门 <strong>硬件</strong> 产生（用专门的硬件记录取指周期微程序首地址）<br>中断周期由 <strong>硬件</strong> 产生 <strong>中断周期微程序首地址</strong>（用专门的硬件记录)</li></ol><hr><ul><li><strong><u>例题-断定方式</u></strong></li></ul><p>某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用<strong>断定法</strong> (下地址字段法)确定下条微指令地址，则微指令中下地址字段的位数至少是多少位?</p><p>【解】其实就是问总共需要存储多少条微指令?</p><p>32 × 4  + 2 = 130条<br>32个执行周期程序段 + 1个取指周期程序段<br>【间址周期和中断周期可以没有】</p><p>标注出130个不同的位置至少需要多少个二进制位?<br>下地址字段的位数至少是8位</p><hr><h2 id="5-4-4-微程序控制单元的设计">5.4.4 微程序控制单元的设计</h2><ul><li><strong><u>微程序控制单元的设计</u></strong></li></ul><p>设计步骤:</p><ol><li><p>分析每个阶段的微操作序列</p></li><li><p>写出对应机器指令的微操作命令及节拍安排</p><p>（1）写出每个周期所需要的微操作(参照硬布线)<br>（2）补充微程序控制器特有的微操作:</p><p>a.取指周期:<br>Ad(CMDR)→CMAR —— 每条微指令结束之后都需要进行<br>OP(IR)→微地址形成部件→CMAR —— 取指周期的最后一条微指令完成后，要根据指令操作码确定其执行周期的微程序首地址</p><p>b.执行周期:<br>OP(IR)→微地址形成部件→CMAR —— 每条微指令结束之后都需要进行</p></li><li><p>确定微指令格式</p><p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。根据CM中存储的微指令总数，确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长</p></li><li><p>编写微指令码点</p><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点</p></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_00-55-15.png" alt=""></p><p>还需考虑 <strong>如何读出</strong> 这3条微指令（设为a,b,c）以及如何转入下一个机器周期：</p><p>取指周期的第一条微指令地址由硬件自动给出<br>用微指令 a 的下地址表示 b 的地址</p><p>Ad(CMDR)→CMAR —— 用当前微指令的下地址表示找到下一条微指令<br>OP(IR)→微地址形成部件→CMAR —— 根据指令操作码确定其执行周期微指令序列的首地址</p><p>修改：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_01-03-14.png" alt=""></p><p>显然，微程序控制器的速度比硬布线控制器更慢</p><p>但是王道书中：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_01-04-39.png" alt=""></p><p>都行，不必纠结，只要保证同一个节拍内的操作可以并行即可</p><hr><ul><li><strong><u>微程序设计分类</u></strong></li></ul><p>1、静态微程序设计和动态微程序设计</p><p><strong>静态</strong> —— 微程序无需改变，采用 <strong>ROM</strong><br><strong>动态</strong> —— 通过 <strong>改变微指令</strong> 和 <strong>微程序</strong> 改变机器指令有利于仿真，采用 <strong>EPROM</strong></p><p>2、<strong>毫微程序设计</strong>（就再套一层呗）</p><p>毫微程序设计的基本概念：<br><strong>微程序设计</strong> 用 <strong>微程序解释机器指令</strong><br><strong>毫微程序设计</strong> 用 <strong>毫微程序解释微程序</strong></p><hr><ul><li><strong><u>硬布线与微程序的比较</u></strong></li></ul><p>【高频考点】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-22-09.png" alt=""></p><hr><h2 id="5-6-1-指令流水线的基本概念">5.6.1 指令流水线的基本概念</h2><ul><li><strong><u>指令流水线的定义</u></strong></li></ul><p>一条指令的执行过程可以分成多个阶段 (或过程)根据计算机的不同，具体的分法也不同。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-26-48.png" alt=""></p><p>取指：根据PC内容访问主存储器，取出一条指令送到IR中。<br>分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。<br>执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。</p><p>特点: 每个阶段用到的硬件不一样。</p><p>设取指、分析、执行3个阶段的时间都相等，用t表示 ，按以下几种执行方式分析n条指令的执行时间:</p><ol><li><strong>顺序执行方式</strong></li></ol><p>总耗时T = n×3t = 3nt</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-31-04.png" alt=""></p><p>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。<br>优点：控制简单，硬件代价小。<br>缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</p><p>2、<strong>一次重叠执行方式</strong></p><p>总耗时T = 3t + (n-1) × 2t =(1+2n)t</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-33-41.png" alt=""></p><p>优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。 缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。</p><ol start="3"><li><strong>二次重叠执行方式</strong>（理想情况下 ）</li></ol><p>总耗时T = 3t + (n-1) × t = (2+n)t</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-35-18.png" alt=""></p><p>与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。</p><p>注：也可以把每条指令的执行过程分成4个或5个阶段，分成5个阶段是比较常见的做法。</p><hr><ul><li><strong><u>流水线的表示方法</u></strong></li></ul><p><strong>指令执行过程图</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-37-59.png" alt=""></p><p>主要用于分析指令执行过程以及影响流水线的因素（见下一个视频）</p><p><strong>时空图</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_15-41-07.png" alt=""></p><p>主要用于分析流水线的性能</p><p>空间：不同的阶段所对应的不同的硬件资源</p><hr><ul><li><strong><u>流水线的性能指标</u></strong></li></ul><p><strong>吞吐率</strong> —— 吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量</p><p>设任务数为n；处理完成n个任务所用的时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">T_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>则计算流水线吞吐率 (TP)的最基本的公式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><msub><mi>T</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">TP=\frac{n}{T_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1463em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>理想情况下，流水线的时空图如下:<br>【理想情况：各阶段花费时间相同；每个阶段结束后能立即进入下一阶段。】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_16-00-40.png" alt=""></p><p>一条指令的执行分为k个阶段，每个阶段耗时Δt，一般取Δt = 一个时钟周期</p><p>Tk = (k+n-1)Δt； <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP=\frac{n}{(k+n-1)Δt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2154em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>当连续输入的任务当连续输入的任务n-o0时最高效率为Emax-1。时，得最大吞吐率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max}=\frac{1}{Δt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>图中装入时间：使得各个硬件部件投入工作的时间<br>排空时间：使得各个硬件部件退出工作的时间</p><p><strong>加速比</strong> —— 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。</p><p>设T0表示不使用流水线时的执行时间，即顺序执行所用的时间；Tk表示使用流水线时的执行时间<br>则计算流水线加速比 (S) 的基本公式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><msub><mi>T</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{T_0}{T_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3393em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>那么对于上面的图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{knΔt}{(k+n-1)Δt} = \frac{kn}{k+n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">kn</span><span class="mord mtight">Δ</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2834em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">kn</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>当连续输入的任务n→∞时，得最大吞吐率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_{max}=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p><p><strong>效率</strong> —— 流水线的设备利用率称为流水线的效率。</p><p>在时空图上，流水线的效率定义为<strong>完成n个任务占用的时空区有效面积</strong>与<strong>n个任务所用的时间与k个流水段所围成的时空区总面积</strong>之比。</p><p>则流水线效率 (E) 的一般公式为<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mtext> 个任务占用 </mtext><mi>k</mi><mtext> 时空区有效面积 </mtext></mrow><mrow><mi>n</mi><mtext> 个任务所用的时间与 </mtext><mi>k</mi><mtext> 个流水段所围成的时空区总面积 </mtext></mrow></mfrac><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><mi>k</mi><msub><mi>T</mi><mi>k</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">E=\frac{n \text { 个任务占用 } k \text { 时空区有效面积 }}{n \text { 个任务所用的时间与 } k \text { 个流水段所围成的时空区总面积 }}=\frac{T_{0}}{k T_{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">个任务所用的时间与</span><span class="mord mtight"> </span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">个流水段所围成的时空区总面积</span><span class="mord mtight"> </span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">个任务占用</span><span class="mord mtight"> </span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord text mtight"><span class="mord mtight"> </span><span class="mord cjk_fallback mtight">时空区有效面积</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3393em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_16-15-17.png" alt=""></p><p>由图可知，空闲区域（左上角 + 右下角）不变，当连续输入的任务n→∞时，最高效率为Emax=1。</p><hr><h2 id="5-6-2-指令流水线的影响因素和分类">5.6.2 指令流水线的影响因素和分类</h2><ul><li><strong><u>机器周期设置</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_20-39-51.png" alt=""></p><p>IF：instruction fetch</p><p>图中的经典五段式流水线是MIPS架构提出的，MIPS是第一个RISC；在MIPS架构下，虽然有的指令不需要经过某个机器周期的操作，但是也需要经过这个周期</p><p>各部件实际耗时可能是：100ns、80ns、70ns、50ns、50ns<br>为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准即此处应将机器周期设置为100ns。</p><p>因此流水线每一个功能段部件后面都要有一个缓冲寄存器（图中蓝色框内部分），或称为锁存器其作用是保存本流水段的执行结果，提供给下一流水段使用</p><p>IF和M阶段可以看到cache拆开变成了两个，这样可以方便并行</p><p>M阶段，可能写回，或者不写回（修改cache内容）</p><p>ID阶段，译码的同时要把操作数从通用寄存器中取出，放到锁存器A和B中，（在RISC中，操作数一定来自通用寄存器，如果来自主存，需要先从主存放到通用寄存器中），如果是指令是立即寻址，就直接将结果放到锁存器Imm中</p><hr><ul><li><strong><u>影响流水线的因素</u></strong></li></ul><ol><li><strong>结构相关（资源冲突）（结构冒险）</strong></li></ol><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_08-53-18.png" alt=""></p><p>解决办法：<br>⑴后一相关指令暂停一周期<br>⑵资源重复配置： 数据存储器+指令存储器；如下图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_08-55-11.png" alt=""></p><ol start="2"><li><strong>数据相关（数据冲突） （数据冒险）</strong></li></ol><p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-05-19.png" alt=""></p><p>解决办法：<br>(1)把遇到数据相关的指令及 其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞(stall)和软件插 入“NOP”两种方法。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-05-51.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-06-36.png" alt=""></p><p>(2)数据旁路技术。 (转发机制)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-11-06.png" alt=""></p><p>(3)编译优化：通过编译器调 整指令顺序来解决数据相关。</p><ol start="3"><li><strong>控制相关（控制冲突）（控制冒险）</strong></li></ol><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-15-29.png" alt=""></p><p>解决办法：<br>(1)转移指令分支预测。简单预测 (永远猜ture或false) 、动态预测 (根据历史情况动态调整)<br>(2)预取转移成功和不成功两个控制流方向上的目标指令（需要增加硬件–硬件代价）<br>(3)加快和提前形成条件码（类似之前的并行进位的并行加法器，把信息提前往后放）<br>(4)提高转移方向的猜准率（优化(1)）</p><hr><ul><li><strong><u>流水线的分类</u></strong></li></ul><ol><li><strong>部件功能级、处理机级和处理机间级流水线</strong></li></ol><p>根据<strong>流水线使用的级别</strong>的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</p><p><strong>部件功能级流水</strong>就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶 差、对阶、尾数相加以及结果规格化等4个子过程。</p><p><strong>处理机级流水</strong>是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回5个子过程。</p><p><strong>处理机间流水</strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放 在与下一个处理机所共享的存储器中。</p><ol start="2"><li><strong>单功能流水线和多功能流水线</strong></li></ol><p>按<strong>流水线可以完成的功能</strong>，流水线可分为单功能流水线和多功能流水线。</p><p><strong>单功能流水线</strong>指只能实现一种固定的专门功能的流水线；</p><p><strong>多功能流水线</strong>指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</p><ol start="3"><li><strong>动态流水线和静态流水线</strong></li></ol><p>按<strong>同一时间内各段之间的连接方式</strong>，流水线可分为静态流水线和动态流水线。</p><p><strong>静态流水线</strong>指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。 （例如ALU运行加法时不能再执行减法）</p><p><strong>动态流水线</strong>指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。 （例如ALU实现加减法并行）</p><ol start="4"><li><strong>线性流水线和非线性流水线</strong></li></ol><p>按流水线的<strong>各个功能段之间是否有反馈信号</strong>，流水线可分为线性流水线与非线性流水线。</p><p><strong>线性流水线</strong>中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</p><p><strong>非线性流水线</strong>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</p><hr><ul><li><strong><u>流水线多发技术</u></strong></li></ul><ol><li><strong>超标量技术</strong></li></ol><p>每个时钟周期内可 <strong>并发多条独立指令</strong><br>要配置多个功能部件<br><strong>不能调整</strong> 指令的 <strong>执行顺序</strong><br>通过编译优化技术，把可并行执行的指令搭配起来</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-43-25.png" alt=""></p><ol start="2"><li><strong>超流水技术</strong></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-47-49.png" alt=""></p><p>在 <strong>一个时钟周期</strong> 内 <strong>再分段</strong> （ 3 段）<br>在一个时钟周期内 一个功能部件使用多次（ 3 次）<br><strong>不能调整</strong> 指令的 <strong>执行顺序</strong><br>靠编译程序解决优化问题</p><p><strong>流水线速度是原来速度的 3 倍</strong></p><ol start="3"><li><strong>超长指令字</strong></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_09-53-17.png" alt=""></p><p>由 <strong>编译程序挖掘</strong> 出指令间 <strong>潜在</strong> 的 <strong>并行性</strong>，<br>将 <strong>多条</strong> 能 <strong>并行操作</strong> 的指令组合成 一条<br>具有 <strong>多个操作码字段</strong> 的 <strong>超长指令字</strong>（可达几百位）<br>采用 <strong>多个处理部件</strong></p><hr><h2 id="5-6-3-五段式指令流水线">5.6.3 五段式指令流水线</h2><blockquote><p>常考大题，难度大</p></blockquote><ul><li><strong><u>五段式指令流水线</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-10_20-39-51.png" alt=""></p><p>①IF取指→②ID译码&amp;取数→③EX 执行→④M访存→⑤WB写回寄存器</p><p>考试中常见的五类指令：<br>运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</p><hr><ul><li><strong><u>运算类指令的执行过程</u></strong></li></ul><p>注:<br>Rs：指源操作数 (source)<br>Rd：指目的操作数(destination)</p><table><thead><tr><th>运算指令举例</th><th>指令的汇编格式</th><th>功能</th></tr></thead><tbody><tr><td>加法指令(两个寄存器相加)</td><td><code>ADD Rs, Rd</code></td><td>(Rs)+(Rd)→Rd</td></tr><tr><td>加法指令(寄存器与立即数相加)</td><td><code>ADD #996, Rd</code></td><td>996+(Rd)→Rd</td></tr><tr><td>算数左移指令</td><td><code>SHL Rd</code></td><td>(Rs)+(Rd)→Rd</td></tr></tbody></table><p>运算类指令：<br>IF：根据PC从指令Cache取指令至IF段的锁存器<br>ID：取出操作数至ID段锁存器<br>EX：运算，将结果存入EX段锁存器<br><s>M</s>：空段<br>WB：将运算结果写回指定寄存器</p><hr><ul><li><strong><u>LOAD指令的执行过程</u></strong></li></ul><p><code>LOAD Rd, 996(Rs)</code> —— (996 + (Rs)) → Rd<br>或者简写为：<br><code>LOAD Rd, mem</code> —— (mem) → Rd</p><p>LOAD指令：<br>IF：根据PC从指令Cache取指令至IF段的锁存器<br>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm<br>EX：运算，得到有效地址<br>M：从数据Cache中取数并放入锁存器（未命中才访存，但是因为访存耗时，为了保证流水线流畅工作，大概率能在数据Cache中找到）<br>WB：将取出的数写回寄存器</p><p>通常，<strong>RISC处理器只有“取数LOAD”和“存数STORE”指令才能访问主存</strong></p><hr><ul><li><strong><u>STORE指令的执行过程</u></strong></li></ul><p><code>STORE Rd, 996(Rs)</code> —— Rd → (996 + (Rs))<br>或者简写为：<br><code>STORE Rd, mem</code> —— Rd → (mem)</p><p>STORE指令：<br>IF：根据PC从指令Cache取指令至IF段的锁存器<br>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm，将要存的数放到B<br>EX：运算，得到有效地址。并将锁存器B的内容放到锁存器 store。<br>M：写入数据Cache<br><s>WB</s>：空段</p><hr><ul><li><strong><u>条件转移指令的执行过程</u></strong></li></ul><p><code>beq Rs, Rt, #偏移量</code> —— 若(Rs)==(Rt),则(<strong>PC)+指令字长+(偏移量×指令字长)→PC</strong>; 否则(PC)+指令字长→PC<br><code>bne Rs, Rt, #偏移量</code> —— 若(Rs)!=(Rt),则(<strong>PC)+指令字长+(偏移量×指令字长)→PC</strong>; 否则(PC)+指令字长→PC</p><p>注：通常在IF段结束止之后PC就会自动+“1”</p><p>条件转移指令：(转移类指令常采用相对寻址)<br>IF：根据PC从指令Cache取指令至IF段的锁存器<br>ID：进行比较的两个数放入锁存器A、B；偏移量放入Imm<br>EX：运算，比较两个数<br>M：将目标PC值写PC（图中没画全)<br><s>WB</s>：空段</p><p>为什么写回PC放在M段？<br>首先WB的写回，是写回通用寄存器，但是PC不是通用寄存器；<br>很多教材把写回PC的功能段称为“WrPc段”其耗时比M段更短，可安排在M段时间内完成</p><hr><ul><li><strong><u>无条件转移指令的执行过程</u></strong></li></ul><p><code>jum #偏移量</code> —— <strong>(PC)+指令字长+(偏移量×指令字长)→PC</strong></p><p>无条件转移指令：(转移类指令常采用相对寻址)<br>IF：根据PC从指令Cache取指令至IF段的锁存器<br>ID：偏移量放入Imm<br>EX：将目标PC值写回PC（图中没画全)<br><s>M</s>：空段<br><s>WB</s>：空段</p><p>为什么写回PC放在EX段？<br>“WrPC段”耗时比EX段更短，可安排在EX段时间内完成。WrPc段越早完成就越能避免控制冲突。当然，也有的地方会在WB段时间内才修改PC的值</p><hr><ul><li><strong><u>例题</u></strong></li></ul><p>假设某指令流水线采用“按序发射，按序完成”方式，没有采用转发技术处理数据相关，并且同一寄存器的读和写操作不能在同一个时钟周期内进行。若高级语言程序中某赋值语句为x = a + b，x、a和b均为int型变量，它们的存储单元地址分别表示为[x]、[a]和[b]。该语句对应的指令序列及其在指令流中的执行过程如下图所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD R1, [a]</span><br><span class="line">LOAD R2, [b]</span><br><span class="line">ADD R1, R2</span><br><span class="line">STORE R2, [x]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_11-36-08.png" alt=""></p><p>则这4条指令执行过程中13的ID段和14的IF段被阻塞的原因各是什么?</p><p>【解】：<br>I3与I1和I2存在数据相关;<br>I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容</p><hr><h2 id="5-7-1-多处理器系统的基本概念">5.7.1 多处理器系统的基本概念</h2><blockquote><p>Tips：大纲只要求掌握“基本概念”，意味着一定只考选择题</p></blockquote><ul><li><strong><u>总览</u></strong></li></ul><p>多处理器的基本概念：</p><ul><li><p>SISD、SIMD、MISD、MIMD向量处理器的基本概念</p><ul><li><p><strong>SISD</strong>（单指令流单数据流）</p><ul><li>特性：<br>各指令序列<strong>只能并发、不能并行</strong>，每条指令处理一两个数据<br><strong>不是 数据级并行技术</strong></li><li>硬件组成：<br>一个处理器 + 一个主存储器<br>若采用指令流水线，需设置多个功能部件，采用多模块交叉存储器</li></ul></li><li><p><strong>SIMD</strong>（单指令多数据流）</p><ul><li>特性：<br>各指令序列只能并发、不能并行，但每条指令可同时处理很多个具有相同特征的数据<br><strong>是一种 数据级并行技术</strong></li><li>硬件组成：<br>一个指令控制部件 (CU) + 多个处理单元/执行单元 (如ALU) + 多个局部存储器 + 一个主存储器<br>一每个执行单元有各自的寄存器组、局部存储器、地址寄存器<br>不同执行单元执行同一条指令，处理不同的数据</li></ul></li><li><p><strong>MISD</strong>（多指令流多数据流）</p><p>多条指令并行执行，处理同一个数据。现实中<strong>不存在</strong>这种计算机</p></li><li><p><strong>MIMD</strong>（多指令流多数据流）</p><ul><li>特性：<br>各指令序列并行执行，分别处理多个不同的数据<br>是一种 <strong>线程级并行</strong>、甚至是线程级以上并行技术</li><li>进一步分类<ul><li>多处理器系统 —— 共享内存多处理器（相同的东西）<ul><li>特性：<br>各处理器之间，可以通过LOAD/STORE指令，访问同一个主存储器，可通过主存相互传送数据</li><li>硬件组成<br>一台计算机内，包含多个处理器 + 一个主存储器<br><strong>多个处理器共享单一的物理地址空间</strong></li></ul></li><li>多计算机系统<ul><li>特性：<br>各计算机之间，不能通过LOAD/STORE指令直接访问特性 一对方的存储器，只能通过“消息传递”相互传送数据</li><li>硬件组成：<br>由多台计算机组成，因此拥有多个处理器 + 多个主存储器<br><strong>每台计算机拥有各自的私有存储器，物理地址空间相互独立</strong></li></ul></li></ul></li></ul></li><li><p><strong>向量处理机</strong> (SIMD思想的进阶应用)</p><ul><li>特性：<br>一条指令的<strong>处理对象是“向量“</strong><br>擅长对向量型数据并行计算、浮点数运算，常被用于超级计算机中，处理科学研究中巨大运算量</li><li>硬件组成：<br>多个处理单元，多组“向量寄存器<br><strong>主存储器应采用“多个端口同时读取”的交叉多模块存储器</strong><br>主存储器大小限定了机器的解题规模，因此要有大容量的、集中式的主存储器</li></ul></li></ul></li><li><p>共享内存多处理器 (Shared MemorymultiProcessor,SMP) 的基本概念<br>—— 多处理器系统（相同的东西）<br>—— 多核处理器（一个东西，命名角度不同而已）</p><ul><li>多处理器系统(简称)</li><li>多个处器共享一个主存储器</li><li>多个处理器共享单一的地址空间，都可以通过LOAD、STORE指令访问共享的主存储器</li><li>干扰项：与 多计算机系统 作区别</li></ul></li><li><p>多核处理器 (multi-core) 的基本概念<br>—— 共享内存多处理器（一个东西，命名角度不同而已）</p><ul><li>一个CPU芯片中包含多个处理器，即多个核 (core)，因此通常也称为 片级多处理器（Chip-LevelMultiProcessing，CMP)。意思是：一块芯片上集成了多个处理器</li><li>所有核共享一个LLC(Last-Level Cache)，并共享主存储器</li></ul></li></ul><hr><ul><li><strong><u>SISD</u></strong><br>单指令流单数据流</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_21-20-38.png" alt=""></p><p>eg：计组课程一直在学的就是SISD，每条指令可以处理一两个数据</p><hr><ul><li><strong>SIMD</strong><br>单指令多指令数据流</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_21-29-31.png" alt=""></p><p>Key：对结构类似的大量数据进行相同处理。一条指令处理很多个数据</p><p>eg1：某些显卡常采用SIMD，图像处理时，常对每个像素点进行完全一样的渲染（比如加个粉红色滤镜）<br>eg2：可用于优化for循环中对数组元素的重复处理</p><hr><ul><li><strong><u>MIMD——共享存储多处理器系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-06-03.png" alt=""></p><p>eg: Intel i5、i7处理器</p><hr><ul><li><strong><u>MIMD——多计算机系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-07-19.png" alt=""></p><p>eg：多台计算机组成的“分布式计算系统”</p><hr><ul><li><strong><u>向量处理器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-09-49.png" alt=""></p><p>eg：向量处理机的LOAD指令，可以将一个向量取到向量寄存器中；加法指令，可以实现两个向量相加应用于:向量计算、大量浮点数计算，空气动力学、核物理学、巨型矩阵计算问题很多超级计算机如中国的“银河”就是向量处理器</p><hr><h2 id="5-7-2-硬件多线程的基本概念">5.7.2 硬件多线程的基本概念</h2><blockquote><p>Tips：大纲只要求掌握“基本概念”，意味着一定只考选择题</p><ul><li>细粒度多线程</li><li>粗粒度多线程</li><li>同时多线程(SMT)</li></ul></blockquote><ul><li><strong><u>三种硬件多线程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-13-44.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-24-14.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-24-29.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-24-45.png" alt=""></p><hr><ul><li><strong><u>一个不太严谨的示意图</u></strong></li></ul><p>不支持硬件多线程的处理器：<br>切换线程要保存环境，增加耗费</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-15-51.png" alt=""></p><p>支持硬件多线程的处理器：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_22-16-05.png" alt=""></p><hr><h1>第六章 总线</h1><blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-21-12.png" alt=""></p></blockquote><h2 id="6-1-1-总线概述">6.1.1 总线概述</h2><ul><li><strong><u>总线简图</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-14-37.png" alt=""></p><p>每个总线可能由很多根信号线组成</p><hr><ul><li><strong><u>总线的物理实现</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-17-13.png" alt=""></p><p>如上，4根信号线组成“一根”总线，所有硬件部件都可以通过这根总线传递数据<br>可并行发送4bit数据。同一时刻<strong>只能有一个部件发送</strong>数据，但是<strong>可有多个部件接受数据</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-20-31.png" alt=""></p><hr><ul><li><strong><u>总线的定义</u></strong></li></ul><p>总线是一组能为多个部件 <strong>分时</strong> <strong>共享</strong> 的公共信息传送线路</p><p><strong>共享</strong>是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。<br><strong>分时</strong>是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-22-33.png" alt=""></p><p>为什么要用总线?<br>早期计算机外部设备时大多采用分散连接方式（就是专门的线路），不易实现随时增减外部设备。<br>为了更好地解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。</p><hr><ul><li><strong><u>总线的特性</u></strong></li></ul><p>1、机械特性：尺寸、形状、管脚数、排列顺序</p><p>2、电气特性：传输方向和有效的电平范围</p><p>3、功能特性：每根传输线的功能(地址、数据、控制）</p><p>4、时间特性：信号的时序关系</p><hr><ul><li><strong><u>总线分类</u></strong></li></ul><p>按数据传输格式：</p><ul><li>串行总线</li><li>并行总线</li></ul><p>按总线功能（连接的部件）：</p><ul><li>片内总线</li><li>系统总线</li><li>通信总线</li></ul><p>按时序控制方式：</p><ul><li>同步总线</li><li>异步总线</li></ul><hr><ul><li><strong><u>串行总线与并行总线</u></strong></li></ul><p>串行总线：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-27-27.png" alt=""></p><p>优点：只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间。<br>缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</p><p>并行总线：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-27-51.png" alt=""></p><p>优点：总线的逻辑时序比较简单，电路实现起来比较容易。<br>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。【所以不一定并行总线的传输速度就比串行总线的快】</p><p>总线带宽 = 总线工作频率 × 总线宽度（bit/s）【6.1.2 总线的性能指标】<br>1、工作频率相同时，串行总线传输速度比并行总线慢。<br>2、并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线。</p><hr><ul><li><strong><u>总线的分类（按总线功能)</u></strong></li></ul><p>数据通路表示的是数据流经的路径<br>数据总线是承载的媒介</p><ol><li>片内总线</li></ol><p>片内总线是芯片内部的总线。<br>它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线</p><ol start="2"><li>系统总线</li></ol><p>系统总线是计算机系统内各功能部件 (CPU、主存、I/O接口)之间相互连接的总线。<br>按系统总线传输信息内容的不同，又可分为3类：<strong>数据总线</strong>、<strong>地址总线</strong>和<strong>控制总线</strong>。<br>1)<strong>数据总线</strong>用来传输各功能部件之间的数据信息，它是<strong>双向</strong>传输总线，其<strong>位数与机器字长、存储字长有关</strong>。<br>2)<strong>地址总线</strong>用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址它是<strong>单向</strong>传输总线，地址总线的<strong>位数与主存地址空间的大小有关</strong>。<br>3)<strong>控制总线</strong>传输的是控制信息，包括<strong>CPU送出的控制命令</strong>和<strong>主存(或外设) 返回CPU的反馈信号</strong>。</p><ol start="3"><li>通信总线</li></ol><p>通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线。</p><hr><ul><li><strong><u>系统总线</u></strong></li></ul><p>数据总线DB：传输各功能部件之间的数据信息，包括指令和操作数；位数(信号线根数)与机器字长、存储字长有关；双向。</p><p>地址总线AB：传输地址信息，包括主存单元或I/O端口的地址；位数(根数)与主存地址空间大小及设备数量有关；单向。</p><p>控制总线CB：传输控制信息一根控制线传输一个信号<br>有出: CPU送出的控制命令<br>有入: 主存(或外设) 返回CPU的反馈信号。</p><hr><ul><li><p><strong><u>系统总线的结构</u></strong></p></li><li><p><strong>单总线结构</strong></p></li></ul><p>注：单总线并不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-41-22.png" alt=""></p><p>结构：CPU、主存、I/O设备 (通过I/O接口) 都连接在一组总线上，允许I/O设备之间、I/O设备和CPU之间或I/O设备与主存之间直接交换信息。<br>优点：结构简单，成本低，易于接入新的设备。<br>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持<s>并发</s>并行传送操作。</p><ul><li><strong>双总线结构</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-43-21.png" alt=""></p><p>主存总线：支持突发（猝发）传送：送出一个地址，收到多个地址连续的数据<br>通道是具有特殊功能的处理器能对I/O设备进行统一管理。通道程序放在主存中。</p><p>结构：双总线结构有两条总线，一条是主存总线，用于CPU、主存和通道之间进行数据传送；另一条是I/O总线，用于多个外部设备与通道之间进行数据传送。<br>优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离。<br>缺点：需要增加通道等硬件设备。</p><ul><li><strong><u>三总线结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-45-40.png" alt=""></p><p>DMA：Direct Memory Access，直接内存访问</p><p>结构：三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为<strong>主存总线</strong>、<strong>I/O总线</strong>和直接内存访问<strong>DMA总线</strong>。<br>优点：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。<br>缺点：系统工作效率较低。</p><hr><ul><li><strong><u>四总线结构简介</u></strong></li></ul><p>首先不考，但是现代计算机一般采用这种</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-48-24.png" alt=""></p><ol><li>桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能。</li><li>靠近CPU的总线速度较快</li><li>每级总线的设计遵循总线标准(见本章第4节)。</li></ol><p>拓展：搜索“北桥芯片“、”南桥芯片”（桥接器）</p><hr><h2 id="6-1-2-总线的性能指标">6.1.2 总线的性能指标</h2><blockquote><ol><li>总线的传输周期(总线周期)</li><li>总线时钟周期</li><li>总线的工作频率</li><li>总线的时钟频率</li><li>总线宽度</li><li>总线带宽</li><li>总线复用</li><li>信号线数</li></ol></blockquote><ul><li><strong><u>总线的性能指标</u></strong></li></ul><ol><li><p>总线的<strong>传输周期</strong>(<strong>总线周期</strong>)</p><p>一次总线操作所需的时间（包括申请阶段（仲裁）、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</p></li><li><p>总线<strong>时钟周期</strong></p><p>即<strong>机器的时钟周期</strong>。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p><p>现在的计算机中总线时钟周期也有可能由桥接器提供</p></li></ol><p>总线周期与总线时钟周期的关系比较魔幻<br>大多数情况下，一个总线周期包含多个总线时钟周期<br>有的时候，一个总线周期就是一个总线时钟周期<br>有的时候，一个总线时钟周期可包含多个总线周期</p><ol start="3"><li><p>总线的<strong>工作频率</strong></p><p>总线上各种操作的频率，为<strong>总线周期的倒数</strong>。 若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。 实际上指<strong>一秒内传送几次数据</strong>。</p></li><li><p>总线的<strong>时钟频率</strong></p><p>即机器的时钟频率，为<strong>时钟周期的倒数</strong>。 若时钟周期为T，则时钟频率为1/T。 实际上指<strong>一秒内有多少个时钟周期</strong>。</p></li><li><p><strong>总线宽度</strong></p><p>又称为<strong>总线位宽</strong>，它是总线上<strong>同时能够传输的数据位数</strong>， 通常是指<strong>数据总线的根数</strong>，如32根称为32位（bit）总线。</p></li><li><p><strong>总线带宽</strong></p><p>可理解为总线的<strong>数据传输率</strong>，即<strong>单位时间内总线上可传输数据的位数</strong>，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。</p><p>总线带宽 = 总线工作频率 × 总线宽度（bit/s）= 总线工作频率 × (总线宽度/8)<br>= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext>总线宽度</mtext><mtext>总线周期</mtext></mfrac><mtext>（</mtext><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">\frac{总线宽度}{总线周期}（bit/s）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总线周期</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总线宽度</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">）</span></span></span></span>  = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mtext>总线宽度</mtext><mi mathvariant="normal">/</mi><mn>8</mn></mrow><mtext>总线周期</mtext></mfrac><mtext>（</mtext><mi>B</mi><mi mathvariant="normal">/</mi><mi>s</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">\frac{总线宽度/8}{总线周期}（B/s）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总线周期</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总线宽度</span><span class="mord mtight">/8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">）</span></span></span></span></p><p>注：总线带宽是指总线本身所能达到的<strong>最高传输速率</strong>。在计算实际的<strong>有效数据传输率</strong>时，要用实际传输的数据量除以耗时。</p></li><li><p><strong>总线复用</strong></p><p>总线复用是指<strong>一种信号线在不同的时间传输不同的信息</strong>。 可以使用<strong>较少的线</strong>传输更多的信息，从而节省了空间和成本。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_08-50-39.png" alt=""></p></li><li><p><strong>信号线数</strong></p><p>地址总线、数据总线和控制总线3种总线数的总和称为信号线数。</p></li></ol><hr><ul><li><strong><u>总线的性能指标-带宽</u></strong></li></ul><p>【例题】某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据(上升沿和下降沿各传送一次数据)。<br>1）该总线的最大数据传输率（总线带宽）是多少？<br>2）若该总线支持突发（猝发）传输方式，传输一个地址占用一个时钟周期，则一次“主存写”总线事务传输128位数据所需要的时间至少是多少？</p><p>【解】<br>1）每个时钟周期传送两次数据 → 总线工作频率是时钟频率的两倍<br>总线工作频率 = 2 × 66MHz =132MHZ<br>总线宽度 = 32bit = 4B<br>总线带宽 = 总线工作频率 × 总线宽度 = 132 × 4 MB/s = 528 MB/s</p><p>2）2突发(猝发)传输方式：一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。<br>发送首地址占用1个时钟周期，128位数据需传输4次，占用2个时钟周期<br>一个时钟周期 = 1/66MHz ≈ 15ns<br>总耗时 =(1+2) × 15ns = 45ns</p><hr><h2 id="6-2-总线仲裁-408不考，简单了解即可">6.2 总线仲裁 (408不考，简单了解即可)</h2><ul><li><strong><u>总线仲裁的基本方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_08-53-35.png" alt=""></p><p>同一时刻只能有<strong>一个设备控制</strong>总线传输操作，可以有<strong>一个或多个设备</strong>从总线<strong>接收</strong>数据。</p><p>将总线上所连接的各类设备按其对总线有无控制功能分为:<br><strong>主设备</strong>：获得总线控制权的设备。<br><strong>从设备</strong>：被主设备访问的设备，只能响应从主设备发来的各种总线命令</p><p>为什么要仲裁?<br>总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</p><p>总线仲裁的定义:<br>多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁</p><p>总线仲裁分类</p><ul><li>集中仲裁方式<ul><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li></ul></li><li>分布仲裁方式</li></ul><hr><ul><li><strong><u>集中仲裁方式</u></strong></li></ul><p>工作流程：</p><ol><li>主设备发出请求信号；</li><li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线；</li><li>获得总线使用权的主设备开始传送数据</li></ol><p><strong>链式查询方式</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_09-05-14.png" alt=""></p><p>“<strong>总线忙</strong>”信号的建立者是<strong>获得总线控制权的设备</strong><br>优先级：离总线控制器越<strong>近</strong>的部件，其<strong>优先级越高</strong>；离总线控制器越<strong>远</strong>的部件，其<strong>优先级越低</strong>。</p><p>优点：链式查询方式优先级固定。<br>只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。<br>缺点：对硬件电路的故障敏感，并且优先级不能改变<br>当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。</p><p><strong>计数器定时查询方式</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_09-13-16.png" alt=""></p><p>结构特点：用一个计数器控制总线使用权，相对链式查询方式<strong>多了一组设备地址线，少了一根总线响应线BG</strong>；它仍共用一根总线请求线。</p><p>当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。</p><p>当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权。同时，中止计数器的计数及查询。</p><p>优点：<br>1、计数初始值可以改变优先次序<br>计数每次从“0”开始，设备的优先级就按顺序排列，固定不变；<br>计数从上一次的终点开始，此时设备使用总线的优先级相等；<br>计数器的初值还可以由程序设置<br>2、对电路的故障没有链式敏感<br>缺点：<br>1、增加了控制线数<br>若设备有n个，则需<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\left\lceil\log _{2} n\right\rceil+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose delimcenter" style="top:0em;">⌉</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>条控制线<br>2、控制相对比链式查询相对复杂</p><p><strong>独立请求方式</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_09-30-38.png" alt=""></p><p>结构特点：每一个设备均有一对总线请求线BRi和总线允许线BGi。</p><p>当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队。</p><p>当总线控制器按一定的优先次序决定批准某个部件的请求时， 则给该部件发送总线响应信号。</p><p>优点：<br>1、响应速度快，总线允许信号 BG直接从控制器发送到有关设备， 不必在设备间传递或者查询。<br>2、对优先次序的控制相当灵活。<br>缺点：<br>1、控制线数量多<br>若设备有n个，则需要2n+1条控制线。 其中+1为BS线，其用处为：用于设备向总线 控制部件反馈已经使用完毕总线。<br>2、总线的控制逻辑更加复杂</p><hr><ul><li><strong><u>集中仲裁方式小节</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_09-35-16.png" alt=""></p><hr><ul><li><strong><u>分布仲裁方式</u></strong></li></ul><p>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</p><p>当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上；<br>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；<br>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；<br>最后，获胜者的仲裁号保留在仲裁总线上。</p><hr><h2 id="6-3-总线操作和定时">6.3 总线操作和定时</h2><ul><li><strong><u>总线周期的四个阶段</u></strong></li></ul><p>1）<strong>申请分配阶段</strong>：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</p><p>2）<strong>寻址阶段</strong>：获得使用权的主模块通过总线<strong>发出</strong>本次要访问的从模块的<strong>地址</strong>及有关<strong>命令</strong>，启动参与本次 传输的从模块。</p><p>3）<strong>传输阶段</strong>：主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</p><p>4）<strong>结束阶段</strong>：主模块的<strong>有关信息</strong>均从系统总线上<strong>撤除</strong>，让出总线使用权。</p><p><strong>总线定时</strong>是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则</p><ul><li>同步通信(同步定时方式) —— 由 <strong>统一时钟</strong> 控制数据传送</li><li>异步通信(异步定时方式) —— 采用 <strong>应答方式</strong>，没有公共时钟标准</li><li>半同步通信 —— <strong>同步、异步结合</strong></li><li>分离式通信 —— 充分 <strong>挖掘</strong> 系统 <strong>总线每瞬间</strong> 的 潜力</li></ul><hr><ul><li><strong><u>同步定时方式-读命令</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_11-41-47.png" alt=""></p><p>系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。</p><p>假设：假设CPU作为主设备，某个输入设备作为从设备</p><p>1）CPU在T1时刻的上升沿给出地址信息</p><p>2）在T2的上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作， 且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上。</p><p>3）CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。</p><p>4）CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</p><p>如果从设备跟不上节奏，在T3给不出数据，就寄了~</p><p>注：<br>上升沿：数字电平从0变为1的一瞬间<br>下降沿：数字电平从1变为0的一瞬间</p><hr><ul><li><strong><u>同步定时方式</u></strong></li></ul><p>同步定时方式是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。</p><p>时钟产生相等的时间间隔，每个间隔构成一个总线周期。</p><p>在一个总线周期中，发送方和接收方可进行一次数据传送。</p><p>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。</p><p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。</p><p>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。</p><p>同步通信适用于<strong>总线长度较短</strong>及总线<strong>所接部件的存取时间比较接近</strong>的系统。</p><hr><ul><li><strong><u>异步定时方式</u></strong></li></ul><p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</p><p>主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p><p>根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型。<br>1）不互锁方式<br>2）半互锁方式<br>3）全互锁方式</p><p>优点：<br>总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。<br>缺点：<br>比同步控制方式稍复杂一些，速度比同步定时方式慢。</p><p>1）不互锁方式 —— 速度最快，可靠性最差<br>主设备发出“<strong>请求</strong>”信号后，不必等到接到从设备的“<strong>回答</strong>”信 号，而是经过一段时间，便撤销“<strong>请求</strong>”信号。<br>而从设备在接到“<strong>请求</strong>”信号后，发出“<strong>回答</strong>”信号，并经过一段时间，自动撤销“<strong>回答</strong>”信号。双方不存在互锁关系。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-01-49.png" alt=""></p><p>2）半互锁方式<br>主设备发出“<strong>请求</strong>”信号后，必须待接到从设备的“<strong>回答</strong>”信号 后，才撤销“<strong>请求</strong>”信号，有互锁的关系。 而从设备在接到“<strong>请求</strong>”信号后，发出“<strong>回答</strong>”信号，但不必等待获知主设备的“<strong>请求</strong>”信号已经撤销，而是隔一段时间后自动撤销“<strong>回答</strong>”信号，不存在互锁关系。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-02-02.png" alt=""></p><p>3）全互锁方式 —— 最可靠，速度最慢<br>主设备发出“请求”信号后，必须待从设备“<strong>回答</strong>”后，才撤销 “<strong>请求</strong>”信号； 从设备发出“<strong>回答</strong>”信号，必须待获知主设备“<strong>请求</strong>”信号已撤 销后，再撤销其“<strong>回答</strong>”信号。双方存在互锁关系。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-02-12.png" alt=""></p><hr><ul><li><strong><u>半同步通信</u></strong></li></ul><p>同步 :<br><strong>发送方</strong> 用系统 <strong>时钟前沿</strong> 发信号<br><strong>接收方</strong> 用系统 <strong>时钟后沿</strong> 判断、识别</p><p>异步:<br>允许不同速度的模块和谐工作</p><p>半同步通信：统一时钟的基础上，增加一个“<strong>等待</strong>”响应信号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>W</mi><mi>A</mi><mi>I</mi><mi>T</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{WAIT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-11-58.png" alt=""></p><hr><ul><li><strong><u>分离式通信</u></strong></li></ul><p>上述三种通信的共同点：</p><p>总线传输周期（以输入数据为例）</p><p>• 主模块发地址 、命令 ———— 使用总线</p><p>• 从模块准备数据 ———— 不使用总线，但是占用总线，导致总线空闲</p><p>• 从模块向主模块发数据 ———— 使用总线</p><p>分离式通信的一个总线传输周期</p><ul><li>子周期1 <strong>主模块</strong>申请<strong>占用总线</strong>，使用完后<strong>放弃总线</strong>的使用权</li><li>子周期2  <strong>从模块</strong>申请<strong>占用总线</strong>，将各种信息送至总线上</li></ul><p>特点:</p><ol><li>各模块均有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线利用率提高</li></ol><hr><h2 id="6-4-总线标准-408不考，简单了解即可">6.4 总线标准 (408不考，简单了解即可)</h2><ul><li><strong><u>来，商量一个总线标准?</u></strong></li></ul><p>并行?串行?<br>—— 并行</p><p>几根数据线?几根地址线?<br>—— 32根数据线。数据线、地址线复用</p><p>用哪种总线仲裁方式?<br>—— 链式查询方式</p><p>用哪种总线定时方式?<br>—— 同步定时方式，每四个时钟完成一次数据传输。</p><p>总线工作频率?<br>—— 985MHz</p><p>电气特性?<br>—— 每根线传送1bit数据，0~0.5V为低电平，4.8~5.2V为高电平。低电平表示1，高电平表示0</p><p>……</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-14-23.png" alt=""></p><p>按照一起制定的标准，各自研发硬件设备（类比软件里的&quot;接口”)</p><hr><ul><li><strong><u>总线标准的基本概念</u></strong></li></ul><p>总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。</p><p>根据总线在计算机系统中的位置，可分为：<br><strong>系统总线</strong>：通常与CPU直接相连，用于连接CPU与北桥芯片、或CPU与主存等<br><strong>局部总线</strong>：没有直接与CPU连接，通常是连接高速的北桥芯片，用于连接了很多重要的硬件部件(如显卡、声卡等)<br><strong>设备总线、通信总线</strong>：通常由南桥芯片控制，用于连接计算机与计算机，或连接计算机与外部I/O设备</p><hr><ul><li><strong><u>系统总线标准</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-27-36.png" alt=""></p><p>【ISA、EISA是一种并行总线】。</p><p>最早的PC总线是IBM公司1981年在PC/XT电脑采用的系统总线，它基于8bit的8088 处理器，被称为PC总线或者PC/XT总线。</p><p>1984年，IBM 推出基于16-bit Intel 80286处理器的PC/AT 电脑，系统总线也相应地扩展为16bit，并被称呼为<strong>PC/AT 总线</strong>。而为了开发与IBM PC 兼容的外围设备，行业内便逐渐确立了以IBM PC总线规范为基础的ISA（工业标准架构:Industry Standard Architecture )总线。</p><p>ISA总线最大传输速率仅为8MB/s ，<strong>数据传送需要CPU或DMA接口来管理</strong>，传输速率过低、CPU占用率高、占用硬件中断资源等，很快使ISA总线在飞速发展的计算机技术中成为瓶颈。<strong>不支持总线仲裁</strong>。</p><p>因此在1988年，康柏、惠普等9厂商协同把ISA 扩展到32-bit，这就是著名的EISA (Extended ISA，扩展ISA)总线。EISA 总线的工作频率仍旧仅有8MHz ，并且与<strong>8/16bit 的ISA总线完全兼容</strong>，带宽提高了一倍，达到了32MB/s。<strong>从CPU中分离出了总线控制权，支持多个总线主控器和突发传送</strong>。可惜的是，EISA 仍旧由于速度有限，并且成本过高，在还没成为标准总线之前，在20世纪90年代初的时候，就给PCI 总线给取代了。</p><p>后来Intel提出来FBS(前端总线)，再进一步提出了QPI</p><hr><ul><li><strong><u>局部总线标准</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-42-50.png" alt=""></p><p>CPU的主频提高，数据宽度增大及处理能力的增强使得系统的性能迅速提高。虽然系统总线在不断发展，仍然跟不上软件和CPU的发展速度，仍然不能充分利用CPU的强大处理能力。大部分时间内，CPU都处于等待状态，特别是在日益强大的CPU处理能力和存储器容量的支持和激励下，操作系统和应用程度变得越来越复杂，而显示卡和硬盘控制器因位于8位或16位系统I/O总线上，相对极高的CPU的速度而言，传输数据的速度低的多，从而影响了系统的整体工作效率。</p><p>因此，为提高系统的整体性能，解决总线传输问题的一个办法是将外设直接挂在CPU局部总线上并以CPU速度运行，将外设挂到CPU局部总线能够极大地提高外设的运行速度，而成本只有轻微的上浮，这个性能/价格比为局部总线创造了一个巨大的市场潜力。</p><p>1991，视频电子标准协会针对视频显示的高数据传输率要求而推出了VESA总线，又叫做视频<strong>局部总线</strong>(VESA local bus)，简称VL-BUS总线，由CPU总线演化而来，是针对多媒体PC要求<strong>高速传送活动图像的大数据</strong>应运而生的。</p><p>【VASE是一种并行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-45-36.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-46-49.png" alt=""></p><p>由于ISA/EISA总线速度缓慢，造成硬盘、显示卡还有其它的外围设备只能通过慢速并且狭窄的瓶颈来发送和接受数据，使得整机的性能受到严重的影响。为了解决这个问题，1992年Intel 在发布486处理器的时候，也同时提出了32-bit 的PCI(周边组件互连) 总线。</p><p>最早提出的PCI总线工作在33MHz 频率之下，传输带宽达到了133MB/s(33MHz * 32bit/8)，比ISA总线有了极大的改善，基本上满足了当时处理器的发展需要目前计算机上广泛采用的是这种32-bit、33MHz 的PCI 总线，可扩展到64bit。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-47-01.png" alt=""></p><p>【PCI总线是一种并行总线】</p><p>特点:<br>1、高性能；<strong>不依附于某个具体的处理器，支持突发传送</strong><br>2、良好的兼容性。<br>3、<strong>支持即插即用</strong>。<br>4、支持多主设备。<br>5、具有与处理器和存储器子系统完全并行操作的能力。<br>6、提供数据和地址奇偶校验的能力。<br>7、<strong>可扩充性好，可采用多层结构提高驱动能力</strong>。<br>8、采用多路复用技术，减少了总线引脚个数。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-54-44.png" alt=""></p><p>PCI总线是独立于CPU的局部总线，可将显示卡、声卡、网卡、硬盘控制器等高速的外围设备直接挂在CPU总线上，打破了瓶颈，使得CPU的性能得到充分的发挥。可惜的是，由于PCI总线只有133MB/s的带宽，对付声卡、网卡、视频卡等绝大多数输入/输出设备也许显得绰绰有余，但对于胃口越来越大的3D显卡却力不从心，并成为了制约显示子系统和整机性能的瓶颈。因此，PCI总线的补充——AGP总线就应运而生了。</p><p>Intel 于1996年7月正式推出了AGP(加速图形接口，Accelerated Graphics Port)接口，这是显示卡专用的局部总线，是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz ，1X模式下带宽为266MB/S，是PCI总线的两倍。后来依次又推出了AGP 2X 、AGP 4X，现在则是AGP 8X ，传输速度达到了2.1GB/S。</p><p>【AGP总线是一种并行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-54-55.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-57-21.png" alt=""></p><p>Intel 在2001年春季的IDF上，正式公布了旨在取代PCI总线的第三代I/O技术，最后却被正式命名为PCI-Express，Express 意思是高速、特别快的意思。</p><p>PCI Express总线是一种完全不同于过去PCI总线的一种全新总线规范，与PCI总线共享并行架构相比，PCI Express总线是一种<strong>点对点串行连接</strong>的设备连接方式，点对点意味着每一个PCI Express设备都拥有自己独立的数据连接，各个设备之间并发的数据传输互不影响，而对于过去PCI那种共享总线方式，PC总线上只能有一个设备进行通信，一旦PCI总线上挂接的设备增多，每个设备的实际传输速率就会下降，性能得不到保证。</p><p><strong>在传输速率方面，PCI Express总线利用串行的连接特点将能轻松将数据传输速度提到一个很高的频率，达到远超出PCI总线的传输速率。与此同时，PCI Exress总线支持双向传输模式，还可以运行全双工模式</strong></p><p><strong>支持热拔插</strong></p><p>【PCI-E总线是一种串行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-01-21.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_12-58-30.png" alt=""></p><hr><ul><li><strong><u>设备总线标准</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-03-54.png" alt=""></p><p>RS-232C是应用于<strong>串行二进制交换的数据终端设备(DTE)和数据通信设备(DCE)</strong> 之间的标准接口。</p><p>RS-232C是美国电子工业协会EIA (Electronic Industry Association)联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的一种串行物理接口标准。RS是英文“推荐标准”的缩写，232为标识号，C表示修改次数。RS-232C总线标准设有25条信号线，包括一个主通道和一个辅助通道。</p><p>该标准规定采用一个25个脚的DB-25连接器，对连接器的每个引脚的信号内容加以规定，还对各种信号的电平加以规定。后来IBM的PC机将RS232简化成了DB-9连接器，从而成为事实标准。而工业控制的RS-232口一般只使用RXD、TXD、GND三条线。</p><p>【RS-232C总线是一种串行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-04-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-07-08.png" alt=""></p><p>SCSI (小型计算机系统接口)是一种用于计算机和能设备之间(硬盘、软驱、光驱、打印机、扫描仪等)系统级接口的独立处理器标准。 SCSI是一种智能的通用接口标准。</p><p>1、IDE的工作方式需要CPU的全程参与，CPU读写数据的时候不能再进行其他操作，这种情况在Windows 95/NT的多任务操作系统中，自然就会导致系统反应的大大减慢。而SCSI接口，则完全通过独立的高速的SCSI卡来控制数据的读写操作，CPU就不必浪费时间进行等待，显然可以提高系统的整体性能。不过，IDE接口为改善这个问题也做了很大改进已经可以使用DMA模式而非PIO模式来读写，数据的交换由DMA通道负责，对CPU的占用可大大减小。尽管如此，比较SCSI和IDE在CPU的占用率，还是可以发现SCSI仍具有相当的优势。</p><p>2、SCSI的扩充性比IDE大，一般每个IDE系统可有2个IDE通道，总共连4个IDE设备，而SCSI接口可连接7-15个设备，比IDE要多很多，而且连接的电缆也远长于IDE。</p><p>3、虽然SCSI设备价格高些，与IDE相比，SCSI的性能更稳定、耐用，可靠性也更好</p><p>【SCSI总线是一种并行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-06-52.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-12-35.png" alt=""></p><p>由于可移动计算机(笔记本)用户对PC卡的需求变了，要求强度高，能耗低，尺寸小，而且对这几条性能的要求都很高。所以PC卡的标准也相应地变了。 1991年，PCMCIA定义了原本用于内存卡的68个脚的I/O连接线路标准。同时增加了插槽使用说明。生产商意识到软件需要提高兼容性，因而这项标准也就得到了相应的应用。</p><p>PCMCIA总线分为两类，一类为16位的PCMCIA，另一类为32位的CardBus。</p><p>CardBus是一种用于笔记本计算机的新的高性能PC卡总线接口标准，就像广泛地应用在台式计算机中的PCI总线一样该总线标准与原来的PC卡标准相比，具有以下的优势:<br>第一是32位数据传输和33MHz操作。CardBus快速以太网PC卡的最大吞量接近90 Mbps，而6位快速以太网PC卡仅能达到20-30 Mbps。第二，总线自主。使PC卡可以独立于主CPU，与计算机内存间直接交换数据，这样CPU就可以处理其它的任务<br>第三，3.3V供电，低功耗。提高了电池的寿命，降低了计算机内部的热扩散，增强了系统的可靠性。<br>第四，后向兼容16位的PC卡。老式以太网和Modem设备的PC卡仍然可以插在CardBus插槽上使用。PCMCIA支持即插即用。</p><p>【PCMCIA总线是一种并行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-12-18.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-33-53.png" alt=""></p><p>USB是在1994年底由英特尔等多家公司联合在1996年推出后，已成功替代串口和并口，已成为当今电脑与大量智能设备的必配接口。USB属于<strong>设备总线</strong>，<strong>是设备和设备控制器之间的接口</strong>。</p><p>USB所有新版本都向下兼容，可以连接鼠标、键盘、打印机、扫描仪、摄像头、充电器、闪存盘、MP3机、手机数码相机、移动硬盘、外置光软驱、USB网卡、ADSL Modem、Cable Modem等几乎所有的外部设备。</p><p>1、可以<strong>热插拔、即插即用</strong>。<br>2、<strong>具有很强的连接能力和很好的可扩充性</strong>。采用菊花链（如下图）形式将多外设连接起来，可使用USB集线器链式<strong>连接127个外设</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-34-06.png" alt=""></p><p>3、<strong>标准统一</strong>。以前大家常见的是IDE接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了USB之后这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了USB硬盘、USB鼠标、USB打印机等等。<br>4、<strong>高速传输</strong><br>5、<strong>连接电缆轻巧，可为低压(5V)外设供电</strong></p><p>【USB总线是一种串行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-38-14.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-38-29.png" alt=""></p><p><strong>差模信号</strong>：如上图，根据2、3的压差来确定1bit数据，差模信号的抗干扰能力很强，因此工作频率可以很高<br>注意: USB 每次只能传输1bit数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-40-29.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-41-46.png" alt=""></p><p>ATA（又叫PATA，parallel）</p><p>Integrated Drive Electronics (电子集成驱动器) 本意是指把“硬盘控制器”与“体”集成在一起的硬盘驱动器。</p><p>用于IDE硬盘的接口最初被称为IDE接口，后来扩展为CD-ROM、磁带机、可移动磁盘、LS-120磁盘等设备的接口。</p><p>硬盘和光驱通过IDE接口与主板连接。</p><p>【IDE总线是一种并行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-41-55.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-47-04.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-43-41.png" alt=""></p><p>Serial ATA即串行高级技术附件，它是一种完全不同于并行ATA的新型硬盘接口类型，由于采用<strong>串行</strong>方式传输数据而知名。是由APT Technologies、DELL、IBM、Intel、Maxtor、Quantum，Seagate等公司合作开发用于取代并行ATA接口技术。</p><p>与并行ATA相比，SATA具有比较大的优势。<br>首先，Serial ATA以连续串行的方式传送数据，可以在较少的位宽下使用较高的工作频率来提高数据传输的带宽Serial ATA一次只会传送1位数据，这样能减少SATA接口的针脚数目，使连接电缆数目变少，效率也会更高。同时还能降低系统能耗，减小系统复杂性。<br>其次，Serial ATA的起点更高、发展潜力更大，Serial ATA 1.0定义的数据传输率可达150MB/sec，这比目前最块的并行ATA(即ATA/133)所能达到133MB/sec的最高数据传输率还高，而在已经发布的Serial ATA 2.0的数护将达到300MB/sec，最终Serial ATA 3.0将实现600MB/sec的最高数据传输率。</p><p>【SATA总线是一种串行总线】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-46-44.png" alt=""></p><hr><ul><li><strong><u>速度对比</u></strong></li></ul><p>画红框考频比较高</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-49-17.png" alt=""></p><hr><ul><li><strong><u>总线标准的发展</u></strong></li></ul><p>趋势：串行总线替代并行总线</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-19-24.png" alt=""></p><hr><ul><li><strong><u>为何串行总线取代并行总线</u></strong></li></ul><p><strong>并行总线</strong>：用m根线每次传送m个比特，用<strong>高/低电平表示1/0</strong>，通常采用同步定时方式，由于线间信号干扰，因此总线<strong>工作频率不能太高</strong>。另外，各条线不能有长度差，长距离并行传输时工艺难度大。</p><p>串行总线：用两根线每次传送一个比特，采用“<strong>差模信号</strong>”<strong>表示1/0</strong>，通常采用异步定时方式，总线<strong>工作频率可以很高</strong>。现在的串行总线通常基于包传输，如80bit为一个数据包，包与包之间有先后关系，因此可以用多个数据通路分别串行传输多个数据包。因此某种程度上现在的串行总线也有“并行”的特点</p><hr><ul><li><strong><u>实例</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-28-42.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_13-28-53.png" alt=""></p><hr><h1>第七章 输入/输出系统</h1><h2 id="7-1-1-输入输出系统和IO控制方式">7.1.1 输入输出系统和IO控制方式</h2><ul><li><strong><u>现代计算机</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-44-26.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-06-05_09-45-23.png" alt=""></p><p>“I/O”就是“输入/输出” (Input/Output)</p><p>I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备</p><hr><ul><li><strong><u>常见的I/O设备</u></strong></li></ul><p>鼠标、键盘——输入设备</p><p>显示器、打印机一一输出设备</p><p>硬盘、光盘一一即可输入、又可输出的设备(有的教材称为：<strong>外存设备</strong>)</p><p>以上可统称“<strong>外部设备</strong>“</p><hr><ul><li><strong><u>主机如何与I/O设备进行交互</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-41-22.png" alt=""></p><p><strong>l/O接口</strong>: 又称<strong>I/O控制器(I/O Controller) 、设备控制器</strong>，负责协调主机与外部设备之间的数据传输</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-35-00.png" alt=""></p><p>I/O控制器多种多样，也会制定相应的标准，如：用于控制USB设备的I/O接口、用于控制SATA3.0硬盘的I/O接口等<br>(I/O控制器就是一块芯片，常被集成在主板上)</p><hr><ul><li><strong><u>I/O控制器（I/O接口）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-36-27.png" alt=""></p><p>现在的I/O接口（芯片）也会被集成在南桥芯片内部</p><hr><ul><li><strong><u>I/O控制方式简介</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-39-25.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;i);# 等待键盘I/O完成</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %c\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据流：键盘→I/O接口的数据寄存器→数据总线→CPU某寄存器→主存(变量i的对应位置)</p><p>CPU如何控制键盘I/O的完成?</p><p>1）<strong>程序查询方式</strong>：CPU不断轮询检查控制器中的“状态寄存器”，检测到状态为“已完成”之后，再从数据寄存器取出输入数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-44-26.png" alt=""></p><p>2）<strong>程序中断方式</strong>：等待键盘I/O时CPU可以先去执行其他程序，键盘I/O完成后I/O控制器向CPU发出中断请求，CPU响应<strong>中断请求</strong>，并取走输入数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-45-06.png" alt=""></p><p>思考：对于快速I/O设备，如“磁盘”，每准备好一个字就给CPU发送一次中断请求，会导致什么问题<br>答：CPU需要花大量的时间来处理中断服务程序，CPU利用率严重下降。</p><hr><ul><li><strong><u>DMA控制方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-45-40.png" alt=""></p><p>DMA：Direct Memory Access，直接内存访问</p><p>DMA控制方式：主存与高速I/O设备之间有条<strong>直接数据通路</strong> (DMA总线)。CPU向DMA接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。<br>DMA控制器自动控制磁盘与主存的数据读写，<strong>每完成一整块数据读写</strong>(如1KB为一整块) ，<strong>才向CPU发出一次中断请求</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-50-33.png" alt=""></p><hr><ul><li><strong><u>通道控制方式</u></strong></li></ul><p>有的商用中型机、大型机可能会接上超多的I/0设备，如果都让CPU来管理，那么CPU就太累了……</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-02-43.png" alt=""></p><p>通道是具有特殊功能的处理器，能对I/O设备进行统一管理。</p><p><strong>通道</strong>：可以理解为是“<strong>弱鸡版的CPU</strong>”。通道可以识别并执行一系列<strong>通道指令</strong>，通道指令种类、功能通常比较单一</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-04-58.png" alt=""></p><hr><ul><li><strong><u>I/O系统的基本组成</u></strong></li></ul><p>一般来说，I/O系统由<strong>I/O软件</strong>和<strong>I/O硬件</strong>两部分构成。</p><ol><li><p>I/O硬件<br>包括输入设备、输出设备、外部设备、I/O接口 、I/O总线等</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-08-08.png" alt=""></p></li><li><p>I/O软件<br>包括驱动程序、用户程序、管理程序、升级补丁等。<br>通常采用I/O指令和通道指令实现主机和I/O设备的信息交换。</p><p>1）I/O指令 CPU指令的一部分<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-09-35.png" alt=""><br>注: I/O 指令与普通指令格式略有不同，操作码指明了CPU要对I/O接口做什么，命令码指明了I/O接公要对设备做什么，设备码指明对哪个设备进行操作。</p><p>2）通道指令 通道能识别的指令</p><p><strong>通道程序</strong>提前编制好<strong>放在主存</strong>中<br>在含有通道的计算机中，CPU执行<strong>I/O指令</strong>对通道发出命令，由通道执行一系列<strong>通道指令</strong>，代替CPU对I/O设备进行管理</p></li></ol><hr><h2 id="7-1-2-外部设备">7.1.2 外部设备</h2><ul><li><strong><u>外部设备</u></strong></li></ul><p>外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。</p><ul><li><strong>输入设备</strong></li></ul><p>用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</p><ul><li><strong>输出设备</strong></li></ul><p>用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机 是最基本的输出设备。</p><ul><li><strong>外存设备</strong></li></ul><p>是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。</p><hr><ul><li><strong><u>输入设备</u></strong></li></ul><p><strong>键盘</strong>是最常用的输入设备，通过它可发出命令或输入数据。 键盘通常以矩阵的形式排列按键，每个键用符号标明它的含义和作用。每个键相当于一个开关，当按下键时，电信号连通； 当松开键时，弹簧把键弹起，电信号断开。</p><p>键盘输入信息可分为3个步骤：<br>①查出按下的是哪个键；<br>②将该键翻译成能被主机接收的编码，如ASCII码；<br>③将编码传送给主机。</p><p><strong>鼠标</strong>是常用的定位输入设备，它把用户的操作与计算机屏幕上 的位置信息相联系。常用的鼠标有机械式和光电式两种。</p><p>工作原理： 当鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应运动。</p><hr><ul><li><strong><u>输出设备——显示器</u></strong></li></ul><p>按显示设备所用的显示器件分类：<br>阴极射线管（CRT）显示器<br>液晶显示器（LCD）<br>LED显示器<br>……</p><p>按所显示的信息内容分类：<br>字符显示器<br>图形显示器<br>图像显示器<br>……</p><p>性能指标：</p><ul><li><p>屏幕大小<br>以对角线长度表示，常用的有12～29英寸等。</p></li><li><p>分辨率<br>所能表示的像素个数，屏幕上的每一个光点就是一个像素，以宽、高的像素的乘积表示，例如，800×600、 1024×768和1280×1024等。</p></li><li><p>灰度级<br>灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚逼真，典型的有8位（256级）、16位等。n位可以表示2n种不同的亮度或颜色。</p></li><li><p>刷新<br>光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。刷新频率：单位时间内扫描整个屏幕内容的次数，按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器刷新频率在60～120Hz。</p></li><li><p>显示存储器（VRAM）<br>也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大</p><p><strong>VRAM容量 = 分辨率 * 灰度级位数</strong><br><strong>VRAM带宽 = 分辨率 * 灰度级位数 * 帧数</strong></p></li></ul><p>VRAM举例:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-34-09.png" alt=""></p><p>1440 * 900 * 3B ≈ 3.7MB（一帧的大小即为显存的<strong>理论最小值</strong>)</p><p>如果显示器刷新率=60Hz，则显存带宽至少要 3.7*60=222MB</p><p>注：现代计算机中，显存除了作为当前显示帧的缓存，还会用于保存即将消边的图像数据。</p><p>集成显卡计算机中，通常分配一片内存作为显存</p><ul><li>阴极射线管（CRT）显示器</li></ul><p>CRT显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极和荧光粉涂 层及玻璃外壳5部分组成。具有可视角度大、无坏点、色彩还原度高、 色度均匀、可调节的多分辨率模式、响应时间极短等<s>目前LCD难以超过</s>（这句话已经跟不上时代了）的优点。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-47-23.png" alt=""></p><ul><li>液晶显示器（LCD）</li></ul><p>原理：利用液晶的电光效应，由图像信号电压直接控制薄膜晶 体管，再间接控制液晶分子的光学特性来实现图像的显示。</p><p>特点：体积小、重量轻、省电、无辐射、绿色环保、画面柔、 不伤眼等。</p><ul><li>LED（发光二极管）显示器</li></ul><p>原理：通过控制半导体发光二极管进行显示，用来显示文字、图 形、图像等各种信息。</p><p>LCD与LED是两种不同的显示技术，LCD是由液态晶体组成的显示屏，而LED则是由发光二极管组成的显示屏。与LCD相比，LED显示器在亮度、功耗、可视角度 和刷新速率等方面都更具优势。</p><hr><ul><li><strong><u>显示器 - 阴极射线管（CRT）显示器</u></strong></li></ul><p>按显示信息内容不同可分为：</p><ul><li>字符显示器。</li></ul><p>显示字符的方法以点阵为基础。<strong>点阵是指由m×n个点组成的阵列</strong>。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕 上所占的点数，它包括字符显示点阵和字符间隔。</p><p>将<strong>点阵存入由ROM构成的字符发生器</strong>中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码不同控制扫描电 子束的开或关，从而在屏幕上显示出字符。对应于每个字符窗口，所需显示<strong>字符的ASCII代码被存放在视频存储器VRAM</strong>中，以备刷新。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-51-18.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_19-51-42.png" alt=""></p><ul><li>图形显示器</li></ul><p>将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中， 缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接 控制电子束在屏幕上的移动。为了在屏幕上保留持久稳定的图像，需要按一 定的频率对屏幕进行反复刷新。 这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器 采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p><ul><li>图像显示器</li></ul><p>现在的电脑手机的显示器</p><p>按扫描方式不同可分为：</p><ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul><hr><ul><li><strong><u>输出设备——打印机</u></strong></li></ul><p>打印机是计算机的输出设备之一，用于将计算机处理结果打印在相关介质上。</p><p>按印字原理不同可分为</p><ul><li><p>击打式打印机：利用机械动作使印字机构与色带和纸相撞而打印字符</p><p>优：<br>设备成本低<br>印字质量好<br>缺：<br>噪声大<br>速度慢</p><p>如：机打发票银行回执单(防伪性好)</p></li><li><p>非击打式打印机：采用电、磁、光、喷墨等物理、化学方法来印刷字符</p><p>优：<br>速度快<br>噪声小<br>缺：<br>成本高（对于现在来说不一定高）</p></li></ul><p>按打印机工作方式不同可分为</p><ul><li>串行打印机：逐字打印 速度慢</li><li>行式打印机：逐行打印 速度快</li></ul><p>按工作方式可分为</p><ul><li><p>针式打印机</p><p>原理：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横 向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</p><p>特点：针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。它工作原理简单，造价低 廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</p></li><li><p>喷墨式打印机</p><p>原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理， 即分别喷射3种颜色墨滴，按一定的比例混合出所要求的颜色。</p><p>特点：打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快；但防水性差，高质量打 印需要专用打印纸。</p></li><li><p>激光打印机</p><p>原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转 印和定影，便在纸上得到所需的字符或图像。</p><p>特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份，且对 纸张的要求高。激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称为硒鼓） 是激光打印机的核心部件。</p></li></ul><hr><h2 id="7-2-I-O接口">7.2 I/O接口</h2><ul><li><strong><u>I/O接口的作用</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-39-25.png" alt=""></p><ul><li>数据缓冲：通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配</li><li>错误或状态监测：通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用</li><li>控制和定时：接收从控制总线发来的控制信号、时钟信号</li><li>数据格式转换：串-并、并-串 等格式转换</li><li>与主机和设备通信：实现 主机—I/O接口—I/O设备 之间的通信</li></ul><hr><ul><li><strong><u>I/O接口</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_20-20-09.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_20-23-24.png" alt=""></p><p>内部接口：内部接门与系统总线相连，实质上是与内存、CPU相连。数据的传输方式<s>只能是并行传输</s>(已过时)。</p><p>外部接口：外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此I/O接口需具有串/并转换功能。</p><p>①发命令：发送<strong>命令字</strong>到/0控制寄存器，向设备发送命令（需要驱动程序的协助)<br>②读状态：从状态寄存器读取<strong>状态字</strong>，获得设备或I/O控制器的状态信息<br>③读/写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换</p><p><strong>控制寄存器、状态寄存器</strong>在使用时间上是错开的，因此有的I/O接口中<strong>可将二者合二为一</strong></p><p>lO控制器中的各种寄存器称为<strong>I/O端口</strong></p><p>数据线：读写数据、状态字、控制字、中断类型号（有的教材也把命令字称为控制字）</p><p>地址线：指明I/O端口</p><p>控制线：读/写IO端口的信号、中断请求信号</p><p>如何确定要操作的设备?<br>有的计算机每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备</p><hr><ul><li><strong><u>接口与端口</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_20-28-30.png" alt=""></p><p>I/O端口是指接口电路中可以被CPU直接访问的寄存器</p><p>如何访问I/O端口?<br>I/O端口要想能够被CPU访问，必须要有端口地址，每一个端口都对应着一个端口地址。</p><hr><ul><li><strong><u>统一编址v.s.独立编址</u></strong></li></ul><p>统一编址：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_20-40-00.png" alt=""></p><p>靠不同的<strong>地址码</strong>区分内存和I/O设备。访存类的指令都可以访问<strong>I/O端口</strong><br>(RISC机器常用)</p><p>独立编址：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_20-40-06.png" alt=""></p><p>靠不同的<strong>指令</strong>区分内存和I/O设备。只能用专门的<strong>I/O指令</strong>访问<strong>I/O端口</strong><br>(Intel处理器常用，IN、OUT就是IO指令)</p><hr><ul><li><strong><u>I/O端口及其编址</u></strong></li></ul><ol><li>统一编址</li></ol><p>把I/O端口当做存储器的单元进行地址分配，用统一的<strong>访存指令</strong>就可以访问I/O端口，又称<strong>存储器映射方式</strong>。</p><p>靠不同的<strong>地址码</strong>区分内存和I/O设备，I/O地址要求相对固定在地址的某部分</p><p>如系统总线中地址线共10根，则可以访问的存储单元个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>=1024个，假设要给10个I/O端口编址：<br>1、0～9表示I/O地址，10～1023为主存单元地址<br>2、0～1013表示I/O地址，1014～1023为主存单元地址<br>3、10～19表示I/O地址，0～9、20～1023为主存单元地址</p><p>优点：<br>不需要专门的输入/输出指令，可使CPU访问I/O的操作更灵活、更方便，还可使端口有较大的编址空间。</p><p>缺点：<br>端口占用了存储器地址，使内存容量变小，而且，利用存储器编址的I/O设备进行数据输入/输出操作，执行速度较慢。</p><ol start="2"><li>独立编址</li></ol><p>I/O端口地址与存储器地址无关，独立编址CPU需要设置<strong>专门的输入/输出指令</strong>访问端口，又称<strong>I/O映射方式</strong>。</p><p>靠不同的<strong>指令</strong>区分内存和I/O设备。</p><p>优点：<br>输入/输出指令与存储器指令有明显区别， 程序编制清晰，便于理解。</p><p>缺点：<br>输入/输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制的复杂性。</p><hr><ul><li><strong><u>I/O接口的类型</u></strong></li></ul><p>按数据传送方式可分为</p><ul><li>并行接口：一个字节或一个字所有位同时传送。</li><li>串行接口：一位一位地传送。</li></ul><p>注：这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧， 数据<strong>总是并行传送的</strong>（已过时）。接口要完成数据格式转换。</p><p>按主机访问I/O设备的控制方式可分为</p><ul><li>程序查询接口</li><li>中断接口</li><li>DMA接口</li></ul><p>按功能选择的灵活性可分为</p><ul><li>可编程接口</li><li>不可编程接口</li></ul><hr><h2 id="7-3-1-程序查询方式">7.3.1 程序查询方式</h2><ul><li><strong><u>I/O方式简介</u></strong></li></ul><p>程序查询方式：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-44-26.png" alt=""></p><p>程序中断方式：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-45-06.png" alt=""></p><p>DMA方式：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-50-33.png" alt=""></p><hr><ul><li><strong><u>程序查询方式</u></strong></li></ul><p>模拟打印3个字符“abc”</p><p>x86中的IO指令实例<br>IN Rd, Rs：把IO端口Rs 的数据输入到CPU寄存器 Rd<br>OUT Rd, Rs：把CPU寄存器 Rs 的数据输出到IO端口 Rd</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_23-08-50.png" alt=""></p><hr><ul><li><strong><u>程序查询方式流程图</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_23-25-12.png" alt=""></p><p>优点：接口设计简单、设备量少。<br>缺点：CPU在信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率大大降低。</p><hr><ul><li><strong><u>程序查询方式-例题</u></strong></li></ul><p>在程序查询方式的输入/输出系统中，假设不考虑处理时间，每一个查询操作需要100个时钟周期， CPU的时钟频率为50MHz。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输率为2×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>B/s。求CPU对这两个设备查询所花费的时间比率，由此可得出什么结论？</p><p>时间的角度：<br>一个时钟周期为 1/50MHz = 20ns<br>一个查询操作耗时 100 × 20ns = 2000ns<br>1)鼠标<br>每秒查询鼠标耗时 30 × 2000ns = 60000ns<br>查询鼠标所花费的时间比率 = 60000ns/1s = 0.006%<br>对鼠标的查询基本不影响CPU的性能<br>2)硬盘<br>每32位需要查询一次，每秒传送2×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>B<br>每秒需要查询(2×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>B)/32 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>19</mn></msup></mrow><annotation encoding="application/x-tex">2^{19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span></span></span></span>次<br>查询硬盘耗时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>19</mn></msup></mrow><annotation encoding="application/x-tex">2^{19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span></span></span></span>× 2000n = 512 × 1024 × 2000ns<br>≈ 1.05×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span><br>查询硬盘所花费的时间比率 = (1.05× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span> ns)/1s = 105%<br>CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求</p><p>频率的角度：<br>CPU的时钟频率为50MHz，即每秒50× 106 个时钟周期<br>1)鼠标<br>每秒查询鼠标占用的时钟周期数 30 × 100 = 3000<br>查询鼠标所花费的时间比率 = 3000/(50× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> ) = 0.006%<br>对鼠标的查询基本不影响CPU的性能<br>2)硬盘<br>每秒需要查询(2×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>B)/32 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>19</mn></msup></mrow><annotation encoding="application/x-tex">2^{19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span></span></span></span>次<br>每秒查询硬盘占用的时钟周期数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>19</mn></msup></mrow><annotation encoding="application/x-tex">2^{19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span></span></span></span>× 100≈ 5.24×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span><br>查询硬盘所花费的时间比率 = (5.24×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span> )/(50× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> ) ≈ 105%<br>CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求</p><hr><ul><li><strong><u>本节回顾</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-12_18-44-26.png" alt=""></p><p>CPU一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序</p><p>主要特点：CPU有“踏步”等待现象，CPU与I/O串行工作。</p><p>优点：接口设计简单、设备量少。<br>缺点：CPU在信息传送过程中要花费很多时间用于查询和等待，而且如果采用独占查询，则在一段时间内只能和一台外设交换信息，效率大大降低。</p><p><strong>独占查询</strong>：CPU 100%的时间都在查询I/O状态，完全串行（如上图）<br><strong>定时查询</strong>：在保证数据不丢失的情况下，每隔一段时间CPU就查询一次I/O状态。查询的间隔内CPU可以执行其他程序</p><hr><h2 id="7-3-2-中断的作用和原理">7.3.2 中断的作用和原理</h2><ul><li><strong><u>中断的基本概念</u></strong></li></ul><p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂 时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-46-16.png" alt=""></p><p>工作流程：</p><ol><li>中断请求<ul><li>中断源向CPU发送中断请求信号。</li></ul></li><li>中断响应<ul><li>响应中断的条</li><li>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。</li></ul></li><li>中断处理<ul><li>中断隐指令。</li><li>中断服务程序。</li></ul></li></ol><hr><ul><li><strong><u>中断请求的分类</u></strong></li></ul><p>看操作系统的第一章</p><p>外中断（也称中断）【狭义的中断】</p><ul><li>非屏蔽中断：关中断(中断标志位IF=0)时也会被响应</li><li>可屏蔽中断：关中断时不会被响应</li></ul><p>IF：Interrupt Flag，存在PSW中，8086芯片的PSW如下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-49-54.png" alt=""></p><p>关中断的作用：实现原子操作<br>开中断 IF=1 允许中断<br>关中断 IF=0 不允许中断</p><hr><ul><li><strong><u>中断请求标记</u></strong></li></ul><p>每个中断源向CPU发出中断请求的时间是随机的。</p><p>为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置<strong>中断请求标记触发器INTR</strong>， 当其状态为“1”时，表示中断源有请求。</p><p>这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-53-32.png" alt=""></p><p>对于<strong>外中断</strong>，CPU是在统一的时刻即<strong>每条指令执行阶段结束前</strong>向接口<strong>发出中断查询信号</strong>【对于执行时间很长 的指令，可在执行 过程中设置若干个 “查询断点”】， 以获取I/O的中断请求，也就是说，<strong>CPU响应中断的时间</strong>是在<strong>每条指令执行阶段的结束时刻</strong>。<br>CPU响应中断必须满足以下3个条件：<br>① 中断源有中断请求。<br>② CPU允许中断即开中断。<br>③ 一条指令执行完毕，且没有更紧迫的任务。</p><hr><ul><li><strong><u>中断判优-实现</u></strong><br>有多个中断信号同时到来，先处理哪个?</li></ul><p>中断判优既可以用硬件实现，也可用软件实现：<br>硬件实现是通过<strong>硬件排队器</strong>实现的，它既可以设置在CPU中，也可以分散在各个中断源中；<br>软件实现是通过<strong>查询程序</strong>实现的。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-56-18.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-56-56.png" alt=""></p><hr><ul><li><strong><u>中断判优-优先级设置</u></strong></li></ul><p>1、硬件故障中断属于最高级，其次是软件中断（系统调用）；</p><p>2、非屏蔽中断优于可屏蔽中断；</p><p>3、DMA请求优于I/O设备传送的中断请求；</p><p>4、高速设备优于低速设备；</p><p>5、输入设备优于输出设备；</p><p>6、实时设备优于普通设备</p><hr><ul><li><strong><u>中断处理过程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-46-16.png" alt=""></p><p>由K地址开始，当前指令执行结束 后，PC内容为K+1<br>进入中断服务程序的方法是把该程序第一条指令的地址放入PC<br>回到主程序的方法是把K+1放入PC</p><p>软件无法完成保存PC的任务，应由硬件实现：<strong>中断隐指令</strong><br>中断隐指令：保存原程序的PC值，并让PC指向中断服务程序的第一条指令</p><hr><ul><li><strong><u>中断处理过程-中断隐指令</u></strong></li></ul><p>中断隐指令的主要任务：<br>① <strong>关中断</strong>。<br>在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</p><p>② <strong>保存断点</strong>。<br>为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。 可以存入堆栈，也可以存入指定单元。</p><p>③ <strong>引出中断服务程序</strong>。<br>引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。</p><p>那么怎么知道中断服务程序的入口地址呢：软件查询法、<strong>硬件向量法</strong></p><hr><ul><li><strong><u>中断处理过程-硬件向量法</u></strong></li></ul><p>由 <strong>硬件</strong> 产生 <strong>向量地址</strong> 再由 <strong>向量地址</strong> 找到 <strong>入口地址</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-13-25.png" alt=""></p><hr><ul><li><strong><u>中断处理过程-中断服务程序</u></strong></li></ul><p>中断服务程序的主要任务：<br>① <strong>保护现场</strong><br>一是保存程序断点(PC)，已由中断隐指令完成；<br>二是保存通用寄存器和状态寄存器的内容，由中断服务程序完成。 可以使用堆栈，也可以使用特定存储单元。</p><p>② <strong>中断服务(设备服务)</strong><br>主体部分，如通过程序控制需打印的字符代码送 入打印机的缓冲存储器中。</p><p>③ <strong>恢复现场</strong><br>通过出栈指令或取数指令把之前保存的信息送回 寄存器中。</p><p>④ <strong>中断返回</strong><br>通过中断返回指令回到原程序断点处。</p><hr><ul><li><strong><u>总结: 中断处理过程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-21-42.png" alt=""></p><p><strong>单重中断</strong>：执行中断服务程序时不响应新的中断请求。 （本节内容）</p><p>多重中断：又称中断嵌套，执行中断服务程序时可响 应新的中断请求。</p><hr><h2 id="7-3-3-多重中断">7.3.3 多重中断</h2><ul><li><strong><u>单重中断与多重中断</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-46-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-47-02.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-48-33.png" alt=""></p><hr><ul><li><strong><u>中断屏蔽技术</u></strong></li></ul><p>中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件。<br>① 在中断服务程序中提前设置开中断指令。<br>② 优先级别高的中断源有权中断优先级别低的中断源。<br>每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-56-18.png" alt=""></p><p>硬件排队器是收到多个中断请求时，只响应其中一个固定优先级</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-51-10.png" alt=""></p><p>中断屏蔽是调整多重中断的优先级</p><p>屏蔽字设置的规律：</p><ol><li>一般用‘1’表示屏蔽，’0’表示正常申请。</li><li>每个中断源对应一个屏蔽字(在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字)。</li><li>屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个’1’(至少要能屏蔽自身的中断)。</li></ol><p>【例题】设某机有4个中断源A、B、C、D，其硬件排队优先次序为A&gt;B&gt;C&gt;D，现要求将中断处理次序改为D&gt;A&gt;C&gt;B。<br>1）写出每个中断源对应的屏蔽字。<br>2）按下图所示的时间轴给出的4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断服 务程序时间均为20us。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-57-10.png" alt=""></p><p>【解】<br>1）<br>中断源A的屏蔽字为1110<br>中断源B的屏蔽字为0100<br>中断源C的屏蔽字为0110<br>中断源D的屏蔽字为1111</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-58-02.png" alt=""></p><p>2）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_09-59-27.png" alt=""></p><hr><ul><li><strong><u>扩展（了解一哈）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_10-04-25.png" alt=""></p><p>IF：Interrupt Flag，存在PSW中，8086芯片的PSW如下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_08-49-54.png" alt=""></p><p><strong>IF</strong>(Interrupt Flag)开/关中断标志。<br>当IF=1时，表示开中断，当IF=0时表示关中断</p><p><strong>INTR</strong>：可屏蔽中断请求 (interrupt request)信号，输入，用来申请一个硬件中断。当IF=1时，若INTR 保持高电平，则在当前指令执行完毕后就进入中断响应周期</p><p><strong>NMI</strong>：非屏蔽中断 (non-maskable interrupt)输入信号。与INTR信号类似，但NMI中断不必检查IF标志位是否为1。常用于处理电源掉电紧急情况。</p><p><strong>INTA</strong>：中断响应 (interrupt acknowledge)信号，输出。响应INTR 输入。该引脚常用来选通中断向量码以响应中断请求</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_10-08-36.png" alt=""></p><hr><h2 id="7-3-4-程序中断方式">7.3.4 程序中断方式</h2><ul><li><strong><u>程序中断方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_10-12-42.png" alt=""></p><p>【例题】假定CPU主频为50MHz，CPI为4。设备D采用异步串行通信方式向主机传送7位ASCII字符，通信规程中有1位奇校验位和1位停止位，从D接收启动命令到字符送入I/O端口需要0.5ms。请回答下列问题，要求说明理由。<br>1）每传送一个字符，在异步串行通信线上共需传输多少位？在设备D持续工作过程中，每秒钟最多可向I/O端口送入多少个字符？<br>2）设备D采用中断方式进行输入/输出，示意图如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_10-23-24.png" alt=""></p><p>I/O端口每收到一个字符申请一次中断，中断响应需10个时钟周期，中断服务程序共有20条指令，其中第15 条指令启动D工作。若CPU需从D读取1000个字符，则完成这一任务所需时间大约是多少个时钟周期？CPU用于完成这一任务的时间大约是多少个时钟周期？在中断响应阶段CPU进行了哪些操作？</p><p>【解】</p><p>1）至少包含1位起始位和1位停止位，停止位可能有多位。 每传送一个字符需要传送1位起始位、7位数据位、 1位校验位、1位停止位，共需传送10位。 每0.5ms可送入1个字符 每秒可送入 1s/0.5ms = 2000 个字符</p><p>2）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_10-23-42.png" alt=""></p><p>主频50MHz，时钟周期为 1/50MHz = 20ns<br>0.5ms对应时钟周期数为 0.5ms/20ns = 25000<br>传送1个字符需要的时钟周期数为 25000 + 10 + 15×4 = 25070<br>传送1000个字符需要的时钟周期数为 25070×1000 = 25070000</p><p>CPU用于该任务的时间大约为 1000×(10+20×4)= 9×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 个时钟周期</p><p>中断隐指令：<br>1、关中断 2、保存断点(PC) 3、引出中断服务程序</p><hr><h2 id="7-3-5-DMA方式">7.3.5 DMA方式</h2><ul><li><strong><u>DMA控制器</u></strong></li></ul><p>对于程序中断方式：<br>每准备好一个数据都要中断CPU，由CPU运行中断服务程序来完成一次传送磁盘机、磁带机等高速设备需要大批量的数据传送 → CPU大量时间用于中断服务<br>由硬件实现控制大批量的数据传送 → DMA控制器</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-14-04.png" alt=""></p><p>在DMA方式中，当I/O设备需要进行数据传送时，通过DMA控制器(DMA接口)向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能有：</p><p>传送前：<br>1）接受外设发出的DMA请求，并向CPU发出总线请求。<br>2）CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。</p><p>传送时：<br>3）确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。<br>4）规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p><p>传送后：<br>5）向CPU报告DMA操作的结束</p><hr><ul><li><strong><u>DMA控制器</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-20-50.png" alt=""></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>控制/状态逻辑</td><td>由控制和时序电路及状态标志组<br />成，用于指定传送方向，修改传<br />送参数，并对DMA请求信号和<br />CPU响应信号进行协调和同步</td></tr><tr><td>DMA请求触发器</td><td>每当I/O设备准备好数据<br />后给出一个控制信号，<br />使DMA请求触发器置位。</td></tr><tr><td>数据缓冲寄存器</td><td>用于暂存每次传送的数据。</td></tr><tr><td>传送长度计数器</td><td>简称WC，用来记录传<br />送数据的长度，计数<br />溢出时，数据即传送<br />完毕，自动发中断请<br />求信号。</td></tr><tr><td>主存地址计数器</td><td>简称AR，存放要交<br />换数据的主存地址。</td></tr><tr><td>中断机构</td><td>当一个数据块传送完毕后触发中<br />断机构，向CPU 提出中断请求。</td></tr></tbody></table><p>注：在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。</p><hr><ul><li><strong><u>DMA传送过程</u></strong></li></ul><p>以数据输入为例</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-30-41.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-32-07.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-29-53.png" alt=""></p><hr><ul><li><strong><u>DMA方式的特点</u></strong></li></ul><p>换一种总线连接方式（之前提到的三总线）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-11_23-45-40.png" alt=""></p><p>主存和DMA接口之间有一条直接数据通路。<br>由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，<strong>I/O与主机并行工作，程序和传送并行工作</strong>。</p><p>DMA方式具有下列特点:<br>① 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。<br>② 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。<br>③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。<br>④ DMA传送速度快，CPU和外设并行工作，提高了系统效率。<br>⑤ DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><p>教材很乱，有的单总线，有的三总线</p><p>这种结构可能出现CPU和DMA控制器同时想要访问主存的情况，怎么解决？</p><hr><ul><li><strong><u>DMA传送方式</u></strong></li></ul><p>主存和DMA控制器之间有一条数据通路，因此主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方法使用主存。</p><p>（1）停止CPU访问主存</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-50-44.png" alt=""></p><p>优点：<br>控制简单<br>缺点：<br>CPU 处于不工作状态或保持状态<br>未充分发挥 CPU 对主存的利用率</p><p>（2）DMA与CPU交替访存</p><p>如下图，一个CPU周期，分为C1 和C2 两个周期<br>C1专供DMA访存<br>C2专供CPU访存</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-51-26.png" alt=""></p><p>优点：<br>不需要总线使用权的申请、建立和归还过程<br>缺点：<br>硬件逻辑更为复杂</p><p>（3）周期挪用(周期窃取)（周期—存取周期）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-51-42.png" alt=""></p><p>DMA 访问主存有三种可能:<br>CPU 此时不访存（不冲突）<br>CPU 正在访存（存取周期结束让出总线）<br>CPU 与 DMA 同时请求访存（<strong>I/O访存优先</strong>）</p><hr><ul><li><strong><u>DMA方式与中断方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-13_11-46-19.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程JLU</title>
      <link href="/2023/05/06/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/06/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>一、计算机游戏概述</h1><ul><li><strong><u>游戏编程</u></strong></li></ul><p>通过本课程的学习，使学生了解计算机游戏编程的基本方法，掌握游戏编程的<strong>基本理论</strong>和<strong>基本技能</strong>， 能够独立编程设计实现二维游戏，了解三维游戏涉及的相关知识，培养学生应用理论知识分析解决与游戏编程相关的实际问题的能力，为今后在相关的领域的深入学习和应用开发打下基础</p><hr><h2 id="计算机游戏及其分类">计算机游戏及其分类</h2><p>计算机游戏的<strong>定义</strong>： 从游戏技术上看计算机游戏是以计算机为操作平台，通过<strong>人机互动</strong>形式实现的，能够体现当前计算机技术较高水平的一种<strong>娱乐方式</strong>。</p><p>第9艺术： 有人把游戏称为继绘画、雕刻、建筑、 音乐、诗歌（文学）、舞蹈、戏剧、 电影之后的人类历史上的第9种艺术。</p><p><strong>游戏类型</strong>【按照是否需要<strong>服务器支持</strong>分类】</p><ul><li>网络游戏<ul><li>客户端网络游戏</li><li>网页游戏</li><li>移动端网络游戏</li></ul></li><li>单机游戏</li></ul><p><strong>网络游戏</strong>：英文名称为Online Game，又被 称为 “在线游戏”，简称“网游”。通常以个人电脑（PC）、平板电脑、智能手机等载体为游戏平台，以<strong>游戏运营商服务器为处理器</strong>，以互联网为数据传输媒介，必须通过广域网网络传输方式（Internet、移动互联 网、广电网等）实现多个用户同时参与的游戏产品，以通过对于游戏中人物角色或者场景的操作实现娱乐、交流为目的的游戏方式， 具有可持续性的个体性多人在线游戏。</p><p><strong>客户端网络游戏</strong>：客户端网络游戏 是网络游戏的形式之一，是需要在电 脑上安装游戏客户端软件才能运行的 游戏。国内的客户端网络游戏主要有 大型角色扮演类网络游戏（MMORPG） 和休闲客户端网络游戏。</p><p>游戏<strong>客户端</strong>，是指与游戏服务器相 对应，为客户提供本地服务的程序。 一般安装在普通的用户电脑上，需要与游戏<strong>服务端</strong>互相<strong>配合</strong>运行。服务端是为游戏数据库服务的，而客户端就是游戏数据使用端。几乎现在任何网络游戏都有其客户端，用来连接服务端为玩家服务。</p><p><strong>网页游戏</strong>：网页游戏是用户可以直接通过互联网浏览器玩的网络游戏， 它不需要安装任何客户端软件。网页游戏又称无端游戏、Web Game，简称 “页游” 。【《传奇》，是兄弟，来砍我】</p><p><strong>移动端网络游戏</strong>：指的是运行在移动终端上的网络游戏，是以移动互联网为传输媒介，以<strong>游戏运营商服务器和用户手持设备</strong>为处理终端，以移动支付为支付渠道， 以<strong>游戏移动客户端软件为信息交互窗口</strong>的多人在线游戏方式。其与电脑形式近似， 可以实现娱乐、休闲、交流和取得虚拟成就的功能。【《绝地求生》《刺激战场》】</p><p>单机游戏：单机游戏以独立的个人电脑 （PC）软硬件设备为依托，主要供单人或利用网络IPX/SPX协议、TCP/IP协议或者UDP协议，供有限数量的用户在局域网中玩的游戏。【《Human fall flat》】</p><p><strong>游戏类型</strong>【按照<strong>内容</strong>分类】</p><ul><li>动作游戏（ACT）</li><li>社交游戏</li><li>棋牌类游戏</li><li>MMORPG</li><li>休闲游戏</li><li>角色扮演（RPG）</li><li>第一人称射击（FPS）</li><li>冒险游戏（AVG）</li><li>策略游戏（SLG）</li><li>运动游戏（SPT）</li></ul><p><strong>社交游戏</strong>：也是网络游戏的一种形式， 英文全称为Social Game，指的是一种运 行在社会性网络服务(SNS)社区内，通过互动娱乐方式增强人与人之间社交游戏交流的网络游戏。社交游戏的特点是互动性强、简单易玩容易上手、以趣味休闲的内容为主，网民参与度高。社交游戏种类繁 多，已经成为大多数网民重要的网络休闲方式之一。【《VRChat》】</p><p><strong>MMORPG</strong>：MMORPG即大型多人在线角色扮演类游戏，<strong>MMORPG客户端网络游戏是客户端网络游戏的类型之一</strong>。指的是使所有的用户都存在于一个大的虚拟世界中，用户可以使用拥有不同特点的角色体验虚拟生活，游戏本身是持续发展的。<br>通常用户创造和操控一个游戏主角，游戏主角通过赢得战斗、完成任务累积一定的经验值（Experience）后提升等级，获得金钱和高级装备，同时游戏主角学习到新的魔法和技能，属性（Attribute）增强， 能力由弱变强，用户融入游戏情节中，视自己的角色为游戏故事的一部分。【《魔兽世界》】</p><p><strong>休闲游戏</strong>：这里所指的休闲游戏，大都 是采用平台竞技方式进行，游戏以“<strong>局</strong>” 的形式存在，每局游戏参与的用户数量相对较少。 一局游戏在一段时间内结束， 此类游戏以纯粹娱乐为主，不强调剧情。 通常游戏用户不需要为玩游戏而付费，但 游戏中的虚拟物品需要花钱购买。【《跑跑卡丁车》】</p><p><strong>棋牌类游戏</strong>：与平台对战网络游戏类似， 该种游戏也以平台为基础，但表现方式会根 据游戏形式的不同而有所区别。比如客户端网络游戏中棋牌类游戏往往从平台自身下载， 无需单独的购买单机游戏就可以体验，内容也多以棋牌等小型互动游戏为主。网页游戏中的棋牌类游戏具有无需下载，打开网络浏览器即可直接游戏的特性。移动网络游戏则根据移动智能终端的特点决定游戏的特性。【《欢乐斗地主》】</p><p><strong>动作游戏</strong>：动作游戏一般多为不需要服务器的单机游戏，以操纵人物行动（主要 是战斗）为主要操作模式，相比于目标用户较广的网络游戏，动作游戏基本上具有较高的计算机配置要求。同时，动作游戏一般在渲染，镜头设计，游戏的感官体验这些方面都具有比较出色的表现。【ARPG（动作游戏+RPG）《只狼》】</p><p><strong>RPG</strong>：RPG（Role Play Game）一般和动作游戏会产生一定的重合性，所以也有很多游戏称为ARPG，RPG相比严格的动作游戏，剧情成为更加重要的因素，而一般的动作游戏在战斗这一环节会更下功夫。【《巫师 3》】</p><hr><h2 id="计算机游戏产业发展">计算机游戏产业发展</h2><p>站在国内游戏的视角来说</p><p><strong>培育期</strong>：（20世纪末-2004）</p><ul><li><p>主要为运营型企业</p></li><li><p>以产品代理为主</p></li><li><p>开始品牌竞争</p></li></ul><p>2001年网游：石器时代<br>2002：精灵<br>2002：大话西游2<br>2002：泡泡堂<br>2003：凯旋<br>2003：传奇3<br>2003：《传奇世界》<br>2003：梦幻西游</p><p><strong>起步期</strong>：（2004-2005）</p><ul><li>大量运营商出现</li><li>出现自主研发企业</li><li>以MMORPG为主导产品</li><li>品牌竞争加剧</li><li>计时收费模式为主</li></ul><p>2004：冒险岛<br>2004：QQ堂<br>2004：魔兽世界<br>2005：街头篮球</p><p><strong>快速发展期</strong>：（2005-2011）</p><ul><li>自主研发超越进口，并开始出口海外</li><li>研发型企业不断涌现</li><li>MMORPG仍为主流</li><li>网页游戏、手机游戏等开始出现</li><li>道具收费等新兴收费模式开始出现</li></ul><p>2006：龙与地下城<br>2006：诛仙<br>2007：防沉迷系统<br>2008：QQ飞车<br>2008：穿越火线<br>2009：剑网3</p><p><strong>稳定发展期</strong>：（2011-2015）</p><ul><li>市场竞争格局趋于稳定</li><li>细分市场稳定，网页游戏及移动游戏开始成熟</li><li>行业进入壁垒提高</li><li>游戏题材极大丰富</li><li>道具收费成为主流收费模式</li></ul><p>2011：英雄联盟<br>2014：炉石传说<br>2015：天涯明月刀</p><p><strong>手机游戏快速发展期</strong>：（2015-2020）：</p><ul><li>智能手机大范围普及</li><li>手机游戏用户超越PC端游戏，成为国内游戏产业的最大市场</li><li>大量优质的手机游戏涌现，创造了一些用户上千万甚至上亿级的手机游戏</li></ul><p>2015：王者荣耀<br>2017：荒野行动</p><p><strong>VR游戏发展初期</strong>：（2016-2020）<br>2018：Beat Saber<br>2019：皇牌空战7: 未知空域</p><hr><h2 id="游戏引擎">游戏引擎</h2><p><strong>游戏引擎</strong>是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。这些系统为游戏设计者提供编写游戏所需的各种工具，其目的在于让游戏设计者能容易和快速地做出游戏而不用由零开始。大部分都支持多种操作平台，如Linux、Mac OS X、Windows。</p><p>游戏引擎包含以下<strong>系统</strong>：渲染引擎（即 “渲染器”，含二维图像引擎和三维图像引擎）、物理引擎、碰撞检测系统、音效、 脚本引擎、电脑动画、人工智能、网络引擎以及场景管理。</p><p>一些常见游戏引擎:<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_16-25-09.png" alt=""></p><p><strong>动画</strong>，游戏所采用的动画系统可以分为两种：一是骨骼动画系统，一是模型动画系统。前者用内置的骨骼带动物体产生运动，比较常见；后者则是在模型的基础上直接进行变形。引擎把这两种动画系统预先植入游戏， 方便动画师为角色设计丰富的动作造 型。</p><p><strong>物理系统</strong>，可以使物体的运动遵循固定的规律，例如，当角色跳起的时候，系统内定的重力值将决定他能跳多高，以及他下落的速度有多快。子弹的飞行轨迹、车辆的颠簸方式也都是由物理系统决定的。</p><p><strong>渲染</strong>是引擎最重要的功能之一，当3D模型制作完毕之后，美工会按照不同的面把材质贴图赋予模型，这相当于为骨骼蒙上皮肤，最后再通过渲染引擎把模型、动画、 光影、特效等所有效果实时计算出来并展示在屏幕上。渲染引擎在引擎的所有部件当中是最复杂的，它的强大与否直接决定着最终的输出质量。</p><p><strong>引擎</strong>相当于游戏的框架，框架搭好后，关卡设计师、建模师、动画师只要往里填充内容就可以了。因此，在3D游戏的开发过程中，引擎的制作往往会占用非常多的 时间。<br>正是出于节约成本、缩短周期和降 低风险这三方面的考虑，越来越多的开发者倾向于使用第三方的现成引擎制作自己的游戏，一个庞大的引擎授权市场已经形成。</p><ul><li><strong><u>引擎发展史</u></strong></li></ul><p>1992年，3D ID Software发布了一款只有2兆多的小游戏——《德军司令部》 （Wolfenstein 3D），这部游戏开创了第一人称射击游戏的先河，更重要的是，它在X轴和Y轴的基础上增加了一根Z轴，在由宽度和高度构成的平面上增加了一个向前向后的纵深空间，这根Z轴对那些看惯了2D游戏的玩家造成的巨大冲击可想而知。</p><p>约翰·卡马克，ID Software的创始人之一</p><p>引擎诞生初期的另一部重要游戏同样是出自ID Software公司的一款非常成功的第 一人称射击游戏——《毁灭战士》 （Doom）。Doom引擎在技术上大大超越 了Wolfenstein 3D引擎。</p><p>在引擎的进化过程中，肯·西尔弗曼于 1994年为3D Realms公司开发3D游戏引擎的Build引擎是一个重要的里程碑，Build引擎的“肉身”就是那款家喻户晓的《毁灭公爵》（Duke Nukem 3D）。</p><p>一年之后，ID Software公司推出《雷神之锤2》，一举确定了自己在3D引擎市场 上的霸主地位。《雷神之锤2》采用了一 套全新的引擎，可以更充分地利用3D加速 和OpenGL技术，在图像和网络方面与前作相比有了质的飞跃，当时相当多的游戏都采用了Quake II引擎。</p><p>1998年，正当Quake II独霸整个引擎市场的时候，Epic Megagames公司（即Epic 游戏公司）的《虚幻》（Unreal）问世了。 游戏中的许多特效即便在今天看来依然很出色，荡漾的水波，美丽的天空，庞大的关卡，逼真的火焰、烟雾和力场等效果。 时至今日，虚幻引擎的图形渲染效果仍旧是业界首屈一指的。</p><p>曾获得无数大奖的《半条命》采用的是 Quake和Quake II引擎的混合体，Valve公司在这两部引擎的基础上加入了两个很重要的特性：一是<strong>脚本序列技术</strong>，这一技术可以令游戏以合乎情理的节奏通过触动事件的方式让玩家真实地体验到情节的发展， 这对于诞生以来就很少注重情节的第一人称射击游戏来说无疑是一次伟大的革命；<br>第二个特性是对<strong>人工智能引擎</strong>的改进， 敌人的行动与以往相比明显有了更多的狡诈，不再是单纯地扑向枪口。这两个特点赋予了《半条命》引擎鲜明的个性，在此基础上诞生的《军团要塞》、《反恐精英》 和《毁灭之日》等优秀作品又通过网络代码的加入令《半条命》引擎焕发出了更为夺目的光芒。</p><p>在人工智能方面真正取得突破的游戏是1998年发行的Looking Glass工作室的《神偷：暗黑计划》，游戏的故事发生在中古年代，玩家扮演一名盗贼，任务是进入不同的场所，在尽量不引起别人注意的情况下窃取物品。<br>《神偷》采用的是Looking Glass工作室自行开发的Dark引擎，Dark引 擎在图像方面比不上《雷神之锤2》 或《虚幻》，但在人工智能方面它的水准却远远高于后两者。</p><p><strong>Unity与UE</strong>：而发展到今天，虚幻4 (UE4) 和 Unity是目前市场上最热门的游戏引擎，也各自拥有为数众多的开发者。 在巨大的市场需求下，独立开发者与游戏工作室仍需要一款优秀的引擎来支持项目的开发，如何选择一款适合自己的引擎是开发者最需要考虑的问 题。</p><p><strong>Unity</strong>适合小团队制作，甚至是独立制作， 主要趋向是手游(目前Unity仍然是手游市场占有率最高的引擎)，而虚幻4适合大团队制作、大制作，主要趋向是PC平台和家用机。Unity5增强了光影渲染，使得整体效果有了长足进步，已经开始逼近虚幻的步伐。虚幻的强大自然不用说，但是他的强大需要硬件的付出支持，玩家要有配置强大的PC，或者在<a href="https://baike.baidu.com/item/%E6%AC%A1%E4%B8%96%E4%BB%A3/536193">次世代（日语衍生词汇）</a>家用上才能体验到虚幻的震撼。</p><p><strong>Unreal Engine4</strong>：虚幻引擎4则凭借其更棒的画质和更新更酷的VR技术赢得了许多人的支持，自从虚幻引擎4宣告免费下载后，该引擎至今已聚集了不下750万名开发者用户。实际上，Gear VR 上风评最佳的游戏之一，CCP Games工作室 2015年出品的《Gunjack》(《炮火杰克》)就 是移动端VR上最早采用虚幻引擎4开发的VR游戏之一。【《Explore En Garde》】<br>虚幻4引擎开始就瞄准了高端游戏市场， 但是目前为了打通手机市场，他们已经通过降低价格的策略进行了调整。相反， Unity科技开始着重于发展基础游戏，旨在为移动手机端打造画质更加精美的2D和3D游戏。</p><p>据VisionMobile2017年的一份数据调查显 示，目前有59%的VR游戏开发者正在使用 Unity工具进行游戏制作，免费游戏热门榜 单前1000名中有38%都是基于Unity引擎开发。 在谷歌DayDream游戏平台上超过半数的游戏 也是如此。因此Unity基本已经占据了主机 和PC游戏市场的半壁江山，对于手游制作所 选择的引擎来说更是达到了70%的占有率。<br>2019年Unity引擎占据全功能游戏引擎市场45%的份额，全世界有6亿的玩家在玩使用Unity 引擎制作的游戏。Unity3D引擎占据全功能游戏引擎市场45%的份额，居全球首位。Unity 3D开发人员占有比例为 47%，Unity 3D全球用户已经超过330万人， 中国区的开发者数量已成为全球第一。</p><hr><h2 id="绘制流水线">绘制流水线</h2><p>绘制流水线主要用于创建一个描述三维世界中的物体的二维图像</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_16-46-01.png" alt=""></p><p><strong>3维世界</strong></p><ul><li>一个3D场景是由物体或模型组成的。</li><li>而物体或模型都是通过三角形组成的。 一个由若干三角形构成的物体称为：网格（mesh）。</li></ul><p>3D场景 (scene)<br> ↑ ↑<br>物体 or 模型 (model)<br> ↑ ↑<br>三角形 (triangle)<br> ↑ ↑<br>顶点 (Vertex)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_16-50-51.png" alt=""></p><p><a href="https://baike.baidu.com/item/Direct3D/910353">Direct3D</a>中的三角形</p><ul><li>三角形是构成三维模型的基本元素。</li><li>通过三角形列表来描述物体的形状和轮廓。</li><li>三角形列表中包含了每个需要绘制的三角形数据。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vertex rect[<span class="number">6</span>] = &#123; v0, v1, v2, <span class="comment">//三角形0</span></span><br><span class="line">v0, v2, v3 &#125;; <span class="comment">// 三角形1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_16-53-27.png" alt=""></p><p><strong>顶点索引</strong></p><ul><li>通常组成三维物体的三角形都会使用许多相同的顶点 ，为避免浪费，就得使用顶点索引</li><li>索引的工作原理：在创建一个顶点列表的同时创建一个索引列表</li></ul><p>索引列表中保存什么呢？<br>保存顶点列表中的索引，或者说顶点数组的下标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vertex vertexList[<span class="number">4</span>] = &#123;v0, v1, v2, v3&#125;;</span><br><span class="line">DWORD indexList[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="comment">// 三角形0 </span></span><br><span class="line"><span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 三角形1 </span></span><br></pre></td></tr></table></figure><p>与前面用顶点表示的三角形列表相比较<br>36个点和8个点的区别</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_16-58-46.png" alt=""></p><p><strong>虚拟摄像机</strong></p><ul><li>摄像机决定观察者可以看到的三维世界的范围</li><li>摄像机可见的体积范围是一个平截台体</li><li>投影窗口位于一个二维平面中， Direct3D中位于z = 1这个平面上</li><li>假设近平面和投影平面是一个平面</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-00-35.png" alt=""></p><p><strong>渲染流水线</strong></p><ul><li>输入装配阶段</li><li>顶点着色阶段</li><li>hullShader阶段</li><li>曲面细分阶段</li><li>裁剪阶段</li><li>光栅化阶段</li><li>像素着色器阶段</li><li>输出合并阶段</li></ul><p><strong>输入装配阶段</strong></p><ul><li>输入装配阶段（IA）从内存中读取数据 （顶点和索引）来装配称几何基元（三角 形、线段等）。</li><li>顶点：顶点不仅包含基本的位置信息， 也可以包含其他数据如法向量、UV值等。</li></ul><p><strong>顶点索引</strong></p><ul><li>索引：下面代码展示了一个顶点数组用来组成四边形和八边形：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vertex quad[<span class="number">6</span>] = &#123;</span><br><span class="line">    v0，v1, v2， <span class="comment">// Triangle 0</span></span><br><span class="line">    ve, v2, v3, <span class="comment">// Triangle 1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vertex octagon[<span class="number">24</span>] = &#123;</span><br><span class="line">v0, v1, v2，<span class="comment">// Triangle 0</span></span><br><span class="line">v0, v2, v3, <span class="comment">// Triangle 1</span></span><br><span class="line">v0， v3, v4, <span class="comment">// Triangle 2</span></span><br><span class="line">v0, v4, v5， <span class="comment">// Triangle 3</span></span><br><span class="line">v0, v5, v6, <span class="comment">// Triangle 4</span></span><br><span class="line">v0, v6, v7, <span class="comment">// Triangle 5</span></span><br><span class="line">v0, v7, v8, <span class="comment">// Triangle 6</span></span><br><span class="line">ve， v8, v1 <span class="comment">// Triangle 7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>顶点着色阶段</strong><br>GPU会对每个顶点使用定义的顶点着色器执行一遍，许多效果可以在顶点着色器中实现，比如：变换，光照，贴图置换等。 它不仅可以访问顶点数据，还可以访问其他保存在GPU内存中的数据，比如：纹理， 灯光数据等。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-06-21.png" alt=""></p><p><strong>曲面细分阶段</strong><br>曲面细分阶段可以细分三角形，产生新的三角形，并且调整它的位置，用以生成更多细节和更好效果：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-07-25.png" alt=""></p><p><strong>几何着色阶段</strong><br>几何着色器输入完整的基元，它可以扩展/增加多个基元或者根据某些条件删除基元，而顶点着色器不能； 比如它可以把点扩展成线或者矩形面； 几何着色器可以流出（stream-out） 顶点数据到内存中的缓存，用以后续的渲染。</p><p><strong>裁切</strong><br>如果几何体完全在截头锥体以外需要被丢弃；如果和边界相交，那么就需要裁切：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-08-57.png" alt=""></p><p><strong>光栅化阶段</strong><br>光栅化阶段的工作是通过投影的3D三角形计算出像素的颜色</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-10-37.png" alt=""></p><p><strong>像素着色器阶段</strong><br>像素着色器是指在GPU上执行的程序， 它可以逐像素计算颜色，光照，反射和阴影等效果。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-11-26.png" alt=""></p><p><strong>输出合并阶段</strong><br>在这个阶段，某些像素片段可能被删除（深度或者模板缓冲测试），没有被拒绝的像素片段将被写入后置缓 冲，混合操作之后，这些像素准备被输出到设备上。</p><p><strong>认识渲染</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-14-01.png" alt=""></p><hr><h1>二、2D游戏编程-环境安装与基本使用</h1><h2 id="二维游戏设计概述">二维游戏设计概述</h2><p><strong>二维游戏的基本流程和架构</strong></p><ul><li>二维游戏的基本功能：<strong>交互和输出</strong><ul><li>交互部分：根据用户的操作，改变游戏的各种数据，以反映游戏的当前状态。</li><li>输出：处理游戏运行中的各种数据，在输出设备上体现游戏的内容，包括游戏画面、游戏音效、游戏提示等。</li></ul></li><li>这两个部件的执行由调度模块指挥，简单的调度模块是一个dowhile循环，串行执行：交互→输出→再输出→再渲染→…。当然也可以将两个部件分成不同的线程，并行执行。</li></ul><p><strong>实现二维游戏框架，需要做下面的几个工作</strong>：</p><ul><li>实现游戏地图的加载和编辑操作</li><li>图像的半透明技术</li><li>精灵动画技术：采用连续静态图片快速切换方式 产生动画效果 【精灵图】</li><li>碰撞检测</li><li>选用何种语言进行游戏程序开发；</li><li>通过VS2019自带的工具箱经过简单的拖拽， 直接进行桌面应用开发；<br>优点：简单，快速，灵活。</li></ul><h2 id="VS2019的安装与配置">VS2019的安装与配置</h2><p>下载链接：<a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio: 面向软件开发人员和 Teams 的 IDE 和代码编辑器 (microsoft.com)</a></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-26-27.png" alt=""></p><p>选项看自己需要进行设置：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_17-28-16.png" alt=""></p><h2 id="C-基础-菜鸟教程自学">C# 基础 菜鸟教程自学</h2><p><a href="https://www.runoob.com/csharp/csharp-tutorial.html">C# 教程 | 菜鸟教程 (runoob.com)</a></p><p>后面老师没有发PPT了。</p><h1>课程信息</h1><p>主讲人：王欣</p><p>计算机图形学与数字媒体研究室</p><p>吉林大学虚拟现实梦工厂</p><p>QQ：<code>158930117</code></p><p>email：<code>158930117@qq.com</code></p><h2 id="成绩考核">成绩考核</h2><p><strong>加权</strong>平均：平时出勤及作业 * <strong>0.5</strong>+开卷考试 * <strong>0.5</strong></p><ul><li><p>平时作业、出勤率 <strong>20%</strong></p></li><li><p>项目作业完成情况：质量、是否自己完成 <strong>30%</strong></p><ul><li>纸质</li><li>电子</li></ul></li><li><p>开卷考试：<strong>50%</strong></p></li></ul><p><strong>附加分（5分）</strong> ：作品展示【加上去也不会超过100分】</p><p>游戏编程大作业：<strong>1-3</strong>人一组</p><p>6.7左右2D，后面还有3D的</p><h2 id="参考资料">参考资料</h2><ul><li>毕文斌，孙明亮，冯大磊 编， C# Windows游戏设计，清华 大学出版社，2014年11月。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_15-52-41.png" alt=""></li><li>Frank D. Luna 著，王陈 译. DirectX 12  3D 游戏开发实战，人民邮电出版社， 2019年1月。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_15-53-28.png" alt=""></li><li>Fletcher Dunn，Ian  Parberry 著，史银雪， 陈洪，王荣静 译 ，3D 数学基础：图形和游戏 开发，清华大学出版社， 2005年1月。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/game_programming/Snipaste_2023-05-06_15-53-56.png" alt=""></li></ul><h1>第一节课</h1><p>2023-05-06</p><p>学生xxx实习：游戏公司实习，xxx的师傅发现是老师的学生，师傅的师傅发现还是学生的老师</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>老师的学生，学长（米哈游），老师可以内推？（小声）</p><h1>第二节课</h1><p><strong>前沿：AI绘画</strong>：</p><p>Stable Diffusion（推荐使用）</p><p>Midjourney</p><p><a href="https://www.scenario.com">ai素材网</a></p><h1>第三节课</h1><p>二维游戏设计概述</p><p>实现二维游戏框架需要做下面几个工作：</p><ul><li>实现地图的加载和编辑操作</li><li>图像的半透明操作</li><li>精灵动画技术：采用连续静态图片切换方式产生动画</li><li>碰撞检测</li></ul><h1>第四节课</h1><p>讲课，组件怎么用</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道计算机网络</title>
      <link href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV19E411D78Q?t=2.3">【王道考研计算机网络】</a></p><h2 id="第一章、计算机网络概述">第一章、计算机网络概述</h2><h3 id="1、概念、组成、功能和分类">1、概念、组成、功能和分类</h3><ul><li><u><strong>计算机网络的概念</strong></u></li></ul><p>计算机网络：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_22-35-11.png" alt=""></p><p>计算机网络是<strong>互连的</strong>、<strong>自治的</strong>计算机集合。</p><p><strong>互连</strong>-互联互通通信链路</p><p><strong>自治</strong>-无主从关系</p><hr><ul><li><u><strong>计算机网络的功能</strong></u></li></ul><ol><li><strong>数据通信</strong>：数据可以在信道上传输，保证了不同主机的<strong>连通性</strong>。（最基本、最重要）</li><li><strong>资源共享</strong>：硬件资源、软件资源、数据资源。</li><li><strong>分布式处理</strong>：多台计算机各自承担同一工作的不同部分。常见分布式处理平台：<strong>hadoop</strong></li><li><strong>提高可靠性</strong>：一台主机宕机了，不会影响其他链路。</li><li><strong>负载均衡</strong>：分布式处理的效果，多台计算机一起工作，工作任务均衡分配。</li></ol><hr><ul><li><u><strong>计算机网络的组成</strong></u></li></ul><ol><li><strong>组成部分</strong>：硬件（如下图）、软件、协议</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_22-53-46.png" alt=""></p><ol start="2"><li><p><strong>工作方式</strong>：</p><ul><li>边缘部分（主机）：用户直接使用：c/s方式、P2P对等方式</li><li>核心部分（路由器、网络）：为边缘模式服务</li></ul></li><li><p><strong>功能组成</strong>：</p><ul><li>通信子网：实现<strong>数据通信</strong></li><li>资源子网：实现<strong>资源共享</strong>/数据处理</li></ul></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_23-05-46.png" alt=""></p><hr><ul><li><u><strong>计算机网络的分类</strong></u></li></ul><ol><li><p>按分布范围分：广域网WAN（<strong>交换技术</strong>）、城域网MAN、局域网LAN（<strong>广播技术</strong>）、个人区域网PAN</p></li><li><p>按使用者分：</p><ul><li>公用网：中国电信</li><li>专用网：军队、政府等等</li></ul></li><li><p>按交换技术分：报文交换、分组交换、电路交换</p></li><li><p>按拓扑结构分：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_23-15-29.png" alt=""></p></li><li><p>按传输技术分：</p><ul><li><strong>广播式网络</strong>：共享公共通信信道</li><li><strong>点对点网络</strong>：使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li></ul></li></ol><hr><h3 id="2、标准化工作以及相关组织">2、标准化工作以及相关组织</h3><ul><li><u><strong>标准的分类</strong></u><ul><li>法定标准：由权威机构制定的正式的、合法的标准。例如：<strong>OSI</strong></li><li>事实标准：某些公司的产品在竞争中占据了主流时间长了，这些产品中的协议和技术就成了标准，例如：<strong>TCP/IP</strong></li></ul></li></ul><hr><ul><li><u><strong>RFC</strong>( Request For Comments )——因特网标准的形式</u></li></ul><p>RFC要上升为因特网正式标准的<strong>四个阶段</strong>:</p><ol><li>因特网草案(Internet Draft) 这个阶段还不是RFC文档</li><li>建议标准(Proposed standard) 从这个阶段开始成为RFC文档。</li><li>草案标准(Draft Standard)：2011年取消</li><li>因特网标准(Internet Standard )：通过IETF、IAB审核后</li></ol><hr><ul><li><u><strong>相关组织</strong></u></li></ul><p><strong>国际标准准化组织ISO</strong>：OSI参考模型、HDLC协议<br><strong>国际电信联盟ITU</strong>：制定通信规则<br><strong>国际电气电子工程师协会IEEE</strong>：学术机构、IEEE802系列标准、5G<br><strong>Internet工程任务组IETF</strong>：负责因特网相关标准的制定，通过后有<code>RFC XXXX</code>编号</p><hr><h3 id="3、速率相关的性能指标">3、速率相关的性能指标</h3><ul><li><u><strong>速率</strong></u><br>即<strong>数据率</strong>或称<strong>数据传输率</strong>或<strong>比特率</strong></li></ul><p>连接在计算机网络上的主机在数字信道上传送数据<strong>位数的速率</strong>。</p><p>单位是：<strong>b/s，kb/s，Mb/s，Gb/s，Tb/s</strong></p><p><strong>速率</strong>：<br>千 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1kb/s=10^3b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span><br>兆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Mb/s=10^3kb/s=10^6b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span><br>吉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Gb/s=10^3Mb/s=10^6kb/s=10^9b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span><br>太 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>T</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>G</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^{12}b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mord mathnormal">kb</span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></p><p><strong>存储容量</strong>：1 Byte（字节）= 8 bit（比特）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>B</mi><mo>=</mo><mn>1024</mn><mi>B</mi><mo>=</mo><mn>1024</mn><mo>×</mo><mn>8</mn><mi>b</mi></mrow><annotation encoding="application/x-tex">1KB=2^{10}B=1024B=1024 \times 8b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1024</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mord mathnormal">b</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>M</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><mn>1024</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1MB=2^{10}KB=1024KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1024</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>M</mi><mi>B</mi><mo>=</mo><mn>1024</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1GB=2^{10}MB=1024MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1024</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>G</mi><mi>B</mi><mo>=</mo><mn>1024</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1TB=2^{10}GB=1024GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">TB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1024</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span></p><hr><ul><li><u><strong>带宽</strong></u></li></ul><ol><li><p>“<strong>带宽</strong>”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹 (HZ)</p></li><li><p>计算机网络中，<strong>带宽</strong>用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。</p><p>简单地说：<strong>网络设备所支持的最高速度</strong></p></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_23-50-56.png" alt=""></p><hr><ul><li><u><strong>吞吐量</strong></u></li></ul><p>表示在<strong>单位时间</strong>内通过<strong>某个网络(或信道、接口)</strong> 的数据量。单位b/s，kb/s，Mb/s等。<br>吞吐量受网络的带宽或网络的额定速率的限制。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-28_23-57-13.png" alt=""></p><hr><h3 id="4、时延、时延带宽积、RTT和利用率">4、时延、时延带宽积、RTT和利用率</h3><ul><li><u><strong>时延</strong></u></li></ul><p>指数据(报文/分组/比特流)从网络(或链路)的一端传送到另一端所需的时间。也叫<strong>延迟</strong>或<strong>迟延</strong>。单位是s。</p><p>分为：</p><ol><li><p><strong>发送时延（传输时延）</strong></p><p>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。（高速链路减少的是发送时延，即提高带宽）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>发送时延</mtext><mo>=</mo><mfrac><mtext>数据长度</mtext><mrow><mtext>信道带宽</mtext><mo stretchy="false">(</mo><mtext>发送速率</mtext><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">发送时延=\frac{数据长度}{信道带宽(发送速率)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">发送时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3923em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">信道带宽</span><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">发送速率</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数据长度</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p><strong>传播时延</strong></p><p>取决于电磁波的传播速度和链路长度</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>传播时延</mtext><mo>=</mo><mfrac><mtext>信道长度</mtext><mtext>电磁波在信道上的传播速率</mtext></mfrac></mrow><annotation encoding="application/x-tex">传播时延=\frac{信道长度}{电磁波在信道上的传播速率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传播时延</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">电磁波在信道上的传播速率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">信道长度</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p><strong>排队时延</strong></p><p>等待输出或输入链路可用</p></li><li><p><strong>处理时延</strong></p><p>检错，找出口</p></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_00-31-17.png" alt=""></p><hr><ul><li><u><strong>时延带宽积</strong></u></li></ul><p>时延带宽积（bit） = 传播时延（s） X 带宽（b/s）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_00-43-57.png" alt=""></p><p>时延带宽积又称为以<strong>比特为单位的链路长度</strong>。即“某段链路现在有多少比特（容量）”。</p><hr><ul><li><u><strong>往返时延RTT</strong></u></li></ul><p>从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_00-52-09.png" alt=""></p><p>RTT越大（期间的时间越长），在收到确认之前，可以发送的数据越多</p><p><strong>RTT包括</strong>：</p><ol><li>往返传播时延=传播时延*2</li><li>末端处理时间（看题目要求是否需要考虑）</li></ol><hr><ul><li><u><strong>利用率</strong></u></li></ul><p>分为：</p><ol><li><strong>信道利用率</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext>有数据通过时间</mtext><mrow><mo stretchy="false">(</mo><mtext>有</mtext><mo>+</mo><mtext>无</mtext><mo stretchy="false">)</mo><mtext>数据通过时间</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{有数据通过时间}{(有+无)数据通过时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3923em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord cjk_fallback mtight">有</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">无</span><span class="mclose mtight">)</span><span class="mord cjk_fallback mtight">数据通过时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">有数据通过时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><strong>网络利用率</strong>：信道利用率加权平均值</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_00-56-20.png" alt=""></p><hr><h3 id="5、分层协议、协议、接口、服务">5、分层协议、协议、接口、服务</h3><ul><li><u><strong>为什么要分层？</strong></u></li></ul><p>发送文件前要完成的工作：<br>(1)发起通信的计算机必须将数据通信的通路进行激活。<br>(2)要告诉网络如何识别目的主机。<br>(3)发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。<br>(4)发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。<br>(5)确保差错和意外可以解决。<br>。。。。。</p><p>计算机：大问题 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> 小问题1、小问题2、…</p><hr><ul><li><u><strong>怎么分层</strong></u></li></ul><p>举例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-16-49.png" alt=""></p><hr><ul><li><u><strong>分层结构</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-24-42.png" alt=""></p><ol><li><strong>实体</strong>：第n层中的活动元素称为<strong>n层实体</strong>。同一层的实体叫<strong>对等实体</strong></li><li><strong>协议</strong>：为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议。【水平】<ul><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ul></li><li><strong>接口(访问服务点SAP)</strong> ：上层使用下层服务的入口。</li><li><strong>服务</strong>：下层为相邻上层提供的功能调用。【垂直】</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-28-03.png" alt=""></p><p><strong>SDU服务数据单元</strong>：为完成用户所要求的功能而应传送的数据。</p><p><strong>PCI协议控制信息</strong>：控制协议操作的信息。</p><p><strong>PDU协议数据单元</strong>：对等层次之间传送的数据单位。</p><hr><ul><li><u><strong>概念总结</strong></u></li></ul><p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</p><p>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong>。</p><p>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</p><p><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</p><p>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</p><p>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</p><p>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</p><hr><h3 id="6、OSI参考模型（1）">6、OSI参考模型（1）</h3><p>计算机网络分层结构：</p><ul><li><strong>7层</strong>OSI参考模型（法定标准）</li><li><strong>4层</strong>TCP/IP参考模型（事实标准）</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> <strong>5层</strong>的体系结构</p><hr><ul><li><u><strong>ISO/OSI参考模型怎么来的</strong></u></li></ul><p>为了解决计算机网络复杂的大问题 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> 分层结构(按<strong>功能</strong>)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-39-09.png" alt=""></p><p>目的：支持异构网络系统的互联互通</p><p>国际标准化组织(<strong>ISO</strong>)于1984年提出开放系统互连 (<strong>OSI</strong>) 参考模型。<strong>但是！理论成功，市场失败</strong>。</p><hr><ul><li><u><strong>ISO/OSI参考模型</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-42-24.png" alt=""></p><hr><ul><li><u><strong>ISO/OSI参考模型解释通信过程</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-55-08.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-55-28.png" alt=""></p><p>上图中 端到端 与 点到点的区别：现在A主机给B主机发送报文，端到端就是A到B，点到点就是自A到中间的路由器再到B；就是说端到端不需要了解中间经过了什么</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_01-55-32.png" alt=""></p><hr><h3 id="7、OSI参考模型（2）">7、OSI参考模型（2）</h3><ul><li><u><strong>应用层</strong></u></li></ul><p>所有能和用户交互产生网络流量的程序。（用户与网络的界面）</p><p>典型应用层服务：文件传输(FTP)、电子邮件(SMTP)、万维网(HTTP)、…</p><hr><ul><li><u><strong>表示层</strong></u></li></ul><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p><p><strong>功能一：数据格式变换</strong>（翻译官)</p><p><strong>功能二：数据加密解密</strong></p><p><strong>功能三：数据压缩和恢复</strong></p><p>主要协议(考研不考)：JPEG、ASCII</p><hr><ul><li><u><strong>会话层</strong></u></li></ul><p>向表示层实体/用户进程<strong>提供建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据。</p><p>这就是会话，也是<strong>建立同步</strong>（SYN）</p><p><strong>功能一</strong>：建立、管理、终止会话。</p><p><strong>功能二</strong>：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。（适用于传输大文件）</p><p>主要协议(考研不考)：ADSP、ASP</p><hr><ul><li><u><strong>传输层</strong></u></li></ul><p>负责主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报。</p><p><strong>功能一：可靠传输</strong> （确认，重发）、<strong>不可靠传输</strong>（不确认，不重发）</p><p><strong>功能二：差错控制</strong></p><p><strong>功能三：流量控制</strong></p><p><strong>功能四：复用分用</strong>（复用：多个应用层进程可同时使用下面运输层的服务。分用：运输层把收到的信息分别交付给上面应用层中相应的进程）</p><p>主要协议: TCP、UDP</p><hr><ul><li><u><strong>网络层</strong></u></li></ul><p>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。<br>网络层传输单位是<strong>数据报</strong>。</p><p><strong>功能一：路由选择</strong> 选择最佳路径</p><p><strong>功能二：流量控制</strong></p><p><strong>功能三：差错控制</strong></p><p><strong>功能四：拥塞控制</strong>（若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采取一定措施缓解这种拥塞）</p><p>主要协议:IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><hr><ul><li><u><strong>数据链路层</strong></u></li></ul><p>主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。</p><p>数据链路层/链路层的传输单位是<strong>帧</strong></p><p><strong>功能一：成帧(定义的开始和结束)</strong>…1000011101010101…</p><p><strong>功能二：差错控制</strong> 帧错+位错</p><p><strong>功能三：流量控制</strong></p><p><strong>功能四：访问(接入)控制</strong> 控制对信道的访问</p><p>主要协议：SDLC、HDLC、PPP、STP</p><hr><ul><li><u><strong>物理层</strong></u></li></ul><p>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>。</p><p>物理层传输单位是<strong>比特</strong></p><p><strong>透明传输</strong>：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p><p><strong>功能一：定义接口特性</strong></p><p><strong>功能二：定义传输模式</strong> 单工、半双工、双工</p><p><strong>功能三：定义传输速率</strong></p><p><strong>功能四：比特同步</strong></p><p><strong>功能五：比特编码</strong></p><p>主要协议：Rj45、802.3</p><hr><h3 id="8、TCP、IP参考模型和5层参考模型">8、TCP、IP参考模型和5层参考模型</h3><ul><li><u><strong>OSI参考模型与TCP/IP模型</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_09-32-41.png" alt=""></p><hr><ul><li><u><strong>OSI参考模型与TCP/IP模型相同点</strong></u></li></ul><ol><li><p>都分层</p></li><li><p>基于独立的协议栈的概念</p></li><li><p>可以实现异构网络互联</p></li></ol><hr><ul><li><u><strong>OSI参考模型与TCP/IP模型不同点</strong></u></li></ul><ol><li><p>OSI定义<strong>三</strong>点:  服务、协议、接口</p></li><li><p>OSI<strong>先</strong>出现，参考模型先于协议发明，不偏向特定协议</p></li><li><p>TCP/IP设计之初就考虑到异构网<strong>互联</strong>问题，将IP作为重要层次</p></li><li><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">ISO/OSI</th><th style="text-align:center">TCP/IP</th></tr></thead><tbody><tr><td style="text-align:center">网络层</td><td style="text-align:center">无连接 + 面向连接</td><td style="text-align:center">无连接</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">面向连接</td><td style="text-align:center">无连接 + 面向连接</td></tr></tbody></table><p><strong>面向连接</strong>分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段接着，当数据传输完毕，必须释放连接。而面向<strong>无连接</strong>没有这么多阶段，它直接进行数据传输。</p></li></ol><hr><ul><li><u><strong>5层参考模型</strong></u></li></ul><p>综合了OSI和TCP/IP的优点</p><p>应用层：支持各种网络应用。FTP、SMTP、HTTP</p><p>传输层：进程-进程的数据传输。TCP、UDP</p><p>网络层：源主机到目的主机的数据分组路由与转发。IP、ICMP、OSPF等</p><p>数据链路层：把网络层传下来的数据报组装成帧。Ethernet、PPP</p><p>物理层：比特传输</p><hr><ul><li><u><strong>5层参考模型的数据封装与解封装</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_09-47-53.png" alt=""></p><hr><h2 id="第二章、物理层">第二章、物理层</h2><h3 id="1、物理层基本概念">1、物理层基本概念</h3><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p><p>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> <strong>定义标准</strong></p><ol><li><p><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况。</p></li><li><p><strong>电气特性</strong>：规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、传输<strong>速率</strong>和<strong>距离</strong>限制等.</p><p>举例：某网络在物理层规定，信号的电平用+10V ~ +15V表示二进制0，用-10V ~ -15V表示二进制1，电线长度限定=15m以内</p></li><li><p><strong>功能特性</strong>：指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途</p><p>举例：描述一个物理层接口引脚处于高电平时的含义</p></li><li><p><strong>规程特性</strong>：（过程特性）定义各条物理线路的工作<strong>规程和时序</strong>关系</p></li></ol><hr><h3 id="2、数据通信的基础知识">2、数据通信的基础知识</h3><ul><li><u><strong>典型的数据通信模型</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_10-20-55.png" alt=""></p><hr><ul><li><u><strong>数据通信的相关术语</strong></u></li></ul><p>通信的<strong>目的</strong>是传送消息<br><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列。</p><p>数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。</p><p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的存在形式。<br>  <strong>数字信号</strong>：代表消息的参数取值是<strong>离散的</strong>。<br>  <strong>模拟信号</strong>：代表消息的参数取值是<strong>连续的</strong>。</p><p><strong>信源</strong>：产生和发送数据的源头。<br><strong>信宿</strong>：接收数据的终点。<br><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br>  按传输信号分：<strong>模拟信道 (传送模拟信号)</strong> 、<strong>数字信道 (传送数字信号 )</strong><br>  按传输介质分：<strong>无线信道</strong>、<strong>有线信道</strong></p><hr><ul><li><u><strong>三种通信方式</strong></u></li></ul><p>从通信双方信息的交互方式看，可以有三种基本方式:</p><ol><li><p><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需要一条信道。</p></li><li><p><strong>半双工通信</strong>：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。</p></li><li><p><strong>全双工通信</strong>：通信双方可以同时发送和接受信息，也需要两条信道。</p></li></ol><hr><ul><li><u><strong>两种数据传输方式</strong></u></li></ul><ol><li><strong>串行传输</strong>：速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远</strong>距离</li><li><strong>并行传输</strong>：速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近</strong>距离用于计算机内部数据传输</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_10-34-54.png" alt=""></p><hr><ul><li><strong><u>同步传输 &amp; 异步传输</u></strong></li></ul><p>实现同步的传输/通信方式:</p><ul><li>同步传输: 在同步传输的模式下，数据的传送是以一个<strong>数据区块</strong>为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-09_15-12-33.png" alt=""></p><ul><li>异步传输: 异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终上位。</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-09_15-14-32.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-09_15-13-58.png" alt=""></p><hr><h3 id="3、码元、速率、波特、带宽">3、码元、速率、波特、带宽</h3><ul><li><u><strong>码元</strong></u></li></ul><p><strong>码元</strong>是指用一个<strong>固定时长</strong>的<strong>信号波形</strong>(数字脉冲)，代表不同离散数值基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<strong>k进制码元</strong>，而该时长称为<strong>码元宽度</strong>。当码元的离散状态有M个时 (M大于2)，此时码元为M进制码元。</p><p><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_10-43-46.png" alt=""></p><p>K进制码元一4进制码元：码元的离散状态有4个，4种高低不同的信号波形 00、01、10、11，1码元2比特。</p><hr><ul><li><u><strong>速率、波特、带宽</strong></u></li></ul><p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示</p><ol><li><p><strong>码元传输速率</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为<strong>脉冲个数</strong>或<strong>信号变化的次数</strong>)，<strong>单位是波特 (Baud)</strong>。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</p><p>简单讲就是：<strong>1s 传输多少个码元</strong>。1 Baud = 1 码元/s</p></li><li><p><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是 比特/秒 (b/s)。</p><p>简单讲就是：1s传输多少个比特</p></li></ol><p><strong>关系</strong>：若一个码元携带 n bit的信息量，则 M Baud的码元传输速率所对应的信息传输速率为 M X n bit/s.</p><p><strong>带宽</strong>：表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力。单位是 b/s。</p><hr><ul><li><u><strong>练习题</strong></u></li></ul><p>某一数字通信系统传输的是四进制码元，4s传输了8000个码元，求系统的码元传输速率是多少？信息传输速率是多少？若另一通信系统传输的是十六进制码元，6s传输了7200个码元。求他的码元传输速率是多少？信息传输速率是多少？并指出哪个系统传输速率快？</p><p><strong>答案</strong>：2000Baud，4000b/s；1200Baud，4800b/s；十六进制更快</p><p><strong>解析</strong>：</p><p>四进制码元系统:<br>码元传输速率就是 8000 / 4 = 2000 Baud，信息传输速率就是2000<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>4</mn></mrow><annotation encoding="application/x-tex">\times log_24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">×</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">4</span></span></span></span> = 4000 b/s</p><p>十六进制码元系统:<br>码元传输速率就是 7200 / 6 = 1200 Baud，信息传输速率就是1200<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>16</mn></mrow><annotation encoding="application/x-tex">\times log_216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">×</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">16</span></span></span></span> = 4800 b/s<br>系统传输的是<strong>比特流</strong>，通常比较的是信息传输速率，所以传输十六进制码元的通信系统传输速率较快，<strong>如果用该系统去传输四进制码元会有更高的码元传输速率。</strong></p><hr><h3 id="4、奈氏准则和香农定理">4、奈氏准则和香农定理</h3><ul><li><u><strong>失真</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_11-08-52.png" alt=""></p><p>影响失直程度的因素：正相关（1、<strong>码元传输速率</strong> 2、<strong>信号传输距离</strong> 3、<strong>噪声干扰</strong>）， 负相关（4、<strong>传输媒体质量</strong>）</p><hr><ul><li><u><strong>失真的一种现象——码间串扰</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_11-15-08.png" alt=""></p><p><strong>信道带宽</strong>是信道能通过的<strong>最高频率和最低频率之差</strong>。3300Hz-300Hz=3000Hz</p><p>200HZ不能通过的原因：频率太低了，衰减后就无法识别了</p><p>4000HZ不能通过的原因：码间串扰</p><p><strong>码间串扰</strong>：接收端收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象</p><hr><ul><li><u><strong>奈氏准则（奈奎斯特定理）</strong></u></li></ul><p>奈氏准则：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为 <strong>2W Baud</strong>，W是信道带宽，单位是Hz。</p><p><strong>只有在这两个公式，带宽单位才用Hz! !</strong></p><p>为了混淆学生，会在求一步极限数据率：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_11-27-01.png" alt=""></p><p>结论：</p><ol><li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li><li>信道的<strong>频带越宽</strong>(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输</li><li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</strong>。</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li></ol><p><strong>例题</strong>：在无噪声的情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅的QAM调制技术，则该通信链路的<strong>最大</strong>数据传输率是多少?</p><p>解析：</p><p>信号有 4 x 4 = 16 种变化<br>最大数据传输率 = 2 x 3k  x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>16</mn></mrow><annotation encoding="application/x-tex">log_216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">16</span></span></span></span> =24 kb/s</p><hr><ul><li><u><strong>香农定理</strong></u></li></ul><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。信噪比 = 信号的平均功率 / 噪声的平均功率，常记为S/N，并用分贝 (dB) 作为度量单位</p><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_11-47-30.png" alt=""></p><p>结论：</p><ol><li><p>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong>。</p></li><li><p>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p></li><li><p>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差错的传输</strong>。</p></li><li><p>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p></li><li><p>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(不可能），那么信道的极限信息传输速率也就没有上限。</p></li></ol><p><strong>例题</strong>：电话系统的典型参数是信道带宽为3000Hz，信噪比为30dB，则该系统最大数据传输速率是多少?</p><p>解析：</p><p>30 dB = 10<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">log_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (S/N)<br>则 S/N = 1000<br>信道的极限数据传输速率 = W <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (1 + S/N) = 3000 x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(1 + 1000) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span></span></span></span> 30 kb/s</p><hr><ul><li><u><strong>两个定理如何选择</strong></u></li></ul><p>缺少计算条件的，直接不考虑；如果都可以计算则都计算，然后比较结果大小。</p><p><strong>例题</strong>： 进制信号在信噪比为127:1的4kHz信道上传输，最大的数据速率可达到多少?</p><p>解析：</p><p>奈氏准则: 2 X 4000 X <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">log_2{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span></span></span></span></span> = 8000 b/s<br>香农定理: 4000 X  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>127</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">log_2{(1 + 127)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">127</span><span class="mclose">)</span></span></span></span></span> = 28000 b/s<br>选择较小的 8000 b/s</p><hr><h3 id="5、编码和调制（1）">5、编码和调制（1）</h3><ul><li><u><strong>基带信号与宽带信号</strong></u></li></ul><p><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br>  按传输信号分：<strong>模拟信道 (传送模拟信号)</strong> 、<strong>数字信道 (传送数字信号 )</strong><br>  按传输介质分：<strong>无线信道</strong>、<strong>有线信道</strong></p><p>信道上传送的信号：</p><ol><li><p><strong>基带信号</strong>：<br>将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输(<strong>基带传输</strong>)。<strong><u>来自信源的信号</u></strong>，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。（可以是数字信号，也可以是模拟信号）</p></li><li><p><strong>宽带信号</strong>：</p><p>将基带信号进行调制后形成的频分复用模拟信号，再传送到<strong>模拟信道</strong>上去传输(<strong>宽带传输</strong>)。把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬移</strong>到<strong>较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></li></ol><p>在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)。</p><p>在传输距离较远时，计算机网络采用宽带传输方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号）。</p><hr><ul><li><u><strong>编码与调制</strong></u></li></ul><p><strong>编码</strong>：数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 数字信号</p><p><strong>调制</strong>：数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 模拟信号</p><p>数字数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>数字发送器</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{数字发送器}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">数字发送器</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 数字信号（编码）</p><p>数字数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>调制器</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{调制器}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">调制器</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 模拟信号（调制）</p><p>模拟数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>P</mi><mi>C</mi><mi>M</mi><mtext>编码器</mtext></mrow></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{PCM编码器}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">PCM</span><span class="mord cjk_fallback mtight">编码器</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 数字信号（编码）</p><p>模拟数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>放大器调制器</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{放大器调制器}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">放大器调制器</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 模拟信号（调制）</p><hr><h3 id="6、编码和调制（2）">6、编码和调制（2）</h3><ul><li><u><strong>数字数据编码为数字信号</strong></u></li></ul><ol><li><p><strong>非归零编码</strong>【<strong>NRZ</strong>】<br>高1低0<br>编码容易实现，但没有检错功能且无法判断一个码元的开始和结束，以至于收发双方难以保持同步</p></li><li><p><strong>曼切斯特编码</strong></p><p>将一个码元分成两个相等的间隔前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步)，又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。<strong>所以数据传输速率只有调制速率的1/2</strong>。</p></li><li><p><strong>差分曼切斯特编码</strong></p><p>同1异0<br>常用于局域网传输，其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间,都有一次电平的跳转，可以实现自同步，且<strong>抗干扰性强于彻斯特编码</strong>。</p></li><li><p>归零编码【RZ】</p><p>信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</p></li><li><p>反向不归零编码【NRZI】</p><p>信号电平翻转表示0，信号电平不变表示1。</p></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_14-30-30.png" alt=""></p><ol start="6"><li><p>4B/5B编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_14-34-27.png" alt=""></p><p>只采用16种对应16种不同的4位码其他的16种作为控制码(的开始和结束，线路的状态信息等)或保留。</p></li></ol><hr><ul><li><u><strong>数字数据编码为模拟信号</strong></u></li></ul><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_14-36-45.png" alt=""></p><p>（调幅 + 调相 也叫 正交调幅调相）</p><p>答案：4800 b/s</p><hr><ul><li><u><strong>模拟数据编码为数字信号</strong></u></li></ul><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现<strong>音频数字化</strong>)。</p><p>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的 WAV文件中均有应用、它主要包括三步: 抽样、量化、编码。</p><ol><li><strong>抽样</strong>：对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">f</mi><mtext mathvariant="bold">采样频率</mtext></msub><mo>≥</mo><mn mathvariant="bold">2</mn><msub><mi mathvariant="bold">f</mi><mtext mathvariant="bold">信号最高频率</mtext></msub></mrow><annotation encoding="application/x-tex">\mathbf{f_{采样频率} \ge 2f_{信号最高频率}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.10903em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3303em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf cjk_fallback mtight">采样频率</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">2</span><span class="mord"><span class="mord mathbf" style="margin-right:0.10903em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3303em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf cjk_fallback mtight">信号最高频率</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></li><li><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</li><li><strong>编码</strong>：把量化的结果转换为与之对应的二进制编码。</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_14-42-50.png" alt=""></p><hr><ul><li><u><strong>模拟数据编码为模拟信号</strong></u></li></ul><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式：模拟的声音数据是加载到模拟的载波信号中传输的。</p><hr><h3 id="7、物理层传输介质">7、物理层传输介质</h3><ul><li><strong><u>传输介质及分类</u></strong></li></ul><p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p><strong>传输媒体不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流。</p><p>传输介质分为：</p><ol><li>导向性传输介质：电磁波被导向沿着固体媒介 (铜线/光纤) 传播。</li><li>非导向性传输介质：自由空间，介质可以是空气、真空、海水等。</li></ol><hr><ul><li><u><strong>导向型传输介质——1、双绞线</strong></u></li></ul><p>双绞线是古老、又最常用的传输介质，它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是<strong>屏蔽双绞线(STP)</strong> ，无屏蔽层的双绞线就称为<strong>非屏蔽双绞线(UTP)</strong> 。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-06-46.png" alt=""></p><p><strong>绞合可以减少对相邻导线的电磁干扰。</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-05-27.png" alt=""></p><p>双绞线价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形。</p><hr><ul><li><u><strong>导向型传输介质——2、同轴电缆</strong></u></li></ul><p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。按特性阻抗数值的不同，通常将同轴电缆分为两类：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">50\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">50Ω</span></span></span></span>同轴电缆和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">75\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">75Ω</span></span></span></span>同轴电缆。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">50\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">50Ω</span></span></span></span>同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">75\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">75Ω</span></span></span></span>同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-13-02.png" alt=""></p><p><strong>同轴电缆 VS 双绞线</strong></p><p>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线好，被广泛用于传输较高速率的数据，其<strong>传输距离</strong>更远，但<strong>价格</strong>较双绞线贵。</p><hr><ul><li><u><strong>导向型传输介质——3、光纤</strong></u></li></ul><p>光纤通信就是利用光导纤维(简称光纤)传递<strong>光脉冲</strong>来进行通信。有光脉冲表示1，无光脉冲表示0。而可见光的频率大约是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲，在接收端用光极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由 <strong>纤芯(实心的!)</strong> 和<strong>包层</strong>构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现<strong>全反射</strong>，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-18-45.png" alt=""></p><table><thead><tr><th></th><th>定义</th><th>光源</th><th>特点</th></tr></thead><tbody><tr><td>多模光纤</td><td>有<strong>多种</strong>传输光信号模式的光纤</td><td>发光二极管</td><td><strong>易失真</strong>，适合<strong>近</strong>距离传输</td></tr><tr><td>单模光纤</td><td>一种在<strong>横向模式</strong>直接传输光信号的光纤</td><td><strong>定向</strong>性很好的<strong>激光</strong>二极管</td><td><strong>衰耗小</strong>，适合<strong>远</strong>距离传输</td></tr></tbody></table><p>光纤的特点:</p><ol><li>传输<strong>损耗小</strong>，中继距离长，对远距离传输特别经济。</li><li><strong>抗电和电磁扰性能好</strong>。</li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取数据</strong>。</li><li><strong>体积小，重量轻</strong>。</li></ol><hr><ul><li><u><strong>非导向性传输介质</strong></u></li></ul><p>1、无线电波：信号向<strong>所有方向</strong>传播</p><p>较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域(如手机通信)。</p><p>2、微波：信号向<strong>固定方向</strong>传播</p><p>微波通信频率较高、频段范，因此数据率很高。</p><p>分类：</p><ol><li><p>地面微波接力通信</p></li><li><p>卫星通信</p><ul><li><p>优点：<br>1、通信容量大</p><p>2、距离远</p><p>3、覆盖广</p><p>4、广播通信和多址通信</p></li><li><p>缺点：</p><p>1、传播时延长 (250-270ms）</p><p>2、受气候影响大 (eg: 强风太阳黑子爆发、日凌)<br>3、误码率较高<br>4、成本高</p></li></ul></li></ol><p>3、红外线、激光：信号向<strong>固定方向</strong>传播</p><p>把要传输的信号分别<strong>转换为各自的信号格式</strong>，即红外光信号和激光信号再在空间中传播。</p><hr><h3 id="8、物理层设备">8、物理层设备</h3><ul><li><u><strong>中继器</strong></u></li></ul><p><strong>诞生原因</strong>：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p><strong>中继器的功能</strong>：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-46-18.png" alt=""></p><p><strong>中继器的两端</strong>：</p><ol><li>两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议。 (中继器不会存储转发，傻)</li></ol><p><strong>5-4-3规则</strong>：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障.</p><ol><li>不超过5个网段</li><li>最多有4个物理层网络设备（中继器、集线器）</li><li>只有三个段可以挂接计算机</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-51-38.png" alt=""></p><hr><ul><li><u><strong>集线器</strong></u></li></ul><p><strong>集线器的功能</strong>：对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_15-53-44.png" alt=""></p><p>集线器不能分割冲突域。</p><p>连在集线器上的工作主机平分宽带。</p><hr><h2 id="第三章、数据链路层">第三章、数据链路层</h2><h3 id="1、数据链路层功能概述">1、数据链路层功能概述</h3><ul><li><u><strong>数据链路层的基本概念</strong></u></li></ul><p><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p><p><strong>结点</strong>：主机、路由器。</p><p><strong>链路</strong>：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的<strong>逻辑通道</strong>，把实现控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><hr><ul><li><u><strong>数据链路层的功能概述</strong></u></li></ul><p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p><p>功能一：为网络层提供服务。<strong>无确认无连接服务</strong>，<strong>有确认无连接服务</strong>，<strong>有确认面向连接服务</strong>。【有连接一定有确认!】<br>功能二：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。<br>功能三：组帧。<br>功能四：流量控制。限制发送方<br>功能五：差错控制(帧错/位错)</p><hr><h3 id="2、封装成帧和透明传输">2、封装成帧和透明传输</h3><ul><li><u><strong>封装成帧</strong></u></li></ul><p><strong>封装成帧</strong>就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p><p>首部和尾部包含许多的控制信息，他们的一个重要作用：<strong>帧定界</strong>(确定的界限)。</p><p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p><strong>组帧的四种方法</strong>：1.字符计数法，2.字符(节) 填充法，3.零比特填充法，4.违规编码法。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_16-48-15.png" alt=""></p><hr><ul><li><u><strong>透明传输</strong></u></li></ul><p><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。</p><p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这档各层的传输是透明的。</p><hr><ul><li><u><strong>1.字符计数法</strong></u></li></ul><p>帧首部使用一个计数字段(第一个<strong>字节</strong>，八位) 来标明帧内字符数。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_16-54-12.png" alt=""></p><p>痛点：如果前面的帧的计数字段改变，会导致后面的全部发送错误</p><hr><ul><li><u><strong>2.字符填充法</strong></u></li></ul><p>前导：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_16-55-42.png" alt=""></p><ol><li>当传送的帧是由文本文件组成时 (文本文件的字符都是从键盘上输入的，都是ASCII码）。不管从键盘上输入什么字符都可以放在帧里传过去，即<strong>透明传输</strong>。</li><li>当传送的帧是由非ASCII码的文本文件组成时(二进制代码的程序或图像等)。就要采用<strong>字符填充方法</strong>实现透明传输。</li></ol><p><strong>字符填充法</strong>：</p><p>填充的字节类似转义字符，这里的作用是告知下一个是正常数据，而不是控制信。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_16-57-48.png" alt=""></p><hr><ul><li><u><strong>3.零比特填充法</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_17-00-58.png" alt=""></p><p>操作:</p><ol><li><p>在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。</p><p>0110111111110111110010（原始数据）</p><p>011011111<strong>0</strong>111011111<strong>0</strong>0010（填充0）</p></li><li><p>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除。</p><p>011011111<strong>0</strong>111011111<strong>0</strong>0010（接受数据）</p><p>0110111111110111110010（删除0）</p></li></ol><hr><ul><li><u><strong>4.违规编码法</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_17-08-59.png" alt=""></p><p>可以用“<strong>高-高</strong>“，”<strong>低-低</strong>”来定界的起始和终止</p><p>由于字节计数法中Count字段的脆弱性(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性，<strong>目前较普遍使用的帧同步法是<u>零比特填充法</u>和<u>违规编码法</u></strong>。</p><hr><h3 id="3、差错控制（检错编码）">3、差错控制（检错编码）</h3><ul><li><u><strong>差错从何而来?</strong> </u></li></ul><p>概括来说，传输中的差错都是由于噪声引起的。</p><p><strong>全局性</strong>：由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的</p><p>    解决办法：提高信噪比来减少或避免干扰。(对传感器下手)</p><p><strong>局部性</strong>：外界特定的短暂原因所造成的冲击噪声，是产生差错 的主要原因</p><p>    解决办法：通常利用编码技术来解决。</p><p>差错：</p><ol><li>位错：比特位出错，1变为0， 0变为1。</li><li>帧错：假设原始数据为【#1】-【#2】-【#3】<ul><li>丢失：【#1】-【#3】</li><li>重复：【#1】-【#2】-【#2】-【#3】</li><li>失序：【#1】-【#3】-【#2】</li></ul></li></ol><p>链路层为网络层提供服务：<strong>无确认无连接服务</strong>（通信质量<strong>好</strong>，<strong>有线</strong>传输链路），<strong>有确认无连接服务和有确认面向连接服务</strong>（通信质量<strong>差</strong>的<strong>无线</strong>传输链路（后面两个））。</p><hr><ul><li><u><strong>数据链路层的差错控制</strong></u></li></ul><p>差错控制（比特错）：</p><ol><li><strong>检错编码</strong>：<ul><li>奇偶校验码</li><li>循环冗余码CRC</li></ul></li><li><strong>纠错编码</strong>：海明码</li></ol><p><strong>编码 VS 编码</strong>：</p><p>数据链路层编码和物理层的数据编码与调制不同。物理层编码针对的是<strong>单个比特</strong>，解决传输过程中比特的同步等问题，如曼彻斯特编码。而数据链路层的编码针对的是<strong>一组比特</strong>，它通过几余码的技术实现一组二进制比特串在传输过程是否出现了差错。</p><p><strong>冗余编码</strong>：</p><p>在数据发送之前，先按某种关系<strong>附加</strong>上一定的<strong>冗余位</strong>，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否仍符合原规则，从而判断是否出错。</p><hr><ul><li><u><strong>检错编码——奇偶校验码</strong></u></li></ul><p>奇偶校验码（1位校验位，其他为信息）</p><ol><li><p>奇校验码：“1”的个数为奇数</p><p>生成时：信息中“1”为偶数，校验位为“1”；信息中“1”为奇数，校验位为“0”</p><p>检测时：“1”的个数不为奇数则发生错误</p></li><li><p>偶校验码：“1”的个数为偶数</p><p>生成时：信息中“1”为偶数，校验位为“0”；信息中“1”为奇数，校验位为“1”</p><p>检测时：“1”的个数不为偶数则发生错误</p></li></ol><p><strong>例题</strong>：如果一个字符S的ASCI编码从低到高依次为1100101，采用奇校验，在下述收到的传输后字符中，哪种错误不能检测<br>   A.11000011 B.11001010 C.11001100 <strong>D.11010011</strong></p><p>奇偶校验码特点：<br>只能检查出奇数个比特错误，检错能力为50%（奇数个比特位出错，才能检验出来）</p><hr><ul><li><u><strong>检错编码——CRC循环冗余码</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_19-18-31.png" alt=""></p><p><strong>接收端检错过程</strong>：</p><p>把收到的每一个帧都除以同样的除数，然后检查得到的余数R。</p><ol><li>余数为0，判定这个帧没有差错，<strong>接受</strong></li><li>余数为不为0，判定这个有差错 (无法确定到位)，<strong>丢弃</strong></li></ol><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速因此不会延误数据的传输。</p><p>  在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”</p><p>“可靠传输”：数据链路层发送端发送什么，接收端就收到什么。<br>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</p><hr><h3 id="4、差错控制（纠错编码）">4、差错控制（纠错编码）</h3><ul><li><strong><u>海明距离</u></strong></li></ul><p>两个合法编码(码字)的对应比特取值不同的比特数称为这两个码字的海明距离(码距)，一个有效编码集中,任意两个合法编码(码字)的海明距离的最小值称为该编码集的海明距离(码距)。</p><p>例如：<br>{000,001,010,001,100,101,110,111} → 码距为1<br>{0000,1001,1010,0011,1100,0101,0110,1111} → 码距为2 → 显然可以检测出一位错，但是不可以纠正</p><p>记住两个结论就行：<br>1、要检测 <strong>d</strong> 位错 → 码距 <strong>d+1</strong><br>2、要纠正 <strong>d</strong> 位错 → 码距 <strong>2d+1</strong></p><hr><ul><li><u><strong>纠错编码——海明码</strong></u></li></ul><p>海明码：<strong>发现双</strong>比特错，<strong>纠正单</strong>比特错</p><p>工作原理：<strong>牵一发而动全身</strong></p><p>工作流程：确定校验码位数r <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 确定校验码和数据的位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 求出校验码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 检错并纠错</p><hr><ul><li><u><strong>1.确定校验码位数r</strong></u></li></ul><p><strong>海明不等式</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>r</mi></msup><mo>≥</mo><mi>k</mi><mo>+</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^r \ge k + r + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8004em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>  (r为冗余位，k为信息位)</p><p><strong>举例：要发送的数据为：D = 101101</strong><br>数据的位数k=6，<br>满足不等式的<strong>最小r</strong>为4,<br>也就是D = 101101的海明码应该有6+4=10位，<br>其中原数据6位，效验码4位。</p><hr><ul><li><u><strong>2.确定校验码和数据的位置</strong></u></li></ul><p>假设这4位校验码分别为P1、P2、P3、P4；数据从左到右为D1、D2、…、D6。</p><p>P1、P2、P3、P4<strong>放在2的几次方位</strong>：</p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">代码</td><td style="text-align:center"><strong>p1</strong></td><td style="text-align:center"><strong>p2</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>p3</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>p4</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>D1、D2、…、D6<strong>按序填满</strong>:</p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">代码</td><td style="text-align:center">p1</td><td style="text-align:center">p2</td><td style="text-align:center"><strong>D1</strong></td><td style="text-align:center">p3</td><td style="text-align:center"><strong>D2</strong></td><td style="text-align:center"><strong>D3</strong></td><td style="text-align:center"><strong>D4</strong></td><td style="text-align:center">p4</td><td style="text-align:center"><strong>D5</strong></td><td style="text-align:center"><strong>D6</strong></td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>1</strong></td></tr></tbody></table><hr><ul><li><u><strong>3.求出校验码</strong></u></li></ul><p><strong>令所有要检验的位异或=0</strong></p><p>P1: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>5</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p1 \oplus D1 \oplus D2 \oplus D4 \oplus D5 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mi>p</mi><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Rightarrow p1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">二进制</td><td style="text-align:center">000<strong>1</strong></td><td style="text-align:center">0010</td><td style="text-align:center">001<strong>1</strong></td><td style="text-align:center">0100</td><td style="text-align:center">010<strong>1</strong></td><td style="text-align:center">0110</td><td style="text-align:center">011<strong>1</strong></td><td style="text-align:center">1000</td><td style="text-align:center">100<strong>1</strong></td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">代码</td><td style="text-align:center"><strong>p1</strong></td><td style="text-align:center">p2</td><td style="text-align:center"><strong>D1</strong></td><td style="text-align:center">p3</td><td style="text-align:center"><strong>D2</strong></td><td style="text-align:center">D3</td><td style="text-align:center"><strong>D4</strong></td><td style="text-align:center">p4</td><td style="text-align:center"><strong>D5</strong></td><td style="text-align:center">D6</td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">1</td></tr></tbody></table><p>p2:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>6</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p2 \oplus D1 \oplus D3 \oplus D4 \oplus D6 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mi>p</mi><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Rightarrow p2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">二进制</td><td style="text-align:center">0001</td><td style="text-align:center">00<strong>1</strong>0</td><td style="text-align:center">00<strong>1</strong>1</td><td style="text-align:center">0100</td><td style="text-align:center">0101</td><td style="text-align:center">01<strong>1</strong>0</td><td style="text-align:center">01<strong>1</strong>1</td><td style="text-align:center">1000</td><td style="text-align:center">1001</td><td style="text-align:center">10<strong>1</strong>0</td></tr><tr><td style="text-align:center">代码</td><td style="text-align:center">p1</td><td style="text-align:center"><strong>p2</strong></td><td style="text-align:center"><strong>D1</strong></td><td style="text-align:center">p3</td><td style="text-align:center">D2</td><td style="text-align:center"><strong>D3</strong></td><td style="text-align:center"><strong>D4</strong></td><td style="text-align:center">p4</td><td style="text-align:center">D5</td><td style="text-align:center"><strong>D6</strong></td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center"><strong>1</strong></td></tr></tbody></table><p>p3: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p3 \oplus D2 \oplus D3 \oplus D4 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mi>p</mi><mn>3</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Rightarrow p3 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">二进制</td><td style="text-align:center">0001</td><td style="text-align:center">0010</td><td style="text-align:center">0011</td><td style="text-align:center">0<strong>1</strong>00</td><td style="text-align:center">0<strong>1</strong>01</td><td style="text-align:center">0<strong>1</strong>10</td><td style="text-align:center">0<strong>1</strong>11</td><td style="text-align:center">1000</td><td style="text-align:center">1001</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">代码</td><td style="text-align:center">p1</td><td style="text-align:center">p2</td><td style="text-align:center">D1</td><td style="text-align:center"><strong>p3</strong></td><td style="text-align:center"><strong>D2</strong></td><td style="text-align:center"><strong>D3</strong></td><td style="text-align:center"><strong>D4</strong></td><td style="text-align:center">p4</td><td style="text-align:center">D5</td><td style="text-align:center">D6</td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>p4: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>5</mn><mo>⊕</mo><mi>D</mi><mn>6</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p4 \oplus D5 \oplus D6 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mi>p</mi><mn>4</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\Rightarrow p4 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">二进制</td><td style="text-align:center">0001</td><td style="text-align:center">0010</td><td style="text-align:center">0011</td><td style="text-align:center">0100</td><td style="text-align:center">0101</td><td style="text-align:center">0110</td><td style="text-align:center">0111</td><td style="text-align:center"><strong>1</strong>000</td><td style="text-align:center"><strong>1</strong>001</td><td style="text-align:center"><strong>1</strong>010</td></tr><tr><td style="text-align:center">代码</td><td style="text-align:center">p1</td><td style="text-align:center">p2</td><td style="text-align:center">D1</td><td style="text-align:center">p3</td><td style="text-align:center">D2</td><td style="text-align:center">D3</td><td style="text-align:center">D4</td><td style="text-align:center"><strong>p4</strong></td><td style="text-align:center"><strong>D5</strong></td><td style="text-align:center"><strong>D6</strong></td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>1</strong></td></tr></tbody></table><p>所以海明码为<strong>00</strong>1<strong>0</strong>011<strong>1</strong>01</p><hr><ul><li><u><strong>4.检错并纠错</strong></u></li></ul><table><thead><tr><th style="text-align:center">数据位</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center"><strong><u>5</u></strong></th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">二进制</td><td style="text-align:center">0001</td><td style="text-align:center">0010</td><td style="text-align:center">0011</td><td style="text-align:center">0100</td><td style="text-align:center"><strong><u>0101</u></strong></td><td style="text-align:center">0110</td><td style="text-align:center">0111</td><td style="text-align:center">1000</td><td style="text-align:center">1001</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">代码</td><td style="text-align:center"><strong>p1</strong></td><td style="text-align:center"><strong>p2</strong></td><td style="text-align:center">D1</td><td style="text-align:center"><strong>p3</strong></td><td style="text-align:center"><u><strong>D2</strong></u></td><td style="text-align:center">D3</td><td style="text-align:center">D4</td><td style="text-align:center"><strong>p4</strong></td><td style="text-align:center">D5</td><td style="text-align:center">D6</td></tr><tr><td style="text-align:center">实际值</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong><u>1</u></strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>假设现在第五位发生了错误：0变成1</p><p><strong>令所有要检验的位进行异或运算</strong>：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>5</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p1 \oplus D1 \oplus D2 \oplus D4 \oplus D5 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>1</mn><mo>⊕</mo><mi>D</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>6</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p2 \oplus D1 \oplus D3 \oplus D4 \oplus D6 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>2</mn><mo>⊕</mo><mi>D</mi><mn>3</mn><mo>⊕</mo><mi>D</mi><mn>4</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p3 \oplus D2 \oplus D3 \oplus D4 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>4</mn><mo>⊕</mo><mi>D</mi><mn>5</mn><mo>⊕</mo><mi>D</mi><mn>6</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p4 \oplus D5 \oplus D6 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mi>p</mi><mn>4</mn><mi>p</mi><mn>3</mn><mi>p</mi><mn>2</mn><mi>p</mi><mn>1</mn><mo>=</mo><mn>0101</mn></mrow><annotation encoding="application/x-tex">\Rightarrow p4 p3 p2 p1 = 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">4</span><span class="mord mathnormal">p</span><span class="mord">3</span><span class="mord mathnormal">p</span><span class="mord">2</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0101</span></span></span></span> 所以可以看出第五位出错了</p><hr><h3 id="5、流量控与可靠传输机制">5、流量控与可靠传输机制</h3><ul><li><u><strong>数据链路层的流量控制</strong></u></li></ul><p><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。网络层是整个网络的流量控制。</p><p>数据链路层流量控制手段: 接收方收不下就不回复确认。</p><p>传输层流量控制手段: 接收端给发送端一个窗口公告</p><hr><ul><li><u><strong>流量控制的方法</strong></u></li></ul><ol><li><strong>停止-等待协议</strong>：发送窗口大小=1，接收窗口大小=1</li></ol><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_20-27-57.png" alt=""></p><ol start="2"><li><p><strong>滑动窗口协议</strong></p><ul><li><p><strong>后退N帧协议</strong>（GBN）：发送窗口大小&gt;1，接收窗口大小=1</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_20-32-16.png" alt=""></p></li><li><p><strong>选择重传协议</strong>（SR）：发送窗口大小&gt;1，接收窗口大小&gt;1</p></li></ul></li></ol><hr><ul><li><u><strong>可靠传输、滑动窗口、流量控制</strong></u></li></ul><p>可靠传输：发送端发啥，接收端收啥。<br>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</p><p>滑动窗口解决了：</p><ol><li>流量控制(收不下就不给确认，想发也发不了)</li><li>可靠传输(发送方自动重传)</li></ol><hr><h3 id="6、停止-等待协议">6、停止-等待协议</h3><ul><li><u><strong>停止-等待协议究竟是哪一层的</strong>？</u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_20-39-29.png" alt=""></p><p>发展后：数据链路层 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 传输层</p><hr><ul><li><u><strong>停止-等待协议</strong></u></li></ul><ol><li><p><strong>为什么要有停止-等待协议</strong>?<br>除了<strong>比特出差错</strong>，底层信道还会出现丢包问题为了实现流量控制。<br>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。</p></li><li><p><strong>研究停等协议的前提</strong>?<br>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据(发送方)，一方接收数据(接收方)。<br>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。<br>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p></li><li><p><strong>停等协议有几种应用情况</strong>？<br>无差错情况和有差错情况</p></li></ol><hr><ul><li><u><strong>停止-等待协议——无差错情况</strong></u></li></ul><p>每发送1个数据帧就停止并等待，因此用1bit来编号就够</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_22-49-30.png" alt=""></p><hr><ul><li><u><strong>停止-等待协议——有差错情况</strong></u></li></ul><p><strong>1、数据帧丢失或检测到帧出错</strong></p><p>超时计时器：每次发送一个帧就启动一个计时（超时计时器设置的重传时间应当比帧传输的平均RTT更长一些）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_22-52-40.png" alt=""></p><p>注意：</p><ol><li>发完一个帧后，必须保留它的副本。</li><li>数据帧和确认帧必须编号。</li></ol><p><strong>2、ACK丢失</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_22-54-55.png" alt=""></p><p><strong>3、ACK迟到</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_22-56-02.png" alt=""></p><hr><ul><li><u><strong>停止-等待协议——性能分析</strong></u></li></ul><p>简单，但是<strong>信道利用率太低</strong>！</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_22-58-08.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>信道利用率</mtext><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">信道利用率U = \frac{T_D}{T_D + RTT + T_A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">信道利用率</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3339em;vertical-align:-0.4453em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8886em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">RTT</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4103em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4453em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><hr><ul><li><u><strong>信道利用率</strong></u></li></ul><p><strong>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</strong>。</p><p>信道利用率 = (L / C) / T<br>T：发送周期<br>L：T内发送L比特数据<br>C：发送方数据传输率</p><p><strong>信道吞吐率 = 信道利用率 * 发送方的发送速率</strong></p><p>例题：一个信道的数据传输率为4kb/s，单向传播时延为30ms，如果使停止-等待协议的信道最大利用率达到80%要求的数据帧长度至少为?</p><p>解析：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>80</mn><mi mathvariant="normal">%</mi><mo>=</mo><mfrac><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>30</mn><mi>m</mi><mi>s</mi></mrow></mfrac><mo>=</mo><mfrac><mi>L</mi><mrow><mi>L</mi><mo>+</mo><mn>2</mn><mo>×</mo><mn>30</mn><mi>m</mi><mi>s</mi><mo>×</mo><mn>4</mn><mi>k</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">80\% = \frac{L/4}{L/4 + 2\times30ms} = \frac{L}{L + 2 \times 30ms \times 4kb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">80%</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">/4</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord mtight">30</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">/4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3923em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord mtight">30</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">×</span><span class="mord mtight">4</span><span class="mord mathnormal mtight">kb</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, L = 960bit</p><hr><h3 id="7、后退N帧协议（GBN）">7、后退N帧协议（GBN）</h3><ul><li><u><strong>停止-等待协议的弊端</strong></u></li></ul><p>信道利用率太低了</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-12-29.png" alt=""></p><p>要求：<br>1、必须增加序号范围<br>2、发送方需要缓存多个分组。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>后退N帧协议（GBN）选择重传协（SR）</strong> 。</p><hr><ul><li><u><strong>后退N帧协议中的滑动窗口</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-16-04.png" alt=""></p><hr><ul><li><u><strong>GBN发送方必须响应的三件事</strong></u></li></ul><ol><li><strong>上层的调用</strong><br>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送；如果<strong>窗口已满</strong>发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧)。</li><li><strong>收到了一个ACK</strong><br>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。（就是说不用每一个都返回一个确认帧）</li><li><strong>超时事件</strong><br>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧（因为后面的肯定不会被接收）。</li></ol><hr><ul><li><u><strong>GBN接收方要做的事</strong></u></li></ul><ol><li><p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p></li><li><p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息: expectedseqnum (下一个按序接收的帧序号)。</p></li></ol><hr><ul><li><u><strong>运行中的GBN</strong></u></li></ul><p>假设发送窗口尺寸为 4 。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-24-54.png" alt=""></p><hr><ul><li><u><strong>滑动窗口的长度</strong></u></li></ul><p>窗口长度可以无限吗？当然不行！</p><p>若采用n个比特对帧编号，那么发送窗口的尺寸<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">W_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应满足: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>W</mi><mi>T</mi></msub><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \le W_T \le 2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><hr><ul><li><u><strong>GBN协议重点总结</strong></u></li></ul><ol><li><strong>累积确认(偶尔捎带确认</strong> (全双工，互相通信的嘛，捎带一下确认帧) <strong>)</strong></li><li>接收方只按顺序接收帧，不按序无情丢弃</li><li>确认序列号最大的、按序到达的帧</li><li>发送窗口最大为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，接收窗口大小为1</li></ol><hr><ul><li><u><strong>习题</strong></u></li></ul><p>数据链路层采用了后退N帧(GBN)协议，发送方已经发送了编号为0~7的。当计时器超时时，若发送方只收到0、2、3号顿的确认，则发送方需要重发的帧数是(       )<br>  A.2 B.3 <strong>C.4</strong> D.5</p><p>解析：需要重发4、5、6、7帧</p><hr><ul><li><u><strong>GBN协议性能分析</strong></u></li></ul><p>因连续发送数据帧而提高了信道利用率；<br>在重传时必须把原来已经正确传送的数据帧重传，使传送效率降低。</p><hr><h3 id="8、选择重传协议（SR）">8、选择重传协议（SR）</h3><ul><li><u><strong>GBN协议的弊端</strong></u></li></ul><p><strong>累计确认 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 批量重传</strong></p><p>想法：<strong>可不可以只重传出错的帧</strong>?<br>解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><hr><ul><li><u><strong>选择重传协议的滑动窗口</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-40-06.png" alt=""></p><hr><ul><li><u><strong>SR发送方必须响应的三件事</strong></u></li></ul><ol><li><strong>上层的调用</strong><br>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧：否则就像GBN一样，要么将数据<strong>缓存</strong>，要么<strong>返回给上层</strong>之后再传输。</li><li><strong>收到了一个ACK</strong><br>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</li><li><strong>超时事件</strong><br>每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</li></ol><hr><ul><li><u><strong>SR接收方要做的事</strong></u></li></ul><p><strong>来者不拒(窗口内的帧)</strong><br>SR接收方将<strong>确认一个正确接收的帧</strong>而<strong>不管其是否按序</strong>。失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧【<strong>收谁确认谁</strong>】，直到所有(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后<strong>向前移动滑动窗口</strong>。</p><p>如果收到了窗口序号外 (小于窗口下界)的顿，就返回一个ACK其他情况，就忽略该帧。</p><hr><ul><li><u><strong>运行中的SR</strong></u></li></ul><p>假设发送窗口和接收窗口尺寸都为 4 。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-51-56.png" alt=""></p><hr><ul><li><u><strong>滑动窗口的长度</strong></u></li></ul><p>窗口长度可以无限吗？当然不行！</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_23-57-22.png" alt=""></p><p>若采用n个比特对帧编号：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>T</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>R</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">W_{Tmax} = W_{Rmax} = 2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><hr><ul><li><u><strong>SR协议重点总结</strong></u></li></ul><ol><li>对数据恢逐一确认，收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>T</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>R</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">W_{Tmax} = W_{Rmax} = 2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li></ol><hr><ul><li><u><strong>习题</strong></u></li></ul><p>数据链路层采用了选择重传(SR)协议，发送方已经发送了编号为0~3的。现已收到1号的确认，而0、2号帧依次超时，则发送方需要重传的帧数是(    )</p><p>  <strong>A.2</strong> B.3 C.4 D.5</p><p>解析：需要重发0、2帧</p><hr><h3 id="9、信道划分介质访问控制">9、信道划分介质访问控制</h3><ul><li><u><strong>传输数据使用的两种链路</strong></u><ul><li><p><strong>点对点链路</strong><br>两个相邻节点通过一个链路相连，没有第三者。<br>应用：PPP协议，常用于<strong>广域网</strong></p></li><li><p><strong>广播式链路</strong><br>所有主机共享通信介质。<br>应用：早期的总线以太网、无线局域网，常用于<strong>局域网</strong>。<br>典型拓扑结构：总线型、星型(逻辑总线型)</p></li></ul></li></ul><hr><ul><li><p><u><strong>介质访问控制</strong></u></p><p>介质访问控制的内容就是，采取一定的措施，使得两对节点之间的通信<strong>不会发生互相干扰</strong>的情况。</p><ul><li><p><strong>静态划分信道</strong></p><ul><li><strong>信道划分介质访问控制</strong><ol><li><strong>频分多路复用 FDM</strong></li><li><strong>时分多路复用 TDM</strong></li><li><strong>波分多路复用 WDM</strong></li><li><strong>码分多路复用 CDM</strong></li></ol></li></ul></li><li><p><strong>动态划分信道</strong></p><p><em>动态媒体接入控制/多点接入</em></p><p>特点：信道并非在用户通信时固定分配给用户。</p><ul><li><p><strong>轮询访问介质访问控制</strong></p><ol><li>轮询协议</li><li><strong>令牌传递协议</strong></li></ol></li><li><p><strong>随机访问介质访问控制</strong></p><p>所有用户可随机发送信息。<br>发送信息时占<strong>全部带宽</strong>。</p><ol><li><strong>ALOHA 协议</strong>（不听（监听信道）就说）</li><li><strong>CSMA 协议</strong>（先听再说）</li><li><strong>CSMA/CD 协议</strong>（先听再说，边听边说）</li><li><strong>CSMA/CA 协议</strong></li></ol></li></ul></li></ul></li></ul><hr><ul><li><u><strong>信道划分介质访问控制</strong></u></li></ul><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离</strong>开，把<strong>时域和频域资源</strong>合理地分配给网络上的设备。</p><p><strong>多路复用技术</strong>：<br>把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_15-41-59.png" alt=""></p><p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，<strong>实际就是把广播信道转变为点对点信道</strong>。</p><hr><ul><li><u><strong>频分多路复用 FDM</strong></u></li></ul><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽(频率带宽）资源</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_15-44-55.png" alt=""></p><p>充分利用传输介质带宽，系统<strong>效率较高</strong>；<br>由于技术比较成熟，实现也比较<strong>容易</strong>。</p><hr><ul><li><u><strong>时分多路复用 TDM</strong></u></li></ul><p>将时间划分为一段段等长的时分复用帧 (TDM帧)。每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_15-47-39.png" alt=""></p><p><strong>频分 VS 时分</strong>：</p><p>频分复用——“并行”<br>时分复用——“并发“</p><hr><ul><li><u><strong>改进的时分复用——统计时分复用STDM</strong></u></li></ul><p>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的<strong>输入缓存</strong>，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM顺中，一个STDM顺满了就发出。<strong>STDM帧不是固定分配时隙，而是按需动态分配时隙</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_15-52-16.png" alt=""></p><p>假设信道带宽为 8000 b/s：<br>时分多路复用 TDM：一人最高 2000 b/s<br>统计时分多路复用 STDM：一人最高 8000 b/s</p><hr><ul><li><u><strong>波分多路复用 WDM</strong></u></li></ul><p>波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_15-55-57.png" alt=""></p><hr><ul><li><u><strong>码分多路复用 CDM</strong></u></li></ul><p>码分多址 (CDMA)是码分复用的一种方式。</p><p>1个比特分为多个码片/芯片 (chip)，每一个站点被指定一个唯一的m位的芯片序列。</p><p>发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1)</p><p><strong>如何不打架</strong>：多个站点同时发送数据的时候，要求各个站点芯片序列<strong>相互正交</strong>（等于0才行）。</p><p><strong>如何合并</strong>：各路数据在信道中被<strong>线性相加</strong>。</p><p><strong>如何分离</strong>：合并的数据和源站<strong>规格化内积</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_16-37-46.png" alt=""></p><hr><h3 id="10、ALOHA-协议">10、ALOHA 协议</h3><ul><li><u><strong>ALOHA 协议</strong></u><ul><li>纯ALOHA 协议</li><li>时隙ALOHA 协议</li></ul></li></ul><hr><ul><li><u><strong>纯ALOHA 协议</strong></u></li></ul><p>纯ALOHA协议思想：不监听信道，不按时间槽发送，随机重发。<strong>想发就发</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_18-09-43.png" alt=""></p><p><strong>冲突如何检测</strong>?<br>如果发生冲突，接收方在就会检测出差错,然后不予确认，发送方在一定时间内收不到就判断发生冲突。<br><strong>冲突如何解决</strong>?<br>超时后等一随机时间再重传</p><hr><ul><li><u><strong>时隙ALOHA 协议</strong></u></li></ul><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。<strong>控制想发就发的随意性</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_18-12-14.png" alt=""></p><hr><ul><li><u><strong>关于ALOHA要知道的事</strong></u></li></ul><ol><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li></ol><hr><h3 id="11、CSMA协议">11、CSMA协议</h3><ul><li><p><u><strong>CSMA协议</strong></u></p><p><strong>载波监听多路访问协议CSMA (carrier sense multiple access)</strong></p><ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>p-坚持CSMA</li></ul></li></ul><p><strong>CS</strong>：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。<br>当几个站同时在总线上发送数据时，总线上的信号<strong>电压摆动值</strong>将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p><p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上</p><p><strong>协议思想</strong>：发送帧之前，<strong>监听</strong>信道</p><p>监听结果：</p><ol><li>信道空闲：<strong>发送完整帧</strong></li><li>信道忙：<strong>推迟发送</strong></li></ol><hr><ul><li><u><strong>1-坚持CSMA</strong></u></li></ul><p>坚持指的是对于监听信道<strong>忙</strong>之后的坚持。</p><p>1-坚持CSMA<strong>思想</strong>：如果一个主机要发送消息，那么它先监听信道。</p><p><strong>空闲则直接传输，不必等待</strong>。</p><p><strong>忙则一直监听</strong>，直到空闲马上传输。</p><p>如果有<strong>冲突</strong>(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</p><p><strong>优点</strong>：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p><p><strong>缺点</strong>：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p><hr><ul><li><u><strong>非坚持CSMA</strong></u></li></ul><p>非坚持指的是对于监听信道<strong>忙</strong>之后就不继续监听。</p><p>非坚持CSMA<strong>思想</strong>： 如果一个主机要发送消息，那么它先监听信道；</p><p><strong>空闲则直接传输，不必等待</strong>；</p><p><strong>忙则等待一个随机的时间之后再进行监听</strong>。</p><p><strong>优点</strong>：采用随机的重发延迟时间可以减少冲突发生的可能性。<br><strong>缺点</strong>：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</p><hr><ul><li><u><strong>p-坚持CSMA</strong></u></li></ul><p>p-坚持指的是对于监听信道<strong>空闲</strong>的处理。</p><p>p-坚持CSMA<strong>思想</strong>：如果一个主机要发送消息，那么它先监听信道；</p><p>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输；</p><p>忙则等待一个随机的时间之后再进行监听。</p><p><strong>优点</strong>：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</p><p><strong>BUT</strong>！：发生冲突后还是要坚持把数据帧发送完，造成了浪费</p><p>思考：有没有什么办法可以减少资源浪费冲突就能发现呢?（后面内容）</p><hr><h3 id="12、CSMA-CD协议">12、CSMA/CD协议</h3><ul><li><p><u><strong>CSMA/CD协议（考研重点）</strong></u></p><p><strong>载波监听多点接入/碰撞检测CSMA/CD (carrier sense multiple access with collision detection)</strong></p></li></ul><p><strong>CS</strong>：载波侦听/监听，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</p><p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（<strong>总线型网络</strong>）</p><p><strong>CD</strong>：碰撞检测(冲突检测)，“<strong>边发送边监听</strong>”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（<strong>半双工网络</strong>）</p><p><strong>先听后发为什么还会冲突</strong>？因为电磁波在总线上总是以有限的速率传播的</p><hr><ul><li><u><strong>传播时延对载波监听的影响</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_20-22-45.png" alt=""></p><p>最迟多久才能知道自己发送的数据没和别人碰撞?</p><p>答案：最多是两倍的总线端到端的传播时延<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>（即总线的端到端往返传播时延，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>也叫做争用期/冲突窗口/碰撞窗口）</p><p>推断：只要经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞。</p><hr><ul><li><u><strong>如何确认碰撞后重传的时间</strong>？</u></li></ul><p><strong>截断二进制指数规避算法</strong>：(二进制回退算法)</p><ol><li>确定基本退避（<strong>推迟</strong>）时间为争用期<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>。</li><li>定义参数<strong>k</strong>，它等于<strong>重传次数</strong>，但k不超过10，即<strong>k=min[重传次数，10]</strong>。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而一直等于10。</li><li>从离散的整数集合[0, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>]中随机取出一个数r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>r</mi><mtext> </mtext><mi>τ</mi></mrow><annotation encoding="application/x-tex">2r\,\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>。</li><li>当重传达<strong>16次</strong>仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol><p>举例：<br>第一次重传，k=1，r从{0，1}选；<br>重传推迟时间为0或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>，在这两个时间中随机选一个。<br>若再次碰撞，则在第二次重传时，k=2，r从0，1，2，3}选；<br>重传推迟时间为0或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">4\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">6\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>，在这四个时间中随机选一个。<br>若再次碰撞，则第三次重传时，k=3，r从{0，1，2，3，4，5，6，7}选…</p><p>结论：若连续多次发生冲突，就表明可能有较多的站参与争用信道使用此算法可使重传需要推迟的平均时间随重传次数的增大而增大，因而减小发生碰撞的概率，有利于整个系统的稳定</p><p><strong>例题</strong>：在以太网的二进制回退算法中，在11次碰撞之后，站点会在0~(?)之间选择一个随机数。（答案：1023）</p><hr><ul><li><u><strong>最小帧长</strong></u></li></ul><p>背景：</p><p>A站发了一个很短的帧，<br>但发生了碰撞，<br>不过帧在发送完毕后才检测到发生碰撞，<br>没法停止发送，<br>因为发完了。。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>最小帧长</strong></p><p>帧的传输时延至少要两倍于信号在总线中的传播时延</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mtext>帧长（</mtext><mi>b</mi><mi>i</mi><mi>t</mi><mtext>）</mtext></mrow><mtext>数据传输速率</mtext></mfrac><mo>≥</mo><mn>2</mn><mo>×</mo><mtext>传播时延</mtext></mrow><annotation encoding="application/x-tex">\frac{帧长（bit）}{数据传输速率} \ge 2 \times 传播时延</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数据传输速率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">帧长（</span><span class="mord mathnormal mtight">bi</span><span class="mord mathnormal mtight">t</span><span class="mord cjk_fallback mtight">）</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">传播时延</span></span></span></span> 即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mtext>帧长（</mtext><mi>b</mi><mi>i</mi><mi>t</mi><mtext>）</mtext></mrow><mtext>数据传输速率</mtext></mfrac><mo>≥</mo><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">\frac{帧长（bit）}{数据传输速率} \ge 2 \tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数据传输速率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">帧长（</span><span class="mord mathnormal mtight">bi</span><span class="mord mathnormal mtight">t</span><span class="mord cjk_fallback mtight">）</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo><mtext>最小帧长</mtext><mo>=</mo><mtext>总线传播时延</mtext><mo>×</mo><mtext>数据传播速率</mtext><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\Rightarrow 最小帧长=总线传播时延\times数据传播速率\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">最小帧长</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">总线传播时延</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">数据传播速率</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/><mspace width="2em"/><mspace width="1em"/><mtext> </mtext><mo>=</mo><mn>2</mn><mi>τ</mi><mo>×</mo><mtext>数据传播速率</mtext></mrow><annotation encoding="application/x-tex">\qquad\qquad\quad\,=2\tau\times数据传播速率</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">数据传播速率</span></span></span></span></p><p>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧</p><hr><h3 id="13、CSMA-CA协议">13、CSMA/CA协议</h3><ul><li><p><u><strong>CSMA/CA协议（非重点 了解即可）</strong></u></p><p><strong>载波监听多点接入/碰撞避免CSMA/CA (carrier sense multiple access with collision avoidance）</strong></p></li></ul><p>为什么要有CSMA/CA?</p><p>无线局域网：</p><ol><li>无法做到360°全面检测碰撞。</li><li>隐蔽站：<br>当A和c都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会导致冲突。（C相对于A来说就是一个隐蔽站，A相对于C也是）</li></ol><hr><ul><li><u><strong>CSMA/CA协议工作原理</strong></u></li></ul><p>发送数据前，先检测信道是否空闲。</p><p>空闲则发出<strong>RTS (request to send)</strong> ，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</p><p>接收端收到RTS后，将响应<strong>CTS (clear to send)</strong>。</p><p>发送端收到CTS后，开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）。</p><p>接收端收到数据帧后，将用<strong>CRC</strong>来检验数据是否正确，正确则响应<strong>ACK帧</strong>。</p><p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间)。</p><p>机制总结：</p><p><strong>1.预约信道      2.ACK帧       3.RTS/CTS帧(可选，解决隐蔽站问题）</strong></p><hr><ul><li><u><strong>CSMA/CD与CSMA/CA</strong></u></li></ul><p><strong>相同点</strong>:<br>CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心是<strong>先听再说</strong>。换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入。<br><strong>不同点</strong>:</p><ol><li><strong>传输介质不同</strong>：CSMA/CD 用于总线式以太网【有线】，而CSMA/CA用于无线局域网【无线】。</li><li><strong>载波检测方式不同</strong>：因传输质不同，CSMA/CD与CSMA/CA的检测方式也不同。CSMA/CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA/CA采用能量检测 (ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。</li><li><strong>CSMA/CD检测冲突，CSMA/CA避免冲突</strong>，二者出现冲突后都会进行<strong>有上限的重传</strong>。</li></ol><hr><h3 id="14、轮询访问介质访问控制">14、轮询访问介质访问控制</h3><ul><li><p><u><strong>介质访问控制</strong></u></p><ul><li><p>信道划分介质访问控制（<strong>MAC</strong> Multiple Access Control）协议：</p><p>基于<strong>多路复用技术</strong>划分资源<br><strong>网络负载重</strong>：共享信道效率高，且公平<br><strong>网络负载轻</strong>：共享信道效率低</p></li><li><p>随机访问MAC协议：<strong>只有这个会发生冲突</strong></p><p>用户根据意愿随机发送信息，发送信息时可独占信道带宽<br><strong>网络负载重</strong>：产生冲突开销<br><strong>网络负载轻</strong>：共享信道效率高，单个结点可利用信道全部带宽</p></li><li><p>轮询访问MAC协议/轮流协议/轮转访问MAC协议:</p><p>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong>。</p><ol><li>轮询协议</li><li><strong>令牌传递协议</strong></li></ol></li></ul></li></ul><hr><ul><li><u><strong>轮询协议</strong></u></li></ul><p><strong>主结点轮流“邀请”从属结点发送数据</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_19-49-13.png" alt=""></p><p>问题:<br>  1.轮询开销 2.等待延迟 3. 单点故障</p><hr><ul><li><u><strong>令牌传递协议</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_19-52-37.png" alt=""></p><p>令牌：一个特殊格式的MAC控制帧，不含任何信息控制信道的使用，确保同一时刻只有一个结点独占信道。</p><p><strong>令牌环网无碰撞</strong></p><p>每个结点都可以在一定的时间内 （令牌持有时间）获得发送数据的权利，并不是无限制地持有令牌。</p><p>问题:<br>  1.令牌开销 2.等待延迟 3.单点故障</p><p>应用于<strong>令牌环网</strong>（物理星型拓扑，<strong>逻辑环形拓扑</strong>）。</p><p>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</p><hr><h3 id="15、局域网的基本概念和体系结构">15、局域网的基本概念和体系结构</h3><ul><li><u><strong>局域网</strong></u></li></ul><p>局域网(Local Area Network)：简称<strong>LAN</strong>，是指在<strong>某一区域内</strong>由多台计算机互联成的计算机组，使用<strong>广播信道</strong>。</p><p>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。<br>特点2：使用专门铺设的传输介质(双绞线、同轴电缆) 进行联网，数据传输速率高(10Mb/s~10Gb/s)。<br>特点3：通信延迟时间短，误码率低，可靠性较高。<br>特点4：各站为平等关系，共享传输信道。<br>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p><p>决定局域网的主要要素为：<strong>网络拓扑</strong>，<strong>传输介质</strong>与<strong>介质访问控制方法</strong>。</p><hr><ul><li><u><strong>局域网拓扑结构</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_21-45-41.png" alt=""></p><p><strong>星型拓扑</strong>：</p><p>中心节点是控制中心，任意两介节点间的通信最多只需<strong>两步</strong>，传输速度快并且网络构形简单、建网容易、便于控制和管理但这种网络系统，网络可靠性低，网络共享能力差有<strong>单点故障</strong>问题。</p><p><strong>总线型拓扑</strong>：（局域网中常用）</p><p>网络可靠性高、网络节点间响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便当某个工作站节点出现故障时，对整个网络系统影响小。</p><p><strong>环型拓扑</strong>：</p><p>系统中通信设备和线路比较节省。有<strong>单点故障</strong>问题：由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p><p><strong>树型拓扑</strong>：</p><p>易于拓展，易于隔离故障，也容易有<strong>单点故障</strong>。</p><hr><ul><li><p><u><strong>局域网传播介质</strong></u></p><ul><li><p>有线局域网</p><p>双绞线、同轴电缆、光纤。</p></li><li><p>无线局域网</p><p>电磁波</p></li></ul></li></ul><hr><ul><li><u><strong>局域网介质访问控制方法</strong></u><ol><li>CSMA/CD  常用于<strong>总线型局域网</strong>，也用于树型网络</li><li>令牌总线  常用于<strong>总线型局域网</strong>，也用于树型网络<br>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li><li>令牌环  用于<strong>环形局域网</strong>，如令牌环网</li></ol></li></ul><hr><ul><li><u><strong>局域网分类</strong></u></li></ul><ol><li><strong>以太网</strong>：以太网是应用最为广泛的局域网，包括标准以太网(10Mbps)、快速以太网(100Mbps)、千兆以太网(1000 Mbps)和10G以太网，它们都符合<strong>IEEE802.3</strong>系列标准规范。逻辑拓总线型，物理拓扑是星型或拓展星型。使用CSMA/CD。</li><li><strong>令牌环网</strong>： 物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已是“明日黄花”</li><li><strong>FDDI网 (Fiber Distributed Data Interface)</strong> ：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</li><li><strong>ATM网 (Asynchronous Transfer Mode)</strong> ：较新型的单元交换技术,使用53字节固定长度的单元进行交换.</li><li><strong>无线局域网 (Wireless Local Area Network; WLAN)</strong> ：采用<strong>IEEE 802.11</strong>标准</li></ol><hr><ul><li><u><strong>IEEE 802标准</strong></u></li></ul><p>IEEE 802系列标准是IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准(<strong>1980年2月</strong>成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p><p>下面加粗的一定要记住：</p><table><thead><tr><th style="text-align:center">标准</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">IEEE 802.1</td><td>局城网体系结构、寻址、网络互联和网络。</td></tr><tr><td style="text-align:center">IEEE 802.1A</td><td>概述和系统结构。</td></tr><tr><td style="text-align:center">IEEE 802.1B</td><td>网络管理和网络互连。</td></tr><tr><td style="text-align:center">IEEE 802.2</td><td>逻辑链路控制子层 (LLC)的定义。</td></tr><tr><td style="text-align:center"><strong>IEEE 802.3</strong></td><td><strong>以太网介质访问控制协议 (CSMA/CD)及物理层技术规范</strong>。</td></tr><tr><td style="text-align:center">IEEE 802.4</td><td>令牌总线网 (Token-Bus)的介质访问控制协议及物理层技术规范。</td></tr><tr><td style="text-align:center"><strong>IEEE 802.5</strong></td><td><strong>令牌环网 (Token-Ring)的介质访问控制协议及物理层技术规范</strong>。</td></tr><tr><td style="text-align:center">IEEE 802.6</td><td>城城网介质访问控制协议DQDB (Distributed Queue Dual Bus 分布式队列双总线)及物理层技术规范。</td></tr><tr><td style="text-align:center">IEEE 802.7</td><td>宽带技术咨询组，提供有关宽带联网的技术咨询。</td></tr><tr><td style="text-align:center"><strong>IEEE 802.8</strong></td><td><strong>光纤技术咨询组，提供有关光纤联网的技术咨询</strong>。</td></tr><tr><td style="text-align:center">IEEE 802.9</td><td>综合声音数据的局城网 (IVD LAN)介质访问控制协议及物理层技术规范。</td></tr><tr><td style="text-align:center">IEEE 802.10</td><td>网络安全技术咨询组，定义了网络互操作的认证和加密方法。</td></tr><tr><td style="text-align:center"><strong>IEEE 802.11</strong></td><td><strong>无线局域网(WLAN)的介质访问控制协议及物理层技术规范</strong>。</td></tr><tr><td style="text-align:center">IEEE 802.11</td><td>1997年，原始标准(2Mbit/s，播在2.4GHz)。</td></tr><tr><td style="text-align:center">IEEE 802.11a</td><td>1999年，物理层补充 (54Mbit/s，播在5GHz)。</td></tr><tr><td style="text-align:center">IEEE 802.11b</td><td>1999年，物理层补充(11Mbit/s播在2.4GHz)。</td></tr></tbody></table><hr><ul><li><u><strong>LLC子层和MAC子层</strong></u></li></ul><p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的<strong>数据链路层</strong>与<strong>物理层</strong>，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_22-07-55.png" alt=""></p><p>【LLC子层】：LLC负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。为网络层提供服务：无确认无连接面向连接、带确认无连接、高速传送。</p><p>【MAC子层】：MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。</p><hr><h3 id="16、以太网">16、以太网</h3><ul><li><u><strong>以太网概述</strong></u></li></ul><p>以太网(<strong>Ethernet</strong>)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。以太网络使用<strong>CSMA/CD</strong> (载波监听多路访问及冲突检测）技术。</p><p>以太网在局域网各种技术中占<strong>统治性地位</strong>:</p><ol><li>造价低廉(以太网网卡不到100块) ；</li><li>是应用最广泛的局域网技术；</li><li>比令牌环网、ATM网便宜，简单；</li><li><strong>满足网络速率要求:10Mb/s~10Gb/s</strong>。</li></ol><p>以太网的<strong>两个标准</strong>：</p><p><strong>DIX Ethernet V2：第一个局域网产品(以太网)规约</strong>。</p><p>I<strong>EEE 802.3：IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准</strong>。</p><p>(两个标准的区别：帧格式有一丢丢改动)</p><hr><ul><li><u><strong>以太网提供无连接、不可靠服务</strong></u></li></ul><p>无连接：发送方和接收方之间无“握手过程”</p><p>不可靠：不对发送方的数据顿<strong>编号</strong>，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</p><p><strong>以太网只实现无差错接收，不实现可靠传输</strong>。</p><hr><ul><li><u><strong>以太网传输介质与拓扑结构的发展</strong></u></li></ul><p>粗同轴电缆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 细同轴电缆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 双绞线+集线器</p><p>物理拓扑：总线型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 星型（以太网目前最常用的物理拓扑）</p><p>使用集线器的以太网在逻辑上仍是一个总线网,各站共享逻辑上的总线，使用的还是协议</p><p>以太网拓扑：逻辑上总线型，物理上星型</p><hr><ul><li><u><strong>10BASE-T以太网</strong></u></li></ul><p>10BASE-T是传送<strong>基带信号</strong>的双绞线以太网，T表示采用双绞线，现10BASE-T 采用的是<strong>无屏蔽双绞线</strong>(UTP)，传输速率是<strong>10Mb/s</strong>。</p><p><strong>物理上采用星型拓扑，逻辑上总线型</strong>，每段双绞线最长为100m。</p><p>采用<strong>曼彻斯特编码。</strong></p><p>采用<strong>CSMA/CD</strong>介质访问控制。</p><hr><ul><li><u><strong>适配器与MAC地址</strong></u></li></ul><p>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。</p><p>网络接口板。</p><p>网络接口卡NIC (network interface card)。</p><p>现在不再使用单独网卡。</p><p>适配器上装有处理器和存储器 (包括RAM和ROM)。</p><p>ROM上有计算机硬件地址MAC地址。</p><p>在局域网中，硬件地址又称为物理地址，或<strong>MAC地址</strong>。【实际上是标识符】</p><p>MAC地址:每个适配器有一个<strong>全球唯一</strong>的48位二进制地址，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21。</p><hr><ul><li><u><strong>以太网MAC帧</strong></u></li></ul><p>最常用的MAC帧是以太网V2的格式。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_22-50-06.png" alt=""></p><p>源地址、目的地址：MAC地址</p><p>类型：指明网络层使用了什么协议</p><p>数据：46（64-6-6-2-4），1500（MTU）</p><p>FCS：看CRC那块——差错控制（检错编码）</p><p>帧开始定界符：为什么没有末尾定界符呢？以太网使用曼切斯特编码，当不发送数据的时候没有跳变了，就相当于结束了</p><p>前同步码：用来迅速实现MAC帧的比特同步</p><hr><ul><li><u><strong>高速以太网</strong></u></li></ul><p>速率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>100</mn><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\ge100Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">100</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>的以太网称为高速以太网</p><ol><li><p><strong>100BASE-T以太网</strong><br>在<strong>双绞线</strong>上传送<strong>100Mb/s基带信号</strong>的<strong>星型</strong>拓扑以太网，仍使用IEEE802.3的<strong>CSMA/CD</strong>协议。<br>支持全双工和半双工，可在全双工方式下工作而无冲突。</p></li><li><p>吉比特以太网<br>在<strong>光纤或双绞线</strong>上传送<strong>1Gb/s</strong>信号<br>支持全双工和半双工，可在全双工方式下工作而无冲突。</p></li><li><p>10吉比特<br>10吉比特以太网在<strong>光纤</strong>上传送<strong>10Gb/s</strong>信号。<br>只支持全双工，无争用问题。</p></li></ol><hr><h3 id="17、无线局域网">17、无线局域网</h3><ul><li><p><u><strong>IEEE 802.11</strong></u></p><p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准。</p></li></ul><p>WiFi？IEEE 802.11b、IEEE 802.11g</p><hr><ul><li><u><strong>802.11的MAC帧头格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-10_20-04-47.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_23-14-25.png" alt=""></p><p><img src="" alt=""></p><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">To DS</th><th style="text-align:center">From DS</th><th style="text-align:center">Adress1（接收端）</th><th style="text-align:center">Adress2（发送端）</th><th style="text-align:center">Adress3</th><th style="text-align:center">Adress4</th></tr></thead><tbody><tr><td style="text-align:center">IBSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">DA</td><td style="text-align:center">SA</td><td style="text-align:center">BSSID</td><td style="text-align:center">未使用</td></tr><tr><td style="text-align:center">To AP（基础结构型）</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">BSSID</td><td style="text-align:center">SA</td><td style="text-align:center">DA</td><td style="text-align:center">未使用</td></tr><tr><td style="text-align:center">From AP（基础结构型）</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">DA</td><td style="text-align:center">BSSID</td><td style="text-align:center">SA</td><td style="text-align:center">未使用</td></tr><tr><td style="text-align:center">WDS（无限分布式系统）</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">RA</td><td style="text-align:center">TA</td><td style="text-align:center">DA</td><td style="text-align:center">SA</td></tr></tbody></table><p>BSSID：基本服务集BSS标识符ID</p><p>AP：Access Point —— 接入点</p><hr><ul><li><u><strong>无线局域网分类</strong></u><ol><li><strong>有固定基础设施无线局域网</strong></li><li><strong>无固定基础设施无线局域网的自组织网络</strong></li></ol></li></ul><hr><ul><li><u><strong>有固定基础设施无线局域网</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_23-21-19.png" alt=""></p><hr><ul><li><u><strong>无固定基础设施无线局域网的自组织网络</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-31_23-23-13.png" alt=""></p><hr><h3 id="18、VLAN的基本概念及基本原理（新增考点）">18、VLAN的基本概念及基本原理（新增考点）</h3><ul><li><strong><u>传统局域网的局限</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-18-57.png" alt=""></p><p><strong>缺乏流量隔离</strong>：即使把组流量局域化道一个单一交换机中，广播流量仍会跨越整个机构网络(ARP、RIP、DHCP协议)</p><p><strong>管理用户不便</strong>：如果一个主机在不同组间移动，必须改变物理布线，连接到新的交换机上</p><p><strong>路由器成本较高</strong>：局域网内使用很多路由器花销较大。</p><hr><ul><li><strong><u>VLAN的基本概念</u></strong></li></ul><p>虚拟局域网VLAN (Virtual Local Area Network) 是一种<strong>将局域网内的设备划分成与物理位置无关的逻辑组的技术</strong>，这些逻辑组有某些共同的需求。每个VLAN是一个单独的广播域/不同的子网。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-22-25.png" alt=""></p><hr><ul><li><strong><u>VLAN的实现</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-27-30.png" alt=""></p><p>交换机上生成的各VLAN互不相通，若想实现通信，需要借助：路由器、三层交换机</p><ul><li>基于接口的VLAN技术：（更常用）</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-30-21.png" alt=""></p><ul><li>基于 MAC地址的VLAN技术：</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-30-31.png" alt=""></p><p>交换机之间如何实现？加tag</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-51-21.png" alt=""></p><hr><ul><li><strong><u>VLAN实现——IEEE 802.1Q帧</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-41-57.png" alt=""></p><p>插入四字节VLAN标记：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-42-18.png" alt=""></p><p>VLAN标记的前两个字节表明是IEEE 802.1Q，接下来4位没用，<strong>后面12位是VLAN标识符VID</strong>，唯一表示了该以太网帧属于哪个VLAN。</p><ul><li>VID的取值范围为0~4095，但0和4095都不用来表示VLAN，因此用于<strong>表示VLAN的有效VID取值范围为1~4094</strong></li><li>IEEE802.1Q帧是由交换机来处理的，而不是由用户主机来处理的。(即<strong>主机和交换机之间只交换普通的以太网帧</strong>)</li></ul><hr><ul><li><strong><u>练习</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-11_08-52-10.png" alt=""></p><p>Q1. A和E能否实现访问?<br>Q2. A和D、H能否实现访问?</p><p>ans：能；不能</p><hr><ul><li><strong><u>题目</u></strong></li></ul><p>以下关于虚拟局域网特性的描述中，错误的是(   )<br>A. 虚拟局域网是建立在局域网交换技术基础上的<br>B. 虚拟局域网可以将局域网上的结点划分成若干个[逻辑工作组]，那么一个逻辑工作组就是一个虚拟网络<br>C. 逻辑工作组的结点组成不受物理位置的限制<br>D. 虚拟网络建立在网络交换机之上，它以硬件方式来实现逻辑工作组的划分与管理</p><p>ans：D<br>VLAN以软件的方式实现逻辑分组和管理</p><hr><h3 id="19、PPP协议和HDLC协议">19、PPP协议和HDLC协议</h3><ul><li><u><strong>广域网</strong></u></li></ul><p>​广域网(WAN，Wide Area Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p><p>​广域网的通信子网主要使用<u><strong>分组交换</strong></u>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<u><strong>资源共享</strong></u>的目的。如因特网(Internet)是世界范围内最大的广域网。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-22-09.png" alt=""></p><hr><ul><li><u><strong>PPP协议的特点</strong></u></li></ul><p>点对点协议PPP (Point-to-Point Protocol) 是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p><p><strong>只支持<u>全双工</u>链路</strong>。</p><hr><ul><li><u><strong>PPP协议应满足的要求</strong></u></li></ul><p><strong>简单</strong> 对于链路层的帧，无需纠错，无需序号，无需流量控制。封装成帧 帧定界符</p><p><strong>透明传输</strong> 与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充。</p><p><strong>多种网络层协议</strong> 封装的IP数据报可以采用多种协议多种类型链路 串行/并行，同步/异步，电/光…</p><p><strong>差错检测</strong> 错就丢弃。</p><p><strong>检测连接状态</strong> 链路是否正常工作。</p><p><strong>最大传送单元</strong> 数据部分最大长度MTU。</p><p><strong>网络层地址协商</strong> 知道通信双方的网络层地址</p><p><strong>数据压缩协商</strong></p><hr><ul><li><u><strong>PPP协议无需满足的要求</strong></u></li></ul><p><strong>纠错</strong> 只需要检错</p><p><strong>流量控制</strong> 交给上层</p><p><strong>序号</strong> 无需对帧编号</p><p><strong>不支持多点线路</strong> 只需要点对点</p><hr><ul><li><u><strong>PPP协议的三个组成部分</strong></u><ol><li>一个将IP数据报封装到串行链路（同步串行/异步串行）的方法。</li><li>链路控制协议<strong>LCP</strong>：建立并维护数据链路连接。 身份验证</li><li>网络控制协议<strong>NCP</strong>：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li></ol></li></ul><hr><ul><li><u><strong>PPP协议的状态图</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-33-02.png" alt=""></p><hr><ul><li><u><strong>PPP协议的帧格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-34-07.png" alt=""></p><p>都是以字节作为单位，所以说是<strong>面向字节</strong>。</p><hr><ul><li><u><strong>HDLC协议</strong></u></li></ul><p>高级数据链路控制 (Hieh-level Data link Control或简称HDLC)，是一个在同步网上传输数据、面向比特的数据路层协议，它是由国际标准化组织(<strong><u>ISO</u></strong>)根据BM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的。</p><p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现。</p><p>采用<strong>全双工通信</strong>。</p><p>所有帧采用<strong>CRC</strong>检验，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高。</p><hr><ul><li><p><u><strong>HDLC的站</strong></u></p><p><strong>主站、从站、复合站</strong></p></li></ul><ol><li>主站的主要功能是发送命令(包括数据信息)、接收响应，并负责对整个链路的控制系统的初启流程的控制、差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li></ol><p><strong>三种数据操作方式</strong>:</p><ol><li>正常响应方式：从站要发送数据，需要主站的同意。</li><li>异步平衡方式：每一个复合站都可以对别的站数据传输。</li><li>异步响应方式：从站要发送数据，可以不经过主站的同意。</li></ol><hr><ul><li><u><strong>HDLC的帧格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-44-02.png" alt=""></p><ol><li>信息 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>) 第1位为0，用来<strong>传输数据信息</strong>，或使用捎带技术对数据进行确认。</li><li>监督帧 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>) 10，用于<strong>流量控制和差错控制</strong>，执行对信息帧的确认、请求重发和请求暂停发送等功能。</li><li>无编号帧 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>) 11，用于提供对<strong>链路</strong>的建立、拆除等多种控制功能。</li></ol><hr><ul><li><u><strong>PPP协议 &amp; HDLC协议</strong></u></li></ul><p>HDLC、PPP只支持<strong>全双工</strong>链路。</p><p>PPP协议既可以实现零比特填充，也可以使实现字节填充；HDLC只能实现零比特填充。</p><p>都可以实现透明传输。</p><p>都可以实现差错检测，但不纠正差错。</p><table><thead><tr><th>PPP协议</th><th>面向字节</th><th>2B协议字段</th><th>无序号和确认机制</th><th>不可靠</th></tr></thead><tbody><tr><td>HDLC协议</td><td>面向比特</td><td>没有</td><td>有编号和确认机制</td><td>可靠</td></tr></tbody></table><p>为什么HDLC协议可靠但是不总用它呢？因为太浪费了，在实际中要兼顾速率。</p><hr><h3 id="20、链路层设备">20、链路层设备</h3><ul><li><u><strong>物理层扩展以太网</strong>？</u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-56-00.png" alt=""></p><p>更好的方法？往下</p><hr><ul><li><p><u><strong>链路层扩展以太网</strong></u></p><p><strong>网桥 &amp; 交换机</strong></p></li></ul><p><strong>网桥</strong>根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃 (即过滤)。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_10-59-57.png" alt=""></p><p>这里的冲突域也叫网段。</p><p><strong>网段</strong>：一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分。</p><p><strong>网桥优点</strong>:</p><ol><li>过滤通信量，增大吞吐量。</li><li>2.扩大了物理范围。</li><li>3.提高了可靠性。</li><li>.可互连不同物理层、不同MAC子层和不同速率的以太网。</li></ol><hr><ul><li><u><strong>网桥分类——透明网桥</strong></u></li></ul><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——<strong>自学习</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_11-09-34.png" alt=""></p><hr><ul><li><u><strong>网桥分类——源路由网桥</strong></u></li></ul><p>源路由网桥：在发送帧时，把详细的最佳路由信息路由最少/时间最短)放在的首部中。<br>方法：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</p><p>打个比方：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_11-14-19.png" alt=""></p><p>假设实际中有：</p><p>方案1：。。。</p><p>方案2：。。。</p><p>方案3：。。。</p><p>。。。。。。</p><p>如果方案3是最佳路由信息，那么将放在首部。</p><hr><ul><li><u><strong>多接口网桥——交换机</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_11-18-38.png" alt=""></p><hr><ul><li><p><u><strong>以太网交换机的两种交换方式</strong></u></p><ul><li><p><strong>直通式交换机</strong></p><p>查完目的地址 (6B) 就立刻转发。</p><p><strong>延迟小</strong>，可靠性低，无法支持具有不同速率的端口的交换。</p></li><li><p><strong>存储转发式交换机</strong></p><p>将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。</p><p>延迟大，<strong>可靠性高，可以支持具有不同速率的端口的交换</strong>。</p></li></ul></li></ul><hr><ul><li><u><strong>冲突域 &amp; 广播域</strong></u></li></ul><p><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">能否隔离冲突域</th><th style="text-align:center">能否隔离广播域</th></tr></thead><tbody><tr><td style="text-align:center">物理层设备【傻瓜】<br />(中器、集线器)</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">链路层设备【路人】<br />(网桥、交换机)</td><td style="text-align:center">能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">网络层设备【大佬】<br />(路由器)</td><td style="text-align:center">能</td><td style="text-align:center">能</td></tr></tbody></table><p>例题：下图有几个冲突域名，几个广播域？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_11-26-48.png" alt=""></p><p>答案：4；1。</p><p>解析：有交换机隔离出4个冲突域；没有被隔离，所以整体是一个广播域。</p><hr><h2 id="第四章、网络层">第四章、网络层</h2><h3 id="1、网络层功能概述">1、网络层功能概述</h3><ul><li><p><u><strong>网络层</strong></u></p><p>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p><p>网络层传输单位是<strong>数据报</strong>。</p><ul><li><p><strong>功能一：路由选择与分组转发 <u>最佳路径</u></strong></p></li><li><p><strong>功能二：异构网络互联 <u>路由器</u></strong></p></li><li><p><strong>功能三：拥塞控制</strong></p><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞：</p><ul><li>WAY1: 开环控制（静态）</li><li>WAY2: 闭环控制（动态）</li></ul></li></ul></li></ul><hr><h3 id="2、电路交换、报文交换和分组交换">2、电路交换、报文交换和分组交换</h3><ul><li><u><strong>网络的”掌中宝“</strong></u></li></ul><p>【<strong>一堆主机</strong>】 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 【<strong>一堆路由器</strong>】 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 【<strong>一堆主机</strong>】</p><p>如何是数据通过网络的核心【路由器】从源主机到达目的主机？<strong>数据交换</strong></p><hr><ul><li><u><strong>为什么需要数据交换</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_12-29-19.png" alt=""></p><hr><ul><li><u><strong>数据交换方式</strong></u><ul><li><strong>电路交换</strong></li><li><strong>报文交换</strong></li><li><strong>分组交换</strong><ul><li>数据报方式</li><li>虚电路方式</li></ul></li></ul></li></ul><hr><ul><li><p><u><strong>电路交换</strong></u></p><p>举例：电话网络</p></li></ul><p>电路交换的原理：在数据传输期间，源结点与目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-08-09_17-37-10.png" alt=""></p><p>电话交换的阶段：建立连接（呼叫/电路建立） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 通信 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 释放连接（拆除电路）</p><p>特点：<strong>独占资源</strong>，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。</p><p><strong>优点</strong>：</p><ol><li>通信延时小</li><li>有序传输</li><li>没有冲突</li><li>实时性强</li></ol><p><strong>缺点</strong>:</p><ol><li>建立接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>无差错控制能力</li></ol><hr><ul><li><u><strong>报文交换</strong></u></li></ul><p>报文：源应用发送的信息整体。报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_12-39-57.png" alt=""></p><p>报文交换的原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用<strong>存储转发</strong>方式<br>1.每个节点收下整个报文后，暂存报文并检查有无错误<br>2.当所需要的输出电路空闲时，利用路由信息找到下一个结点地址，传送给下一个结点。<br>在两个通信用户间的其他线路段，可传输其他用户的报文，不像电路交换那样必须占用端到端的全部信道。</p><p><strong>优点</strong>:</p><ol><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>多目标服务</li></ol><p><strong>缺点</strong>:</p><ol><li>有存储转发时延</li><li>报文大小不定，需要网络节点有较大缓存空间</li></ol><hr><ul><li><u><strong>分组交换</strong></u></li></ul><p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组 (packet)。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_12-42-31.png" alt=""></p><p>分组交换的原理：分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要<strong>限制所传输的数据单位的长度</strong>，一般选128B。 发送节点首先对从终端设备送来的数据报文进行接收存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p><p><strong>小数据块 + 控制信息(源和目的地址、编号) = 分组</strong></p><p><strong>优点</strong>:</p><ol><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>相对于报文交换，存储管理更容易</li></ol><p><strong>缺点</strong>:</p><ol><li>有存储转发时延</li><li>需要传输额外的信息量</li><li>乱序到目的主机时，要对分组排序重组</li></ol><hr><ul><li><u><strong>报文交换 &amp; 分组交换</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_12-48-31.png" alt=""></p><p>报文交换：（串行）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>10000</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><mrow><mn>1000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></mfrac><mo>=</mo><mn>10</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{10000bit}{1000b/s}=10s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mord mathnormal mtight">b</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10000</span><span class="mord mathnormal mtight">bi</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>s</mi><mo>+</mo><mn>10</mn><mi>s</mi><mo>+</mo><mn>10</mn><mi>s</mi><mo>=</mo><mn>30</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">10s + 10s + 10s = 30s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span><span class="mord mathnormal">s</span></span></span></span></p><p>分组交换：（并行）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>10000</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><mrow><mn>1000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></mfrac><mo>=</mo><mn>10</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{10000bit}{1000b/s}=10s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mord mathnormal mtight">b</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10000</span><span class="mord mathnormal mtight">bi</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>10</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><mrow><mn>1000</mn><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></mfrac><mo>=</mo><mn>0.01</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{10bit}{1000b/s}=0.01s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mord mathnormal mtight">b</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span><span class="mord mathnormal mtight">bi</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.01</span><span class="mord mathnormal">s</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>s</mi><mo>+</mo><mn>0.01</mn><mi>s</mi><mo>+</mo><mn>0.01</mn><mi>s</mi><mo>=</mo><mn>10.02</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">10s + 0.01s + 0.01s = 10.02s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.01</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.01</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10.02</span><span class="mord mathnormal">s</span></span></span></span></p><p>所以生活中最常用的是分组交换方式，因特网。</p><p><strong>计算题中要注意的几点</strong>:</p><ol><li>单位换算。</li><li>2.是否考虑传播延迟（一般不考虑，看题目）。</li><li>时间至少是多少——选择最少跳数。</li><li>起始时间（从发送开始到接收完为止 / 从发送开始到发送完毕）</li><li>是否有分组头部大小的开销</li><li>报文交换时延更长，分组交换时延可能不是整数</li></ol><hr><ul><li><u><strong>三种数据交换方式比较</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_12-56-50.png" alt=""></p><ol><li><strong>报文交换</strong>和<strong>分组交换</strong>都采用存储转发</li><li>传送数据量大，且传送时间远大于呼叫时，选择<strong>电路交换</strong>。电路交换传输时延最小。</li><li>当端到端的通路有很多段的链路组成时，采用<strong>分组交换</strong>传送数据较为合适。</li><li>从信道利用率看，报文交换和分组交换优于电路交换，其中分组交换时延更小，尤其适合于计算机之间的突发式的数据通信。</li></ol><hr><h3 id="3、数据报与虚电路">3、数据报与虚电路</h3><blockquote><p>分组交换：数据报方式、虚电路方式</p></blockquote><ul><li><u><strong>数据报方式 &amp; 虚电路方式</strong></u></li></ul><p>数据报方式为网络层提供无连接服务。</p><p>虚电路方式为网络层提供连接服务。</p><p><strong>无连接服务</strong>：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p><strong>连接服务</strong>：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p><hr><ul><li><u><strong>几种传输单元名词解析</strong></u></li></ul><p> 应用层 <strong> 报文</strong></p><p> 传输层 <strong> 报文段</strong></p><p> 网络层 <strong> IP数据报，分组</strong></p><p>数据链路层 <strong>帧</strong></p><p> 物理层  <strong>比特流</strong></p><hr><ul><li><u><strong>数据报（因特网在用）</strong></u></li></ul><p><strong>无连接服务</strong>：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p><strong>每个分组携带源和目的地址</strong>。</p><p><strong>路由器根据分组的目的地址转发分组</strong>：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路。</p><hr><ul><li><u><strong>虚电路</strong></u></li></ul><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p>虚电路：一条源主机到目的主机类似于电路的路径(逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。</p><p>通信过程:</p><p><strong>建立连接（虚电路建立）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 数据传输 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 释放连接（虚电路释放）</strong></p><p>说明：</p><p>建立连接（虚电路建立）：每个分组携带<strong>虚电路号</strong>，而非目的地址。源主机发送“呼叫请求”分组并收到“呼叫应答分组后才算建立连接。</p><p>数据传输：全双工通信。</p><p>释放连接（虚电路释放）：源主机发送“释放请求“，分组以拆除虚电路。</p><hr><ul><li><u><strong>数据报 &amp; 虚电路</strong></u></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">数据报服务</th><th style="text-align:left">虚电路服务</th></tr></thead><tbody><tr><td style="text-align:center">连接的建立</td><td style="text-align:left">不要</td><td style="text-align:left">必须有</td></tr><tr><td style="text-align:center">目的地址</td><td style="text-align:left">每个分组都有完整的目的地址</td><td style="text-align:left">仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td></tr><tr><td style="text-align:center">路由选择</td><td style="text-align:left">每个分组独立的进行路由选择和转发</td><td style="text-align:left">属于同一条虚电路的分组按同一路由转发</td></tr><tr><td style="text-align:center">分组顺序</td><td style="text-align:left">不保证分组有序到达</td><td style="text-align:left">保证分组有序到达</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:left">不保证可靠通信，可靠性由主机来保证</td><td style="text-align:left">可靠性由网络保证</td></tr><tr><td style="text-align:center">对网络故障的适应性</td><td style="text-align:left">出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td><td style="text-align:left">所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td style="text-align:center">差错处理和流量控制</td><td style="text-align:left">由用户主机进行流量控制，不保证数据报的可靠性</td><td style="text-align:left">可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table><hr><h3 id="4、IP数据报格式">4、IP数据报格式</h3><ul><li><u><strong>TCP/IP协议栈</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-20-57.png" alt=""></p><hr><ul><li><u><strong>IP数据报格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-22-37.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-24-34.png" alt=""></p><p><strong>版本</strong>：IPv4/IPv6?</p><p><strong>首部长度</strong>：单位是<strong>4B</strong>，最小为5。</p><p><strong>区分服务</strong>：指示期望获得哪种类型的服务。</p><p><strong>总长度</strong>：首部+数据，单位是<strong>1B</strong>。</p><p><strong>生存时间(TTL)</strong> ：IP分组的保质期。经过一个路由器-1，变成0则丢弃。</p><p><strong>协议</strong>：数据部分的协议。（要记住TCP和UDP）</p><table><thead><tr><th style="text-align:center">协议名</th><th style="text-align:center">ICMP</th><th style="text-align:center">IGMP</th><th style="text-align:center"><u>TCP</u></th><th style="text-align:center">EGP</th><th style="text-align:center">IGP</th><th style="text-align:center"><u>UDP</u></th><th style="text-align:center">IPv6</th><th style="text-align:center">ESP</th><th style="text-align:center">OSPF</th></tr></thead><tbody><tr><td style="text-align:center">字段值</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center"><u><strong>6</strong></u></td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center"><u><strong>17</strong></u></td><td style="text-align:center">41</td><td style="text-align:center">50</td><td style="text-align:center">89</td></tr></tbody></table><p><strong>首部检验和</strong>：只检验首部。</p><p><strong>源IP地址和目的IP地址</strong>：32位。</p><p><strong>可选字段</strong>：0~40B,用来支持排错测量以及安全等措施。</p><p><strong>填充</strong>：全0，把首部补成4B的整数倍。</p><hr><h3 id="5、IP数据报分片">5、IP数据报分片</h3><ul><li><u><strong>最大传送单元MTU</strong></u></li></ul><p>链路层数据帧可封装数据的上限。</p><p>以太网的MTU是1500字节。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_16-00-12.png" alt=""></p><p>如果所传送的数据报长度超过某链路的MTU值? <strong>分片</strong></p><hr><ul><li><u><strong>IP数据报格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-24-34.png" alt=""></p><p><strong>标识</strong>：同一数据报的分片使用同一标识。</p><p><strong>标志</strong>：只有2位有意义。<br>最高位：保留不使用。<br><strong>中间位DF</strong>(Don’tFragment)：DF=1，禁止分片；DF=0，允许分片<br><strong>最低位MF</strong>(More Fragment)：MF=1，后面“还有分片”；MF=0，代表最后一片/没分</p><p><strong>片偏移</strong>：指出较长分组分片后某片在原分组中的相对位置。以<strong>8B</strong>为单位。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 除了最后一个分片，每个分片长度一定是<strong>8B的整数倍</strong>。</p><hr><ul><li><u><strong>IP数据报分片例题</strong></u></li></ul><p>需要分片为长度不超过1420B的数据报片</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_16-14-46.png" alt=""></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">总长度(B)</th><th style="text-align:center">标识</th><th style="text-align:center">MF</th><th style="text-align:center">DF</th><th style="text-align:center">片偏移(8B)</th></tr></thead><tbody><tr><td style="text-align:center">原始数据报</td><td style="text-align:center">3820</td><td style="text-align:center">12345</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">数据报片1</td><td style="text-align:center">1420</td><td style="text-align:center">12345</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">数据报片2</td><td style="text-align:center">1420</td><td style="text-align:center">12345</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">175</td></tr><tr><td style="text-align:center">数据报片3</td><td style="text-align:center">1020</td><td style="text-align:center">12345</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">350</td></tr></tbody></table><hr><h3 id="6、IPv4地址">6、IPv4地址</h3><ul><li><u><strong>IP地址</strong></u></li></ul><p>在哪个网络？</p><p>是哪个主机？</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>IP地址</strong></p><hr><ul><li><u><strong>IP编址的历史阶段</strong></u></li></ul><p>分类的IP地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 子网的划分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 构成超网（无分类编址方法）</p><hr><ul><li><u><strong>分类的IP地址</strong></u></li></ul><p>IP地址：全世界唯一的<strong>32位/4字节</strong>的标识符，标识路由器主机的接口。</p><p>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</p><p>11011111 00000001 00000001 00000001</p><p> 网络号      主机号</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 223.1.1.1</p><hr><ul><li><u><strong>互联网中的IP地址</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_17-36-46.png" alt=""></p><hr><ul><li><u><strong>分类的IP地址</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_17-38-02.png" alt=""></p><table><thead><tr><th style="text-align:center">网络类别</th><th style="text-align:center">最大可用网络数</th><th style="text-align:center">每个网络中的最大主机数</th><th style="text-align:center">第一个可用网络号</th><th style="text-align:center">最后一个可用网络号</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^7-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><br />（全0、全1）</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{24}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><br />（全0、全1）</td><td style="text-align:center">1</td><td style="text-align:center">126</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{14}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><br />(全0)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{16}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><br />（全0、全1）</td><td style="text-align:center">128.1</td><td style="text-align:center">191.255</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{21}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><br />(全0)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{8}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><br />（全0、全1）</td><td style="text-align:center">192.0.1</td><td style="text-align:center">233.255.255</td></tr></tbody></table><hr><ul><li><u><strong>特殊IP地址</strong></u></li></ul><table><thead><tr><th style="text-align:center">NetID网络号</th><th style="text-align:center">HostId主机号</th><th style="text-align:center">作为IP分组源地址</th><th style="text-align:center">作为IP分组目的地址</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">全0</td><td style="text-align:center">全0</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td><td style="text-align:left">本网范围内表示主机，路由表中用于表示默认路由(表示整个Internet网络)</td></tr><tr><td style="text-align:center">全0</td><td style="text-align:center">特殊值</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:left">表示本网内某个特定主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:left">本网广播地址(路由器不转发)</td></tr><tr><td style="text-align:center">特殊值</td><td style="text-align:center">全0</td><td style="text-align:center">不可以</td><td style="text-align:center">不可以</td><td style="text-align:left">网络地址，表示一个网络</td></tr><tr><td style="text-align:center">特殊值</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:left">直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td style="text-align:center">127</td><td style="text-align:center">任何数（非全0/1）</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:left">用于本地软件换回测试，称为环回地址</td></tr></tbody></table><hr><ul><li><u><strong>私有IP地址</strong></u></li></ul><table><thead><tr><th style="text-align:center">地址类别</th><th style="text-align:center">地址范围</th><th style="text-align:center">网段个数</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">10.0.0.0 ~ 10.255.255.255</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">172.16.0.0 ~ 172.31.255.255</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">192.168.0.0 ~ 192.168.255.255</td><td style="text-align:center">256</td></tr></tbody></table><p>路由器对目的地址是私有IP地址的数据报一律不进行转发。</p><hr><h3 id="7、网络地址转换NAT">7、网络地址转换NAT</h3><ul><li><u><strong>网络地址转换NAT</strong></u></li></ul><p>网络地址转换<strong>NAT</strong> (Network Address Translation)：在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件，安装了NAT<br>软件的路由器叫<strong>NAT路由器</strong>，它至少有一个有效的<strong>外部全球IP地址</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_19-08-12.png" alt=""></p><hr><h3 id="8、子网划分和子网掩码">8、子网划分和子网掩码</h3><ul><li><u><strong>子网划分</strong></u></li></ul><p>分类IP地址的弱点：</p><ol><li>IP地址的空间利用率有时候很低</li><li>两级IP地址不够灵活</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_20-13-06.png" alt=""></p><p>某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。</p><p>子网号能否全1或全0要看情况。</p><p>主机号不能全0或全1。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_20-15-41.png" alt=""></p><hr><ul><li><u><strong>子网掩码</strong></u></li></ul><p><strong>子网掩码与IP地址逐位相与，就得到子网网络地址</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_20-17-59.png" alt=""></p><hr><ul><li><u><strong>子网掩码——练习题</strong></u></li></ul><p><strong>例题1</strong>：已知IP地址是141.14.72.24，子网掩码是255.255.192.0，求网络地址。 如果子网掩码是255.255.224.0，求网络地址。</p><p>141.14 和 255.255 相与为 141.14；</p><p>24 与 0 相与为 0；</p><p>72:   0100 1000</p><p>192: 1100 0000</p><p>相与: 0100 0000</p><p>所以网络地址为 141.14.64.0</p><p>同理 下一问答案为 141.14.64.0</p><p>常见二进制：</p><table><thead><tr><th style="text-align:center">二级制</th><th style="text-align:center">十进制</th></tr></thead><tbody><tr><td style="text-align:center">1000 0000</td><td style="text-align:center">128</td></tr><tr><td style="text-align:center">1100 0000</td><td style="text-align:center">192</td></tr><tr><td style="text-align:center">1110 0000</td><td style="text-align:center">224</td></tr><tr><td style="text-align:center">1111 0000</td><td style="text-align:center">240</td></tr><tr><td style="text-align:center">1111 1000</td><td style="text-align:center">248</td></tr><tr><td style="text-align:center">1111 1100</td><td style="text-align:center">252</td></tr><tr><td style="text-align:center">1111 1110</td><td style="text-align:center">254</td></tr><tr><td style="text-align:center">1111 1111</td><td style="text-align:center">255</td></tr></tbody></table><p><strong>例题2</strong>：某主机的IP地址为180.80.77.55，子网掩码为255.255.252.0。若该主机向其所在子网发送广播分组，则目的地址可以是(  )     A.180.80.76.0   B.180.80.76.255   C.180.80.77.255   D.180.80.79.255</p><p>解析：</p><p>先将IP地址180.80.77.55与子网掩码相与，结果得到子网为180.80.76.0；</p><p>再看子网掩码中，252：1111 1100，所以子网位数为6位再加上255.255这里16位，一共22位；</p><p>子网位数为22，则主机号位数为10，又因为发送的是广播分组，主机号全为1；</p><p>所以结果为子网22位，再加10个1，即180.80.79.255。</p><hr><ul><li><u><strong>使用子网时分组的转发</strong></u></li></ul><p>路由表中：</p><ol><li>目的网络地址</li><li>目的网络子网掩码</li><li>下一跳地址</li></ol><p><strong>路由器转发分组的算法</strong>:</p><ol><li>提取目的IP地址</li><li>是否直接交付（直接交付：目的IP就在路由器所连的子网上）</li><li>特定主机路由</li><li>检测路由表中有无路径（目的IP和路由器所有子网掩码相与）</li><li>默认路由 0.0.0.0（发给下一个路由器）</li></ol><p>重复1-5步，直到找到，或者生命周期结束，丢弃，报告转发分组出错。</p><hr><h3 id="9、无分类编址CIDR">9、无分类编址CIDR</h3><ul><li><u><strong>无分类编址CIDR</strong></u></li></ul><p>无分类域间路由选择CIDR:</p><ol><li>消除了传统的A类，B类和C类地址以及划分子网的概念</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_21-12-12.png" alt=""></p><p>CIDR记法：IP地址后加上“/”，然后写上网络前缀 (可以任意长度)的位数。e.g.128.14.32.0/<strong>20</strong></p><ol start="2"><li><p>融合子网地址与子网掩码，方便子网划分。</p><p>CIDR把<strong>网络前缀都相同</strong>的连续的IP地址组成一个”CIDR地址块”。</p><p>举例：128.14.35.7/20是某CIDR地址块中的一个地址</p><p>二进制: <u><strong>10000000 00001110 0010</strong></u>0011 00000111</p><p>最小地址：<u><strong>10000000 00001110 0010</strong></u>0000 00000000</p><p>最大地址：<u><strong>10000000 00001110 0010</strong></u>1111 11111111</p><p>地址块: 128.14.32.0/20 不需要指明起始地址时，也可以写作“/20地址块“</p><p>地址掩码(子网掩码)：<u><strong>10000000 00001110 0010</strong></u>0000 00000000</p></li></ol><hr><ul><li><u><strong>构成超网</strong></u></li></ul><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合</p><p>方法：将网络前缀缩短。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_21-20-34.png" alt=""></p><hr><ul><li><u><strong>最长前缀匹配</strong></u></li></ul><p>使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小,路由越具体。</p><p><strong>例题</strong>：路由器RO的路由表见下表：若进入路由器RO的分组的目的地址为132.19.237.5，请问该分组应该被转发到哪一个下一跳路由器 (  )。</p><p> A.R1 B.R2 C.R3 D.R4</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">下一帧</th></tr></thead><tbody><tr><td style="text-align:center">132.0.0.0/8</td><td style="text-align:center">R1</td></tr><tr><td style="text-align:center">132.0.0.0/11</td><td style="text-align:center">R2</td></tr><tr><td style="text-align:center">132.19.232.0/22</td><td style="text-align:center">R3</td></tr><tr><td style="text-align:center">0.0.0.0/0</td><td style="text-align:center">R4</td></tr></tbody></table><p>解析：132.19.237.5，按8、11、22计算出子网为：132.0.0.0、132.0.0.0、132.19.236.0；</p><p>可见前两项都匹配，但是132.0.0.0/11前缀匹配更多，所以答案选B。</p><hr><ul><li><u><strong>习题</strong></u></li></ul><p>【2010】某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是 (  ）</p><p> A.32,8 B.32,6 C.8,32 D.8,30</p><p>解析：本题在CIDR的基础上又划分了子网。</p><p>除去24位，那么最后八位由于子网掩码248：11111000，那么有五位是子网位数，3位是主机号，所以最大子网个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5=32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span>，最大可分配地址个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2^3-2=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>。答案选B。</p><hr><h3 id="10、ARP协议">10、ARP协议</h3><ul><li><u><strong>发送数据的过程</strong></u></li></ul><p>1、发给本网络</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_22-03-18.png" alt=""></p><p>2、发给另一网络</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_22-03-42.png" alt=""></p><hr><ul><li><u><strong>ARP协议</strong></u></li></ul><p>由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> ARP协议：完成主机或路由器IP地址到MAC地址的映射。<strong>解决下一跳走哪的问题</strong></p><p>ARP协议使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的封装并<strong>广播ARP请求分组</strong>，<strong>同一局域网</strong>中所有主机都能收到该请求。目的主机收到请求后就会向源主机<strong>单播一个ARP响应分组</strong>，源主机收到后将此映射<strong>写入ARP缓存</strong> (10-20min更新一次)。</p><p>ARP协议4种典型情况:</p><ol><li>主机A发给<strong>本网络</strong>上的主机B：用ARP找到主机B的硬件地址；</li><li>主机A发给<strong>另一网络</strong>上的主机B：用ARP找到本网络上一个路由器(网关)的硬件地址；</li><li>路由器发给<strong>本网络</strong>的主机A：用ARP找到主机A的硬件地址；</li><li>路由器发给<strong>另一网络</strong>的主机B：用ARP找到本网络上的一个路由器的硬件地址。</li></ol><p><strong>ARP协议自动进行</strong></p><hr><ul><li><u><strong>ARP协议习题</strong></u></li></ul><p>主机发送IP数据报给主机B，经过了5个路由器，请问此过程总共使用了几次ARP协议?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_22-13-50.png" alt=""></p><p>答案：6次</p><hr><h3 id="11、DHCP协议">11、DHCP协议</h3><ul><li><p><u><strong>主机如何获得IP地址</strong>？</u></p><ul><li><p><strong>静态配置</strong></p><p>IP地址、子网掩码、默认网关</p></li><li><p><strong>动态配置</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_22-42-33.png" alt=""></p></li></ul></li></ul><hr><ul><li><u><strong>DHCP协议</strong></u></li></ul><p>动态主机配置协议DHCP是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于<strong>UDP</strong>。</p><p>DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许<strong>地址重用</strong>，支持<strong>移动用户加入网络</strong>，支持<strong>在用地址续租</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_22-42-33.png" alt=""></p><p>工作流程：</p><ol><li><p>主机广播DHCP<strong>发现</strong>报文</p><p><strong>“有没有DHCP服务器呀?”</strong><br>试图找到网络中的服务器，服务器获得一个IP地址。</p></li><li><p>DHCP服务器广播DHCP<strong>提供</strong>报文</p><p><strong>“有!”“有!”“有!”</strong></p><p>服务器拟分配给主机一个IP地址及相关配置，先到先得</p></li><li><p>主机广播DHCP<strong>请求</strong>报文</p><p><strong>”我用你给我的IP地址啦?”</strong></p><p>主机向服务器请求提供IP地址</p></li><li><p>DHCP服务器广播DHCP<strong>确认</strong>报文</p><p><strong>“用吧!”</strong></p><p>正式将IP地址分配给主机。</p></li></ol><hr><h3 id="12、ICMP协议">12、ICMP协议</h3><ul><li><u><strong>TCP/IP协议栈</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-20-57.png" alt=""></p><p>ICMP：为了更有效地转发IP数据报和提高交付成功的机会…</p><hr><ul><li><u><strong>网际控制报文协议ICMP</strong></u><ul><li><strong>ICMP差错报文</strong></li><li><strong>ICMP询问报文</strong></li></ul></li></ul><p>ICMP协议支持主机或路由器：</p><p>差错（或者异常）报告 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 发送特定ICMP报文</p><p>网络探询</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_07-53-01.png" alt=""></p><hr><ul><li><u><strong>ICMP差错报告报文（5种）</strong></u></li></ul><p>1、<strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。（<strong>无法交付</strong>）</p><p>2、<strong>源点抑制</strong>（已取消使用）：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（<strong>拥塞丢数据</strong>）</p><p>3、<strong>时间超过</strong>：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。（<strong>TTL=0</strong>）</p><p>4、<strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。（<strong>首部字段有问题</strong>）</p><p>5、<strong>改变路由(重定向)</strong> ：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。（<strong>值得更好的路由</strong>）</p><hr><ul><li><u><strong>ICMP差错报告报文数据字段</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_07-59-39.png" alt=""></p><hr><ul><li><u><strong>不应该发送ICMP差错报文的情况</strong></u></li></ul><p>1、对<strong>ICMP差错报告报文</strong>不再发送ICMP差错报告报文。</p><p>2、对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送ICMP差错报告报文。</p><p>3、对具有<strong>组播地址</strong>的数据报都不发送ICMP差错报告报文</p><p>4、对具有<strong>特殊地址</strong>(如127.0.0.0或0.00.0)的数据报不发送ICMP差错报告报文。</p><hr><ul><li><u><strong>ICMP询问报文</strong></u></li></ul><p>1、回送请求和回答报文</p><p>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>。</p><p>2、时间戳请求和回答报文</p><p>请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</p><p>3、掩码地址请求和回答报文（不再使用）</p><p>4、路由器询问和通告报文（不再使用）</p><hr><ul><li><u><strong>ICMP的应用</strong></u></li></ul><p><strong>PING</strong>  测试两个主机的连通性，使用了ICMP回送请求和回答报文。</p><p><strong>Traceroute</strong>  跟踪一个分组从源点到终点的路径，使用了<strong>ICMP时间超过差错报文</strong>。（发送一连串数据报， TTL分别为1, 2, 3…）</p><hr><h3 id="13、IPv6">13、IPv6</h3><ul><li><u><strong>为什么要有IPv6</strong>?</u></li></ul><p>32位IPv4地址空间会分配完…</p><p><strong>CIDR</strong>、<strong>NAT</strong>治标不治本</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> <strong>IPv6</strong> 从根本上解决了地址耗尽问题</p><p>改进首部格式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>快速处理/转发数据报</strong>、<strong>支持QoS</strong></p><p>Qos (Quality of Service，服务质量)指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。</p><hr><ul><li><u><strong>IPv6数据报格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_08-37-12.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_08-37-15.png" alt=""></p><p><strong>版本</strong>：指明了协议版本，总是6.</p><p><strong>优先级</strong>：区分数据报的类别和优先级</p><p><strong>流标签</strong>：“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。</p><p><strong>跳数限制</strong>：相当于IPv4的TTL。</p><p><strong>下一个首部</strong>：标识下一个扩展首部或上层协议首部。</p><hr><ul><li><u><strong>IPv6和IPv4</strong></u></li></ul><p>1、IPv6将地址从32位(4B)扩大到<strong>128位(16B)</strong> ，更大的地址空间。</p><p>2、IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</p><p>3、IPv6将IPV4的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</p><p>4、IPv6支持<strong>即插即用</strong>(即自动配置)，不需要DHCP协议。</p><p>5、IPv6首部长度必须是<strong>8B的整数倍</strong>，IPv4首部是4B的整数倍。</p><p>6、IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片。</p><p>7、ICMPv6:附加报文类型“分组过大”。</p><p>8、IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</p><p>9、IPv6取消了协议字段，改成下一个首部字段。</p><p>10、IPv6取消了总长度字段，改用有效载荷长度字段。</p><p>11、IPv6取消了服务类型字段。</p><hr><ul><li><u><strong>IPv6地址表示形式</strong></u></li></ul><p><strong>一般形式</strong>  冒号十六进制记法：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p><p><strong>压缩形式</strong></p><p>4BF5:0000:0000:0000:BA 5F:039A:000A:2176</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 4BF5:0:0:0:BA5F:39A:A:2176</p><p>零压缩：一连串连续的0可以被一对冒号取代。</p><p>FF05:0:0:0:0:0:0:B3</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> FF05::B3</p><p>双冒号表示法在一个地址中仅可出现一次。</p><hr><ul><li><u><strong>IPv6基本地址类型</strong></u></li></ul><p><strong>单播</strong>  一对一通信  可做源地址+目的地址</p><p><strong>多播</strong>  一对多通信  可做目的地址</p><p><strong>任播</strong>  一对多中的一个通信</p><hr><ul><li><u><strong>IPv6向IPv4过渡的策略</strong></u></li></ul><p><strong>双栈协议</strong>：</p><p>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong>。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个<strong>路由器</strong>，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个<strong>计算机</strong>，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p><p><strong>隧道技术</strong>:</p><p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包（作为数据部分）<strong>重新封装</strong>然后通过隧道发送。</p><hr><h3 id="14、路由算法与路由协议概述">14、路由算法与路由协议概述</h3><ul><li><u><strong>路由算法</strong></u></li></ul><p>路由表/路由转发表</p><table><thead><tr><th style="text-align:center">目的网络IP地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳IP地址</th><th style="text-align:center">接口</th></tr></thead></table><p>最佳路电：“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</p><hr><ul><li><p><u><strong>路由算法的分类</strong></u></p><ul><li><p><strong>静态路由算法</strong>（非自适应路由算法）</p><p>管理员手工配置路由信息。</p><p><strong>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络</strong>。</p><p><strong>路由更新慢，不适用大型网络</strong>。</p></li><li><p><strong>动态路由算法</strong>（自适应路由算法）</p><p>路由器间彼此交换信息，按照路由算法优化出路由表项。</p><p><strong>路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化</strong>。</p><p><strong>算法复杂，增加网络负担</strong>。</p><ul><li><p><strong>全局性</strong></p><p>链路状态路由算法 典型应用：<strong>OSPF协议</strong></p><p>所有路由器掌握完整的网络拓扑和链路费用信息。</p></li><li><p><strong>分散性</strong></p><p>距离向量路由算法 典型应用：<strong>RIP协议</strong></p><p>路由器只掌握物理相连的邻居及链路费用。</p></li></ul></li></ul></li></ul><hr><ul><li><u><strong>分层次的路由选择协议</strong></u></li></ul><p>问题：</p><p>(1)因特网规模很大。<br>(2) 许多单位不想让外界知道自己的路由选择协议，但还想连入因特网。</p><p>解决：</p><p><strong>路由器在本自治系统内都必须连通</strong>。</p><p>路由选择协议：</p><p><strong>内部网关协议IGP</strong> 一个AS内使用的 <strong>RIP、OSPF</strong>；</p><p><strong>外部网关协议EGP</strong> AS之间使用的 <strong>BGP</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-01_15-45-53.png" alt=""></p><hr><h3 id="15、RIP协议与距离向量算法">15、RIP协议与距离向量算法</h3><ul><li><u><strong>RIP协议</strong></u></li></ul><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是<strong>简单</strong>。</p><p>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>(即一组距离)。</p><p>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为<strong>16表示网络不可达</strong>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> RIP协议只适用于<strong>小互联网</strong>。</p><hr><ul><li><u><strong>RIP协议和谁交换? 多久交换一次? 交换什么?</strong></u></li></ul><p>1、仅和<strong>相邻路由器</strong>交换信息。</p><p>2、路由器交换的信息是<strong>自己的路由表</strong>。</p><p>3、<strong>每30秒</strong>交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</p><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相令路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“<strong>收敛</strong>”。</p><hr><ul><li><u><strong>距离向量算法</strong></u></li></ul><p>1、修改相邻路由器发来的RIP报文中所有表项</p><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离”字段+1。</p><p>2、对修改后的RIP报文中的每一个项目，进行以下步骤:</p><p> (1) R1路由表中若没有X，则把该项目填入R1路由表</p><p> (2) R1路由表中若有X，则查看下一跳路由器地址:</p><p>  若下一跳是X，则用收到的项目替换源路由表中的项目;<br>  若下一跳不是X，原来距离比从X走的距离远则更新，否则不作处理。</p><p>3、若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p><p>4、返回。</p><hr><ul><li><u><strong>距离向量算法练习1</strong></u></li></ul><p>已知路由器R6的路由表，现收到相邻路由器R4发来的路由更新信息，试更新路由器R1的路由表:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_09-29-31.png" alt=""></p><hr><ul><li><u><strong>距离向量算法练习2</strong></u></li></ul><p>考虑如图所示的子网，该子网使用了距离-向量算法，下面的向量刚刚到达路由器C：来自B的向量为(5, 0, 8, 12, 6, 2)；来自D的向量为(16, 12, 6, 0, 9, 10)；来自E的向量为(7, 6, 3, 9, 0, 4)。经过测量，C到B、D和E的延迟分别为6，3和5，那么C到达所有结点的最短路径是( )。</p><p> A.(5, 6, 0, 9, 6, 2)</p><p> B.(11, 6, 0, 3, 5, 8 )</p><p> C.(5, 11, 0, 12, 8, 9)</p><p> D.(11 ,8 ,0, 7, 4, 9)</p><p>解析：</p><table><thead><tr><th style="text-align:center">向量名称</th><th style="text-align:center">(A,  B,  C,  D,  E,  F)</th><th style="text-align:center">(A,  B,  <u>C</u>,  D,  E,  F)</th></tr></thead><tbody><tr><td style="text-align:center">来自B</td><td style="text-align:center">(5,   <strong>0</strong>,   8, 12,  6,  2)</td><td style="text-align:center">(<strong>11</strong>, <strong>6</strong>, 14,18, 12,  <strong>8</strong>)</td></tr><tr><td style="text-align:center">来自D</td><td style="text-align:center">(16,12,  6,  <strong>0</strong>,   9, 10)</td><td style="text-align:center">(19,15,   9,  <strong>3</strong>, 12, 13)</td></tr><tr><td style="text-align:center">来自E</td><td style="text-align:center">(7,   6,   3,  9,   <strong>0</strong>,   4)</td><td style="text-align:center">(12,11,   8,14,   <strong>5</strong>,  9)</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center"></td><td style="text-align:center"><strong>(11, 6,   0,  3,  5,  8)</strong></td></tr></tbody></table><p>所以答案为B</p><hr><ul><li><u><strong>RIP协议的报文格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_09-58-39.png" alt=""></p><p>RIP是<strong>应用层协议</strong>使用<strong>UDP</strong>传送数据。</p><p>一个RIP报文最多可包括25 个路由，如超过，必须再用一个RIP报文传送。</p><hr><ul><li><u><strong>RIP协议好消息传得快，坏消息传得慢</strong></u></li></ul><p>RIP的特点：当网络出现故障时，要经过比较长的时间(例如数分钟) 才能将此信息传送到所有的路由器，“慢收敛”。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_13-25-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_13-26-04.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>说：“我到网1的距离是16(表示无法到达)，是直接交付；</p><p>但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在收到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新报文之前，还发送原来的报文，因为这时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并不知道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出了故障；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>收到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新报文后，误认为可经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到达网1，于是更新自己的路由表，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>说：“我到网1的距离是3，下一跳经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”。然后将此更新信息发送给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>以后又更新自己的路由表为“1，4，R,”，表明“我到网1距离是4，下一跳经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”；</p><p>这样不断更新下去，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到网1的距离都增大到16时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>才知道网1是不可达的。</p><hr><h3 id="16、OSPF以及链路状态算法">16、OSPF以及链路状态算法</h3><ul><li><u><strong>OSPF协议</strong></u></li></ul><p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是<strong>公开发表</strong>的：“最短路径优先“是因为使用了<strong>Diikstra</strong>提出的最短路径算法<strong>SPF</strong>。</p><p>OSPF最主要的特征就是使用分布式的<strong>链路状态协议</strong>。</p><p>OSPF的特点:</p><p><strong>和谁交换？</strong></p><ol><li>使用洪泛法向自治系统内<strong>所有路由器</strong>发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 最终整个区域内所有路由器都得到了这个信息的一个副本。</li></ol><p><strong>交换什么？</strong></p><ol start="2"><li>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>(本路由器和哪些路由器相邻，以及该链路的度量/代价一一费用、距离、时延、带宽等)。</li></ol><p><strong>多久交换？</strong></p><ol start="3"><li>只有当<strong>链路状态发生变化时</strong>，路由器才向所有路由器洪泛发送此信息。</li></ol><p>最后，所有路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong>。</p><hr><ul><li><u><strong>链路状态路由算法</strong></u></li></ul><p>1、每个路由器发现它的邻居结点【HELLO问候分组】，并了解邻居节点的网络地址。</p><p>2、设置到它的每个邻居的成本度量metric。</p><p>3、构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</p><p>4、如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</p><p>5、收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</p><p>6、更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</p><p>只要一个路由器的链路状态发生变化:</p><p>5、泛洪发送【LSU链路状态更新分组】进行更新。</p><p>6、更新完毕后，其他站返回一个【LSAck链路状态确认分组】进行确认。</p><p>7、使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</p><hr><ul><li><u><strong>OSPF的区域</strong></u></li></ul><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若个更小的范围，叫做区域。</p><p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p><p>区域也不能太大，在一个区域内的路由器最好不超过 200 个。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-22-06.png" alt=""></p><hr><ul><li><u><strong>OSPF分组</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-24-21.png" alt=""></p><p>OSPF直接用<strong>IP数据报</strong>传送。</p><p>【考纲】：OSPF是<strong>网络层协议</strong>。</p><hr><ul><li><u><strong>OSPF其他特点</strong></u></li></ul><p>1、每隔<strong>30min</strong>，要刷新一次数据库中的链路状态。</p><p>2、由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当<strong>互联网规模很大</strong>时，OSPF 协议要比距离向量协议 RIP 好得多。</p><p>3、OSPF不存在坏消息传的慢的问题，它的<strong>收敛速度很快</strong>。</p><hr><h3 id="17、BGP协议">17、BGP协议</h3><ul><li><u><strong>BGP协议</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-44-20.png" alt=""></p><p><strong>和谁交换?</strong><br>与其他AS的邻站BGP发言人交换信息。</p><p><strong>交换什么?</strong><br>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p><p><strong>多久交换?</strong><br>发生变化时更新有变化的部分。</p><hr><ul><li><u><strong>BGP协议交换信息的过程</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-46-57.png" alt=""></p><p>BGP所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。当BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-52-27.png" alt=""></p><p>BGP发言人交换<strong>路径向量</strong>:</p><p>自治系统<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">AS_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的 BGP 发言人通知主干网<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">AS_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的BGP 发言人：“要到达网络<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">N_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">AS_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>主干网还可发出通知：“要到达网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">N_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">N_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">N_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可沿路径(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">AS_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">AS_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p><hr><ul><li><u><strong>BGP协议报文格式</strong></u></li></ul><p>一个BGP发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要<strong>先建立TCP 连接</strong>，即通过TCP传送，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_10-55-03.png" alt=""></p><p>BGP是<strong>应用层协议</strong>，借助<strong>TCP</strong>传送</p><hr><ul><li><u><strong>BGP协议特点</strong></u></li></ul><p>BGP支持<strong>CIDR</strong>。因此BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><hr><ul><li><u><strong>BGP-4的四种报文</strong></u></li></ul><p>1、<strong>OPEN(打开)报文</strong>：用来与相邻的另一个BGP发言人建立关系，并认证发送方。</p><p>2、<strong>UPDATE(更新) 报文</strong>：通告新路径或撤销原路径。</p><p>3、<strong>KEEPALIVE(保活)报文</strong>：在无UPDATE时，周期性证实邻站的连通性:也作为OPEN的确认。</p><p>4、<strong>NOTIFICATION(通知) 报文</strong>：报告先前报文的差错:也被用于关闭连接。</p><hr><ul><li><u><strong>三种路由协议比较</strong></u></li></ul><p><strong>RIP</strong>是一种分布式的基于距离向量的内部网关路由选择协议，通过广播<strong>UDP</strong>报文来交换路由信息。</p><p><strong>OSPF</strong>是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议(如UDP或TCP)，而是直接采用<strong>IP</strong>。</p><p><strong>BGP</strong>是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用<strong>TCP</strong>。</p><table><thead><tr><th style="text-align:center">协议</th><th style="text-align:center">RIP</th><th style="text-align:center">OSPF</th><th style="text-align:center">BGP</th></tr></thead><tbody><tr><td style="text-align:center">类型</td><td style="text-align:center">内部</td><td style="text-align:center">内部</td><td style="text-align:center">外部</td></tr><tr><td style="text-align:center">路由算法</td><td style="text-align:center">距离-向量</td><td style="text-align:center">链路状态</td><td style="text-align:center">路径-向量</td></tr><tr><td style="text-align:center">传递协议</td><td style="text-align:center">UDP</td><td style="text-align:center">IP</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">路径选择</td><td style="text-align:center">跳数最少</td><td style="text-align:center">代价最低</td><td style="text-align:center">较好、非最佳</td></tr><tr><td style="text-align:center">交换节点</td><td style="text-align:center">和本结点相邻的路由器</td><td style="text-align:center">网络中的所有路由器</td><td style="text-align:center">和本结点相邻的路由器</td></tr><tr><td style="text-align:center">交换内容</td><td style="text-align:center">当前本路由器知道的全部信息，即自己的路由表</td><td style="text-align:center">与本路由器相邻的所有路由器的链路状态</td><td style="text-align:center">首次，整个路由表<br/>非首次，有变化的部分</td></tr></tbody></table><hr><h3 id="18、IP组播">18、IP组播</h3><ul><li><u><strong>IP数据报的三种传输方式</strong></u></li></ul><p><strong>单播</strong></p><p>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。<br>在发送者和每一接收者之间需要<strong>单独的数据信道</strong>。</p><p><strong>广播</strong></p><p>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式。</p><p><strong>组播（多播）</strong></p><p>当网络中的某些用户需要特定数据时组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输方式。<br>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络 (如果有组播路由器的支持)。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 运行组播协议的路由器</p><hr><ul><li><u><strong>IP组播地址</strong></u></li></ul><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个<strong>组播组IP地址</strong>(一群共同需求主机的相同标识)。<br>组播地址范围为<strong>224.0.0.0~239.255.255.255(D类地址)</strong> ，一个D类地址表示一个组播组。只能用作分组的<strong>目标地址</strong>。源地址总是为<strong>单播地址</strong>。</p><p>1.组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于<strong>UDP</strong>。</p><p>2.对组播数据报不产生ICMP差错报文。</p><p>3.并非所有D类地址都可以作为组播地址。</p><p>又分为：因特网范围内组播、硬件组播。</p><hr><ul><li><u><strong>硬件组播</strong></u></li></ul><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值<strong>01-00-5E</strong>打头，余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的</p><p>TCP/IP 协议使用的以太网多播地址的范围是:<br> 从<strong>01-00-5E-00-00-00</strong>到<strong>01-00-5E-7F-FF-FF</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_13-39-21.png" alt=""></p><p>若多个IP组播地址最后23位相同：收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><hr><ul><li><u><strong>IGMP协议与组播路由选择协议</strong></u></li></ul><p>因特网范围内组播：</p><p>IGMP协议</p><p>组播路由选择协议</p><hr><ul><li><u><strong>网际管理协议</strong></u></li></ul><p>IGMP协议让路由器知道本局域网上<strong>是否有主机(的进程)参加或退出了某个组播组</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_14-03-58.png" alt=""></p><hr><ul><li><u><strong>IGMP工作的两个阶段</strong></u></li></ul><p><strong>ROUND 1</strong>:</p><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p><p><strong>ROUND 2</strong>:</p><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p><p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的:如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p><p><strong>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员，不知道多少个</strong>。</p><hr><ul><li><u><strong>组播路由转发协议</strong></u></li></ul><p>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</p><p>构造树可以避免在路由器之间兜圈子。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p><p>组播路由选择协议常使用的三种算法:</p><p><strong>基于链路状态的路由选择</strong></p><p><strong>基于距离-向量的路由选择</strong></p><p><strong>协议无关的组播(稀疏/密集)</strong></p><hr><h3 id="19、移动IP">19、移动IP</h3><ul><li><u><strong>移动IP的相关术语</strong></u></li></ul><p>移动IP技术是移动结点(计算机/服务器等)以<strong>固定的网络IP地址</strong>，实现跨越不同网段的<strong>漫游</strong>功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动结点</strong>  具有永久IP地址的移动设备</p><p><strong>归属代理(本地代理)</strong>  一个移动结点拥有的就“居所”称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做<strong>归属代理</strong>。</p><p><strong>外部代理(外地代理)</strong>  在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>永久地址 (归属地址/主地址 )</strong>  移动站点在归属网络中的原始地址。</p><p><strong>转交地址 (辅地址)</strong>  移动站点在外部网络使用的临时地址。</p><hr><ul><li><u><strong>移动IP通信过程</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_14-22-40.png" alt=""></p><p><strong>A刚进入外部网络</strong>:</p><ol><li>在外部代理登记获得一个转交地址，离开时注销。</li><li>外地代理向本地代理登记转交地址。</li></ol><p><strong>B给A发送数据报</strong>:</p><ol><li>本地代理截获数据报。</li><li>本地代理再封装数据报，新的数据报目的地址是转交地址，发给外部代理(隧道)。</li><li>外部代理拆封数据报并发给A。</li></ol><p><strong>A给B发送数据报</strong>:</p><p> A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址。（不需要在经过代理）</p><p><strong>A移动到了下一个网络</strong>：</p><ol><li>在新外部代理登记注册一个转交地址。</li><li>新外部代理给本地代理发送新的转交地址覆盖旧的)。</li><li>通信。</li></ol><p><strong>A回到了归属网络</strong>:</p><ol><li>A向本地代理注销转交地址。</li><li>按原始方式通信。</li></ol><hr><h3 id="20、网络层设备">20、网络层设备</h3><ul><li><u><strong>路由器</strong></u></li></ul><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_14-35-53.png" alt=""></p><p>根据所选定的路由选择协议<strong>构造出路由表</strong>，同时经常或定期地和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong>。</p><p>交换结构：根据转发表(路由表得来)对分组进行转发。</p><p>转发VS路由选择：转发：输入端口到输出端口；路由选择：路由器。</p><p>若收到RIP/OSPF分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出。</p><hr><ul><li><u><strong>输入端口对线路上收到的分组的处理</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_14-42-48.png" alt=""></p><p>输入端口中的<strong>查找和转发</strong>功能在路由器的交换功能中是最重要的。</p><hr><ul><li><u><strong>输出端口将交换结构传送来的分组发送到线路</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_14-43-02.png" alt=""></p><p>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。<br><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因</strong>。</p><hr><ul><li><u><strong>三层设备的区别</strong></u></li></ul><p><strong>路由器</strong>  可以互联两个不同网络层协议的网段。</p><p><strong>网桥</strong>  可以互联两个物理层和链路层不同的网段。</p><p><strong>集线器</strong>  不能互联两个物理层不同的网段。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">能否隔离冲突域</th><th style="text-align:center">能否隔离广播域</th></tr></thead><tbody><tr><td style="text-align:center">物理层设备【傻瓜】<br />(中器、集线器)</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">链路层设备【路人】<br />(网桥、交换机)</td><td style="text-align:center">能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">网络层设备【大佬】<br />(路由器)</td><td style="text-align:center">能</td><td style="text-align:center">能</td></tr></tbody></table><hr><ul><li><u><strong>路由表与路由转发</strong></u></li></ul><p>路由表根据<strong>路由选择算法</strong>得出的，主要用途是路由选择，总用软件来实现。</p><p>路由表</p><table><thead><tr><th style="text-align:center">目的网络IP地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳IP地址</th><th style="text-align:center">接口</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0.0.0.0(默认路由)</td><td style="text-align:center">0.0.0.0</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 转发表</p><p>转发表由<strong>路由表</strong>得来，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射。】</p><hr><h2 id="第五章、传输层">第五章、传输层</h2><h3 id="1、传输层概述">1、传输层概述</h3><ul><li><p><u><strong>传输层</strong></u></p><p>只有主机才有的层次。</p></li></ul><p>传输层的功能：</p><ol><li>传输层提供<strong>进程和进程</strong>之间的逻辑通信。<br>网络层提供<strong>主机之间</strong>的逻辑通信。</li><li>复用和分用。</li><li>传输层对收到的报文进行差错检测。</li><li>传输层的两种协议。</li></ol><hr><ul><li><u><strong>传输层的两个协议</strong></u></li></ul><p>传输层有两个好兄弟;</p><p>大哥TCP和二弟UDPl</p><p>大哥靠谱，二弟不靠谱。</p><p><strong>VS</strong>:</p><p><strong>面向连接的传输控制协议TCP</strong>：<br>传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。<br><strong>可靠，面向连接，时延大，适用于大文件</strong>。</p><p><strong>无连接的用户数据报协议UDP</strong>：<br>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。<br><strong>不可靠，无连接，时延小，适用千小文件</strong>。</p><hr><ul><li><u><strong>传输层的寻址与端口</strong></u></li></ul><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。<br>分用：传输层从网络层收到数据后交付指明的应用进程。</p><p><strong>端口（逻辑端口/软件端口）</strong>：是传输层的SAP(访问服务点)，标识主机中的应用进程。</p><p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。</p><p>端口号长度为<strong>16bit</strong>，能表示65536个不同的端口号。</p><p>端口号（按范围分）：</p><ul><li><p><strong>服务端</strong>使用的端口号</p><ul><li>熟知端口号（0~1023）：给TCP/IP最重要的一些应用程序，让所有用户都知道。</li><li>登记端口号（1024~49151）：为没有熟知端口号的应用程序使用的。</li></ul></li><li><p><strong>客户端</strong>使用的端口号（49152 ~ 65535）:</p><p>仅在客户进程运行时才动态选择。</p></li></ul><table><thead><tr><th style="text-align:center">应用程序</th><th style="text-align:center">FTP</th><th style="text-align:center">TELNET</th><th style="text-align:center">SMTP</th><th style="text-align:center">DNS</th><th style="text-align:center">TFTP</th><th style="text-align:center">HTTP</th><th style="text-align:center">SNMP</th></tr></thead><tbody><tr><td style="text-align:center">熟知端口号</td><td style="text-align:center">21</td><td style="text-align:center">23</td><td style="text-align:center">25</td><td style="text-align:center">53</td><td style="text-align:center">69</td><td style="text-align:center">80</td><td style="text-align:center">161</td></tr></tbody></table><p>在网络中采用发送方和接收方的套接字组合来识别端点，<strong>套接字</strong>唯一标识了网络中的一个主机和它上面的一个进程。<br><strong>套接字socket = (主机IP地址，端口号)</strong></p><hr><h3 id="2、UDP协议">2、UDP协议</h3><ul><li><u><strong>用户数据报UDP概述</strong></u></li></ul><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><p>UDP的主要特点:</p><ol><li><p>UDP是<strong>无连接</strong>的，减少开销和发送数据之前的时延。</p></li><li><p>UDP使用最大努力交付，即<strong>不保证可靠交付</strong>。</p></li><li><p>UDP是<strong>面向报文</strong>的，适合一次性传输少量数据的网络应用。</p><p>应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。</p></li><li><p>UDP<strong>无拥塞控制</strong>，适合很多实时应用</p></li><li><p>UDP<strong>首部开销小</strong>，<strong>8B</strong>，TCP：20B</p></li></ol><hr><ul><li><u><strong>UDP首部格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_18-22-32.png" alt=""></p><p><strong>UDP长度</strong>：UDP用户数据报的<strong>整个</strong>长度。<br><strong>16位UDP检验和</strong>：检测整个UDP数据报是否有错，错就丢弃。</p><p>另一种出错情况：分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。</p><hr><ul><li><u><strong>UDP校验</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_18-26-49.png" alt=""></p><p>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。<br>17：封装UDP报文的IP数据报首部协议字段是17。<br>UDP长度：UDP首部8B+数据部分长度(不包括伪首部)。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_18-30-46.png" alt=""></p><p>在<strong>发送端</strong>:</p><ol><li>填上伪首部。</li><li>全0填充检验和字段。</li><li>全0填充数据部分(UDP数据报要看成许多4B的字串接起来)</li><li>伪首部+首部+数据部分采用二进制反码求和。</li><li>把和求反码填入检验和字段。</li><li>去掉伪首部，发送。</li></ol><p>在<strong>接收端</strong>:</p><ol><li>填上伪首部。</li><li>伪首部+首部+数据部分采用二进制反码求和。</li><li>结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告。</li></ol><hr><h3 id="3、TCP协议特点和TCP报文段格式">3、TCP协议特点和TCP报文段格式</h3><ul><li><u><strong>TCP协议的特点</strong></u></li></ul><p>1、TCP是面向连接(虚连接) 的传输层协议。</p><p>2、每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。</p><p>3、TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。<strong>可靠有序，不丢不重</strong></p><p>4、TCP提供全双工通信。</p><p> <strong>发送缓存</strong> 准备发送的数据 &amp; 已发送但尚未收到确认的数据</p><p> <strong>接收缓存</strong> 按序到达但尚未被接受应用程序读取的数据 &amp; 不按序到达的数据</p><p>5、TCP面向字节流。</p><p> TCP把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong>。</p><p> 流：流入到进程或从进程流出的字节序列。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-06-37.png" alt=""></p><hr><ul><li><u><strong>TCP报文段首部格式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-08-05.png" alt=""></p><p><strong>序号</strong>：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的<strong>第一个字节的序号</strong>。<br><strong>确认号</strong>：<strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。<br><strong>数据偏移(首部长度)</strong> ：TCP报文段的数据起始处距离TCP报文段的起始处有多远以<strong>4B</strong>位单位，即1个数值是4B。</p><p>6个控制位：</p><ol><li><strong>紧急位URG</strong>：URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位ACK</strong>：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH（几乎不考）：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST（几乎不考）：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位SYN</strong>：SYN=1时，表明是一个连接请求/连接接受报文。</li><li><strong>终止位FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ol><p><strong>窗口</strong>：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。<br><strong>检验和</strong>：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。<br><strong>紧急指针</strong>：URG=1时才有意义，指出本报文段中紧急数据的字节数。<br><strong>选项</strong>：最大报文段长度MSS、窗口扩大、时间戳、选择确认…</p><hr><h3 id="4、TCP连接管理">4、TCP连接管理</h3><ul><li><u><strong>TCP连接管理</strong></u></li></ul><p>TCP连接的三个阶段：连接建立 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 数据传送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 连接释放</p><p>TCP连接的建立采用<strong>客户服务器方式</strong>，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。</p><hr><ul><li><u><strong>TCP的连接建立(三次握手)</strong></u></li></ul><p>假设运行在一台主机(客户)上的一个进程想与另一台主机(服务器)上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-40-48.png" alt=""></p><p><strong>ROUND 1</strong>:<br>客户端发送连接请求报文段，无应用层数据。<br>SYN=1，seq=x(随机)（seq就是上一节的<strong>序号</strong>）</p><p><strong>ROUND 2</strong>:<br>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。<br>SYN=1，ACK=1，seq=y(随机)，ack=x+1（ack就是上一节的<strong>确认号</strong>）</p><p><strong>ROUND 3</strong>:<br>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。<br>SYN=0，ACK=1，seg=x+1，ack=y+1</p><hr><ul><li><u><strong>SYN洪范攻击</strong></u></li></ul><p>SYN洪泛攻击发生在OSI第四层，这种方式利用<strong>TCP</strong>协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的<strong>第一个数据包</strong>，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><hr><ul><li><u><strong>TCP的连接释放(四次握手)</strong></u></li></ul><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”(缓存和变量)将被释放。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-41-21.png" alt=""></p><p><strong>ROUND 1</strong>:<br>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。<br>FIN=1，seq=u</p><p><strong>ROUND 2</strong>:<br>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了一一半关闭状态。<br>ACK=1，seq=v，ack=u+1</p><p><strong>ROUND 3</strong>:<br>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。<br>FIN=1，ACK=1，seq=w，ack=u+1</p><p><strong>ROUND 4</strong>:<br>客户端回送一个确认报文段，再等到时间等传+时器设置的<strong>2MSL(最长报文段寿命)</strong> 后，连接底关闭。</p><hr><h3 id="5、TCP可靠传输">5、TCP可靠传输</h3><ul><li><u><strong>TCP可靠传输</strong></u></li></ul><p>传输层：使用TCP实现可靠传输。<br>网络层：提供尽最大努力交付，不可靠传输。</p><p><strong>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的</strong>。</p><p>TCP实现可靠传输的机制：</p><ol><li><p><strong>校验</strong></p><p>与UDP校验一样，增加伪首部</p></li><li><p><strong>序号</strong></p></li><li><p><strong>确认</strong></p></li><li><p><strong>重传</strong></p></li></ol><hr><ul><li><u><strong>序号</strong></u></li></ul><p>一个字节占一个序号。<br><strong>序号字段</strong>指的是一个报文段第一个字节的序号。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-59-07.png" alt=""></p><hr><ul><li><u><strong>确认</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_20-58-38.png" alt=""></p><hr><ul><li><u><strong>重传</strong></u></li></ul><p>确认重传不分家，TCP的发送方在 <strong>规定的时间(重传时间)</strong> 内<strong>没有收到确认</strong>就要重传已发送的报文段。<strong>超时重传</strong></p><p>TCP采用自适应算法，动态改变重传时间<strong>RTTs</strong>(加权平均往返时间)</p><p>觉得重传时间太久了！<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 冗余ACK</p><p><strong>冗余ACK (冗余确认)</strong><br>每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。</p><p>举例：发送方已发送1，2，3，4，5报文段。<br>接收方收到1，返回给1的确认(确认号为2的第一个字节)；<br>接收方收到3，仍返回给1的确认 (确认号为2的第一个字节)；<br>接收方收到4，仍返回给1的确认 (确认号为2的第一个字节)；<br>接收方收到5，仍返回给1的确认(确认号为2的第一个字节)；<br>发送方收到3个对于报文段1的冗余ACK <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 认为2报文段丢失，重传2号报文段。<strong>快速重传</strong></p><hr><h3 id="6、TCP流量控制">6、TCP流量控制</h3><ul><li><u><strong>TCP流量控制</strong></u></li></ul><p>流量控制：让发送方慢点，要让接收方来得及接收。</p><p>TCP利用<strong>滑动窗口</strong>机制实现流量控制。</p><p>在通信过程中，接收方根据自己<strong>接收缓存的大小</strong>，动态地调整发送方的发送窗口大小，即接收窗口rwnd (接收方设置确认报文段的<strong>窗口字段</strong>来将rwnd通知给发送方)，发送方的<strong>发送窗口取决于接收窗口rwnd和拥塞窗口cwnd的最小值</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_21-23-06.png" alt=""></p><p><strong>发送窗口大小可以动态变化</strong></p><p><strong>举例</strong>：</p><p>A向B发送数据，连接建立时，B告诉A：“我的rwnd=400(字节)”，设每一个报文段100B，报文段序号初始值为1。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_21-24-17.png" alt=""></p><p>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。</p><p>若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>。接收方收到探测报文段时给出现在的窗口值。</p><p>若窗口仍然是0，那么发送方就重新设置持续计时器。</p><hr><h3 id="7、TCP拥塞控制">7、TCP拥塞控制</h3><ul><li><u><strong>TCP拥塞控制</strong></u></li></ul><p>出现拥塞的条件:<br>对资源需求的总和 &gt; 可用资源<br>网络中有许多资源同时呈现供应不足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 网络性能变坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 网络吞吐量将随输入负荷增大而下降</p><p>拥塞控制:<br>防止过多的数据注入到网络中。 <strong>全局性</strong></p><p>拥塞控制 &amp; 流量控制：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_21-56-20.png" alt=""></p><hr><ul><li><u><strong>拥塞控制四种算法</strong></u></li></ul><p><strong>慢开始  拥塞避免</strong><br><strong>快重传  快恢复</strong></p><p>假定:</p><ol><li><p>数据单方向传送，而另一个方向只传送确认。</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度。</p><p>从前面知道：发送窗口=Min(接收窗口rwnd，拥塞窗口cwnd}</p></li></ol><p>接收窗口  <strong>接收方</strong>根据接受缓存设置的值，并告知给发送方，反映接收方容量。</p><p>拥塞窗口  <strong>发送方</strong>根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p><hr><ul><li><u><strong>慢开始和拥塞避免</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_22-07-18.png" alt=""></p><p>一个<strong>传输轮次</strong>：<br>发送了一批报文段并收到它们的确认的时间。<br>也表示：一个往返时延RTT。<br>还可以是：开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间。</p><p>ssthresh：慢重传门限（slow start thresh）</p><p>乘法减小：拥塞时的cwmd/2。</p><hr><ul><li><u><strong>快重传和快回复</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_22-07-29.png" alt=""></p><p>乘法减小：除 2.</p><p>TCP Reno版本考试会考。</p><p>TCP Tahoe版本可以不做了解。</p><hr><h2 id="第六章、应用层">第六章、应用层</h2><h3 id="1、网络应用模型">1、网络应用模型</h3><ul><li><u><strong>应用层概述</strong></u></li></ul><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义</strong>：</p><p>应用进程交换的报文类型，请求还是响应？<br>各种报文类型的语法，如报文中的各个字段及其详细描述。<br>字段的语义，即包含在字段中的信息的含义。<br>进程何时、如何发送报文，以及对报文进行响应的规则。</p><p>应用层的<strong>功能</strong>：<br>文件传输、访问和管理<br>电子邮件<br>虚拟终端<br>查询服务和远程作业登录</p><p>应用层的重要<strong>协议</strong>：<br>FTP<br>SMTP、POP3<br>HTTP<br>DNS</p><hr><ul><li><u><strong>网络应用模型</strong></u><ul><li>客户端/服务器模型（Client/Server）</li><li>P2P模型（Peer-to-Peer）</li></ul></li></ul><hr><ul><li><u><strong>客户/服务器（C/S）模型</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_22-44-32.png" alt=""></p><p><strong>服务器</strong>：<strong>提供计算服务</strong>的设备。</p><ol><li>永久提供服务</li><li>永久性访问地址/域名</li></ol><p><strong>客户机</strong>：<strong>请求计算服务</strong>的主机。</p><ol><li><p>与服务器通信，使用服务器提供的服务</p></li><li><p>间歇性接入网络</p></li><li><p>可能使用动态IP地址</p></li><li><p>不与其他客户机直接通信</p></li></ol><p>应用：Web，文件传输FTP，远程登录，电子邮件</p><hr><ul><li><u><strong>P2P模型</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_22-43-56.png" alt=""></p><p>不存在永远在线的服务器</p><p>每个主机既可以<strong>提供服务</strong>，也可以<strong>请求服务</strong></p><p>任意端系统/节点之间可以<strong>直接通讯</strong></p><p>节点间歇性接入网络</p><p>节点可能改变IP地址</p><p>可扩展性好</p><p>网络健壮性强</p><hr><h3 id="2、DNS系统">2、DNS系统</h3><ul><li><u><strong>DNS系统</strong></u></li></ul><p>IP地址难记忆？ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 域名</p><p>DNS系统：IP地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 域名</p><p>访问域名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> DNS服务器将域名解析成IP地址，通过IP地址就可以访问了。</p><hr><ul><li><u><strong>域名</strong></u></li></ul><p><strong>根</strong></p><p><strong>顶级域名</strong></p><p>国家顶级域名 cn（中国），us（美国），uk（英国）</p><p>通用顶级域名 com（公司、企业），net（网络服务机构），org（非盈利性组织），gov（政府），int（国际组织），aero（航空传输企业），museum（博物馆），travel（旅游业）</p><p>基础结构域名/反向域名  arpa</p><p><strong>二级域名</strong></p><p>类别域名 ac（科研机构），com，edu（教育行业），gov，mil（中国国防机构），net，org</p><p>行政区域名 用于我国各省、自治区、直辖市 bj（北京），js（江苏）</p><p>自己注册的 注意要全球唯一</p><p><strong>三级域名</strong></p><p><strong>四级域名</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_23-19-33.png" alt=""></p><hr><ul><li><u><strong>域名服务器</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_23-22-26.png" alt=""></p><p>根域名服务器</p><p>顶级域名服务器 （管理该顶级域名服务 器注册的所有二级域名）</p><p>权限域名服务器 （负责一个区的域名服 务器）</p><p>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</p><hr><ul><li><u><strong>域名解析过程</strong></u><ul><li>递归解析</li><li>迭代解析</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_23-23-57.png" alt=""></p><hr><h3 id="3、文件传输协议FTP">3、文件传输协议FTP</h3><ul><li><p><u><strong>文件传输协议</strong></u></p><ul><li><p>文件传送协议FTP（File Transfer Protocol）</p><p>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。</p></li><li><p>简单文件传送协议TFTP（Trivial File Transfer Protocol）</p></li></ul></li></ul><hr><ul><li><u><strong>FTP服务器和用户端</strong></u></li></ul><p>FTP是基于客户/服务器（C/S）的协议。</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。</p><p>依照 FTP 协议提供服务，进行文件传送的计算机就是 <strong>FTP 服务器</strong>。</p><p>连接 FTP 服务器，遵循FTP协议与服务器传送文件的电脑就是 <strong>FTP 客户端</strong>。</p><p>应用：FTP客户端软件、Windows自 带FTP命令</p><hr><ul><li><u><strong>FTP工作原理</strong></u></li></ul><p>登录：ftp地址 用户名&amp;密码</p><p>匿名登录：互连网中有很大一部分 FTP 服务器被称为“匿名”（Anonymous）FTP 服 务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在 该服务器进行登记注册，也不用取得FTP服务器的授权。 Anonymous（匿名文件传输）能够使用户与远程主机建立连接并以匿名身 份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特 殊的用户名“anonymous”登录FTP服务，就可访问远程主机上公开的文件。</p><p>FTP使用TCP实现可靠传输。</p><p>FTP服务器服务进程：</p><ol><li>1个主进程</li><li>n个从属进程</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-02_23-43-34.png" alt=""></p><p><strong>控制</strong>连接<strong>始终</strong>保持</p><p><strong>数据</strong>连接保持一会</p><p>是否使用TCP 20端口建立数据 连接与传输模式有关。<strong>主动</strong>方式使用TCP 20端口；<strong>被动</strong>方式由服务器和客户端自行协商决定（端口&gt;1024）</p><p><strong>FTP传输模式</strong><br>​文本模式：ASCII模式，以文本序列传输数据；<br>​二进制模式：Binary模式，以二进制序列传输数据。</p><hr><h3 id="4、电子邮件">4、电子邮件</h3><ul><li><u><strong>电子邮件系统概述—电子邮件的信息格式</strong></u></li></ul><p>电子邮件</p><ul><li><p>信封 <code>abc@163.com</code></p></li><li><p>内容</p><ul><li><p>首部</p><p>To：<code>abc@163.com</code></p><p>Subject：Hello！</p></li><li><p>主体</p></li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span></p><table><thead><tr><th>From：111@163.com <br />To：abc@163.com <br />Subject：Hello！ <br />Date：2018-8-8</th></tr></thead><tbody><tr><td>Blabla…</td></tr></tbody></table></li></ul><hr><ul><li><u><strong>电子邮件系统概述—组成结构</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_07-42-20.png" alt=""></p><p>客户端软件（Foxmail、Outlook）功能：1.撰写 2.显示 3.处理 4.通信<br>邮件服务器功能：1.发送&amp;接收邮件 2.向发件人报告邮件传送结果（C/S模式）</p><hr><ul><li><u><strong>简单邮件传送协议SMTP</strong></u></li></ul><p>SMTP规定了在两个相互通信的<strong>SMTP进程</strong>之间应如何交换信息。<br>负责发送邮件的SMTP进程就是<strong>SMTP客户</strong>，负责接收邮件的进程就是<strong>SMTP服务器</strong>。<br>SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）。</p><p>SMTP建立在TCP连接之上，使用端口号25，C/S模式。</p><p>STMP通信的三个阶段：连接建立 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 邮件传送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 连接释放</p><p><strong>1、连接建立</strong></p><p>发送方写好邮件，放到发送服务器的邮件缓存里面；<br>发送方邮件服务器每隔一定时间扫描缓存，有邮件则与接收方邮件服务器建立TCP连接（发：端口号25）；<br>接收方邮件服务器发出应答信息：22 Service ready；<br>发送方邮件服务器在发出：HELLO命令；<br>发送方邮件服务器若有能力接收邮件，回答“250 OK” 否则，回答“421 Service not available”。</p><p><strong>2、邮件传送</strong></p><p>A : MAIL FROM：<br>B : 250 OK / B : 451（452、500…） SMTP服务器是否已经准备好接收邮件<br>A : RCPT TO：&lt;<code>mooc@163\com</code>&gt;  可以有多个RCPT命令<br>B : 250 OK / B : 550 No such user here  SMTP服务器确定是否有这个用户<br>A : DATA 要开始传输邮件的内容了<br>B : 354 start mail input; end with  &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; SMTP服务器同意传输<br>A : Date…. 开始传输邮件内容<br>B : 250 OK 接收结束</p><p><strong>3、连接释放</strong></p><p>邮件发完，SMTP客户发送QUIT命令，SMTP服务器返回“221”，表示同意释放TCP连接。</p><hr><ul><li><u><strong>MIME</strong></u></li></ul><p><strong>STMP的缺点</strong>：<br>1.SMTP不能传送可执行文件或者其他二进制对象。<br>2.SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。<br>3.SMTP服务器会拒绝超过一定长度的邮件。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>通用因特网邮件扩充MIME</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_08-04-05.png" alt=""></p><p><strong>使得传输内容丰富多彩</strong><br>使电子邮件系统可以支 持声音、图像、视频、 多种国家语言等等。</p><hr><ul><li><u><strong>邮局协议POP3</strong></u></li></ul><p>POP3建立在TCP连接之上，使用端口号25，C/S模式。</p><p>POP3工作方式</p><ul><li>下载并保留（在服务器）</li><li>下载并删除</li></ul><hr><ul><li><u><strong>网际报文存取协议IMAP</strong></u></li></ul><p>IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部， 若用户需要打开某个邮件，该邮件才上传到用户的计算机上。<br>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分 （先看正文，有WiFi的时候再下载附件）。</p><hr><ul><li><u><strong>基于万维网的电子邮件</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_08-09-03.png" alt=""></p><hr><h3 id="5、万维网和HTTP协议">5、万维网和HTTP协议</h3><ul><li><u><strong>万维网概述</strong></u></li></ul><p>万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/<strong>资料空间</strong>，是无数个网络站点和网页的集合。<br><strong>统一资源定位符URL</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>唯一标识</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{唯一标识}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">唯一标识</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> <strong>资源</strong>（文字、视频、音频…）</p><p>URL一般形式：（<strong>URL不区分大小写</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 例如：http://www.pku.edu.cn</span><br><span class="line"> http    域名</span><br><span class="line"> ftp    IP地址</span><br></pre></td></tr></table></figure><p>用户通过点击超链接（<a href="http://www.baidu.com">http://www.baidu.com</a>）获取资源，这些资源通过超文本传输协议（<strong>HTTP</strong>）传送给使用者。<br>万维网以<strong>客户/服务器</strong>方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。<br>万维网使用超文本标记语言<strong>HTML</strong>，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能 够在自己的屏幕上显示出来。</p><hr><ul><li><u><strong>超文本传输协议HTTP</strong></u></li></ul><p>HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给 浏览器。</p><p>用户浏览页面方法：</p><ol><li>输入URL</li><li>点击超链接</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_08-29-52.png" alt=""></p><p>具体过程：</p><ol><li>浏览器分析URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示</li></ol><p>注：浏览器可以只下载文本部分。</p><hr><ul><li><u><strong>HTTP协议的特点</strong></u></li></ul><p>HTTP协议是<strong>无状态</strong>的（没有记忆的）。</p><p>但是在实际工作中，一些万维网站点常常希望能够识别用户。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> Cookie</p><p>Cookie是存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别，如“123456”）的访问记录。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 提供个性化服务</p><p>HTTP采用<strong>TCP</strong>作为运输层协议，但HTTP协议<strong>本身是无连接的</strong>（通信双方在交换HTTP报文之前不需要先建立HTTP连接）。</p><hr><ul><li><u><strong>HTTP协议的连接方式</strong></u><ul><li>持久连接 Keep-alive<ul><li>非流水线</li><li>流水线</li></ul></li><li>非持久连接 Close</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_08-37-42.png" alt=""></p><hr><ul><li><u><strong>超文本传输协议HTTP——报文结构</strong></u></li></ul><p>HTTP报文：请求报文 和 响应报文</p><p>HTTP报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些ASCII码串。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-02-03_08-40-59.png" alt=""></p><p>状态码：<br>1xx表示通知信息的，如请求收到了或正在处理。<br>2xx表示成功，如接受或知道了。 <strong>220 Accepted</strong><br>3xx表示重定向，如要完成请求还必须采取进一步的行动。 <strong>301 Moved</strong><br>4xx表示客户的差错，如请求中有错误的语法或不能完成。 <strong>Permanently</strong><br>5xx表示服务器的差错，如服务器失效无法完成请求。<strong>404 Not Found</strong></p><p>例如：某浏览器发出的请求报文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.test.edu.cn</span><br><span class="line">Connection: Close</span><br><span class="line">Cookie: 123456</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道操作系统</title>
      <link href="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YE411D7nH?t=3.0&amp;p=2">【王道考研操作系统】</a></p><p>微博大号–@王道咸鱼老师-计算机考研<br>微博小号–@王道楼楼老师-计算机考研</p><h1>第一章 计算机系统概述</h1><h2 id="1-1-1-操作系统的概念、功能">1.1.1 操作系统的概念、功能</h2><ul><li><strong><u>大家都熟悉的操作系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_18-59-48.jpg" alt=""></p><hr><ul><li><u><strong>操作系统的概念（定义）</strong></u></li></ul><p>一台电脑的诞生~<br>Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机）<br>Step 2：出售前安装操作系统<br>Step 3：用户安装应用程序（eg：QQ）<br>Step 4：使用 QQ 聊天</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-16-00.jpg" alt=""></p><p><strong>操作系统</strong>（Operating System， OS）</p><ul><li>是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>（<u>①操作系统是系统资源的管理者</u>）资源，并合理地组织调度计算机的工作和资源的分配；</li><li>以<strong>提供给用户和其他软件方便的接口和环境</strong>（<u>②向上层提供方便易用的服务</u>）；</li><li>它是计算机系统中最基本的<strong>系统软件</strong>（<u>③是最接近硬件的一层软件</u>）。</li></ul><p>直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-25-08.jpg" alt=""></p><hr><ul><li><u><strong>操作系统的功能和目标——作为系统资源的管理者</strong></u><ul><li>提供的功能：<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>目标：<ul><li>安全、高效</li></ul></li></ul></li></ul><p>补充知识：执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p><p>用QQ和朋友视频聊天的过程：<br>Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）【逐层打开文件夹，找到QQ.exe 这个程序（可执行文件）的存放位置】<br>Step 2：双击打开 QQ.exe 【需要把该程序相关数据放入内存】<br>Step 3：QQ 程序正常运行 【对应的进程被处理机（CPU）处理】<br>Step 4：开始和朋友视频聊天 【需要将摄像头设备分配给进程】</p><hr><ul><li><u><strong>操作系统的功能和目标——向上层提供方便易用的服务</strong></u></li></ul><p><strong>封装思想</strong>：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-35-16.jpg" alt=""></p><p><strong>GUI</strong>：图形化用户接口（Graphical User Interface） 【很多现代操作系统都提供GUI】<br>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p><p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口<br>Step 1：win键+R<br>Step 2：输入cmd，按回车，打开命令解释器<br>Step 3：尝试使用 time 命令<br>【特点：用户说一句， 系统跟着做一句】</p><p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口<br>使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。<br>【特点：用户说一堆， 系统跟着做一堆】<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-40-45.jpg" alt=""></p><p>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。<br>如：写C语言“Hello world”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-45-43.jpg" alt=""><br>系统调用类似于函数调用，是应用程 序请求操作系统服务的唯一方式。<strong>在有的教材中： 系统调用=广义指令</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-50-22.jpg" alt=""><br>【有的教材中把命令接口和程序接口统称为“用户接口”，意思就是说狭义的用户接口不包括GUI。】</p><hr><ul><li><u><strong>操作系统的功能和目标——作为最接近硬件的层次</strong></u></li></ul><p>需要实现<strong>对硬件机器的拓展</strong>；<br>没有任何软件支持的计算机成为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器；<br>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p><p>类比汽车： 发动机——只会转；轮胎——只会滚；<br>在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展</p><p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</p><hr><h2 id="1-1-2-操作系统的特征">1.1.2 操作系统的特征</h2><blockquote><ul><li>并发</li><li>共享</li></ul><p>并发和共享是两个最基本的特征，二者互为存在条件。</p><ul><li>虚拟</li><li>异步</li></ul><p>重要考点：<br>理解并发和并行的区别<br>并发和共享互为存在条件<br>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</p></blockquote><ul><li><u><strong>操作系统的特征——并发</strong></u></li></ul><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。<br>常考易混概念——<strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p><p>并发 VS 并行：<br>eg：假设小渣和老渣每人有两个女朋友。任务1：和一号约会；任务2：和二号约会…<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_20-10-44.jpg" alt=""></p><p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。<br>操作系统就是伴随着“多道程序技术”（后面介绍）而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p><p>注意（<strong>重要考点</strong>）：<br><strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行<br><strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行<br>比如Intel 的第八代 i3 处理器就是 <strong>4 核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>；【即使是对于4核CPU来说，只要有4个以 上的程序需要“同时”运行，那么并发性依然是必不可少的，因此<strong>并发性是操作系统一个最基本的特性</strong>】</p><hr><ul><li><u><strong>操作系统的特征——共享</strong></u></li></ul><p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><ul><li><p><strong>两种资源共享方式</strong></p><ul><li><p><strong>互斥共享方式</strong>：<br>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p></li><li><p><strong>同时共享方式</strong>：</p><p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p></li></ul></li></ul><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p><p>生活实例：<br>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p><hr><ul><li><u><strong>操作系统的特征——并发和共享的关系</strong></u></li></ul><p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。<br><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>通过上述例子来看并发与共享的关系：<br>使用QQ发送文件A，同时使用微信发送文件B。<br>1.两个进程正在并发执行（并发性） 【如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义】<br>2.需要共享地访问硬盘资源（共享性）【如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发】</p><p><strong>二者互为存在条件。</strong></p><hr><ul><li><strong><u>操作系统的特征——虚拟</u></strong></li></ul><p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>Yo~用一个例子来理解<br>背景知识：一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p><p>GTA5需要4GB的运行内存，<br>QQ 需要256MB的内存，<br>迅雷需要256MB的内存，<br>网易云音乐需要256MB的内存……<br>我的电脑：4GB内存<br>问题：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？<br>答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>空分复用技术</strong>” 。</p><p>某单核CPU的计算机中，用户打开了以下软件。。。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-18-58.jpg" alt=""></p><p>问题：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>时分复用技术</strong>” 。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p><ul><li><strong>虚拟技术</strong><ul><li><strong>空分复用技术</strong>（如虚拟存储技术）</li><li><strong>时分复用技术</strong>（如虚拟处理器）</li></ul></li></ul><p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p><hr><ul><li><u><strong>操作系统的特征——异步</strong></u></li></ul><p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>老渣要和两个女孩并发约会：</p><ul><li>第一道程序：<ul><li>一号的指令1：老渣陪我吃饭</li><li>一号的指令2：老渣把心给我</li></ul></li><li>第二道程序：<ul><li>二号的指令1：老渣把心给我</li><li>二号的指令2：老渣陪我吃饭</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p><p>与一、二号的约会 = 两道并发执行的程序 老渣的心 = 有限的系统资源</p><p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</p><p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p><hr><h2 id="1-2-操作系统的发展与分类">1.2 操作系统的发展与分类</h2><ul><li><strong><u>手工操作阶段</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-40-24.jpg" alt=""></p><hr><ul><li><strong><u>批处理阶段——单道批处理系统</u></strong></li></ul><p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-43-53.jpg" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-48-41.jpg" alt=""></p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p><hr><ul><li><strong><u>批处理阶段——多道批处理系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-04.jpg" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-54.jpg" alt=""></p><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）</p><hr><ul><li><strong><u>分时操作系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-14-13.jpg" alt=""></p><p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。<br>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</p><hr><ul><li><strong><u>实时操作系统</u></strong><ul><li>硬实时系统<br>必须在绝对严格的规定时间内完成处理<br>如：导弹控制系统、自动驾驶系统</li><li>软实时系统<br>能接受偶尔违反时间规定<br>如：12306火车订票系统</li></ul></li></ul><p>实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p><hr><ul><li><strong><u>其他几种操作系统</u></strong></li></ul><p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p><p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p><p>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</p><hr><h2 id="1-3-1-操作系统的运行机制">1.3.1 操作系统的运行机制</h2><blockquote><p>Tips：</p><ol><li>都是高频考点，很重要</li><li>初学者不完全理解没关系， 放心大胆地往后学，随着后面章节的学习，理解会逐渐加深</li></ol></blockquote><ul><li><strong><u>预备知识：程序是如何运行的？</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-19-00.jpg" alt=""></p><p>程序运行的过程其实就 是CPU执行一条一条的机器指令的过程</p><p>“指令”就是处理器（CPU）能识别、执行的最基本命令</p><p>注：很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也 称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别 开。本节中的“指令”指二进制机器指令</p><hr><ul><li><strong><u>内核程序 v.s. 应用程序</u></strong></li></ul><p>我们普通程序员写的程序就是“<strong>应用程序</strong>”</p><p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”<br>由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong> ” 内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核） 操作系统的功能未必都在内核中，如图形化用户界面 GUI</p><hr><ul><li><strong><u>特权指令 v.s. 非特权指令</u></strong></li></ul><p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU 执行一条指令前就能判断出其类型</p><p>应用程序只能使用“非特权指令”，如： 加法指令、减法指令等</p><p>操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</p><hr><ul><li><strong><u>内核态 v.s. 用户态</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-25-21.jpg" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 问题：如何实现CPU状态的切换？</p><p>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<br>处于<strong>内核态时</strong>，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong><br>处于<strong>用户态时</strong>，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p><p>拓展：CPU 中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong> ，其中有个二进制位，1表示 “内核态”，0表示“用户态”</p><p><strong>别名</strong>：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></p><hr><ul><li><strong><u>内核态、用户态 的切换</u></strong></li></ul><table>    <tr>        <td>            一个故事：</br>    ① 刚开机时，CPU 为“<b>内核态</b>”，操作系统内核程序先上CPU运行</br>② 开机完成后，用户可以启动某个应用程序</br> ③ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行</br>【操作系统内核在让出CPU之前，会<b>用一条特权指令把 PSW 的标志位设置为“用户态”</b>】</br>④ 应用程序运行在“用户态”</br> ⑤ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…</br> ⑥ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”</br> ⑦ 这个非法事件会引发一个<b>中断信号</b></br>【<b>CPU检测到中断信号后</b>，会立即<b>变为“核心态”</b>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序】</br> ⑧ “中断”使操作系统再次夺回CPU的控制权</br> ⑨ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</br>        </td>    </tr>    </table><u>内核态</u> → <u>用户态</u>：<u>执行一条特权指令</u>——修改<u>PSW</u>的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权 <u>用户态</u> → <u>内核态</u>：由“<u>中断</u>”引发，<u>硬件自动完成变态过程</u>，触发中断信号意味着操作系统将强行夺回CPU的使用权【除了非法使用特权指令之外，还有很多事件 会触发中断信号。一个共性是，<u>但凡需要操作系统介入的地方，都会触发中断信号</u>】<hr><h2 id="1-3-2-中断和异常">1.3.2 中断和异常</h2><ul><li><strong><u>中断的作用</u></strong><br>“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li></ul><p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>（是整个系统的管理者），一种是<strong>应用程序</strong></p><p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）</p><p>“中断”是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径</p><p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序<br>没有中断机制，就不可能实现操作系统，不可能实现程序并发</p><hr><ul><li><strong><u>中断的类型</u></strong><ul><li><strong>内中断</strong><br>与当前执行的指令有关， 中断信号来源于CPU内部</li><li><strong>外中断</strong><br>与当前执行的指令无关， 中断信号来源于CPU外部</li></ul></li></ul><hr><ul><li><u><strong>内中断的例子</strong></u></li></ul><p>例子 1：试图在用户态下执行特权指令<br>例子 2：执行除法指令时发现除数为 0<br>【若当前执行的指令是非法的，则会引发一个中断信号】</p><p>例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<br>【执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “<strong>系统调用”就是通过陷入指令完成的</strong>】</p><hr><ul><li><strong><u>外中断的例子</u></strong></li></ul><p>例子1：时钟中断——由时钟部件发来的中断信号</p><p>例子2：I/O中断——由输入/输出设备发来的中断信号</p><hr><ul><li><strong><u>中断的分类</u></strong>【广义的中断】<ul><li>内中断（也称<strong>异常</strong>、例外）<ul><li>陷阱、陷入（trap）【由陷入指令引发，是应用程序故意引发的】</li><li>故障（fault）【由错误条件引起的，可能被 内核程序修复。内核程序修 复故障后会把 CPU使用权还 给应用程序，让它继续执行 下去。如：<strong>缺页中断</strong>。】</li><li>终止（abort）【由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序。如： 整数除0、非法使用特权指令】</li></ul></li><li>外中断（也称中断）【狭义的中断】<ul><li>时钟中断</li><li>I/O中断</li></ul></li></ul></li></ul><p>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常“</p><hr><ul><li><u><strong>中断机制的基本原理</strong></u></li></ul><p>检测中断信号：</p><ul><li>内中断：CPU在<strong>执行指令时</strong>会检查是否有异常发生</li><li>外中断：<strong>每个指令周期末尾</strong>，CPU都会检查是否有外中断信号需要处理</li></ul><p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-07-58.jpg" alt=""></p><p>显然，中断处理程序一定是内核程序，需要运行在“内核态”</p><hr><h2 id="1-3-3-系统调用">1.3.3 系统调用</h2><ul><li><strong><u>什么是系统调用，有何作用？</u></strong></li></ul><p>知识点回顾：<br>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p><p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p><hr><ul><li><strong><u>系统调用与库函数的区别</u></strong></li></ul><table>    <tr>        <td>普通应用程序</td>        <td>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>    </tr>    <tr>        <td>编程语言</td>        <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>    </tr>    <tr>        <td>操作系统</td>        <td>向上提供系统调用，使得上层程序能请求内核的服务</td>    </tr>    <tr>        <td>裸机</td>        <td></td>    </tr></table><p>不涉及系统调用的库函数：如的“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-21-42.jpg" alt=""></p><hr><ul><li><strong><u>小例子：为什么系统调用是必须的？</u></strong></li></ul><p>生活场景：去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开 始工作。<br>你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</p><p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p><p>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p><p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p><hr><ul><li><strong><u>什么功能要用到系统调用？</u></strong></li></ul><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p><ul><li><strong>系统调用（按功能分类）</strong><ul><li><strong>设备管理</strong>：完成设备的 <strong>请求/释放/启动</strong> 等功能</li><li><strong>文件管理</strong>：完成文件的 <strong>读/写/创建/删除</strong> 等功能</li><li><strong>进程管理</strong>：完成进程的 <strong>创建/撤销/阻塞/唤醒</strong> 等功能</li><li><strong>进程通信</strong>：完成进程之间的 <strong>消息传递/信号传递</strong> 等功能</li><li><strong>内存管理</strong>：完成内存的 <strong>分配/回收</strong> 等功能</li></ul></li></ul><p>拓展：感兴趣的同学可以搜索“Linux 系统调用”，了解 Linux 操作系统提供了哪些系统调用</p><hr><ul><li><strong><u>系统调用的过程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-36-59.png" alt=""></p><p>传递系统调用参数 → 执行陷入指令（<strong>用户态</strong>，陷入指令是非特权指令） →  执行相应的内请求核程序处理系统调用（<strong>核心态</strong>） → 返回 应用程序<br>注意：<br>1.陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态<br>2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</p><p>注意别名： 陷入指令 = trap 指令 = 访管指令</p><hr><h2 id="1-4-1-操作系统的体系结构（上）">1.4.1 操作系统的体系结构（上）</h2><ul><li><strong><u>操作系统的内核</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-43-27.png" alt=""></p><p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分。<br>实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-45-33.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-46-56.png" alt=""></p><p>注意：<br>操作系统<strong>内核</strong>需要运行在<strong>内核态</strong><br>操作系统的<strong>非内核</strong>功能运行在<strong>用户态</strong></p><p>一个故事：现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-58-30.png" alt=""></p><p>注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能<br>【注意：“变态”在这里是口头表述，考试应该正规表述，例如“状态改变”】</p><hr><ul><li><strong><u>操作系统的体系结构</u></strong><ul><li>大内核<ul><li>将操作系统的主要功能模块作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li>微内核<ul><li>只把最基本功能保留在内核</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li></ul></li></ul></li></ul><p>典型的大内核/宏内核/单内核 操作系统： Linux、UNIX<br>典型的 微内核 操作系统： Windows NT</p><p>类比：<br>操作系统的体系结构问题与企业的管理问题很相似。<br><strong>内核</strong>就是企业的<strong>管理层</strong>，负责一些重要的工作。只有管理层才能执行<strong>特权指令</strong>，普通员工只能执行<strong>非特权指令</strong>。<strong>用户态</strong>、<strong>核心态</strong>之间的切换相当于普通员工和管理层之间的工作交接<br><strong>大内核</strong>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。<br><strong>微内核</strong>：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p><hr><h2 id="1-4-2-操作系统的体系结构（下）">1.4.2 操作系统的体系结构（下）</h2><blockquote><ul><li>大内核（又名：宏内核/单内核）</li><li>微内核</li><li>分层结构（新增）</li><li>模块化（新增）</li><li>外核（新增）</li></ul><p>Tips: 一定是<strong>考简单的选择题</strong>，了解各种体系结构的<strong>特性</strong>，了解各自的<strong>优缺点</strong></p></blockquote><ul><li><strong><u>操作系统结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_15-55-43.png" alt=""></p><p>【注：加星号是作者认为更容易考的，红色星号是全新的内容，黄色星号的是老内容（大内核、微内核）】</p><hr><ul><li><strong><u>操作系统结构——分层结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-00-31.png" alt=""></p><p>最底层是硬件，最高层是用户接口<br>每层可调用更低一层【不能跨层调用】</p><hr><ul><li><strong><u>操作系统结构——模块化</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-04-57.png" alt=""></p><p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，上图所示为由模块、子模块等组成的模块化操作系统结构。</p><hr><ul><li><strong><u>操作系统结构——外核（exokernel）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-11-27.png" alt=""></p><hr><h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2><blockquote><p>操作系统引导(boot)–开机的时候怎么让操作系统运行起来?</p></blockquote><ul><li><strong><u>一个刚买来的磁盘（硬盘）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-25-17.png" alt=""></p><hr><ul><li><strong><u>安装操作系统后，操作系统引导（开机过程）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-33-54.png" alt=""></p><p>【注释】<br>根目录：顾名思义，双击C盘看到的那些东西<br>分区表：实际上是一个数据结构，记录每个盘每个分区多大、地址范围这些信息<br>BIOS：Basic Input/Output System<br>ROM引导程序：ROM boot 程序</p><p><strong>操作系统引导</strong>:<br>① CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序 (先进行硬件自检，再开机)<br>② 将磁盘的第一块–主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>③ 从活动分区 (又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序<br>④ 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作</p><hr><ul><li><strong><u>例: windows 操作系统的初始化程序</u></strong></li></ul><p>注：完整的操作系统初始化程序 (即 启动管理器) 可在根目录下找到<br>Eg：windows操作系统完整的开机初始化程序在“根目录/Windows/Boot”下</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-38-37.png" alt=""></p><hr><h2 id="1-6-虚拟机">1.6 虚拟机</h2><ul><li><strong><u>传统计算机</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-42-34.png" alt=""></p><hr><ul><li><strong><u>虚拟机</u></strong></li></ul><p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统</p><p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-53-47.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_17-02-17.png" alt=""></p><hr><ul><li><strong><u>两类虚拟机管理程序（VMM）的对比</u></strong></li></ul><table><thead><tr><th style="text-align:left"></th><th>第一类VMM</th><th>第二类VMM</th></tr></thead><tbody><tr><td style="text-align:left">对物理资源的控制权</td><td>直接运行在硬件上，能直接控制和分配物理资源</td><td>运行在Host OS之上，依赖Host OS为其分配物理资源</td></tr><tr><td style="text-align:left">资源分配方式</td><td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td><td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td></tr><tr><td style="text-align:left">性能</td><td>性能更好</td><td>性能更差，需要Host OS作为“中介”</td></tr><tr><td style="text-align:left">可支持虚拟机的数量</td><td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td><td>更少，Host OS本身也需要使用物力资源，Host OS上运行的其他进程也需要物理资源</td></tr><tr><td style="text-align:left">虚拟机的可迁移性</td><td>更差</td><td>更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛</td></tr><tr><td style="text-align:left">运行模式</td><td>第一类VMM运行在最高权限级（Ring 0），可以执行最高权限指令</td><td>第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用</td></tr></tbody></table><hr><h1>第二章 进程与线程</h1><h2 id="2-1-1-进程的概念、组成、特征">2.1.1 进程的概念、组成、特征</h2><ul><li><strong><u>进程的概念</u></strong></li></ul><p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的 可执行文件，就是一系列的指令集合。<br>进程（Process）：是<strong>动态的</strong>，是程序的一 次执行过程 同一个程序多 次执行会对应 多个进程</p><hr><ul><li><strong><u>进程的组成——PCB</u></strong></li></ul><p>思考：操作系统是这些进程的管理者，它要怎么区分各个进程？<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <strong>PID</strong>（Process ID，进程ID）</p><ol><li>操作系统要记录PID、进程所属用户ID（UID）<br>【基本的进程描述信息，可以让操作系统区分各个进程】</li><li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<br>【可用于实现操作系统对资源的管理】</li><li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）<br>【可用于实现操作系统对进程的控制、调度】</li><li>这些信息都被保存在一个数据结构<strong>PCB</strong> （Process Control Block）中，即<strong>进程控制块</strong><br>操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong></li></ol><p>【总结】：</p><ul><li><strong>进程控制块（PCB）</strong> ：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。<ul><li><strong>进程描述信息</strong><ul><li>进程标识符PID</li><li>用户标识符UID</li></ul></li><li><strong>进程控制和管理信息</strong><ul><li>CPU、磁盘、网络流量使用情况统计…</li><li>进程当前状态：就绪态 / 阻塞态 / 运行态…</li></ul></li><li><strong>资源分配清单</strong><ul><li>正在使用哪些文件</li><li>正在使用哪些内存区域</li><li>正在使用哪些I/O设备</li></ul></li><li><strong>处理机相关信息</strong><ul><li>如PSW，PC等等各种寄存器的值（用于实现进程切换）</li></ul></li></ul></li></ul><p>操作系统对进程进行管理工作所需的信息都存在PCB中</p><hr><ul><li><u><strong>进程的组成——程序段、数据段</strong></u><ul><li><strong>PCB</strong><ul><li>进程描述信息</li><li>进程控制和管理信息</li><li>资源分配清单</li><li>处理机相关信息</li></ul></li><li><strong>程序段</strong><ul><li>程序的代码（指令序列）</li></ul></li><li><strong>数据段</strong><ul><li>运行过程中产生的各种数据（如：程序中定义的变量）</li></ul></li></ul></li></ul><p><strong>PCB</strong> 是<strong>给操作系统用的</strong>。<br><strong>程序段、数据段</strong>是<strong>给进程自己用的</strong>。</p><hr><ul><li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li></ul><p>一条高级语言的代码翻译过来可能会对应多条机器指令<br>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-07-33.png" alt=""></p><p>一个<strong>进程实体（进程映像）</strong> 由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。 <strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong> 是<strong>静态</strong>的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）</p><hr><ul><li><u><strong>进程的组成</strong></u>【更确切的说，应该 是“进程实体(进程 映像)的组成”】<ul><li><strong>PCB</strong>【PCB 是给操作系统用的】<ul><li>进程描述信息</li><li>进程控制和管理信息</li><li>资源分配清单</li><li>处理机相关信息</li></ul></li><li><strong>程序段</strong><ul><li>程序的代码（指令序列）</li></ul></li><li><strong>数据段</strong><ul><li>运行过程中产生的各种数据（如：程序中定义的变量）</li></ul></li></ul></li></ul><p>【程序段、数据段是给进程自己用的， 与进程自身的运行逻辑有关】<br>【同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）】</p><p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong> 引入进程实体的概念后，<br>可把<strong>进程定义为</strong>： 进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。<br>【一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行】</p><p>注意：PCB是进程存在的唯一标志！</p><hr><ul><li><strong><u>进程的特征</u></strong></li></ul><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p><ol><li><strong>动态性</strong>【动态性是进程最基本的特征】<br>进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li><strong>并发性</strong><br>内存中有多个实体进程，各进程可并发执行</li><li><strong>独立性</strong><br>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性</strong><br>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li><li><strong>结构性</strong><br>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ol><hr><h2 id="2-1-2-进程的状态与转换、进程的组织">2.1.2 进程的状态与转换、进程的组织</h2><ul><li><u><strong>进程的状态——创建态、就绪态</strong></u></li></ul><p>进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</p><p>当进程创建完成后，便进入“<strong>就绪态</strong>”， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行</p><hr><ul><li><strong><u>进程的状态——运行态</u></strong></li></ul><p>系统中可能会有很多个进程都处于就绪态；</p><p>当CPU空闲时，操作系统就会选择一个就绪进程， 让它上处理机运行；</p><p>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。 CPU会执行该进程对应的程序（执行指令序列）</p><hr><ul><li><strong><u>进程的状态——阻塞态</u></strong></li></ul><p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p><p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</p><p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p><hr><ul><li><u><strong>进程的状态——终止态</strong></u></li></ul><p>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。</p><p>此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。</p><p>当终止进程的工作完成之后，这个进程就彻底消失了。</p><hr><ul><li><strong><u>进程状态的转换</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-37-42.png" alt=""></p><p><strong>注意：不能由阻塞态直接转换为运行态， 也不能由就绪态直接转换为阻塞态</strong>（因为 进入阻塞态是进程主动请求的，必然需要 进程在运行时才能发出这种请求）</p><hr><ul><li><strong><u>进程的状态</u></strong><ul><li><strong>三种基本状态</strong>【进程的整个生命周期 中，大部分时间都处 于三种基本状态】<ul><li>运行态（Running）【单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态】<br>占有CPU，并在CPU上运行</li><li>就绪态（Ready）<br>已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li><li>阻塞态（Waiting / Blocked，又称：等待态）<br>因等待某一事件而暂时不能运行</li></ul></li><li>另外两种状态<ul><li>创建态（New，又称：新建态）<br>进程正在被创建，操作系统为进程分配资源、初始化PCB</li><li>终止态（Terminated，又称：结束态）<br>进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li></ul></li></ul></li></ul><p><strong>进程PCB中，会有一个变量 state 来表示进程的当前状态</strong>。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p><hr><ul><li><strong><u>进程的组织——链接方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-03-39.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-04-35.png" alt=""></p><hr><ul><li><u><strong>进程的组织——索引方式</strong></u></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-05-33.png" alt=""></p><hr><ul><li><strong><u>进程的组织</u></strong><ul><li><strong>链接方式</strong><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ul></li><li><strong>索引方式</strong><ul><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有指向各个索引表的指针</li></ul></li></ul></li></ul><p>大多数操作系统使用链接方式【</p><hr><h2 id="2-1-3-进程控制">2.1.3 进程控制</h2><ul><li><strong><u>什么是进程控制？</u></strong></li></ul><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：反正进程控制就是要实现进程状态转换</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-15-07.png" alt=""></p><hr><ul><li><strong><u>如何实现进程控制？</u></strong></li></ul><p>用“原语”实现【第一章提到了】</p><p>原语的执行具有“原子性”，一气呵成</p><p>思考：为何进程控制（状态转 换）的过程要“一气呵成”？<br>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</p><p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…<br>假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>①将PCB2的 state 设为 1<br>②将PCB2从阻塞队列放到就绪队列</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-22-47.png" alt=""></p><p>但是完成了第一步后收到中断信号，CPU处理中断去了，那么这个时候PCB2 的state=1，但是它却还在阻塞队列里。</p><hr><ul><li><strong><u>如何实现原语的“原子性”？</u></strong></li></ul><p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。<br>可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现<strong>原子性</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-28-05.png" alt=""></p><p>如上图：<br>CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</p><p>这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子 性”</p><p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？<br>假设用户直接在程序开头设置关中断，在程序尾设置开中断，那么这个程序执行时将不能被打断，一直霸占资源，这是不合理的。</p><hr><ul><li><strong><u>进程控制相关的原语</u></strong></li></ul><ol><li><strong>进程的创建</strong><ul><li><strong>创建原语</strong>【操作系统创建一个进程时使用的原语】<ul><li>申请空白PCB</li><li>为新的进程分配资源</li><li>初始化PCB</li><li>将PCB插入就绪队列【创建态 → 就绪态】</li></ul></li><li>引起进程创建的事件<ul><li>用户登录<br>分时系统中，用户登录成功，系统会为其创建一个新的进程</li><li>作业调度<br>多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务<br>用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求<br>由用户进程主动请求创建一个子进程</li></ul></li></ul></li><li><strong>进程的终止</strong><ul><li><strong>撤销原语</strong>【就绪态/阻塞态/运行态 → 终止态 → 无】<ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程【进程间的关系是树形结构】</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的事件<ul><li>正常结束【进程自己请求终止（exit系统调用）】</li><li>异常结束【整数除以0、非法使用特权指令， 然后被操作系统强行杀掉】</li><li>外界干预【Ctrl+Alt+delete，用户选择杀掉进程】</li></ul></li></ul></li></ol><p>3.阻塞原语、4.唤醒原语必须成对使用</p><ol start="3"><li><strong>进程的阻塞</strong><ul><li><strong>阻塞原语</strong>【运行态 → 阻塞态】<ul><li>找到要阻塞的进程对应的PCB</li><li><strong>保护进程运行现场</strong>，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li><strong>进程的唤醒</strong><ul><li><strong>唤醒原语</strong>【阻塞态 → 就绪态】<ul><li>在事件等待队列找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件<ul><li>等待的事件发生【因何事阻塞，就应由何事唤醒】</li></ul></li></ul></li><li><strong>进程的切换</strong><ul><li><strong>切换原语</strong>【运行态 → 就绪态、就绪态 → 运行态】<ul><li>将<strong>运行环境信息</strong>【进程上下文（Context ）】存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复<strong>新进程所需的运行环境</strong></li></ul></li><li>引起进程切换的事件<ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ol><hr><ul><li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li></ul><p>【上接：2.1.1 进程的概念、组成、特征 中的知识滚雪球】</p><p>CPU中会设置很多 “寄存器”，用来存放程序运行过程中所需的某些数据。</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>PSW</td><td>程序状态字寄存器</td></tr><tr><td>PC</td><td>程序计数器，存放下一条指令的地址</td></tr><tr><td>IR</td><td>指令寄存器，存放当前正在执行的指令</td></tr><tr><td>通用寄存器</td><td>其他一些必 要信息</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><table> <tr>     <td>         int x = 1;</br>x++;</br>…… </br></br>         指令1: 往内存中某个地方写入变量x的值</br>指令2: 把变量x的值放到某个寄存器中</br>指令3: 寄存器中的数值+1</br>指令4: 把寄存器的值写回变量x的存放位置</br>……</br>     </td>    </tr>  </table><p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p><p>思考：执行完指令3后， 另一个进程开始上CPU运行。<br>注意：另一个进程在运行过程中也会使用各个寄存器<br>灵魂拷问：之后还怎么切换回之前的进程？？？？</p><p>解决办法：在进程切换时<strong>先在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<br>当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong></p><hr><ul><li><strong><u>学习技巧</u></strong></li></ul><p>进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</p><ol><li>更新PCB中的信息<ul><li>a. 所有的进程控制原语一定都会修改进程状态标志</li><li>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>c. 某进程开始运行前必然要恢复期运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><hr><h2 id="2-1-4-进程通信">2.1.4 进程通信</h2><ul><li><strong><u>什么是进程通信？</u></strong><br>进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-27-27.png" alt=""></li></ul><hr><ul><li><strong><u>为什么进程通信需要操作系统支持？</u></strong></li></ul><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-30-11.png" alt=""></p><p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p><p>下面将介绍三种进程通信方式：<strong>1. 共享存储、2. 消息传递、3. 管道通信</strong></p><hr><ul><li><strong><u>进程通信——共享存储</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-36-25.png" alt=""></p><p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。<br>各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作【后面介绍】)</p><p>linux中，如何实现共享内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(...)</span><span class="comment">// 通过 shm_open 系统调用，申请一片共享内存区</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(...)</span><span class="comment">// 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中(第三章内容)</span></span></span><br></pre></td></tr></table></figure><p><strong>共享存储</strong>：</p><ul><li><strong>基于数据结构</strong>的共享：<br>比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种<strong>低级通信</strong>方式</li><li><strong>基于存储区</strong>的共享：<br>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</li></ul><hr><ul><li><strong><u>进程通信——消息传递</u></strong></li></ul><p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-44-02.png" alt=""></p><p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p><p><strong>消息传递</strong>：</p><ul><li><strong>直接通信方式</strong><br>消息直接挂到接收进程的消息缓冲队列上</li><li><strong>间接通信方式</strong><br>消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li></ul><hr><ul><li><strong><u>进程通信——消息传递（直接通信方式）</u></strong></li></ul><p>点名道姓的消息传递</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-55-43.png" alt=""></p><hr><ul><li><strong><u>进程通信——消息传递（间接通信方式）</u></strong></li></ul><p>以“信箱”作为中间实体进行消息传递</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-01-46.png" alt=""></p><hr><ul><li><strong><u>进程通信——管道通信</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-47-19.png" alt=""></p><p>那么管道通信和进程通信又有什么区别呢？<br>管道通信读写要求先进先出（循环队列）；而共享存储存取没有要求，都行</p><ol><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li><li>各进程要<strong>互斥</strong>地访问管道。 （由操作系统实现）</li><li>当<strong>管道写满</strong>时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当<strong>管道读空</strong>时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：1、<strong>一个管道允许多个写进程，一个读进程</strong> (2014年408真题高教社官方答案)；2、允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)。</li></ol><hr><ul><li><strong><u>王道书修正</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-58-27.png" alt=""></p><hr><h2 id="2-1-5-线程概念-多线程模型">2.1.5 线程概念 多线程模型</h2><ul><li><strong><u>什么是线程，为什么要引入线程？</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_14-48-55.png" alt=""></p><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>传统的进程是程序执行流的最小单位。<br>引入线程后，线程成为了程序执行流的最小单位</p><p>可以把线程理解为“轻量级进程”。</p><p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>， 也是<strong>程序执行流的最小单位</strong>。<br>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内 也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）</p><p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br><strong>线程</strong>则作为<strong>处理机的分配单元</strong>。</p><hr><ul><li><strong><u>引入线程机制后，有什么变化？</u></strong></li></ul><ol><li><strong>资源分配、调度</strong><ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li><strong>并发性</strong><ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul></li><li><strong>系统开销</strong><ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后，并发所带来的系统开销减小</li></ul></li></ol><hr><ul><li><strong><u>线程的属性</u></strong></li></ul><ol><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块 (TCB)</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ol><hr><h2 id="2-1-6-线程的实现方式-多线程模型">2.1.6 线程的实现方式 多线程模型</h2><ul><li><strong><u>线程的实现方式——用户级线程（User-Level Thread, ULT）</u></strong></li></ul><p>历史背景：早期的操作系统（如：早期Unix）只支持进程， 不支持线程。当时的“线程”是由线程库实现的</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-01-10.png" alt=""></p><p>eg：将下面进程描述成如下代码</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-02-37.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span><span class="comment">// i = 0, 1, 2, 0, 1, 2...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码的角度看，线程其实就是一段代码逻辑。 上述三段代码逻辑上可以看作三个“线程”。 while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。</p><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p><p>【问题：】<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><ol><li>线程的管理工作由谁来完成？</li><li>线程切换是否需要CPU变态？</li><li>操作系统是否能意识到用户级线程的存在？</li><li>这种线程的实现方式有什么优点和缺点？</li></ol><p>【答：】</p><ol><li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“<strong>用户级线程</strong>”就是“<strong>从用户视角看能看到的线程</strong>”</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li></ol><hr><ul><li><strong><u>线程的实现方式——内核级线程（Kernel-Level Thread, KLT”）</u></strong><br>又称“<strong>内核支持的线程</strong>“</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p><p>由操作系统支持的线程，<strong>内核级线程才是处理机分配的单位</strong></p><p>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</p><p>【问题：】<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><ol><li>线程的管理工作由谁来完成？</li><li>线程切换是否需要CPU变态？</li><li>操作系统是否能意识到用户级线程的存在？</li><li>这种线程的实现方式有什么优点和缺点？</li></ol><p>【答：】</p><ol><li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li><li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li><li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块）， 通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看能看到的线程</strong>”</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>缺点：一个用户进程会占用多个内核级线程，内核级线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ol><hr><ul><li><strong><u>多线程模型</u></strong><br>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关 系，可以划分为几种多线程模型</li></ul><p><strong>重点重点重点</strong>： 操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</p><p><strong>一对一</strong>模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p><p><strong>多对一</strong>模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-06.png" alt=""></p><p>多对多模型：n 用户及线程映射到 m 个内核级 线程（n &gt;= m）。每个用户进程对应 m 个内核 级线程。</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-11.png" alt=""></p><p>可以这么理解：<br>用户级线程是“代码逻辑”的载体<br>内核级线程是“运行机会”的载体<br>【<strong>内核级线程才是处理机分配的单位</strong>。例如：多核 CPU环境下，上图这个进程最多能被分配两个核。】</p><p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU执行<br>【内核级线程中可以运行任意一个有映射关系的用户级线程代码，如上图，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞】</p><hr><h2 id="2-1-7-线程的状态与转换">2.1.7 线程的状态与转换</h2><ul><li><strong><u>线程的状态与转换</u></strong></li></ul><p>下面与进程完全一致</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p><hr><ul><li><strong><u>线程的组织与控制</u></strong></li></ul><p>类似于进程</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-40-03.png" alt=""></p><p>组织：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-41-19.png" alt=""></p><hr><h2 id="2-2-1-调度的概念、层次">2.2.1 调度的概念、层次</h2><ul><li><strong><u>调度的概念</u></strong></li></ul><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p><hr><ul><li><strong><u>调度的三个层次——高级调度</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-49-48.png" alt=""></p><p>作业：一个具体的任务<br>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>内存空间有限，有时无法将用户提交的作业全部放入内存</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。<br>【简化理解：好几个程序需要启动，到底先启动哪个】</p><hr><ul><li><strong><u>调度的三个层次——低级调度</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-50-23.png" alt=""></p><p><strong>低级调度（进程调度/处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p><hr><ul><li><strong><u>调度的三个层次——中级调度</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-53-15.png" alt=""></p><p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p><p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p><p><strong>中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。<br>一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p><hr><ul><li><strong><u>补充知识：进程的挂起态与七状态模型</u></strong></li></ul><p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p><p>五状态模型→七状态模型：【看学校怎么考】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p><p>注意“挂起”和“阻塞”的区别，两种 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。<br>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p><hr><ul><li><strong><u>三层调度的联系、对比</u></strong></li></ul><table><thead><tr><th style="text-align:center"></th><th>要做什么</th><th style="text-align:center">调度发生在…</th><th style="text-align:center">发生频率</th><th style="text-align:center">对进程状态的影响</th></tr></thead><tbody><tr><td style="text-align:center">高级调度<br />（作业调度）</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td style="text-align:center">外存→内存<br />（面向作业）</td><td style="text-align:center">最低</td><td style="text-align:center">无→创建态→就绪态</td></tr><tr><td style="text-align:center">中级调度<br />（内存调度）</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td style="text-align:center">外存→内存<br />（面向进程）</td><td style="text-align:center">中等</td><td style="text-align:center">挂起态→就绪态 <br />（阻塞挂起→阻塞态）</td></tr><tr><td style="text-align:center">低级调度<br />（进程调度）</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td style="text-align:center">内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU</td><td style="text-align:center">最高</td><td style="text-align:center">就绪态→运行态</td></tr></tbody></table><hr><h2 id="2-2-2-进程调度的时机、切换与过程调度方式">2.2.2 进程调度的时机、切换与过程调度方式</h2><ul><li><strong><u>进程调度的时机</u></strong></li></ul><p><strong>进程调度</strong>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p><strong>需要进行</strong>进程调度与切换的情况：</p><ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如 等待I/O）</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><p><strong>不能进行</strong>进程调度与切 换的情况：</p><ol><li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区</strong>中。<br>【但是进程在普通临界区中是可以进行调度和切换的】</li><li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol><p>【考题：】<br>【对】进程在操作系统内核程序临界区中不能进行调度与切换<br>【错】（2012年联考真题）进程处于临界区时不能进行处理机调度<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>首先要知道：<br>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>临界区：访问临界资源的那段代码。<br><strong>内核程序临界区</strong>一般是用来<strong>访问某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成)</p><p>【eg:】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-24-53.png" alt=""></p><p>如果还没退出临界区 (还没解锁 )就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p><p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-25-07.png" alt=""></p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p><hr><ul><li><strong><u>进程调度的方式</u></strong></li></ul><p>有的系统中，只允许进程主动放弃处理机<br>有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><ul><li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br>【实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统】</li><li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>【可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统】</li></ul><hr><ul><li><strong><u>进程的切换与过程</u></strong></li></ul><p>“狭义的进程调度”与“进程切换”的区别：<br><strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程， 也可能是另一个进程，后一种情况就需要进程切换）<br><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p><p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ol><p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><hr><h2 id="2-2-3-调度器和闲逛程序">2.2.3 调度器和闲逛程序</h2><ul><li><strong><u>调度器/调度程序（scheduler）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p><p>上图中，2和3由调度程序引起，调度程序决定:</p><p>让谁运行?——调度算法<br>运行多长时间?——时间片大小</p><p>调度时机——什么事件会触发“调度程序” ?</p><ul><li><strong>创建新进程</strong></li><li><strong>进程退出</strong></li><li>运行<strong>进程阻塞</strong></li><li><strong>l/O中断</strong>发生(可能唤醒某些阻塞进程)</li><li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li><li>抢占式调度策略，每个<strong>时钟中断</strong>或k个时钟中断会触发调度程序工作</li></ul><p>不支持内核级线程的操作系统，调度程序的处理对象是进程<br>支持内核级线程的操作系统，调度程序的处理对象是内核线程</p><hr><ul><li><strong><u>闲逛进程</u></strong></li></ul><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程(idle)</p><p>闲逛进程的<strong>特性</strong>:</p><ul><li>优先级最低</li><li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li><li>能耗低</li></ul><hr><h2 id="2-2-4-调度算法的评价指标">2.2.4 调度算法的评价指标</h2><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>等待时间</mtext><mo>=</mo><mtext>周转时间</mtext><mo>−</mo><mtext>运行时间</mtext></mrow><annotation encoding="application/x-tex">等待时间=周转时间-运行时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">周转时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">运行时间</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均等待时间</mtext><mo>=</mo><mfrac><mtext>各作业等待时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均等待时间=\frac{各作业等待时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业等待时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></blockquote><ul><li><strong><u>CPU利用率</u></strong></li></ul><p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong></p><p><strong>CPU利用率</strong>：指CPU “忙碌”的时间占总时间的比例。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>【有的题目还会要求计 算某种设备的利用率】</p><p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒， 再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中， CPU利用率、打印机利用率分别是多少？</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>打印机利用率</mtext><mo>=</mo><mfrac><mn>5</mn><mn>15</mn></mfrac><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">打印机利用率=\frac{5}{15}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">打印机利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span><br>【通常会考察多道程序并发 执行的情况，可以用“甘 特图”来辅助计算】</p><hr><ul><li><u><strong>系统吞吐量</strong></u></li></ul><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<br><strong>系统吞吐量</strong>：单位时间内完成作业的数量</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<br>10/100 = 0.1 道/秒</p><hr><ul><li><strong><u>周转时间</u></strong></li></ul><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br><strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。<br>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>【对于用户来说，更关心自 己的单个作业的周转时间】</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>【对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值】</p><p>【思考】有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<br>eg：等待1分钟，执行10分钟；等待10分钟，运行1分钟。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><hr><ul><li><strong><u>等待时间</u></strong></li></ul><p>计算机的用户希望自己的作业尽可能少的等待处理机<br><strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p><p>作业在后备队列等待被服务（调度）<br>作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候</p><p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p><p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p><hr><ul><li><strong><u>响应时间</u></strong></li></ul><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p><p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p><hr><h2 id="2-2-5-调度算法1：先来先服务-最短作业优先-最高响应比优先">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</h2><blockquote><p>Tips：各种调度算法的学习思路</p><ol><li>算法思想</li><li>算法规则</li><li>这种调度算法是用于 作业调度 还是 进程调度？</li><li>抢占式？非抢占式？</li><li>优点和缺点</li><li>是否会导致<strong>饥饿</strong>【某进程/作业长期得不到服务】</li></ol></blockquote><ul><li><strong><u>先来先服务（FCFS, First Come First Serve）</u></strong></li></ul><ol><li><strong>算法思想</strong><br>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li><li><strong>算法规则</strong><br>按照作业/进程到达的先后顺序进行服务</li><li><strong>用于作业/进程调度</strong><br>用于作业调度时，考虑的是哪个作业先到达后备队列；<br>用于进程调度时，考虑的是哪个进程先到达就绪队列</li><li><strong>是否可抢占？</strong><br>非抢占式的算法</li><li><strong>优缺点</strong><br>优点：公平、算法实现简单<br>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶，前面某个人要买100杯…）</li><li>是否会导致<strong>饥饿</strong><br>不会</li></ol><p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p><p>先来先服务调度算法：按照到达的先后顺序调度，事实上就 是等待时间越久的越优先得到服务。 因此，调度顺序为：P1 → P2 → P3 → P4</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-52-11.png" alt=""></p><p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11</p><p>带权周转时间 = 周转时间/运行时间     P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75</p><p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7</p><p>平均周转时间 = (7+9+8+11)/4 = 8.75</p><p>平均带权周转时间 = (1+2.25+8+2.75)/4 = 3.5</p><p>平均等待时间 = (0+5+7+7)/4 = 4.75</p><hr><ul><li><strong><u>短作业优先（SJF, Shortest Job First）</u></strong></li></ul><ol><li><strong>算法思想</strong><br>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li><li><strong>算法规则</strong><br>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li><li><strong>用于作业/进程调度</strong><br>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</li><li><strong>是否可抢占？</strong><br>SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本</strong>——<strong>最短剩余时间优先算法</strong>（<strong>SRTN</strong>, Shortest Remaining Time Next）</li><li><strong>优缺点</strong><br>优点：“最短的”平均等待时间、平均周转时间<br>缺点：不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的， 并不一定真实，不一定能做到真正的短作业优先</li><li>是否会导致<strong>饥饿</strong><br>会。如果源源不断地有短作业/进程到来，可能使长作业/进 程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不 到服务，则称为“<strong>饿死</strong>”</li></ol><p>【<strong>例题1</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>非抢占式</strong>的<strong>短作业优先</strong>调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周 转时间。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p><p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业/进程。 因此，<strong>调度顺序</strong>为：P1 → P3 → P2 → P4</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p><p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p><p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p><p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p><p>平均周转时间 = (7+4+10+11)/4 = 8</p><p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p><p>平均等待时间 = (0+3+6+7)/4 = 4</p><p>【对比FCFS算法的结果的平均周转时间8.75、平均带权周转时间3.5、平均等待时间4.75，显然SPF算法的 平均等待/周转/带权周转时间都要更低】</p><p>【<strong>例题2</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>抢占式</strong>的<strong>短作业优先</strong>调度算法， 计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时 间。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p><p><strong>最短剩余时间优先</strong>算法：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个<strong>进程完成时也需要调度</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-10-34.png" alt=""></p><p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_n(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表 示当前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进程剩余时间为 m。各个时刻的情况如下：<br>0时刻（P1到达） ： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(7)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">7</span><span class="mclose">)</span></span></span></span></span><br>2时刻（P2到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>4时刻（P3到达）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">3</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、P_2(2)、\mathbf{P_3(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span></span></span></span></span><br>5时刻（P3完成且P4刚好到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">2</mn><mo stretchy="false">)</mo></mrow><mtext>、</mtext><msub><mi>P</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(2)}、P_4(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">2</span><span class="mclose">)</span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span><br>7时刻（P2完成）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">4</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_4(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>11时刻（P4完成） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(5)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">5</span><span class="mclose">)</span></span></span></span></span></p><p>周转时间 = 完成时间 - 到达时间    P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6</p><p>带权周转时间 = 周转时间/运行时间    P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5</p><p>等待时间 = 周转时间 – 运行时间    P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2</p><p>平均周转时间 = (16+5+1+6)/4 = 7</p><p>平均带权周转时间 = (2.28+1.25+1+1.5)/4 = 1.50</p><p>平均等待时间 = (9+1+0+2)/4 = 3</p><p>【对比非抢占式的短作业优先算法的平均周转时间8、平均带权周转时间2.56、平均等待时间4，显 然抢占式的这几个指标又要更低】</p><ul><li><strong>注意</strong>几个小细节：</li></ul><ol><li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</li><li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”<ul><li>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待 时间、平均周转时间还要更少</li><li>应该加上一个条件“在<strong>所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最 少”；</li><li>或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</li><li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算 法）的平均等待时间、平均周转时间最少”</li></ul></li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS）， SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ol><hr><ul><li><strong><u>对FCFS和SJF两种算法的思考…</u></strong></li></ul><p>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p><p>SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p><p>能不能设计一个算法，即考虑到各个作业 的等待时间，也能兼顾运行时间呢？<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高响应比优先算法</strong></p><hr><ul><li><strong><u>高响应比优先（HRRN, Highest Response Ratio Next）</u></strong></li></ul><ol><li><strong>算法思想</strong><br>要综合考虑作业/进程的等待时间和要求服务的时间</li><li><strong>算法规则</strong><br>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间 + 要求服务时间}{要求服务时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">等待时间</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><strong>用于作业/进程调度</strong><br>即可用于作业调度，也可用于进程调度</li><li><strong>是否可抢占？</strong><br><strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li><li><strong>优缺点</strong><br>综合考虑了等待时间和运行时间（要求服务时间）<br>等待时间相同时，要求服务时间短的优先（SJF 的优点）<br>要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li><li>是否会导致<strong>饥饿</strong><br>不会</li></ol><p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算 各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p><p><strong>高响应比优先</strong>算法：<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进 行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的</strong>进程上处理机。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p><p>0时刻：只有 P1到达就绪队列，<strong>P1</strong>上处理机<br>7时刻（P1主动放弃CPU）： 就绪队列中有 P2 (响应比=(5+4)/4=2.25)、 <strong>P3</strong>((3+1)/1=4)、 P4((2+4)/4=1.5)，<br>8时刻（P3完成）： <strong>P2</strong>(2.5)、 P4(1.75)<br>12时刻（P2完成）：就绪队列中只剩下 <strong>P4</strong></p><p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p><p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p><p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p><p>平均周转时间 = (7+4+10+11)/4 = 8</p><p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p><p>平均等待时间 = (0+3+6+7)/4 = 4</p><hr><ul><li><strong><u>三种调度算法对比</u></strong></li></ul><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">可抢占？</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">考虑到等待时间&amp;运行时间？</th><th style="text-align:center">导致饥饿？</th></tr></thead><tbody><tr><td style="text-align:center">FCFS</td><td style="text-align:center">非抢占式</td><td style="text-align:center">公平；实现简单</td><td style="text-align:center">对短作业不利</td><td style="text-align:center">等待时间√ <br />运行时间×</td><td style="text-align:center">不会</td></tr><tr><td style="text-align:center">SJF/SPF</td><td style="text-align:center">默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN）</td><td style="text-align:center">“最短的”平均等待/周转时间；</td><td style="text-align:center">对长作业不利，可能导致饥饿；难以做到真正的短作业优先</td><td style="text-align:center">等待时间× <br />运行时间√</td><td style="text-align:center">会</td></tr><tr><td style="text-align:center">HRRN</td><td style="text-align:center">非抢占式</td><td style="text-align:center">上述两种算法的权衡 折中，综合考虑的等 待时间和运行时间</td><td style="text-align:center"></td><td style="text-align:center">等待时间√ <br />运行时间√</td><td style="text-align:center">不会</td></tr></tbody></table><p>注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但 是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算 法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的 角色。而适合用于<strong>交互式系统</strong>的调度算法将在下个小节介绍…</p><p><strong>提示：一定要动手做课后习题</strong>！这些算法特性容易考小题，算法的使用常结合调度算法的评价指标在大题 中考察。</p><hr><h2 id="2-2-6-调度算法2：时间片轮转-优先级调度-多级反馈队列">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</h2><ul><li><strong><u>时间片轮转（RR, Round-Robin）</u></strong></li></ul><ol><li><strong>算法思想</strong><br>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li><strong>算法规则</strong><br>按照各进程到达<strong>就绪队列</strong>的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li><strong>用于作业/进程调度</strong><br>用于进程调度（只有作业放入内存建立了相应的进程后， 才能被分配处理机时间片）</li><li><strong>是否可抢占？</strong><br>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</li><li><strong>优缺点</strong><br>优点：公平；响应快，适用于<strong>分时操作系统</strong>；<br>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li><li>是否会导致<strong>饥饿</strong><br>不会</li><li>补充<br>时间片太大或太小分别有什么影响？【下面例题中介绍】</li></ol><p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>时间片轮转</strong>调度算法，分析时间片大小分别是2、5时的进程运行情况。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-02-10.png" alt=""></p><p>时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p><p>时间片大小为 2 （注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p><p>0时刻（<strong>P1(5)</strong> ）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片<br>2时刻（<strong>P2(4)</strong>  → P1(3)）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。 此时P2排在队头，因此让P2上处理机。（<strong>注意</strong>： 2时刻，P1<strong>下处理机</strong>，同一时刻新进程P2到达，如果在 题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>）<br>4时刻（<strong>P1(3)</strong>  → P3(1) → P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾<br>5时刻（<strong>P3(1)</strong>  → P2(2) → P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此 暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）<br>6时刻（<strong>P3(1)</strong> → P2(2) → P4(6) → P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发 生调度<br>7时刻（<strong>P2(2)</strong> → P4(6) → P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行 完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>9时刻（<strong>P4(6)</strong> → P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机<br>11时刻（<strong>P1(1)</strong> → P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机<br>12时刻（<strong>P4(4)</strong> ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机<br>14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>16时刻：所有进程运行结束</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-10-53.png" alt=""></p><p>时间片大小为 5</p><p>0时刻（<strong>P1(5)</strong> ）：只有P1到达，P1上处理机。<br>2时刻（<strong>P2(4)</strong> ）：P2到达，但P1时间片尚未结束，因此暂不调度<br>4时刻（<strong>P2(4)</strong> → P3(1)）：P3到达，但P1时间片尚未结束，因此暂不调度<br>5时刻（<strong>P2(4)</strong> → P3(1) → P4(6) ）：P4到达，同时，P1运行结束。发生调度，P2上处理机。<br>9时刻（<strong>P3(1)</strong> → P4(6) ）：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>10时刻（<strong>P4(6)</strong> ）：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>15时刻（ ）：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。<br>16时刻（ ）：P4运行完，主动放弃处理机。所有进程运行完。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p><p>若按照先来先服务调度算法…<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且会<strong>增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。<br>【比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应 可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调 试命令，可能需要等待9秒才能被系统响应】</p><p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理%进程切换，从而导致实际用于进程执行的时间比例减小。可见<strong>时间片也不能太小</strong>。<br>【一般来说，设计 时间片时要让切换进程的开销占比不超过1%】</p><hr><ul><li><strong><u>优先级调度算法</u></strong></li></ul><ol><li><strong>算法思想</strong><br>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li><li><strong>算法规则</strong><br>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li><strong>用于作业/进程调度</strong><br>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li><li><strong>是否可抢占？</strong><br>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li><li><strong>优缺点</strong><br>优点：用优先级区分紧急程度、重要程度，适用于<strong>实时操作系统</strong>。可灵活地调整对各种作业/进程的偏好程度。<br>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>是否会导致<strong>饥饿</strong><br>会</li><li>补充：<br>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置<br>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。<br><strong>静态优先级</strong>：创建进程时确定，之后一直不变。<br><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ol><p>【<strong>思考</strong>】<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>如何合理地设置各类进程的优先级？<br>通常：<br>系统进程优先级 <strong>高于</strong> 用户进程<br>前台进程优先级 <strong>高于</strong> 后台进程<br>操作系统更<strong>偏好 I/O型进程（或称 I/O繁忙型进程）</strong><br>注：与I/O型进程相对的是<strong>计算型进程（或称 CPU繁忙型进程)</strong><br>【I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话， 则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p><p>如果采用的是动态优先级，什么时候应该调整？<br>可以从追求公平、提升资源利用率等角度考虑<br>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级<br>如果某进程占用处理机运行了很长时间，则可适当降低其优先级<br>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p><p>【<strong>例题1</strong>】</p><p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p><p>非抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。</p><p>注：以下括号内表示当前处于就绪队列的进程<br>0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>7时刻（P2、<strong>P3</strong>、P4）：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。<br>8时刻（ <strong>P2</strong>、P4 ）：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机<br>12时刻（ <strong>P4</strong> ）：P2完成，就绪队列只剩P4，P4上处理机。<br>16时刻（ ）：P4完成，所有进程都结束</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-23-54.png" alt=""></p><p>【<strong>例题2</strong>】</p><p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p><p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机</strong>时发生调度。另 外，当<strong>就绪队列发生改变时</strong>也需要检查是会发生抢占。</p><p>注：以下括号内表示当前处于就绪队列的进程<br>0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>2时刻（<strong>P2</strong>）：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。<br>4时刻（P1、<strong>P3</strong>）：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。<br>5时刻（P1、<strong>P2</strong>、P4）：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列， 因此选择P2上处理机<br>7时刻（P1、<strong>P4</strong>）：P2完成，就绪队列只剩P1、P4，P4上处理机。<br>11时刻（<strong>P1</strong> ）：P4完成，P1上处理机<br>16时刻（）：P1完成，所有进程均完成</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-26-59.png" alt=""></p><hr><ul><li><strong><u>思考</u></strong></li></ul><p>FCFS算法的优点是公平</p><p>SJF 算法的优点是能尽快处理完短作业， 平均等待/周转时间等参数很优秀</p><p>时间片轮转调度算法可以让各个进程得 到及时的响应</p><p>优先级调度算法可以灵活地调整各种进 程被服务的机会</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？</p><p><strong>多级反馈队列调度算法</strong></p><hr><ul><li><u><strong>多级反馈队列调度算法</strong></u></li></ul><ol><li><strong>算法思想</strong><br>对其他调度算法的折中权衡</li><li><strong>算法规则</strong><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li></ol></li><li><strong>用于作业/进程调度</strong><br>用于进程调度</li><li><strong>是否可抢占？</strong><br><strong>抢占式</strong>的算法。在 k 级队列的进程运行过程中，若更上级的队列 （1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的 队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列 队尾。</li><li><strong>优缺点</strong><br>对各类型进程相对公平（FCFS的优点）；<br>每个新到达的进程都可以 很快就得到响应（RR的优点）；<br>短进程只用较少的时间就可完成 （SPF的优点）；<br>不必实现估计进程的运行时间（避免用户作假）；<br>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密 集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级）</li><li>是否会导致<strong>饥饿</strong><br>会【一直来短进程的话，有可能一直在高优先级队列处理，被降级的会饥饿】</li></ol><p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>多级反馈队列调度算法</strong>，分析进程运行的过程。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-47-19.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-55-40.png" alt=""></p><p>P1(1) —&gt; P2(1) —&gt; P1(2) —&gt; P2(1)—&gt; P3(1)—&gt; P2(2) —&gt; P1(4) —&gt; P1(1)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-05_22-22-51.gif" alt=""></p><p>设置多级就绪队列，各级队列<strong>优先级</strong>从<strong>高到低</strong>，<strong>时间片</strong>从<strong>小到大新进程</strong>到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程<strong>还未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>已经在最下级</strong>的队列，则<strong>重新放回最下级</strong>队列队尾<br>只有第 <strong>k 级队列为空</strong>时，才会<strong>为 k+1 级</strong>队头的进程<strong>分配时间片</strong><br><strong>被抢占处理机</strong>的进程<strong>重新放回原队列</strong>队尾</p><hr><ul><li><strong><u>三种调度算法对比</u></strong></li></ul><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">可抢占？</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">导致饥饿？</th><th style="text-align:center">补充</th></tr></thead><tbody><tr><td style="text-align:center">时间片轮转</td><td style="text-align:center">抢占式</td><td style="text-align:center">公平，适用于分时系统</td><td style="text-align:center">频繁切换有开销，不区分优先级</td><td style="text-align:center">不会</td><td style="text-align:center">时间片太大或太小有何 影响？</td></tr><tr><td style="text-align:center">优先级调度</td><td style="text-align:center">有抢占式的，也有非抢占式的。注意做题时的区</td><td style="text-align:center">区分优先级， 适用于实时系统</td><td style="text-align:center">可能导致饥饿</td><td style="text-align:center">会</td><td style="text-align:center">动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？</td></tr><tr><td style="text-align:center">多级反馈队列</td><td style="text-align:center">抢占式</td><td style="text-align:center">平衡优秀 666</td><td style="text-align:center">一般不说它有缺点，不过可能导致饥饿</td><td style="text-align:center">会</td><td style="text-align:center"></td></tr></tbody></table><p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括 分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也 能较好地满足交互式系统的需求。因此这三种算法适合用于<strong>交互式系统</strong>。（比如UNIX使用的就是多级反馈 队列调度算法）</p><p><strong>提示：一定要动手做课后习题</strong></p><hr><h2 id="2-2-5-调度算法3：多级队列">2.2.5 调度算法3：多级队列</h2><ul><li><strong><u>多级队列调度算法</u></strong></li></ul><p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_08-38-34.png" alt=""></p><p>队列之间可采取固定优先级，或时间片划分<br>固定优先级: 高优先级空时低优先级进程才能被调度<br>时间片划分:如三个队列分配时间50%、40%、10%</p><p>各队列可采用不同的调度策略，如：<br>系统进程队列采用 优先级调度<br>交互式队列采用 RR<br>批处理队列采用 FCFS</p><hr><h2 id="2-3-1-进程同步-进程互斥">2.3.1 进程同步 进程互斥</h2><ul><li><strong><u>什么是进程同步</u></strong></li></ul><p>知识点回顾：进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><p>【<strong>例1</strong>】老渣要和两个女孩并发约会：</p><ul><li>第一道程序：<ul><li>一号的指令1：老渣陪我吃饭</li><li>一号的指令2：老渣把心给我</li></ul></li><li>第二道程序：<ul><li>二号的指令1：老渣把心给我</li><li>二号的指令2：老渣陪我吃饭</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p><p>但是这个时候：<br>女一号只想做老渣的初恋<br>女二号只想交一个有恋爱经验的渣男</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>那么，老渣在并发执行这两个约会进程的时候，<br>就必须保证“一号的指令2” 一定要在“二号的指令1”之前执行。</p><p>操作系统要提供“<strong>进程同步</strong>机制”来实现上述需求。</p><p>【<strong>例2</strong>】进程通信——管道通信</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_22-46-57.png" alt=""></p><p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据→读数据</strong>”的顺序来执行的。 如何解决这种异步问题，就是 “<strong>进程同步</strong>”所讨论的内容。</p><p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><hr><ul><li><strong><u>什么是进程互斥</u></strong></li></ul><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p><p><strong>两种资源共享方式</strong></p><ul><li><p><strong>互斥共享方式</strong>：<br>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p></li><li><p><strong>同时共享方式</strong>：</p><p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p></li></ul><p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。</p><ul><li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">entry section;<span class="comment">// 进入区</span></span><br><span class="line">    critical section;<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;<span class="comment">// 退出区</span></span><br><span class="line">    remainder section; <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">区</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">进入区</td><td>负责检查是否可进入临界区，若可进入，则应<br />设置<strong>正在访问临界资源的标志</strong>（可理解为“上锁”），<br />以阻止其他进程同时进入临界区</td></tr><tr><td style="text-align:center">临界区</td><td><strong>访问临界资源</strong>的那段代码</td></tr><tr><td style="text-align:center">退出区</td><td>负责解除<strong>正在访问临界资源的标志</strong>（可理解为“解锁”）</td></tr><tr><td style="text-align:center">剩余区</td><td>做其他处理</td></tr></tbody></table><p>注意：<br><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。<br><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。<br>临界区也可称为“临界段”。</p><ul><li>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下<strong>原则</strong>：</li></ul><ol><li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><hr><h2 id="2-3-2-进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2><blockquote><p>学习提示：</p><ol><li>理解各个算法的思想、原理</li><li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li><li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li></ol></blockquote><ul><li><strong><u>如果没有注意进程互斥？</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程A、进程B在系统中并发地运行</span></span><br><span class="line">进程A： </span><br><span class="line">&#123;</span><br><span class="line">其他代码；</span><br><span class="line">使用打印机；</span><br><span class="line">其他代码；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程B：</span><br><span class="line">&#123;</span><br><span class="line">其他代码；</span><br><span class="line">使用打印机；</span><br><span class="line">其他代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调度A上处理机运行<br>当A在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度B让它上处理机运行<br>进程B也在使用打印机</p><p>结局：A、B 的打印内容混在一起了【错误的，不希望看到的】</p><p>如何实现进程互斥？</p><hr><ul><li><strong><u>单标志法</u></strong></li></ul><p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);<span class="comment">// 1 进入区</span></span><br><span class="line">critical section;<span class="comment">// 2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// 3 退出区</span></span><br><span class="line">remainder section;<span class="comment">// 4 剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);<span class="comment">// 5 进入区</span></span><br><span class="line">critical section;<span class="comment">// 6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// 7 退出区</span></span><br><span class="line">remainder section;<span class="comment">// 8 剩余区</span></span><br></pre></td></tr></table></figure><p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。<br>若 P1 先上处理机运行，则会一直卡在5。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。<br>代码1不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在5。<br>只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</p><p>因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p><p>只能按 P0 → P1 → P0 → P1 →……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。<br>因此，<strong>单标志法</strong>存在的<strong>主要问题</strong>是：<strong>违背“空闲让进”原则</strong>。</p><hr><ul><li><u><strong>双标志先检查法</strong></u></li></ul><p>算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如 “flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// 1 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 2 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// 5 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照 1 5 2 6 3 7….的顺序执行，P0 和 P1 将会同时访问临界区。 因此，<strong>双标志先检查法</strong>的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。<br>原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><hr><ul><li><strong><u>双标志后检查法</u></strong></li></ul><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查” 的方法，来避免上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// 2 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// 5 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// 6 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照 1 5 2 6….的顺序执行，P0 和 P1 将都无法进入临界区<br>因此，双标志后检查法虽然<strong>解决了“忙则等待”的问题</strong>，但是<strong>又违背了“空闲让进”和“有限等待” 原则</strong>，会因各进程都长期无法访问临界资源而<strong>产生 “饥饿”</strong> 现象。<br>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p><hr><ul><li><strong><u>Peterson 算法</u></strong></li></ul><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// 2 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);<span class="comment">// 3 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;<span class="comment">// 4 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 5 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// 7 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);<span class="comment">// 8 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;<span class="comment">// 9 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 10 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>动手推导： 按不同的顺序穿插 执行会发生什么？<br>1 2 3  6 7 8…    1 6 2 3…   1 3 6 7 8…   1 6 2 7 8…</p><p>Peterson 算法用软件方法解决了进 程互斥问题，<strong>遵循了空闲让进、忙 则等待、有限等待 三个原则</strong>，但是 依然<strong>未遵循让权等待</strong>的原则。</p><p>Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p><hr><h2 id="2-3-3-进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2><ul><li><strong><u>中断屏蔽方法</u></strong></li></ul><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为 止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断； <span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断； <span class="comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：简单、高效<br>缺点：不适用于多处理机【多个处理机同时访问临界区】；<br>只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><hr><ul><li><strong><u>TestAndSet指令</u></strong></li></ul><p>简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令<br>TSL 指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true 表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line"><span class="type">bool</span> old;</span><br><span class="line">old = *lock; <span class="comment">// old用来存放Lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将Lock设为true</span></span><br><span class="line"><span class="keyword">return</span> old;<span class="comment">// 返回Lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用 TSL 指今实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// &quot;上锁“并检查临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// “解锁”</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。<br>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p><hr><ul><li><strong><u>Swap指令</u></strong></li></ul><p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。<br>Swap 指令是<strong>用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap 指令的作用是交换两个变量的值</span></span><br><span class="line">Swap (<span class="type">bool</span> *a，<span class="type">bool</span> *b) &#123;</span><br><span class="line"><span class="type">bool</span> temp;</span><br><span class="line">temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// Lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">    Swap (&amp;lock，&amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p><hr><ul><li><strong><u>TestAndSet指令和Swap指令的逻辑</u></strong></li></ul><ol><li>old记录是否已被上锁;</li><li>再将lock设为 true;</li><li>检查临界区是否已被上锁(若已上锁，则循环重复前几步)</li></ol><p>总之就是为了：<strong>检查并上锁</strong></p><hr><h2 id="2-3-4-互斥锁">2.3.4 互斥锁</h2><ul><li><strong><u>进程互斥：锁</u></strong></li></ul><p>解决临界区最简单的工具就是<strong>互斥锁 (mutex lock)</strong> 。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 <code>acquire()</code> 获得锁，而函数 <code>release()</code> 释放锁。</p><p>每个互斥锁有一个布尔变量 <code>available</code>，表示锁是否可用。如果锁是可用的，调用 acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻寒，直到锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);<span class="comment">// 忙等待</span></span><br><span class="line">available = <span class="literal">false</span>;<span class="comment">// 获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">available = <span class="literal">true</span>;<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire()或release()的执行必须是<strong>原子</strong>操作，因此互斥锁通常<strong>采用硬件</strong>机制来实现。</p><p>互斥锁的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必约连续循环调用 acquire()。当多个进程共享同一 CPU 时，就浪费了CPU 周期。因此，互斥锁通用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p><p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong> ，如TSL指令、swap指令、单标志法</p><p>【<strong>特性</strong>】:</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li><li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><hr><h2 id="2-3-5-信号量机制">2.3.5 信号量机制</h2><ul><li><strong><u>复习回顾</u></strong></li></ul><p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题?</p><p>进程互斥的四种软件实现方式 (单标志法、双标志先检查、双标志后检查、Peterson算法)</p><p>进程互斥的三种硬件实现方式 (中断屏蔽方法、TS/TSL指令、Swap/XCHG指令)</p><ol><li>在双标志先检查法中，<strong>进入区的“检查”、“上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题:</li><li>所有的解决方案<strong>都无法实现“让权等待“</strong></li></ol><p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法–<strong>信号量机制</strong></p><hr><ul><li><strong><u>信号量机制</u></strong></li></ul><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p><p><strong>信号量</strong>其实就是一个变量 (<strong>可以是一个整数，也可以是更复杂的记录型变量</strong>)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如: 系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><p><strong>一对原语</strong>: <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p><p>wait、signal 原语常<strong>简称为 P、V操作</strong> (来自荷兰语 proberen 和 verhogen)。因此，做题的时候<strong>常</strong>把wait(S)、signal(S) 两个操作<strong>分别写为 <code>P(S)</code>、<code>V(S)</code></strong></p><hr><ul><li><strong><u>信号量机制——整型信号量</u></strong></li></ul><p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。<br>【与普通整数变量的区别： 对信号量的操作只有三种， 即 初始化、P操作、V操作】</p><p>Eg ：某计算机系统中有一台打印机…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整型信号量s，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --“检查”和“上锁”一气呵成，避免了并发、异步导致的问题--</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;<span class="comment">// wait 原语，相当于“进入区”</span></span><br><span class="line">    <span class="comment">// --存在的问题：不满足“让权等待”原则，会发生“忙等”--</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S=S<span class="number">-1</span>;<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> s)</span> &#123;<span class="comment">// signal 原语，相当于“退出区&quot;</span></span><br><span class="line">    S=S+<span class="number">1</span>;<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">进程P0:</span><br><span class="line">...</span><br><span class="line">wait(S);<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程P1:</span><br><span class="line">...</span><br><span class="line">wait(S);<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程Pn:</span><br><span class="line">...</span><br><span class="line">wait(S);<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><ul><li><p><strong><u>信号量机制——记录型信号量</u></strong></p><p><strong>大题、小题超高频出题点</strong></p></li></ul><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表 示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> value;<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过 wait 原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【如果剩余资源数不够，使用block原语使进程从</span></span><br><span class="line"><span class="comment">// 运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过 signal 原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【释放资源后，若还有别的进程在等待这种资源，则使用</span></span><br><span class="line"><span class="comment">// wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态】</span></span><br></pre></td></tr></table></figure><p>Eg：某计算机系统中有2台打印机…，<br>则可在初始化信号量 S 时将 S.value 的值设为 2，队列 S.L 设置为空</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_9-44-38.gif" alt=""></p><p>在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S)， 这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong> 。</p><p><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p><p>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>（当前运行的进程从<strong>运行态→阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待”原则&quot;</strong> ， 不会出现“忙等”现象。</p><p>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加1， 若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类 资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态→就绪态</strong>）。</p><p>注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量。</p><hr><h2 id="2-3-6-用信号量机制实现：进程互斥、同步、前驱关系">2.3.6 用信号量机制实现：进程互斥、同步、前驱关系</h2><blockquote><p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p><p>信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p><p>P( S ) —— 申请一个资源S，如果<strong>资源不够就阻塞等待</strong></p><p>V( S ) —— 释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong></p></blockquote><ul><li><strong><u>信号量机制实现进程互斥</u></strong></li></ul><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置<strong>互斥信号量</strong> mutex，<strong>初值为 1</strong> 【互斥访问临界资源】<br>【理解：信号量 mutex 表示 “进入临界区的名额”】</li><li>在进入区 P(mutex)——<strong>申请资源</strong></li><li>在退出区 V(mutex)——<strong>释放资源</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> value;<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">// 这是上一小节信号量的定义，但是如果题目没有特别说明，用下面方式定义即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【要会自己定义记录型信号量，但如果题目中没特别说明，可以把信号量的声明简写成这种形式】</span></span><br><span class="line">semphore muutex = <span class="number">1</span>;<span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">    . . .</span><br><span class="line">P(mutex);<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">    . . .</span><br><span class="line">P(mutex);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-07-06.png" alt=""></p><p><strong>P、V操作必须成对出现</strong>。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</p><hr><ul><li><strong><u>信号量机制实现进程同步</u></strong></li></ul><p>进程同步：要让各并发进程按要求有序地推进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">代码<span class="number">4</span>;</span><br><span class="line">代码<span class="number">5</span>;</span><br><span class="line">代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p><p>若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。</p><p>用信号量实现进程同步：</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li><li>设置<strong>同步信号量</strong> S, <strong>初始为 0</strong></li><li><strong>在“前操作”之后执行 V(S)</strong></li><li><strong>在“后操作”之前执行 P(S)</strong></li></ol><p>【<strong>技巧口诀：前V后P</strong>】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号量机制实现进程同步 */</span></span><br><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化同步信号量，初值为0</span></span><br><span class="line"><span class="comment">// 【理解：信号量S代表“某种资源”，刚开始是没有这种资源的。</span></span><br><span class="line"><span class="comment">// P2需要使用这种资源，而又只能由P1产生这种资源】</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);<span class="comment">// 释放资源</span></span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">P(S)<span class="comment">// 保证了 代码4 一定是在 代码2 之后执行</span></span><br><span class="line">代码<span class="number">4</span>;</span><br><span class="line">代码<span class="number">5</span>;</span><br><span class="line">代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作 时，由于 S=1，表示有可用资源，会执行 S–，S 的值变回 0， P2 进程不会执行 block 原语，而是继续往下执行代码4。</p><p>若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。 之后当执行完代码2，继而执行 V(S) 操作， S++，使 S 变回 0， 由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续 执行 代码4 了</p><hr><ul><li><strong><u>信号量机制实现前驱关系</u></strong></li></ul><p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求 按如下前驱图所示的顺序来执行：</p><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作） 因此，</p><ol><li>要<strong>为每一对前驱关系各设置一个同步信号量</strong></li><li><strong>在“前操作”之后对相应的同步信号量执行 V 操作</strong></li><li><strong>在“后操作”之前对相应的同步信号量执行 P 操作</strong></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-22-13.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">...</span><br><span class="line">s1;</span><br><span class="line">V(a);</span><br><span class="line">V(b);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">...</span><br><span class="line">    P(a);</span><br><span class="line">s2;</span><br><span class="line">    V(c);</span><br><span class="line">    V(d);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3() &#123;</span><br><span class="line">...</span><br><span class="line">    P(b);</span><br><span class="line">s3;</span><br><span class="line">    V(g);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4() &#123;</span><br><span class="line">...</span><br><span class="line">    P(c);</span><br><span class="line">s4;</span><br><span class="line">    V(e);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5() &#123;</span><br><span class="line">...</span><br><span class="line">P(d);</span><br><span class="line">    s5;</span><br><span class="line">    V(f);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">...</span><br><span class="line">    P(e);</span><br><span class="line">    P(f);</span><br><span class="line">    P(g);</span><br><span class="line">s6;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>知识点和考点</u></strong></li></ul><p>除了互斥、同步问题外， 还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行 V 操作即可</p><p>互斥问题，信 号量初值为1<br>同步问题，信 号量初值为0</p><p>前驱关系问题， 本质上就是多级同步问题</p><hr><h2 id="2-3-7-生产者消费者问题">2.3.7 生产者消费者问题</h2><ul><li><p><strong><u>问题描述</u></strong></p></li><li><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者 进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p></li><li><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p></li><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 【缓冲区没满→生产者生产】</p></li><li><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 【缓冲区没空→消费者消费】</p></li><li><p>缓冲区是临界资源，各进程必须互斥地访问。【互斥关系】</p></li><li><p>缓冲区满时，生产者必须等待。</p></li><li><p>缓冲区空时，消费者必须等待。</p></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_21-54-04.gif" alt=""></p><hr><ul><li><strong><u>问题分析</u></strong></li></ul><p>PV操作题目分析步骤：</p><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li><li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n; <span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">生产一个产品;</span><br><span class="line">P(empty);<span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        <span class="comment">// --实现互斥是在同一进程中进行一对PV操作--</span></span><br><span class="line">P(mutex);</span><br><span class="line">把产品放入缓冲区;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);<span class="comment">// 增加一个产品</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V--</span></span><br><span class="line">consumer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(full);<span class="comment">// 消耗一个产品（非空缓冲区）</span></span><br><span class="line">P(mutex);</span><br><span class="line">从缓冲区取出一个产品;</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);<span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【分析双方执行后，增加了什么，申请了什么资源<br>生产者增加了产品 V(full），消费者增加了缓冲区空白 V(empty）<br>生产者申请了空白 P(empty)，消费者申请了产品 P(full)】</p><hr><ul><li><strong><u>思考：能否改变相邻P、V操作的顺序？</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">producer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">生产一个产品;</span><br><span class="line">P(mutex);<span class="comment">// ①</span></span><br><span class="line">P(empty);<span class="comment">// ②</span></span><br><span class="line">把产品放入缓冲区;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(mutex);<span class="comment">// ③</span></span><br><span class="line">P(full);<span class="comment">// ④</span></span><br><span class="line">从缓冲区取出一个产品;</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若此时缓冲区内已经放满产品，则 empty=0，full=n。<br>则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。<br>由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。<br>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“<strong>死锁</strong>”。</p><p>同样的，若缓冲区中没有产品，即full=0，empty=n。按③④① 的顺序执行就会发生死锁。</p><p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。<br>V操作不会导致进程阻塞，因此<strong>两个V操作顺序可以交换</strong>。</p><p>【思考】能否将“生产一个产品;”和“使用产品;”放到PV操作之间呢？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><p>可以；但是不这么做，这样会使上锁和解锁之间的时间变长，实际应该让这个时间尽可能短。</p><hr><ul><li><strong><u>知识点和考点</u></strong></li></ul><p>生产者消费者问题是一个互斥、同步的综合问题。<br>对于初学者来说最难的是发现题目中隐含的两对同步关系。<br>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p><hr><h2 id="2-3-8-多生产者-多消费者">2.3.8 多生产者-多消费者</h2><ul><li><strong><u>问题描述</u></strong></li></ul><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_23-13-01.gif" alt=""></p><hr><ul><li><strong><u>问题分析</u></strong></li></ul><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>【互斥：临界区前后加P、V；同步：前V后P】</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li></ol><p>互斥关系：mutex = 1<br>对缓冲区（盘子）的访问要互斥地进行</p><p>同步关系（一前一后）：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果<br>【“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果】</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-21-38.png" alt=""></p><hr><ul><li><strong><u>如何实现</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>; <span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">准备一个苹果;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">把苹果放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(apple);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">准备一个橘子;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">把橘子放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(orange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(apple);</span><br><span class="line">P(mutex);</span><br><span class="line">从盘中取出苹果;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃掉苹果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(orange);</span><br><span class="line">P(mutex);</span><br><span class="line">从盘中取出橘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃掉橘子;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：<strong>可不可以不用互斥信号量</strong>？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore apple = <span class="number">0</span>; <span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">准备一个苹果;</span><br><span class="line">P(plate);</span><br><span class="line">把苹果放入盘子;</span><br><span class="line">V(apple);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">准备一个橘子;</span><br><span class="line">P(plate);</span><br><span class="line">把橘子放入盘子;</span><br><span class="line">V(orange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(apple);</span><br><span class="line">从盘中取出苹果;</span><br><span class="line">V(plate);</span><br><span class="line">吃掉苹果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(orange);</span><br><span class="line">从盘中取出橘子;</span><br><span class="line">V(plate);</span><br><span class="line">吃掉橘子;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程即使上处理机运行也会被阻塞。如果刚开始是父亲进程先上处理机运行，则： 父亲 P(plate)，可以访问盘子→母亲 P(plate)，阻塞等待盘子→父亲放入苹果 V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）→女儿 P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒→母亲进程访问盘子（其他进程暂时都无法进入临界区）→……</p><p><strong>结论</strong>：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。</p><p><strong>原因</strong>在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻， 最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p><p><strong>如果盘子容量为2的话</strong>…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate = <span class="number">2</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure><p>父亲 P(plate)，可以访问盘子→母亲 P(plate)，可以访问盘子→父亲在往盘子里放苹果，同时母亲也可以往盘子里 放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现 互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p><p>建议：在考试中如果来不及仔细分析，最好是可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。 但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p><p>PV 操作题目的<strong>解题思路</strong>：</p><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>【互斥：临界区前后加P、V；同步：前V后P】</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li></ol><p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。 在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生 的事看做是两种“事件”的前后关系。<br>比如，如果<strong>从单个进程行为的角度来考虑</strong>的话，我们会有以下结论：<br><strong>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</strong><br><strong>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</strong><br>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-40-36.png" alt=""></p><p>正确的分析方法应该从“事件”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”【<strong>我认为：关注点应该在资源上（请求盘子，释放盘子）</strong> 】<br>盘子变空事件→放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件” 既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-44-39.png" alt=""></p><hr><h2 id="2-3-9-吸烟者问题">2.3.9 吸烟者问题</h2><ul><li><strong><u>问题描述</u></strong></li></ul><p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、 第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它</strong>，并<strong>给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-49-18.png" alt=""></p><hr><ul><li><strong><u>问题分析</u></strong></li></ul><p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li></ol><p>组合一：纸+胶水<br>组合二：烟草+胶水<br>组合三：烟草+纸</p><p>互斥关系：桌子可以抽象为容量为1的缓冲区，要互斥访问</p><p>同步关系（从事件的角度来分析）：<br>桌上有组合一 → 第一个抽烟者取走东西<br>桌上有组合二 → 第二个抽烟者取走东西<br>桌上有组合三 → 第三个抽烟者取走东西<br>发出完成信号 → 供应者将下一个组合放到桌上</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-54-13.png" alt=""></p><hr><ul><li><strong><u>如何实现</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>; <span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure><p>【思考】是否需要设置 一个专门的互斥信号量？<br>缓冲区大小为1，同一时 刻，四个同步信号量中至多有一个的值为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">provider() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">将组合一放桌上;</span><br><span class="line">V(offer1);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">将组合二放桌上;</span><br><span class="line">V(offer2);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">将组合三放桌上;</span><br><span class="line">V(offer3);</span><br><span class="line">&#125;</span><br><span class="line">i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">P(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(offer1);</span><br><span class="line">从桌上拿走组合</span><br><span class="line">一；卷烟；抽掉；</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(offer2);</span><br><span class="line">从桌上拿走组合</span><br><span class="line">二；卷烟；抽掉；</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(offer3);</span><br><span class="line">从桌上拿走组合</span><br><span class="line">三；卷烟；抽掉；</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。<br>值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注 意体会我们是如何用一个整型变量 i 实现这个“轮流”过程的。</p><p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = rand() % <span class="number">3</span>;<span class="comment">// 随机产生0/1/2</span></span><br></pre></td></tr></table></figure><p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的 “事件”发生之后的位置。</p><hr><h2 id="2-3-10-读者-写者问题">2.3.10 读者-写者问题</h2><ul><li><strong><u>问题描述</u></strong></li></ul><p>有读者和写者两组并发进程，共享<strong>一个文件</strong>【不要被下面的图误导了，本问题只有一个已存在的文件】，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<strong>因此要求</strong>：<br>① 允许多个读者可以同时对文件执行读操作；<br>② 只允许一个写者往文件中写信息；<br>③ 任一写者在完成写操作之前不允许其他读者或写者工作；<br>④ 写者执行写操作前，应让已有的读者和写者全部退出。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_00-15-28.png" alt=""></p><ul><li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。 因此多个读者可同时访问共享数据</li><li>两个写进程同时共享数据，可能导致数据错误覆盖的问题</li><li>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题</li></ul><hr><ul><li><strong><u>问题分析</u></strong></li></ul><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li><li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li></ol><p>两类进程：写进程、读进程<br>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p><hr><ul><li><strong><u>如何实现</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">写文件…</span><br><span class="line">V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">读文件…</span><br><span class="line">count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【思考】：若两个读进程并发执行，则 count=0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况。 如何解决：出现上述问题的<strong>原因在于对 count 变量的检查和赋值无法一气呵成</strong>，因此可以设置另一个互斥信号量来保证各读进 程对count 的访问是互斥的</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">写文件…</span><br><span class="line">V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">V(mutex);</span><br><span class="line">读文件…</span><br><span class="line">P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>潜在的问题</strong>：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。 因此，这种算法中，读进程是优先的</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line">semaphore w = <span class="number">1</span>; <span class="comment">// 用于实现“写优先”【其实不是写优先，是“读写公平法”】</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(w)</span><br><span class="line">P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">写文件…</span><br><span class="line">V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">        V(W)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(w)</span><br><span class="line">P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">V(mutex);</span><br><span class="line">        V(W)</span><br><span class="line">读文件…</span><br><span class="line">P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以下并发执行 P(w) 的情况：<br>（1）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>（2）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2<br>（3）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<br>（4）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>（5）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2</p><p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并<strong>不是真正的“写优先”</strong> ，而是相对公平的先来先服务原则。 有的书上把这种算法称为“<strong>读写公平法</strong>”。</p><p>【其实是通过w实现了一个<strong>等待w的队列</strong>】<br>对上面各情况来说，当第一个事件占用了“w资源”，等待队列如下：<br>（1）[w] → [读者2]<br>（2）[w] → [写者2]<br>（3）[w] → [读者1]<br>（4）[w] → [写者1] → [读者2]<br>（5）[w] → [读者1] → [写者2]<br>所以其实是先来先服务原则，不会导致写操作饿死，但也不是“写优先”，而是”读写公平法“</p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><p>读者-写者问题为我们解决复杂的互斥问题ᨀ供了一个参考思路。</p><p>其<strong>核心思想</strong>在于设置了一个<strong>计数器 count</strong> 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p><p>另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量</strong>。</p><p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p><p>【例题：南北桥】没写完</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore west = <span class="number">0</span>;</span><br><span class="line">semaphore east = <span class="number">0</span>;</span><br><span class="line">semaphore ableForPerson = n;</span><br><span class="line">semaphore full = <span class="number">1</span>;<span class="comment">// 满人了</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 避免死锁</span></span><br><span class="line">    </span><br><span class="line">westPerson() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(west);</span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == <span class="number">0</span>)</span><br><span class="line">            P(full);</span><br><span class="line">        ableForPerson--;</span><br><span class="line">        V(west);</span><br><span class="line">        过河...</span><br><span class="line">        P(mutex);</span><br><span class="line">        ableForPerson++;  </span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == n) <span class="comment">// 我是桥上最后一个人</span></span><br><span class="line">            V(east);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eastPerson() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(east);</span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == <span class="number">0</span>)</span><br><span class="line">            P(full);</span><br><span class="line">        ableForPerson--;</span><br><span class="line">        V(east);</span><br><span class="line">        过河...</span><br><span class="line">        P(mutex);</span><br><span class="line">        ableForPerson++;  </span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == n) <span class="comment">// 我是桥上最后一个人</span></span><br><span class="line">            V(west);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-11-哲学家进餐问题">2.3.11 哲学家进餐问题</h2><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_09-27-55.png" alt=""></p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学 家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组 <code>chopstick[5]=&#123;1,1,1,1,1&#125;</code> 用于实现对5个筷子的互 斥访问。并对哲学家按<code>0~4</code>编号，哲学家 <code>i</code> 左边 的筷子编号为 <code>i</code>，右边的筷子编号为 <code>(i+1)%5</code>。</li></ol><ul><li><strong>每个哲学家吃饭前依次拿起左、 右两支筷子</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">吃饭…</span><br><span class="line">V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">思考…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果5个哲学家并发地拿起了自己左手边的筷子…<br>每位哲学家循环等待右边 的人放下筷子（阻塞）。 发生“死锁”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p><ul><li><strong>如何防止死锁的发生呢</strong>？</li></ul><p>① 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore able2eat = <span class="number">4</span>;<span class="comment">// 最多有4个人能吃饭</span></span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p(able2eat);<span class="comment">// 申请吃饭</span></span><br><span class="line">P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">吃饭…</span><br><span class="line">V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        v(able2eat);<span class="comment">// 吃完了，别人可以吃</span></span><br><span class="line">思考…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就 避免占有一支后再等待另一只的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">// 奇数号哲学家</span></span><br><span class="line">            P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 偶数号哲学家</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">            P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">        &#125;</span><br><span class="line">吃饭…</span><br><span class="line">V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">思考…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。【下面的实现其实并不是这样】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">P(mutex);</span><br><span class="line">P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">V(mutex);</span><br><span class="line">吃饭…</span><br><span class="line">V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">思考…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面代码分析下面的情况：<br>【哲学家0拿起来左边的筷子，然后进程切换到哲学家2】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-58-44.gif" alt=""></p><p>【哲学家0吃饭，这个时候哲学家1想吃饭，然后哲学家2想吃饭】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-02-32.gif" alt=""></p><p>【哲学家0吃饭，这个时候哲学家4想吃饭】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-04-15.gif" alt=""></p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><p>哲学家进餐问题的关键在于解决进程死锁。<br>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p><p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。<br>可以参考哲学家就餐问题解决死锁的三种思路。</p><hr><h2 id="2-3-12-管程">2.3.12 管程</h2><ul><li><strong><u>为什么要引入管程</u></strong></li></ul><p>信号量机制存在的问题：编写程序困难、易出错</p><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p><p>1973年，Brinch Hansen 首次在程序设计语言 (Pascal) 中引入了“管程”成分——一种高级同步机制</p><hr><ul><li><strong><u>管程的定义和基本特征</u></strong></li></ul><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明；</li><li>对该数据结构进行操作的<strong>一组过程</strong>；</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程需要一个名字。</li></ol><p>跨考Tips: “过程”其实就是“函数”</p><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></li></ol><hr><ul><li><strong><u>拓展1：用管程解决生产者消费者问题</u></strong></li></ul><p>以下当做伪代码来理解:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下当做伪代码来理解</span></span><br><span class="line">monitor ProcedureConsumer   <span class="comment">// 定义一个管程</span></span><br><span class="line">    管程内容...</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line">monitor ProcedureConsumer</span><br><span class="line">    condition full, empty;  <span class="comment">// 条件变量用来实现同步</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 缓冲区中的产品</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span> <span class="params">(Item item)</span> &#123;   <span class="comment">// 把产品放入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (count == N)     <span class="comment">// 是否满</span></span><br><span class="line">            wait(empty);    <span class="comment">// 相当于P操作</span></span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);  <span class="comment">// 放入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)     <span class="comment">// 我是第一个，空-&gt;非空，那么我会唤醒等待队列的进程</span></span><br><span class="line">            signal(full);   <span class="comment">// 相当于V操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// 从缓冲区取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)     <span class="comment">// 是否空</span></span><br><span class="line">            wait(full);     <span class="comment">// 相当于P操作</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>) <span class="comment">// 我是最后一个，满-&gt;不满，那么我会唤醒等待队列的进程</span></span><br><span class="line">            signal(empty);  <span class="comment">// 相当于V操作</span></span><br><span class="line">        <span class="keyword">return</span> remove_item();   <span class="comment">// 取出一个产品</span></span><br><span class="line">        &#125;</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProcedureConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = ProcedureConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由编译器负责实现 各进程互斥地进入管程中的过程</p><p>每次仅允许一个进程在管程内执行某个内部过程。<br>例1：两个生产者进程并发执行，依次调用了 insert 过程…<br>例2：两个消费者进程先执行，生产者进程后执行…</p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者 问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li><li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li><li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong> ，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一 个时间段内最多只会有一个进程在访问缓冲区。<strong>注意：这种互斥特性是由编译器负责实现的， 程序员不用关心</strong>）</li><li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒</strong>操作以解决同步问题。可以让一个进程或线程在条件变量上等待（<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong> ）；可以通过唤醒操作将 等待在条件变量上的进程或线程唤醒。</li></ol><p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;）， 之后其他程序员就可以使用这个管程提供的特定“入口”【“封装”思想】很方便地使用实现进程同步/互斥了。</p><hr><ul><li><strong><u>拓展2：Java 中类似于管程的机制</u></strong></li></ul><p>Java 中，如果用关键字 <code>synchronized</code> 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次只能有一个线程进入insert 函数，如果多个线程同时调用 insert 函数，则后来者需要排队等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> viod <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：不熟悉 Java 的同学看不懂也没关系，不会考，仅作为思维拓展。 熟悉 Java 的同学在时间充裕的情况下可以动手尝试用 synchronized 实现生产者消费者问题的“管程”</p><hr><h2 id="2-4-1-死锁的概念">2.4.1 死锁的概念</h2><ul><li><strong><u>什么是死锁</u></strong></li></ul><p>每位哲学家都在等待自己右边的人放下筷 子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推 进的现象，就是“死锁”。 发生死锁后若无外力干涉， 这些进程都将无法向前推进。</p><hr><ul><li><strong><u>死锁、饥饿、死循环的区别</u></strong></li></ul><p><strong>死锁</strong>：<strong>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</strong>。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。</p><p><strong>共同点</strong>：都是进程无法顺利向前推进的现象 （故意设计的死循环除 外）</p><table><thead><tr><th style="text-align:center">现象</th><th>区别</th></tr></thead><tbody><tr><td style="text-align:center">死锁</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td></tr><tr><td style="text-align:center">饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)</td></tr><tr><td style="text-align:center">死循环</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者（程序员）的问题</strong>。</td></tr></tbody></table><hr><ul><li><strong><u>死锁产生的必要条件</u></strong></li></ul><p>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ol><li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待 这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ol><p><strong>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）【选择题】</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><hr><ul><li><strong><u>什么时候会发生死锁</u></strong></li></ul><ol><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资 源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1， 两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资 源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><hr><ul><li><strong><u>死锁的处理策略</u></strong></li></ul><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><hr><h2 id="2-4-2-死锁的处理策略——预防死锁">2.4.2 死锁的处理策略——预防死锁</h2><ul><li><strong><u>破坏互斥条件</u></strong></li></ul><p><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>SPOOLing技术</strong>。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p><p>【进程1还没用完打印机之前，进程2申请使用打印机会阻塞】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-24.png" alt=""></p><p>【使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理 了，不需要再阻塞等待】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-29.png" alt=""></p><p>该策略的<strong>缺点</strong>：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p><hr><ul><li><strong><u>破坏不剥夺条件</u></strong></li></ul><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：<br>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的<strong>优先级</strong>（比如：剥夺调度方式，就是将处理机资源强行剥 夺给优先级更高的进程使用）</p><p>该策略的<strong>缺点</strong>：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><hr><ul><li><strong><u>破坏请求和保持条件</u></strong></li></ul><p><strong>请求和保持条件</strong>：进程已经<strong>保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</p><p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源 了。</p><p>该策略实现起来简单，但也有明显的<strong>缺点</strong>：<br>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造 成严重的资源浪费，<strong>资源利用率极低</strong>。</p><p>另外，该策略也有可能<strong>导致某些进程饥饿</strong>。eg:<br>【如下图：假设A类进程结束后，又来了A类进程，这样C类进程一直的怒道资源1，发生了饥饿】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-39-42.png" alt=""></p><hr><ul><li><strong><u>破坏循环等待条件</u></strong></li></ul><p><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>， 同类资源（即编号相同的资源）一次申请完。</p><p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>eg：假设系统中共有10个资源，编号为 1, 2, …… 10</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-45-16.png" alt=""></p><p>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。 因此，不可能出现所有进程都阻塞的死锁现象<br>【<strong>我的疑问</strong>，假设现在有P1,P2,P3,P4,P5，他们需要任意三个资源才能运行，这个时候他们几乎同时进行申请资源，第一轮P1[1]，p2[2]，p3[3]，p4[4]，p5[5]，第二轮P1[1,6]，p2[2,7]，p3[3,8]，p4[4,9]，p5[5,10]，这不是死锁了吗？】<br>【上面的问题，首先资源不同的编号的资源不相同，错啦】<br>【证明：反证法，假设资源编完号了（10个资源，10个进程），有以下死锁情况：(资源&lt;a，b，…，j&gt;，已经按&lt;1, 2, …,10&gt;有序编号了)<br>P1需要a资源，但是a资源被P2占有了；<br>P2需要b资源，但是b资源被P3占有了；<br>…<br>p10需要j资源，但是j资源被P1占有了。<br>那么这里对于P1进程，拥有了j(10)，资源，但是却还申请a(1)资源，矛盾<br>大概是这个意思。】</p><p>该策略的缺点： 1. 不方便增加新的设备，因为可能需要重新分配所有的编号； 2. 进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源浪费； 3. 必须按规定次序申请资源，用户编程麻烦。</p><hr><h2 id="2-4-3-死锁的处理策略——避免死锁">2.4.3 死锁的处理策略——避免死锁</h2><ul><li><strong><u>什么是安全序列</u></strong></li></ul><p>你是一位成功的银行家，手里掌握着100个亿的资金…<br>有三个企业想找你贷款，分别是 企业B、企业A、企业T，为描述方便，简称BAT。<br>B 表示：“大哥，我最多会跟你借70亿…”<br>A 表示：“大哥，我最多会跟你借40亿…”<br>T 表示：“大哥，我最多会跟你借50亿…”<br><strong>然而…江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了</strong></p><p>刚开始，BAT三个企业分别从你这儿借了 20、10、30 亿 …</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-33-04.png" alt=""></p><p>手里还有：40亿<br>此时… B 还想借 30 亿，你敢借吗？ 假如答应了B的请求……</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p><p>手里还有：10亿<br>只剩下10亿，如果BAT都提出再借20亿的请求，那么任何一个企业的需求都得不到满足…<br>【借30亿是不安全的】</p><p>手里还有：40亿<br>此时… A 还想借 20 亿，你敢借吗？假如答应了A的请求……</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-38-30.png" alt=""></p><p>手里还有：20亿<br>可以先把20亿全部借给T，等T把钱全部还回来了，手里就会有20+30=50亿，再把这些钱全借给B，B还钱后总共有 50+20=70亿，最后再借给A【之后按T → B → A的顺序借钱是OK的】</p><p>或者，先借给A 10亿，等A还钱了手里就 有 20+30 = 50 亿，再给 T 20亿，等T还钱 了就有 50+30 = 80 亿，最后再给 B 借…【按A → T → B的顺序借钱也是OK的】</p><hr><ul><li><strong><u>安全序列、不安全状态、死锁的联系</u></strong></li></ul><p>给B借30亿是不安全的…之后手里只剩10亿，如果BAT都提出再借20亿的请求，那么任何一个企 业的需求都得不到满足…</p><p>给A借 20 亿是安全的，因为存在 T → B → A 这样的<strong>安全序列</strong>。</p><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>【如下解释】，不过我们在分配资源之前总是要考虑到最坏的情况。<br>【系统也有可能重新回到安全状态】：手里还有10亿，比如A先归还了10亿，那么就有安全序列 B → A → T</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p><p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）<br>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想。</p><hr><ul><li><strong><u>银行家算法</u></strong></li></ul><p>银行家算法是荷兰学者 Dijkstra【还提出了信号量机制】 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能 满足所有客户需要的情况。后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p><p><strong>核心思想</strong>：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>思考：BAT 的例子中，只有一种类型的资源——钱，但是在计算机系统中会有多种多样的资源，应该怎么把算法拓展为多种资源的情况呢？</p><p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0~P4，3 种资源 R0~R2，初始数量为 (<strong>10, 5, 7</strong>)，则某一时刻的情况可表示如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-52-53.png" alt=""></p><p>【查看上表的情况是否安全】：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-14-26.gif" alt=""></p><p>依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求<br>可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)<br>依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求<br>可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)<br>依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求……<br>。。。<br>以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列（P1,P3,P0,02,P4)<br>该算法称为<strong>安全性算法</strong>。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。 实际做题时可以更快速的得到安全序列。</p><p><strong>实际做题（手算）时</strong>可用更快速的方法找到一个安全序列： 经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 可把 P1、P3 先加入安全序列。 (2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3) 剩下的 P0、P2、P4 都可被满足。同理，这些进程都可以加入安全序列。</p><p>于是，5个进程全部加入安全序列，说明此时系统<strong>处于安全状态</strong>，暂<strong>不可能发生死锁</strong>。</p><p>【不安全序列的例子】资源总数 (10, 5, 7) ，剩余可用资源  (7,4,3)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-20-55.png" alt=""></p><p>无法找到任何一个安全序列，说明此时系统<strong>处于不安全状态</strong>，<strong>有可能发生死锁</strong>。</p><p>【<strong>代码实现</strong>】</p><p>假设<strong>系统中有 n 个进程，m 种资源</strong><br>每个进程在运行前先声明对各种资源的最大需求数， 则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的<strong>最大需求数</strong>。不妨称为最大需求 <strong>矩阵 Max</strong>，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源 Rj。同理，系统可以用一个 n*m 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。Max – Allocation = <strong>Need 矩阵</strong>，表示各进程最多还需要多少各类资源。 另外，还要用一个<strong>长度为m的一维数组 Available</strong> 表示当前系统中还有多少可用资源。 某进程Pi向系统申请资源，可用一个长度为m的一维数组 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong> 表示本次申请的各种资源量。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-33-25.png" alt=""></p><p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：<br>① 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>[j] ≤ Need[i, j] (0≤j≤m)便转向②；否则认为出错。<br>② 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>[j] ≤ Available[j] (0≤j≤m)，便转向③ ；否则表示尚无足够资源，Pi必须等待。<br>③ 系统试探着把资源分配给进程Pi，并修改相应的数据（<strong>并非真的分配，修改数值只是为了做预判</strong>）<br>④ 操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统<strong>是否处于安全状态</strong>。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配资源</span></span><br><span class="line">Available = Available - Request_i;</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Request_i[j];</span><br><span class="line">Need[i, j] = Need[i, j] – Request_i[j]</span><br></pre></td></tr></table></figure><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><p>数据结构：<br>长度为 m 的一维数组 Available 表示还有多少可用资源<br>n*m 矩阵 Max 表示各进程对资源的最大需求数<br>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源<br>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源</p><p>银行家算法步骤：<br>① 检查此次申请是否超过了之前声明的最大需求数<br>② 检查此时系统剩余的可用资源是否还能满足这次请求<br>③ 试探着分配，更改各数据结构<br>④ 用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全性算法步骤：<br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，<br>并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><hr><h2 id="2-4-4-死锁的处理策略——检测和解除">2.4.4 死锁的处理策略——检测和解除</h2><blockquote><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很<strong>可能发生死锁</strong>。在这种情况下，系统应当提供两个算法：<br>① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。<br>② 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p></blockquote><ul><li><strong><u>死锁的检测</u></strong></li></ul><p>为了能对系统是否已发生了死锁进行检测，必须：<br>① 用<strong>某种数据结构</strong>来保存资源的请求和分配信息；<br>② 提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</p><p><strong>数据结构：资源分配图</strong></p><ul><li><strong>两种结点</strong><ul><li>进程结点<br>对应一个进程</li><li>资源结点<br>对应一类资源</li></ul></li><li><strong>两种边</strong><ul><li>进程结点→资源结点<br>表示进程想申请几个资源 (每条边代表一个)</li><li>资源结点→进程结点<br>表示已经为进程分配了几个资源 (每条边代表一个)</li></ul></li></ul><p>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p><p>如果系统中剩余的可用资源数足够满足进程的需求，那 么这个进程暂时是不会阻塞的，可以顺利地执行下去。 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-54-52.gif" alt=""></p><p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-57-00.gif" alt=""></p><p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong><br><strong>最终还连着边的那些进程就是处于死锁状态的进程</strong>。</p><p><strong>检测死锁的算法</strong>：<br>1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中， P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p><p>2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能<strong>消去途中所有的边</strong>，则称该图是<strong>可完全简化的</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p><p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化的</strong>，那么此时系统<strong>死锁</strong></p><hr><ul><li><strong><u>死锁的解除</u></strong></li></ul><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p><p>解除死锁的主要方法有：</p><ol><li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li><strong>撤销进程法</strong>（或称<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>如何决定“对谁动手”</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><hr><h1>第三章 内存管理</h1><h2 id="3-1-1-内存的基础知识">3.1.1 内存的基础知识</h2><ul><li><strong><u>什么是内存？有何作用？</u></strong></li></ul><p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的速度矛盾</p><p>思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p><p>方案：给内存的存储单元编地址</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_16-10-10.png" alt=""></p><p>内存地址从0 开始，<strong>每个地址对应一个存储单元</strong></p><p>内存中也有一个一个的“小 房间”，每个小房间就是一 个“<strong>存储单元</strong>”</p><p>如果计算机“<strong>按字节编址</strong>”， 则<strong>每个存储单元大小</strong>为 <strong>1字节</strong>，即 1B，即 8个二进制位</p><p>如果<strong>字长为16位</strong>的计算机 “<strong>按字编址</strong>”，则<strong>每个存储单元大小</strong>为 <strong>1个字</strong>；每个字的大小为 16 个二进制位</p><hr><ul><li><strong><u>补充知识：几个常用的数量单位</u></strong></li></ul><p>一台手机/电脑 有 4GB 内存，是什么意思？<br>是指该内存中可以存放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span></span></span></span>个字节。如果是按字节编址的 话，也就是有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30} = 2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>个“小房间”</p><p>补充知识：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1</mn><mi>K</mi><mtext>（千）</mtext></mrow><annotation encoding="application/x-tex">2^{10} = 1K （千）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord cjk_fallback">（千）</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mtext>（兆，百万）</mtext></mrow><annotation encoding="application/x-tex">2^{20} = 1M （兆，百万）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">（兆，百万）</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><mn>1</mn><mi>G</mi><mtext>（十亿，千兆）</mtext></mrow><annotation encoding="application/x-tex">2^{30} = 1G （十亿，千兆）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord cjk_fallback">（十亿，千兆）</span></span></span></span></p><p>注：有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）</p><hr><ul><li><strong><u>知识滚雪球：指令的工作原理</u></strong></li></ul><p><a href="https://www.bilibili.com/video/BV1YE411D7nH/?p=42&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">3.1_1_内存的基础知识_哔哩哔哩_bilibili</a></p><p>07:57-18:31</p><p>程序经过编译、链接 后生成的指令中指明的是逻辑地址（相对地址），即：相对于 进程的起始地址而言 的地址</p><p>指令使用的是逻辑地址（相对地址），那么<strong>如何装入内存</strong>无法确定。</p><p>接下来解决的就是<strong>如何把逻辑地址转化为最终的物理地址</strong></p><hr><ul><li><strong><u>装入的三种方式——绝对装入</u></strong></li></ul><p><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>Eg：如果知道装入模块要从地址为100 的地方开始存放…</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-12.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-53.png" alt=""></p><p>绝对装入<strong>只适用于单道程序环境</strong>【此时还没有产生操作系统】。</p><p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p><p>【灵活性很低，换个电脑就无法执行了】</p><hr><ul><li><strong><u>装入的三种方式——可重定位装入</u></strong></li></ul><p><strong>静态重定位</strong>：又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-53-04.png" alt=""></p><p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</p><p>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p><p>用于早期的<strong>多道批处理操作系统</strong></p><hr><ul><li><strong><u>装入的三种方式——动态运行时装入</u></strong></li></ul><p><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-57-03.png" alt=""></p><p>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。</p><p>并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p><p>用于<strong>现代操作系统</strong></p><hr><ul><li><strong><u>从写程序到程序运行</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-59-27.png" alt=""></p><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<strong>翻译为机器语言</strong>）</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p><strong>装入（装载）</strong> ：<strong>由装入程序将装入模块装入内存运行</strong></p><hr><ul><li><strong><u>链接的三种方式</u></strong></li></ul><p><strong>静态链接</strong>：在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）， 之后不再拆开。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-03-22.png" alt=""></p><p><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接的链接方式。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-13.png" alt=""></p><p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-39.png" alt=""></p><hr><h2 id="3-1-2-内存管理的概念">3.1.2 内存管理的概念</h2><ul><li><strong><u>内存空间的分配与回收</u></strong></li></ul><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-08-54.png" alt=""></p><p>很多位置都可以放， 那应该放在哪里？<br>操作系统要怎么记录哪些内存区域已经被分配出去了， 哪些又还空闲？<br>当进程运行结束之后，如何将进程占用的内存空间回收？</p><ol><li>操作系统负责<strong>内存空间的分配与回收</strong></li></ol><hr><ul><li><strong><u>内存空间的扩展</u></strong></li></ul><p>游戏 GTA 的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 4GB，但为什么这个游戏可以顺利运行呢？——虚拟技术（操作系统的虚拟性）</p><ol start="2"><li>操作系统需要提供某种技术<strong>从逻辑上对内存空间进行扩充</strong></li></ol><hr><ul><li><strong><u>地址转换</u></strong></li></ul><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p><ol start="3"><li>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></li></ol><p><strong>三种装入方式</strong>：</p><ul><li>绝对装入【单道程序阶段，此时还没产生操作系统】<br>编译时产生绝对地址</li><li>可重定位装入【用于早期的多道批处理操作系统】<br>装入时将逻辑地址转化为物理地址</li><li>动态运行时装入【现代操作系统】<br>运行时将逻辑地址转化为物理地址，需设计重定位寄存器</li></ul><hr><ul><li><strong><u>内存保护</u></strong></li></ul><ol start="4"><li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-19-44.png" alt=""></p><p>内存保护可采取两种方法：<br>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-21-03.png" alt=""></p><p>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定 位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-22-21.png" alt=""></p><hr><h2 id="3-1-3-覆盖与交换">3.1.3 覆盖与交换</h2><blockquote><p>内存空间的扩充</p><ul><li>覆盖技术</li><li>交换技术</li><li>虚拟存储技术</li></ul></blockquote><ul><li><strong><u>覆盖技术</u></strong></li></ul><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。</p><p>后来人们引入了<strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong></p><p>覆盖技术的思想：将<strong>程序分为多个段</strong>（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为<strong>一个“固定区”</strong> 和<strong>若干个“覆盖区”</strong> 。 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p><p>不常用的段放在“<strong>覆盖区</strong>”，<strong>需要用到时调入内存， 用不到时调出内存</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-17-36.png" alt=""></p><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一 个覆盖区</p><p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。<br><strong>缺点：对用户不透明</strong>，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。</p><hr><ul><li><strong><u>交换技术</u></strong></li></ul><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-20-50.png" alt=""></p><p><strong>中级调度（内存调度）</strong> ，就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p><ol><li>应该在外存（磁盘）的什么位置保存被换出的进程？</li></ol><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节 后即可理解）。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-33-45.png" alt=""></p><ol start="2"><li>什么时候应该交换？</li></ol><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</p><ol start="3"><li>应该换出哪些进程？</li></ol><p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… （<strong>注意：PCB 会常驻内存</strong>，不会被换出外存）</p><hr><h2 id="3-1-4-连续分配管理方式">3.1.4 连续分配管理方式</h2><blockquote><p><strong>连续分配</strong>：指为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</p></blockquote><ul><li><strong><u>单一连续分配</u></strong></li></ul><p>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-08-53.png" alt=""></p><p>系统区通常位于内存的低地址部分，用于存放操作系统<br>相关数据；用户区用于存放用户进程相关数据。</p><p>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区 空间。</p><p>优点：实现简单；<strong>无外部碎片</strong>【后面说】；可以采用覆盖技术扩充<br>内存；不一定需要采取内存保护（eg：早期的 PC 操作 系统 MS-DOS）。</p><p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>【分配给某进程的内存区域中，如果有些部分没有用 上，就是“内部碎片”】；存储器利用率极低。</p><hr><ul><li><strong><u>固定分区分配</u></strong><ul><li>分区大小相等</li><li>分区大小不相等</li></ul></li></ul><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰， 于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-17-32.png" alt=""></p><p>分区大小相等：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序）</p><p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）</p><p>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-19-44.png" alt=""></p><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表， 从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”。</p><p>优点：实现简单，<strong>无外部碎片</strong>。</p><p>缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. <strong>会产生内部碎片</strong>，内存利用率低</p><hr><ul><li><strong><u>动态分区分配</u></strong></li></ul><p><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时， <strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p><ol><li>系统要用什么样的数据结构记录内存的使用情况？</li></ol><p>两种数据结构：</p><ul><li><strong>空闲分区表</strong><br>每个空闲分区对应 一个表项。表项中包含分区号、 分区大小、分区起始地址等信息</li><li><strong>空闲分区链</strong><br>每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-37-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p><ol start="2"><li>当很多个空闲分区都能满足需求时， 应该选择哪个分区进行分配？</li></ol><p>上图中有三个分区，现有进程5 (4MB)，应该用最大的分区进行分配？还是用最小的分区进行分配？又或是用地址最低的部分进行分配？</p><p>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p><p>下个小节会介绍四种<strong>动态分区分配算法</strong>…</p><ol start="3"><li>如何进行分区的分配与回收操作？</li></ol><p><strong>分配</strong>情况1：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-41-39.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-41-51.png" alt=""></p><p><strong>分配</strong>情况2：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-44-10.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-44-16.png" alt=""></p><p><strong>回收</strong>情况1：回收区的后（前）面有一个相邻的空闲分区<br>两个相邻的空闲分区合并为一个</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-47-32.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-47-35.png" alt=""></p><p><strong>回收</strong>情况2：回收区的前、后各有一个相邻的空闲分区<br>三个相邻的空闲分区合并为一个</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-52-23.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-52-27.png" alt=""></p><p><strong>回收</strong>情况3：回收区的前、后都没有相邻的空闲分区</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-54-07.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-54-20.png" alt=""></p><p>新增一个表项<br>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</p><p>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。</p><p><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。</p><p><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-32-27.png" alt=""></p><p>如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些 “碎片”不能满足进程的需求。</p><p>可以通过<strong>紧凑（拼凑，Compaction）</strong> 技术来解决外部碎片。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-08_9-34-40.gif" alt=""></p><p>思考动态分区分配应使用哪种装方 式？“紧凑”之后需要做什么处理？<br>【动态运行时装入；需要修改重定位寄存器的起始地址】</p><hr><h2 id="3-1-5-动态分区分配算法">3.1.5 动态分区分配算法</h2><blockquote><p><strong>动态分区分配算法</strong>：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个 分区进行分配？</p><ul><li><strong>首次适应算法</strong>（First Fit）</li><li><strong>最佳适应算法</strong>（Best Fit）</li><li><strong>最坏适应算法</strong>（Worst Fit）</li><li><strong>临近适应算法</strong>（Next Fit）</li></ul></blockquote><ul><li><u><strong>首次适应算法（First Fit）</strong></u></li></ul><p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p><strong>如何实现：空闲分区以<u>地址</u>递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-37-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p><hr><ul><li><strong><u>最佳适应算法（Best Fit）</u></strong></li></ul><p><strong>算法思想</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区， 即，优先使用更小的空闲区。</p><p><strong>如何实现</strong>：空闲分区<strong>按<u>容量</u>递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-04-13.png" alt=""></p><p><strong>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</strong></p><hr><ul><li><strong><u>最坏适应算法（Worst Fit）</u></strong></li></ul><p>又称 <strong>最大适应算法（Largest Fit）</strong></p><p><strong>算法思想</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p><strong>如何实现</strong>：空闲分区<strong>按<u>容量</u>递减次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p><p><strong>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的 空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></p><hr><ul><li><strong><u>邻近适应算法（Next Fit）</u></strong></li></ul><p><strong>算法思想</strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p><strong>如何实现</strong>：空闲分区<strong>以<u>地址</u>递增的顺序排列</strong>（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-14-07.png" alt=""></p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区 都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><table><thead><tr><th style="text-align:center">算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:center">首次适应</td><td><strong>从头到尾找适合的分区</strong></td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td style="text-align:center">最佳适应</td><td><strong>优先使用更小的分区，以保留更多大分区</strong></td><td>空闲分区以容量 递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片；<strong>算法开销大</strong>， 回收分区后可能需要对空 闲分区队列重新排序</td></tr><tr><td style="text-align:center">最坏适应</td><td><strong>优先使用更大的分区，以防止产生太小的不可用的碎片</strong></td><td>空闲分区以容量 递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程；<strong>算法开销大</strong> （原因同上）</td></tr><tr><td style="text-align:center">邻近适应</td><td><strong>由首次适应演变而来，每次从上次查找结束位置开始查找</strong></td><td>空闲分区以地址 递增次序排列 （可排列成循环 链表）</td><td>不用每次都从低地址的小分区开始检索。 <strong>算法开销小</strong>（原因同首次适应算法）</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><hr><h2 id="3-1-6-基本分页存储管理的基本概念">3.1.6 基本分页存储管理的基本概念</h2><blockquote><p><strong>连续分配</strong>：为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</p><p><strong>非连续分配</strong>：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</p></blockquote><ul><li><strong><u>什么是分页存储</u></strong></li></ul><p>将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个“<strong>页框</strong>”（<strong>页框</strong>=<strong>页帧</strong>=<strong>内存块</strong>=<strong>物理块</strong>=<strong>物理页面</strong>）。每个页框有一个编号，即“<strong>页框号</strong>”（<strong>页框号</strong>=<strong>页帧号</strong>=<strong>内存块号</strong>=<strong>物理块号</strong>=<strong>物理页号</strong>），页框号<strong>从0开始</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-49-26.png" alt=""></p><p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个部分， 每个部分称为一个“<strong>页</strong>”或“<strong>页面</strong>” 。每个页面也有一个编号， 即“<strong>页号</strong>”，页号也是<strong>从0开始</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-51-48.png" alt=""></p><p>Tips：初学易混——页、页面 vs 页框、页帧、物理页</p><p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p><p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p><p>（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费）</p><hr><ul><li><strong><u>重要的数据结构——页表</u></strong></li></ul><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。 注：页表通常存在PCB（进程控制块）中</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-56-52.png" alt=""></p><ol><li>一个进程对应一张页表</li><li>进程的每个页面对应一个<strong>页表项</strong></li><li>每个<strong>页表项</strong>由“页号”和“块号”组成</li><li>页表记录进程<strong>页面</strong>和实际存放的<strong>内存块</strong>之间的<strong>映射关系</strong></li><li>每个页表项的长度是相同的</li></ol><hr><ul><li><strong><u>问题一：每个页表项占多少字节？</u></strong></li></ul><p>每个页表项多大？占几个字节？<br>如何通过页表实现逻辑地址到物理地址的转换？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节？</p><p>内存块大小=页面大小=4KB= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B<br>→4GB 的内存总共会被分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} / 2^{12} = 2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个内存块<br>→内存块号的范围应该是 0 ~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1<br>→内存块号至少要用 20 bit 来表示<br>→至少要用3B来表示块号（3*8=24bit）【注意：页表记录的只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J*内存块大小】<br>→由于<strong>页号</strong>是<strong>隐含</strong>的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B【0~n页】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-08-08.png" alt=""></p><p>页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）<br>假设页表中的各页表项从内存地址为 X 的地方开始连续存放…<br>如何找到页号为 i 的页表项？<br>i 号页表项的存放地址 = X + 3*i 因此，页表中的<strong>页号</strong>可以是<strong>隐含</strong>的，即<strong>页号不占用存储空间</strong></p><hr><ul><li><strong><u>问题二：如何实现地址的转换</u></strong></li></ul><p>进程在内存中连续存放时，操作系统是如何实现逻辑地址到物理地址的转换的？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-12-38.png" alt=""></p><p>将进程地址空间<strong>分页</strong>之后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p>特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p><p>如果要访问逻辑地址 A，则<br>① 确定逻辑地址A 对应的“<strong>页号</strong>”   ？<br>②找到P号页面在内存中的起始地址（需要查页表） 【前面介绍了】<br>③确定逻辑地址A 的“<strong>页内偏移量</strong>”    ？</p><p>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W</p><hr><ul><li><strong><u>子问题：如何确定一个逻辑地址对应的页号、页内偏移量？</u></strong></li></ul><p>Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应的页号、页内偏移量是多少？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-39-39.png" alt=""></p><p>如何计算：<br><strong>页号</strong> = 逻辑地址 / 页面长度 （取除法的<strong>整数</strong>部分）<br><strong>页内偏移量</strong> = 逻辑地址 % 页面长度（取除法的<strong>余数</strong>部分）</p><p>页号 = 110 / 50 = 2<br>页内偏移量 = 110 % 50 = 10</p><p><strong>逻辑地址</strong> 可以拆分为（<strong>页号</strong>，<strong>页内偏移量</strong>）</p><p>通过页号查询页表，可知页面在内存中的起始地址<br>页面在内存中的起始地址+页内偏移量 = 实际的物理地址</p><p>在计算机内部，地址是用二进制表示的， 如果<strong>页面大小</strong>刚好是 <strong>2 的整数幂</strong>，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>假设某计算机用32 个二进制位表示逻辑地址，页面大小为 4KB= 212B = 4096B</p><p>0号页的逻辑地址范围应该是 0~4095，用二进制表示应该是：<br>00000000000000000000<u>000000000000</u> ~<br>00000000000000000000<u>111111111111</u></p><p>1号页的逻辑地址范围应该是 4096~8191，用二进制表示应该是：<br>00000000000000000001<u>000000000000</u> ~<br>00000000000000000001<u>111111111111</u></p><p>2号页的逻辑地址范围应该是 8192~12287，用二进制表示应该是：<br>00000000000000000010<u>000000000000</u> ~<br>00000000000000000010<u>111111111111</u></p><p>Eg：逻辑地址 2，用二进制表示应该是 00000000000000000000<u>000000000010</u><br>页号 = 2/4096 = 0 = 00000000000000000000，<br>页内偏移量 = 2%4096 = 2 = <u>000000000010</u></p><p>Eg：逻辑地址 4097，用二进制表示应该是 00000000000000000001<u>000000000001</u><br>页号 = 4097/4096 = 1 = 00000000000000000001，<br>页内偏移量 = 4097%4096 = 1 = <u>000000000001</u></p><p><strong>结论</strong>：如果每个页面大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址， 则<strong>末尾 K 位</strong>即为<strong>页内偏移量</strong>，<strong>其余</strong>部分就是<strong>页号</strong>，计算机硬件就 可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。</p><p>假设物理地址也用32个二进制位表示，则由于内存块的大小=页面大小，因此：<br>0号内存块的起始物理地址是 00000000000000000000<u>000000000000</u><br>1号内存块的起始物理地址是 00000000000000000001<u>000000000000</u><br>2号内存块的起始物理地址是 00000000000000000010<u>000000000000</u><br>3号内存块的起始物理地址是 00000000000000000011<u>000000000000</u></p><p>根据页号可以查询页表，而页表中记录的只是内存块号，而不是内存块的起始地址！<br><strong>J 号内存块的起始地址 = J *内存块大小</strong></p><p>假设通过查询页表得知1号页面存放的内存块号是9（1001），则 9号内存块的起始地址 = 9*4096（4KB） = 00000000000000001001000000000000<br>则逻辑地址4097对应的物理地址 = 页面在内存中存放的起始地址 + 页内偏移量 =（00000000000000001001<u>000000000001</u>）</p><p><strong>结论</strong>：如果页面大小刚好是2的整数幂，则只需把页表中记录的<strong>物理块号拼接上页内偏移量</strong>就能得到对应的<strong>物理地址</strong></p><hr><ul><li><strong><u>逻辑地址结构</u></strong></li></ul><p>分页存储管理的逻辑地址结构如下所示：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-55-48.png" alt=""></p><p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0~11位 为“<strong>页内偏移量</strong>”，或称“<strong>页内地址</strong>”；12~31 位为“<strong>页号</strong>”。</p><p><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>个内存单元</strong><br><strong>如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">2^M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span></span> 个页面</strong></p><p>【<strong>重要重要重要</strong>！！！】 <strong>页面大小↔页内偏移量位数 → 逻辑地址结构</strong></p><p>Tips：有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算：<br>页号 = 逻辑地址 / 页面长度 （取除法的整数部分）<br>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</p><hr><h2 id="3-1-7-基本地址变换机构">3.1.7 基本地址变换机构</h2><blockquote><p>结合上一小节理解基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理和流程</p></blockquote><ul><li><strong><u>基本地址变换机构</u></strong></li></ul><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong> ，存放<strong>页表在内存中的起始地址F和页表长度M</strong>。 进程未执行时，页表的始址 和 页表长度 <strong>放在进程控制块（PCB）</strong> 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意：页面大小是2的整数幂<br>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-25-06.png" alt=""></p><p>①计算页号 P 和页内偏移量W（ 如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</p><p>②比较页号P 和页表长度M，若 P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开 始的，而页表长度至少是1，因此 <strong>P=M 时也会越界</strong>）</p><p>③页表中页号P对应的<strong>页表项地址 = 页表起始地址F + 页号P * 页表项长度</strong>，取出该页表项内容b， 即为内存块号。（注意区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>的区别。<strong>页表长度</strong>指的是这个页表中总共有几个页表项，即总共有几个页；<strong>页表项长度</strong>指的是每个页表项占多大的存储空间； <strong>页面大小</strong>指的是一个页面占多大的存储空间）</p><p>④计算 E = b * L + W，用得到的物理地址E 去访存。（如果内存块号、页面偏移量是用二进制表 示的，那么把二者拼接起来就是最终的物理地址了）</p><p>⑤访问目标内存单元</p><p><strong>例</strong>：若页面大小L 为 1K 字节，页号2对应的内存块号 b = 8，将逻辑地址 A=2500 转换为物理地址E。</p><p>等价描述：某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占10(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mi>B</mi><mo>=</mo><mn>1</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{10}B=1KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>)位</strong>，页号2对应的内存块号 b = 8， 将逻辑地址 A=2500 转换为物理地址E。</p><p>①计算页号、页内偏移量<br>页号P = A/L = 2500/1024 = 2；<br>页内偏移量 W = A%L = 2500%1024 = 452</p><p>②根据题中条件可知，页号2没有越界，其存放的内存块号 b = 8</p><p>③物理地址 E = b * L + W = 8 * 1024 + 425 = 8644</p><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong>。<strong>即，只要给出一个逻辑地址</strong>，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><p>【<strong>一共两次访问内存的操作</strong>】</p><ol><li>查询页表</li><li>访问目标内存单元</li></ol><hr><ul><li><strong><u>对页表项大小的进一步探讨</u></strong></li></ul><p><strong>每个页表项的长度是相同的，页号是“隐含”的</strong></p><p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB的内存总共会被分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} / 2^{12} = 2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个内存块，因此内存块号的范围应该是 0 ~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1，因此至少要 20 个二进制位才能表示这么多的内存块号，因此至少要 3个字节才够 （每个字节 8 个二进制位，3个字节共 24 个二进制位）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-43-56.png" alt=""></p><p>各页表项会按顺序连续地存放在内存中，如果该页表在内存中存放的起始地址为 X ，则 M 号页对应的页表项是存放在内存地址为 X + 3*M</p><p>一个页面为 4KB，则每个页框可以存放 4096/3 = 1365 个 页表项，但是这个页框会剩余 4096 % 3 = 1 B 页内碎片 因此，1365 号页表项存放的地址为 X + 3*1365 <strong>+ 1</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-45-17.png" alt=""></p><p>如果每个页表项占 4字节，则每个页框刚好可存放 1024 个页表项<br>1024 号页表项虽然是存放在下一个页框中的，但是它 的地址依然可以用 X + 4*1024 得出</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_13-36-12.png" alt=""></p><p>【进程页表通常是<strong>装在连续的内存块中</strong>的】</p><p><strong>结论</strong>：理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询， 常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。</p><hr><h2 id="3-1-8-具有快表的地址变换机构">3.1.8 具有快表的地址变换机构</h2><blockquote><p>快表：是基本地址变换机构的改进版本</p></blockquote><ul><li><strong><u>什么是快表（TLB）</u></strong></li></ul><p><strong>快表</strong>，又称<strong>联想寄存器</strong>（<strong>TLB</strong>，translation lookaside buffer），是一种<strong>访问速度比内存快很多的高速缓存</strong>（<strong>TLB不是内存</strong>！），用来<strong>存放最近访问的页表项的副本</strong>，可以加速地址变换的速度。 与此对应，内存中的页表常称为<strong>慢表</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-57-38.png" alt=""></p><hr><ul><li><strong><u>思考：能否把整个页表都放在TLB中？</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p><strong>贵！</strong></p><hr><ul><li><strong><u>引入快表后，地址的变换过程</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_16-48-08.png" alt=""></p><p>① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此， 若<strong>快表命中</strong>，则访问某个逻辑地址仅需<strong>一次访存</strong>【快表不是内存】即可。</p><p>③ 如果没有找到匹配的页号，则需要<strong>访问内存中的页表</strong>，找到对应页表项，得到页面存放的内存块 号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此， 若<strong>快表未命中</strong>，则访问某个逻辑地址需要<strong>两次访存</strong>（<strong>注意：在找到页表项后，应同时将其存入快表</strong>， 以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p><p><strong>例</strong>：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？<br>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us<br>有的系统支持<strong>快表和慢表同时查找</strong>，如果是这样，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 = 110.9 us<br>若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p><p>【快表和慢表同时查找】：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_16-59-23.png" alt=""></p><hr><ul><li><strong><u>局部性原理</u></strong></li></ul><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再 次被访问。（因为程序中存在大量的循环）</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p>上小节介绍的<strong>基本地址变换机构</strong>中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，<strong>可能连续很多次查到的都是同一个页表项</strong></p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><table><thead><tr><th></th><th>地址变换过程</th><th>访问一个逻辑地 址的访存次数</th></tr></thead><tbody><tr><td>基本地址变换机构</td><td>①：算页号、页内偏移量 <br />②：检查页号合法性 <br />③：查页表，找到页面存放的内存块号 <br />④：根据内存块号与页内偏移量得到物理地址 <br />⑤：访问目标内存单元</td><td><strong>两次访存</strong></td></tr><tr><td>具有快表的地址变换机构</td><td>①：算页号、页内偏移量 <br />②：检查页号合法性 <br />③：查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤； 若未命中则进行④ <br />④：查页表，找到页面存放的内存块号，并且将页表项复制到快表中 <br />⑤：根据内存块号与页内偏移量得到物理地址 <br />⑥：访问目标内存单元</td><td>快表<strong>命中</strong>，只需 <strong>一次</strong>访存 快表<br /><strong>未命中</strong>，需要<strong>两次</strong>访存</td></tr></tbody></table><p>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p><hr><h2 id="3-1-9-两级页表">3.1.9 两级页表</h2><ul><li><strong><u>单级页表存在的问题</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-56-52.png" alt=""></p><p>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页 面大小为4KB，页表项长度为 4B。</p><p>4KB = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，因此页内地址要用12位表示，剩余 20 位表示页号。<br>因此，该系统中用户进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 页。相应的，一个进程的页表中，最多会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> = 1M = 1,048,576 个页表项，所以一个页表最大需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> *4B = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> B，共 需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span>/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页框存储该页表。<br>根据页号查询页表的方法：K 号页对应的页表项存放位置 = 页表始址 + K * 4 要在<strong>所有的页表项都连续存放</strong>的基础上才能用这种方法找到页表项</p><p><strong>第一个问题</strong>：需要专门给进程分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> = 1024 个连续的页框来存放它的页表【与自身离散存储的优点相违背】</p><p><strong>第二个问题</strong>：根据局部性原理可知，很多时候，<strong>进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存</strong>。</p><hr><ul><li><strong><u>如何解决单级页表的问题？</u></strong></li></ul><p><strong>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</strong></p><p>思考:我们是如何解决进程在内存中必须连续存储的问题的?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置<br>同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</p><p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组 (比如上个例子中，页面大小4KB，<br>每个页表项 4B，每个页面可存放 1K 个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中)</p><p>另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>（408常用），或称<strong>外层页表</strong>，或称<strong>顶层页表</strong></p><p>看本小节下面内容 《<strong>两级页表的原理、地址结构</strong>》</p><p><strong>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</strong></p><p>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p><p>【实现】可以在页表增加标志位，如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-20-54.png" alt=""></p><p>若想访问的页面不在内存中，则产生缺页中断（内中断/异常）， 然后将目标页面从外存调入内存</p><hr><ul><li><strong><u>两级页表的原理、地址结构</u></strong></li></ul><p>32位逻辑地址空间，页表项大小为4B，页面大小为 4KB，则页内地址占12位</p><p>单级页表结构的逻辑地址结构：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-55-48.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-02-11.png" alt=""></p><p>进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 个页面， 用 20 位二进制刚好可以 表示 0~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1 个页号。 每个页面可存放 4KB/4B = 1K = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> = 1024 个页表项</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-07-42.png" alt=""></p><p>套娃，<strong>两级页表</strong>结构如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-11-59.png" alt=""></p><p><strong>例</strong>：将逻辑地址 (0000000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-16-09.png" alt=""></p><p>如上图：</p><p>① 按照地址结构将逻辑地址拆分成三部分</p><p>② 从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p><p>③ 根据二级页号查二级页表，找到最终想访问的内存块号</p><p>④ 结合页内偏移量得到物理地址</p><p>最终要访问的内存块号为4 该内存块的起始地址为 4*4096 = 16384 页内偏移量为 4095<br>最终的物理地址为 16384 + 4095= 20479</p><hr><ul><li><strong><u>需要注意的几个细节</u></strong></li></ul><ol><li>若分为两级页表后，页表依然很长，则可以采用更多级页表，<strong>一般来说各级页表的大小不能超过一个页面</strong></li></ol><p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p><p>页面大小 = 4KB =<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，按字节编址，因此页内偏移量为12位<br>页号 = 40 - 12 = 28 位<br>【<strong>问题</strong>：这里取顶，应该是取到整个字节，还是更要取到2的整数倍，比如23位的话，是取到3B呢，还是4B呢？看看考研什么要求吧】<br>页面大小 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，页表项大小 = 4B ，则每个页面可存放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> / 4 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项<br>因此各级页表最多包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项，需要 10 位二进制位才能映射到 210 个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-26-00.png" alt=""></p><p>如果只分为两级页表，则一级页号占 18 位， 也就是说页目录表中最多可能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">2^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span>个页表项， 显然，一个页面是放不下这么多页表项的。</p><ol start="2"><li>两级页表的<strong>访存次数</strong>分析（假设没有快表机构）<br>第一次访存：访问内存中的页目录表<br>第二次访存：访问内存中的二级页表<br>第三次访存：访问目标内存单元<br><strong>规律</strong>：N级页表访问一个逻辑地址需要N+1次访存</li></ol><hr><h2 id="3-1-10-基本分段存储管理方式">3.1.10 基本分段存储管理方式</h2><blockquote><p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同</p></blockquote><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名（在低级语言 中，程序员使用段名来编程），<strong>每段从0开始编址</strong></p><p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-01-28.png" alt=""></p><p>由于是按逻辑功能模块划分，用户<strong>编程更方便，程序的可读性更高</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1, [D] | &lt;A&gt;; // 将分段D中A单元内的值读入寄存器1 </span><br><span class="line">STORE 1, [X] | &lt;B&gt;; // 将寄存器1的内容存入X 分段的B单元中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-21-28.png" alt=""></p><p><strong>段号的位数决定了每个进程最多可以分几个段</strong><br><strong>段内地址位数决定了每个段的最大长度是多少</strong></p><p>在上述例子中，若系统是按字节寻址的，则<br>段号占16位，因此在该系统中，每个进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64K 个段<br>段内地址占 16位，因此每个段的最大长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64KB。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-23-44.png" alt=""></p><p>写程序时使用的 段名 [D]、[X] 会被编译程序翻译成对应段号<br>&lt;A&gt;单元、&lt;B&gt;单元会被编译程序翻译成段内地址</p><hr><ul><li><strong><u>段表</u></strong></li></ul><p>问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-26-31.png" alt=""></p><ol><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置</strong>（又称 “<strong>基址</strong>”）和段的长度。</li><li><strong>各个段表项的长度是相同的</strong>。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位 即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内 存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由于段表项长度相同，因此<strong>段号可以是隐含的，不占存储空间</strong>。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6</li></ol><hr><ul><li><strong><u>地址变换</u></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1, [D] | &lt;A&gt;; // 将分段D中A单元内的值读入寄存器1 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-33-16.png" alt=""></p><p>经过编译程序编译后，形成等价的机器指令： “取出段号为2，段内地址为 1024 的内存单元中的内容，放到寄存 器1中”</p><p>CPU执行指令时需要将逻辑地址变换为物理地址:<br>机器指令中的逻辑地址用二进制表示： 0000000000000010<u>0000000100000000</u></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_13-44-53.png" alt=""></p><hr><ul><li><strong><u>分段、分页管理的对比</u></strong></li></ul><p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。</p><p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-39-52.png" alt=""></p><p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名【我的理解是：相当于汇编语言，你自己设置了数据段，取地址就得给出多给出 是那个段 ，这样的信息】，也要给出段内地址。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-39-56.png" alt=""></p><p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong>。<br>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的【比如，有一个代码段只是简单的输出 “Hello World！”】。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）<br>【分析：】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-50-48.png" alt=""></p><p>分段可以如下实现：设置标志位</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-52-06.png" alt=""></p><p>访问一个逻辑地址需要几次访存？<br><strong>分页</strong>（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共<strong>两次</strong>访存<br><strong>分段</strong>：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共<strong>两次</strong>访存<br>与分页系统类似，分段系统中<strong>也可以引入快表机构</strong>，将近期访问过的段表项放到快表中，这样可以 <strong>少一次访问</strong>，加快地址变换速度。</p><hr><h2 id="3-1-11-段页式管理方式">3.1.11 段页式管理方式</h2><ul><li><strong><u>分页、分段的优缺点分析</u></strong></li></ul><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td></tr></tbody></table><p>分段管理中产生的外部碎片也 可以用“<strong>紧凑</strong>”【上面介绍了，Ctrl + F吧！】来解决，只是需要付出较大的时间代价</p><hr><ul><li><strong><u>分段+分页=段页式管理</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-02-08.png" alt=""></p><p>将进程按逻辑模块分段，再将各段分页（如每个页面4KB）<br>再将内存空间分为大小相同的内存块/页框/页帧/物理块<br>进程前将各页面分别装入各内存块中</p><hr><ul><li><strong><u>段页式管理的逻辑地址结构</u></strong></li></ul><p><strong>分段</strong>系统的逻辑地址结构由段号和段内地址（段内偏移量）组成。如：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-04-36.png" alt=""></p><p><strong>段页式</strong>系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。如：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-05-24.png" alt=""></p><p><strong>段号的位数决定了每个进程最多可以分几个段</strong><br><strong>页号位数决定了每个段最大有多少页</strong><br><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p><p>在上述例子中，若系统是按字节寻址的，则<br>段号占16位，因此在该系统中，每个进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64K 个段<br>页号占4位，因此每个段最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> = 16页<br>页内偏移量占12位，因此每个页面\每个内存块大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> = 4096 = 4KB</p><p>“分段”对用户是可见的，程 序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统 会根据段内地址自动划分页号和页内偏移量。 因此<strong>段页式</strong>管理的<strong>地址结构是二维的</strong>。</p><hr><ul><li><strong><u>段表、页表</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-14-33.png" alt=""></p><p>每个段对应一个段表项，每个段表项由段号、<strong>页表长度</strong>、<strong>页表存放块号（页表起始 地址）</strong> 组成。每个<strong>段表项长度相等，段号是隐含的</strong>。</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-25-59.png" alt=""></p><p>访问一个逻辑地址所需访存次数:</p><p>第一次:查段表、第二次:查页表、第三次:访问目标单元</p><p>可引入快表机构，以<strong>段号</strong>和<strong>页号</strong>为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存</p><hr><h2 id="3-2-1-虚拟内存的基本概念">3.2.1 虚拟内存的基本概念</h2><blockquote><p>在传统存储管理方式的基础上引入了<strong>交换技术、覆盖技术</strong>，使得内存利用率有所提 升，并且能从逻辑上扩充内存容量。</p></blockquote><ul><li><strong><u>传统存储管理方式的特征、缺点</u></strong></li></ul><p>很多暂时用不到的数据也会长期占用内存， 导致内存利用率不高</p><p><strong>传统存储管理</strong></p><ul><li><strong>连续分配</strong><ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li><strong>非连续分配</strong><ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li></ul><p><strong>一次性</strong>：<strong>作业必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题：<br>① 作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong>；<br>② 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。<br>【可用虚拟存储技术解决问题】</p><p><strong>驻留性</strong>：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p><hr><ul><li><strong><u>局部性原理</u></strong></li></ul><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><hr><ul><li><strong><u>虚拟内存的定义和特征</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-57-38.png" alt=""></p><p><strong>高速缓存技术</strong>：使用频繁的数据放到更高速的存储器中</p><p>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>， 就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。</p><p>若内存空间不够，由<strong>操作系统</strong>负责将内存中<strong>暂时用不到的信息换出到外存</strong>。 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p><p>【操作系统虚拟性的一个体现，实 际的物理内存大小没有变，只是在逻辑上进行了扩充。】</p><p><strong>易混知识点</strong>：<br>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的<br>虚拟内存的<strong>实际容量</strong> = min(内存和外存容量之和，CPU寻址范围)<br>如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 则虚拟内存的<strong>最大容量</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> B = 4GB<br>虚拟内存的<strong>实际容量</strong> = min(4GB, 512MB+2GB) = 2GB+512MB</p><p>虚拟内存有一下三个主要特征：</p><ol><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ol><hr><ul><li><strong><u>如何实现虚拟内存技术</u></strong></li></ul><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上。</p><p><strong>传统非连续分配存储管理</strong></p><ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul><p><strong>虚拟内存的实现</strong></p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>主要区别： 在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。 【操作系统要提供<strong>请求调页</strong>（或<strong>请求调段</strong>）功能】</p><p>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong>。【操作系统要提供<strong>页面置换</strong>（或<strong>段置换</strong>）的功能】</p><hr><h2 id="3-2-2-请求分页管理方式">3.2.2 请求分页管理方式</h2><ul><li><strong><u>页表机制</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-57-28.png" alt=""></p><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p><p><strong>请求分页存储管理的页表</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-59-44.png" alt=""></p><p>请求页表项增加了四个字段:</p><ol><li><strong>状态位</strong>：是否已调入内存</li><li><strong>访问字段</strong>：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</li><li><strong>修改位</strong>：页面调入内存后是否被修改过</li><li><strong>外存地址</strong>：页面在外存中的存放位 置</li></ol><hr><ul><li><strong><u>缺页中断机构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-07-46.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-09-25.png" alt=""></p><p>假设此时要访问逻辑地址 =（页号，页内偏移量）=（0, 1024）</p><ul><li><p>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong>。</p></li><li><p>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</p></li><li><p>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</p></li><li><p>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p></li></ul><p><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此<strong>属于内中断</strong></p><p><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）</p><hr><ul><li><strong><u>地址变换机构</u></strong></li></ul><p><strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的主要区别：</p><ul><li>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。 【操作系统要提供<strong>请求调页</strong>（或<strong>请求调段</strong>）功能】</li><li>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong>。【操作系统要提供<strong>页面置换</strong>（或<strong>段置换</strong>）的功能】</li></ul><p>新增步骤1：请求调页（查到页表项时进行判断）</p><p>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）</p><p>新增步骤3：需要修改请求页表中新增的表项</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-18-45.png" alt=""></p><p>快表中有的页面一定是在内存中的。若某个页面被换出外存， 则<strong>快表中的相应表项也要删除</strong>， 否则可能访问错误的页面。</p><p>书上：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-31-41.png" alt=""></p><p>补充细节：<br>① 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p><p>② 和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p><p>③ 需要用某种“页面置换算法” 来决定一个换出页面（下节内容）</p><p>④ 换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。</p><p>⑤ 页面调入内存后，需要修改慢表，同时也需要将表项复制到快 表中。【在具有快表机构的请求分页系统中，访问一个逻辑地址 时，若发生缺页，则地址变换步骤是： 查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元】</p><hr><h2 id="3-2-3-页面置换算法">3.2.3 页面置换算法</h2><blockquote><p>页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该<strong>追求更少的缺页率</strong></p></blockquote><ul><li><strong><u>最佳置换算法（OPT）</u></strong></li></ul><p>最佳置换算法（OPT，Optimal）：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p><p>例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：<br>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-09_16-49-53.gif" alt=""></p><p>整个过程缺页中断发生了9次，页面置换发生了6次。<br>注意：缺页时未必发生页面置换。若还有可用的空闲内存块， 就不用进行页面置换。<br><strong>缺页率</strong> = 9/20 = 45%</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到 的是哪个页面。操作系统无法ᨀ前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p><hr><ul><li><strong><u>先进先出置换算法（FIFO）</u></strong></li></ul><p>先进先出置换算法（FIFO）：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong></p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。<br>队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：<br>3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-04-37.png" alt=""></p><p>分配三个内存块时，缺页次 数：9次</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-05-56.png" alt=""></p><p>分配四个内存块时， 缺页次数：10次</p><p><strong>Belady 异常</strong>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p><strong>只有 FIFO 算法会产生 Belady 异常</strong>。另外，FIFO算法虽然<strong>实现简单</strong>，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong></p><hr><ul><li><strong><u>最近最久未使用置换算法（LRU）</u></strong></li></ul><p>最近最久未使用置换算法（LRU，least recently used）：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p><p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间t</strong>。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-11-19.png" alt=""></p><p>例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br>1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-13-35.png" alt=""></p><p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong>。</p><p>该算法的实现需要专门的硬 支持，虽然算法<strong>性能好</strong>， 但是<strong>实现困难，开销大</strong></p><hr><ul><li><strong><u>时钟置换算法（CLOCK）</u></strong></li></ul><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；<br>最近最久未使用 置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>时钟置换算法是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-19-13.png" alt=""></p><ul><li><strong>简单的CLOCK 算法实现方法</strong>：</li></ul><p>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</p><p>例：假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串：<br>1, 3, 4, 2, 5, 6, 3, 4, 7</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-09_17-28-10.gif" alt=""></p><hr><ul><li><strong><u>改进型的时钟置换算法</u></strong></li></ul><p><strong>简单的时钟置换算法</strong>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免I/O操作。这就是改进型的时钟置换算法的思想。 <strong>修改位=0</strong>，表示页面没有被修改过；<strong>修改位=1</strong>，表示页面被修改过。</p><p>为方便讨论，用（<strong>访问位</strong>，<strong>修改位</strong>）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过， 且被修改过。</p><p>算法规则：将所有可能被置换的页面排成一个循环队列</p><ol><li><strong>第一轮</strong>：从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位<br>【第一优先级：最近没访问， 且没修改的页面】</li><li><strong>第二轮</strong>：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>【第二优先级：最近没访问， 但修改过的页面】</li><li><strong>第三轮</strong>：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位<br>【第三优先级：最近访问过， 但没修改的页面】</li><li><strong>第四轮</strong>：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。<br>【第四优先级：最近访问过， 且修改过的页面】</li></ol><p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面<strong>最多会进行四轮扫描</strong></p><p>例子：【自己推】下图都是（起始状态，最终状态）</p><p>需要1轮扫描</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-33-50.png" alt=""></p><p>需要2轮扫描</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-36-01.png" alt=""></p><p>需要3轮扫描</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-38-16.png" alt=""></p><p>需要4轮扫描</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-38-43.png" alt=""></p><hr><ul><li><strong><u>知识点与考点</u></strong></li></ul><table><thead><tr><th style="text-align:center"></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td style="text-align:center">OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好；但无法实现</td></tr><tr><td style="text-align:center">FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单；但性能很差，可能出现Belady异常</td></tr><tr><td style="text-align:center">LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好；但需要硬件 支持，算法开销大</td></tr><tr><td style="text-align:center">CLOCK（NRU）</td><td>循环扫描各页面 <br />第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小；但未考虑页面是否被修改过</td></tr><tr><td style="text-align:center">改进型CLOCK（改 进型NRU）</td><td>若用（访问位, 修改位）的形式表述，则<br />第一轮：淘汰（0, 0） <br />第二轮：淘汰（0, 1），并将扫描过的页面访问位 都置为0 <br />第三轮：淘汰（0, 0） <br />第四轮：淘汰（0, 1）</td><td>算法开销较小，性能也不错</td></tr></tbody></table><hr><h2 id="3-2-4-页面分配策略">3.2.4 页面分配策略</h2><ul><li><strong><u>页面分配、置换策略</u></strong></li></ul><p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的物理块的集合。<br>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少； 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。<br>【考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页】</p><p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</p><p><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</p><p><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</p><p><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p>全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">局部置换</th><th style="text-align:center">全局置换</th></tr></thead><tbody><tr><td style="text-align:center"><strong>固定分配</strong></td><td style="text-align:center">√</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>可变分配</strong></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p><strong>固定分配局部置换</strong>：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的<strong>缺点</strong>是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，<strong>只要某进程发生缺页， 都将获得新的物理块</strong>，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个<strong>被选中的进程拥有的物理块会减少，缺页率会增加</strong>。<br>【系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设置为“锁定”）】</p><p><strong>可变分配局部置换</strong>：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块<br>可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来动态地增加或减少进程的物理块</p><hr><ul><li><strong><u>何时调入页面</u></strong></li></ul><p><strong>预调页策略</strong>：根据局部性原理【主要指空间局部性】，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略<strong>主要用于进程的首次调入</strong>， 由程序员指出应该先调入哪些部分。</p><p><strong>请求调页策略</strong>：进程在<strong>运行期间发现缺页时才将所缺页面调入内存</strong>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</p><hr><ul><li><strong><u>从何处调入页面</u></strong></li></ul><p>1、系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-44-14.png" alt=""></p><p>2、系统缺少足够的对换区空间：凡是不会被修改 的数据都直接从文件区调入，由于这些页面不 会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时 再从对换区调入。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-47-33.png" alt=""></p><p>3、UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-51-13.png" alt=""></p><hr><ul><li><strong><u>抖动（颠簸）现象</u></strong></li></ul><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>。产生抖动的<strong>主要原因</strong>是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p><p>为进程分配的物理块太少，会使进 程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p><p>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“<strong>工作集</strong>”的概念</p><hr><ul><li><strong><u>工作集</u></strong></li></ul><p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的内存块的集合。<br><strong>工作集</strong>：指在某段时间间隔里，进程实际访问页面的集合。</p><p>操作系统会根据“窗口尺寸”来算出工作集。例：<br>某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-00-10.png" alt=""></p><p><strong>工作集大小</strong>可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。</p><p>一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong></p><p>拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p><hr><h2 id="3-2-5-内存映射文件">3.2.5 内存映射文件</h2><ul><li><strong><u>传统的文件访问方式</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-14-43.png" alt=""></p><p>open 系统调用——打开文件<br>seek 系统调用――将读写指针移到某个位置<br>read 系统调用――从读写指针所指位置读入若干数据（从磁盘读入内存)<br>write 系统调用――将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-14-36.png" alt=""></p><hr><ul><li><strong><u>内存映射文件（Memory-Mapped Files）</u></strong></li></ul><p>open系统调用――打开文件<br>mmap系统调用一一将文件映射到进程的虚拟地址空间</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-16-18.png" alt=""></p><ul><li>以访问内存的方式访问文件数据</li><li>文件数据的读入、写出由操作系统自动完成</li><li>进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</li></ul><p>多个进程可以映射同一个文件，实现<strong>共享</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-18-05.png" alt=""></p><p>在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马“看到”</p><hr><ul><li><strong><u>知识回顾</u></strong></li></ul><p>内存映射文件：</p><ul><li><strong>特性</strong><ul><li>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间</li><li>以访问内存的方式读写文件</li><li>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</li><li>多个进程可以映射同一个文件，方便共享</li></ul></li><li><strong>优点</strong><ul><li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li><li>文件数据的读入/写出完全由操作系统负责，I/O效率可以由操作系统负责优化【eg:预读入、缓写出等】</li></ul></li></ul><hr><h1>第四章 内存管理</h1><h2 id="4-1-1-初识文件管理">4.1.1 初识文件管理</h2><ul><li><strong><u>前情回顾</u></strong></li></ul><p><strong>操作系统的功能和目标——作为系统资源的管理者</strong></p><ul><li>提供的功能：<ul><li>处理机管理</li><li>存储器管理</li><li><strong>文件管理</strong></li><li>设备管理</li></ul></li><li>目标：<ul><li>安全、高效</li></ul></li></ul><p><strong>文件的定义：文件——就是一组有意义的信息/数据集合</strong></p><p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p><p><strong>文件内部</strong>的数据应该怎样组织起来？</p><p><strong>文件之间</strong>又应该又应该怎么组织起来？</p><p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？<br>从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p><hr><ul><li><p><strong><u>文件的属性</u></strong></p></li><li><p><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</p></li><li><p><strong>标识符</strong>：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分各个文件的一种内部名称。</p></li><li><p><strong>类型</strong>：指明文件的类型位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p></li><li><p><strong>大小</strong>：指明文件大小</p></li><li><p><strong>创建时间</strong>、<strong>上次修改时间</strong>、<strong>文件所有者信息</strong>……</p></li><li><p><strong>保护信息</strong>：对文件进行保护的访问 控制信息</p></li></ul><hr><ul><li><strong><u>文件内部的数据应该怎样组织起来？</u></strong></li></ul><p><strong>无结构文件</strong>（如文本文件）——由一些二进制或字 符流组成，又称“<strong>流式文件</strong>”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-06.png" alt=""></p><p><strong>有结构文件</strong>（如数据库表）——由一组相似的记录组成，又称“<strong>记录式文件</strong>”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-15.png" alt=""></p><p>记录是一组相关数据项的集合<br>数据项是文件系统中最基本的数据单位</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-48-12.png" alt=""></p><p>有结构文件中，各个记录间应该如何组织的问题——应该顺序存放？ 还是用索引表来表示记录间的顺序？——这是“文件的逻辑结构” 重点要探讨的问题</p><hr><ul><li><strong><u>文件之间应该怎样组织起来？</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-49-41.png" alt=""></p><p>所谓的“<strong>目录</strong>” 其实就是我们熟悉的“<strong>文件夹</strong>”</p><p>用户可以自己创建一层一 层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了</p><p>目录其实也是一种特殊的有结构文件（由记录组成），如何实现文件目录是之后会重点探讨的问题</p><hr><ul><li><strong><u>操作系统应该向上提供哪些功能？</u></strong></li></ul><p>可以“<strong>创建文件</strong>”， （点击新建后，图形 化交互进程在背后调 用了“<strong>create 系统调用</strong>”）</p><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统 提供的“读文件”功能，即 <strong>read 系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p><p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后， “记事本”应用程序通过操作系统提供 的“写文件”功能，即 <strong>write 系统调用</strong>， 将文件数据从内存写回外存）</p><p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“删除文件”功能，即 <strong>delete 系统调用</strong>， 将文件数据从外存中删除）</p><p><strong>向上提供的几个最基本的功能</strong>：</p><ul><li><strong>创建文件（ create 系统调用）</strong></li><li><strong>读文件（ read 系统调用）</strong></li><li><strong>写文件（ write 系统调用）</strong></li><li><strong>删除文件（ delete系统调用）</strong></li><li><strong>打开文件（ open系统调用）</strong><br>读/写文件之前，需要“打开文件”</li><li><strong>关闭文件（ close系统调用）</strong><br>读/写文件结束之后， 需要“关闭文件”</li></ul><p>可用几个基本操作完成更复杂的操作，比如：“复制文件”： 先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</p><p>操作系统在背后做的处理会在以后进行探讨</p><hr><ul><li><strong><u>从上往下看，文件应如何存放在外存？</u></strong></li></ul><p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1B）。每个存储单元对应一个物理地址</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-01-25.png" alt=""></p><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。外存中的数据读入内存时同样以块为单位</p><p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如本例中，一块包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小</p><ul><li>文件数据放在连续的几个磁盘块中:</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-05-00.png" alt=""></p><ul><li>文件数据放在离散的几个磁盘块中。 此时，应该如何记录各个磁盘块之间的先后顺序呢？<br>操作系统又应该怎么管理空闲磁盘块？</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-07-09.png" alt=""></p><p>操作系统又应该怎么管理空闲磁盘块？</p><hr><ul><li><strong><u>其他需要由操作系统实现的文件管理功能</u></strong></li></ul><p><strong>文件共享</strong>：使多个用户可以共享使用一个文件</p><p><strong>文件保护</strong>：如何保证不同的用户对文件有不同的操作权限</p><p>之后会结合 Windows操作系 统的实际应用进 行探讨</p><hr><h2 id="4-1-2-文件的逻辑结构">4.1.2 文件的逻辑结构</h2><blockquote><ul><li>无结构文件</li><li>有结构文件<ul><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul><p>所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><p>类似于数据结构的“逻辑结构”和“物理结构”。<br>如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a, b, c, d, e ……<br>“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问。<br>可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关）</p></blockquote><ul><li><strong><u>无结构文件</u></strong></li></ul><p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。如： Windows 操作系统中的 .txt 文件。</p><p>文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。</p><hr><ul><li><strong><u>有结构文件</u></strong></li></ul><p><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又若干个数据项组成。如： 数据库表文件。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID【数据库的Primary Key】）</p><p>这是一张数据库表，记录了各个学生的信息:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-15.png" alt=""></p><p>每个学生对应一条记录，每条记录由若干个数据项组成<br>在本例中， “学号”即可 作为各个记录的关键字</p><p>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p><p><strong>定长记录</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-42-13.png" alt=""></p><p>这个有结构文件由定长记录组成，每条记录的长度都相同（共 128 B）。各数据项都处在记录中相同的位置，具有相同的顺序和长度 （前32B一定是学号，之后32B一定是姓名……）</p><p><strong>可变长记录</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-44-28.png" alt=""></p><p>这个有结构文件由可变长记录组成，由于各个学生的特长存在很大区别，因此“特长” 这个数据项的长度不确定，这就导致了各条记录的长度也不确定。当然，没有特长的学生甚至可以去掉“特长”数据项。</p><hr><ul><li><strong><u>有结构文件的逻辑结构</u></strong></li></ul><p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p><ul><li>有结构文件<ul><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul><hr><ul><li><strong><u>顺序文件</u></strong></li></ul><p><strong>顺序文件</strong>：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。</p><p><strong>顺序存储</strong>——逻辑上相邻的记录物理上也相邻（类似于顺序表）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-48-29.png" alt=""></p><p><strong>链式存储</strong>——逻辑上相邻的记录物理上不一定相邻 （类似于链表）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-48-40.png" alt=""></p><p>顺序文件：</p><ul><li><strong>串结构</strong><br>记录之间的顺序与关键字无关<br>【通常按照记录存入的时间决定记录的顺序】</li><li><strong>顺序结构</strong><br>记录之间的顺序按关键字顺序排列</li></ul><p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p><p>思考1：能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）</p><p>思考2：能否快速找到某个关键字对应的记录存放的位置？</p><p><strong>顺序文件</strong>：</p><ul><li>链式存储<br>无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</li><li>顺序存储<ul><li>可变长记录<br>无法实现随机存取。每次只能从第一个记录开始依次往后查找</li><li>定长记录<ul><li>可实现随机存取。记录长度为L，则第 i个记录存放的相对位置是 i*L</li><li>若采用串结构，无法快速找到某关键字对应的记录</li><li>若采用顺序结构，可以快速找到某关键字对应的记录(如折半查找【二分查找】)</li></ul></li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-00-46.png" alt=""></p><p>结论：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索 （即根据关键字快速找到对应记录）</p><p>注：一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>。之 后的讲解中提到的顺序文件也默认如此。</p><p>可见，顺序文件的<strong>缺点</strong>是<strong>增加/删除一个记录比较困难</strong>（如果是串结构则相对简单）</p><hr><ul><li><strong><u>索引文件</u></strong></li></ul><p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1 个记录， 但是很多应用场景中又必须使用可变长记录。如何解决这个问题？</p><p>建立一张索引表【连续存储】以加快文件检索速度。每条记录对应一个索引项。<br>文件中的这些记录在物理上可以离散地存放。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-04-37.png" alt=""></p><p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第 i 个记录对应的索引项。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p><p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong>。</p><p>另外，<strong>可以用不同的数据项建立多个索引表</strong>。如： 学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。 （Eg：SQL 就支持根据某个数据项建立索引的功能）</p><hr><ul><li><strong><u>索引顺序文件</u></strong></li></ul><p>思考索引文件的<strong>缺点</strong>：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p><p><strong>索引顺序文件</strong>是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-41-38.png" alt=""></p><p>在本例中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件， 分组内的记录不需要按关键字排序</p><p>索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p><hr><ul><li><strong><u>索引顺序文件（检索效率分析）</u></strong></li></ul><p>用这种策略确实可以让索引 表“瘦身”，但是是否会出 现不定长记录的顺序文件检索速度慢的问题呢？</p><p>若一个<strong>顺序文件</strong>有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记 录、顺序结构的顺序文件），平均须查找 5000 个记录。 若采用<strong>索引顺序文件</strong>结构，可把 10000 个记录分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>10000</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{10000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1328em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9072em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">10000</span></span></span><span style="top:-2.8672em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1328em;"><span></span></span></span></span></span></span></span></span> = 100 组，每组 100 个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，<strong>平均查找次数减少为 50+50 = 100 次</strong>。</p><p>同理，若文件共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录平均需要查找 500+500 = 1000 次。这个<strong>查找次数依然很多</strong>，如何解决呢？</p><hr><ul><li><strong><u>多级索引顺序文件</u></strong></li></ul><p>为了进一步提高检索效率，可以为顺序文件建立<strong>多级索引表</strong>。例如，对于一个含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长 记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表 项。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-47-26.png" alt=""></p><p>此时，检索一个记 录平均需要查找 50+50+50 = 150 次</p><p><strong>Tips</strong>:  要为 N 个记录的文件 建立 K 级索引，则最优的分组是每组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">N^{1/(K+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>个记录。</p><p>检索一个记录的平均查找次数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msup><mi>N</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mn>2</mn></mfrac><mo>×</mo><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{N^{1/(K+1)}}{2}\times (K+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4157em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1/</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>如：本例中，建立2级索 引，则最优分组为每组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn><msup><mn>0</mn><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">100000^{1/3} = 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord">10000</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span> 个记录， 平均查找次数是 (100/2) *  3 = 150 次</p><hr><h2 id="4-1-3-文件目录">4.1.3 文件目录</h2><blockquote><p><strong>文件目录</strong>：就是我们很熟悉 的 Windows 操作系统的“文件夹”</p><p>这种目录结构对 于用户来说有什么<strong>好处</strong>？</p><ul><li>文件之间的组织结构清晰，易于查找</li><li>编程时也可以很方便的用文件路径找到一个文件。如： FILE *fp; fp=fopen(“F:\data\myfile.dat”); 用户可以轻松实现“按名存取”</li></ul><p>从操作系统的角度来看，这些目录结构应该是如何实现的？</p></blockquote><ul><li><strong><u>文件控制块FCB</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-56-23.png" alt=""></p><p>当我们双击“照片”后，操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-59-17.png" alt=""></p><p><strong>FCB</strong> 的有序集合称为“文件目录”，一个FCB就是一个文件<strong>目录项</strong>。 FCB 中包含了文件的<strong>基本信息</strong>（<strong>文件名</strong>、<strong>物理地址</strong>、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。 <strong>最重要</strong>，<strong>最基本</strong>的还是<strong>文件名</strong>、<strong>文件存放的物理地址</strong>。<br>【FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”】</p><p><strong>需要对目录进行哪些操作</strong>？</p><ol><li><strong>搜索</strong>：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li><strong>创建文件</strong>：创建一个新文件时，需要在其所属的目录中增加一个目录项</li><li><strong>删除文件</strong>：当删除一个文件时，需要在目录中删除相应的目录项</li><li><strong>显示目录</strong>：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li><strong>修改目录</strong>：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ol><hr><ul><li><strong><u>目录结构——单级目录结构</u></strong></li></ul><p>早期操作系统并不支持多级目录，整个系统中<strong>只建立一张目录表</strong>，每个文件占一个目录项。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-05-22.png" alt=""></p><p>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong>。</p><p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p><p>显然，单级目录结构不适用于多用户操作系统【容易重复】。</p><hr><ul><li><strong><u>目录结构——两级目录结构</u></strong></li></ul><p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD，Master File Directory）和<strong>用户文件目录</strong>（UFD，User Flie Directory）。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-09-07.png" alt=""></p><p>主文件目录记录用户名及相应用户文件目录的存放位置<br>用户文件目录由该用户的文件FCB组成</p><p><strong>允许不同用户的文件重名</strong>。文件名虽然相 同，但是对应的其实是不同的文件</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类</p><hr><ul><li><strong><u>目录结构——多级目录结构</u></strong><br>又称<strong>树形目录结构</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-11-37.png" alt=""></p><p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从<strong>根目录出发</strong>的路径称为<strong>绝对路径</strong>。例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg”</p><p>系统根据绝对路径一层一层地找到下一级目录。刚开始<strong>从外存读入根目录的目录表</strong>；找到“照片”目录的 存放位置后，<strong>从外存读入对应的目录表</strong>；再找到“2015-08”目录的存放位置，再<strong>从外存读入对应目录表</strong>； 最后才找到文件“自拍.jpg”的存放位置。整个过程<strong>需要3次读磁盘I/O操作</strong>。</p><p>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）， 显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“<strong>当前目录</strong>”。<br>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用<strong>从当前目录出发</strong>的“<strong>相对路径</strong>” 。<br>在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为： “./2015-08/自拍.jpg”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。</p><p>可见，引入“<strong>当前目录</strong>”和“<strong>相对路径</strong>”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</p><p><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构<strong>不便于实现文件的共享</strong>。为此，提出了“<strong>无环图目录结构</strong>”。</p><hr><ul><li><strong><u>目录结构——无环图目录结构</u></strong></li></ul><p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使 整个目录成为一个<strong>有向无环图</strong>。 可以更方便地实现多个用户间的文件共享。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-20-14.png" alt=""></p><p><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p><p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。<br><strong>只有共享计数器减为0时，才删除结点</strong>。</p><p>注意：共享文件不同于复制文件。在<strong>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</strong>。</p><hr><ul><li><strong><u>索引结点（FCB的改进）</u></strong></li></ul><p>其实在查找各级目录的过程中只需要用到“文件名”这个信 息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-24-21.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-25-05.png" alt=""></p><p><strong>思考有何好处</strong>？ 假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放 16个FCB。若一个文件目录中共有640个目录项，则共需要占用 640/16 = 40 个盘块。因此按照某文件名检索该目录，平均需要查询320 个目录项，<strong>平均需要启动磁盘20次（每次磁盘I/O读入一块</strong>）。</p><p>若<strong>使用索引结点机制</strong>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录<strong>平均只需要读入 320/64 = 5 个磁盘块</strong>。显然，这<strong>将大大提升文件检索速度</strong>。</p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存<strong>放在外存中</strong>的索引结点称为“<strong>磁盘索引结点</strong>”，当索引结点<strong>放入内存后</strong>称为“<strong>内存索引结点</strong>”。 相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><hr><h2 id="4-1-4-文件的物理结构（上）">4.1.4 文件的物理结构（上）</h2><blockquote><p>要探讨的问题:</p><p>“文件的物理结构/文件分配方式” 即：文件数据应该怎样存放在外存中？</p><p>“文件存储空间管理”</p></blockquote><ul><li><strong><u>文件块、磁盘块</u></strong></li></ul><p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-28-44.png" alt=""></p><p>内存与磁盘之间的数据交换（即读/写操作、磁盘I/O）都是以“块”为单位进行的。即每次读入一块，或每次写出一块</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-29-56.png" alt=""></p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面<br>同样的，在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的文件“块”</strong> 。 于是文件的逻辑地址也可以表示为（<strong>逻辑块号</strong>，<strong>块内地址</strong>）的形式。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-33-08.png" alt=""></p><p>操作系统为文件分配存储空间都是以块为单位的<br>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</p><hr><ul><li><strong><u>文件分配方式——连续分配</u></strong></li></ul><p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-38-19.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？<br>（逻辑块号，块内地址）→ （物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）…<br><strong>物理块号 = 起始块号 + 逻辑块号</strong><br>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）</p><p>【可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问</strong>）】</p><p>如下图，读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-47-07.png" alt=""></p><p><strong>结论</strong>：<strong>连续分配的文件在顺序读/写时速度最快</strong></p><p><strong>eg</strong>: 如下图：若此时文件A要拓展，需要再增加一个磁盘块（总共 需要连续的4个磁盘块）。 由于采用连续结构，因此文件A占用的磁盘块必须是连续的。 因此只能将文件A全部“迁移”到绿色区域。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-41-52.png" alt=""></p><p><strong>结论</strong>：物理上采用<strong>连续配的文件不方便拓展</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-43-37.png" alt=""></p><p><strong>结论</strong>：物理上采用<strong>连续分配</strong>， <strong>存储空间利用率低</strong>，<strong>会产生难以利用的磁盘碎片</strong><br>可以用<strong>紧凑</strong>【之前介绍了】来处理碎片，但是需要耗费很大的时间代价。</p><hr><ul><li><strong><u>连续分配（总结）</u></strong></li></ul><p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p><p><strong>优点</strong>：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p><p><strong>缺点</strong>：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p><hr><ul><li><strong><u>文件分配方式——链接分配</u></strong></li></ul><p><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</p><hr><ul><li><strong><u>链接分配——隐式链接</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-52-12.png" alt=""></p><p>除了文件的最后一个磁盘块之外，每 个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-51-24.png" alt=""></p><p>目录中记录了文件存放的起始块号和结束块号。当然， 也可以增加一个字段来表示文件的长度</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>如何实现文件的逻辑块号到物理块号的转变？</p><ul><li>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</li><li>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</li><li>因此，读入i号逻辑块，总共需要 i+1 【0<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>i】次磁盘 I/O。</li></ul><p><strong>结论</strong>：采用<strong>链式分配（隐式链接）</strong> 方式的文件，<strong>只支持顺序访问，不支持随机访问</strong>，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>是否方便拓展文件？</p><p>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-56-32.png" alt=""></p><p><strong>结论</strong>：采用隐式链接的<strong>链接分配方式</strong>，<strong>很方便文件拓展</strong>。 另外，所有的空闲磁盘块都可以被利用，<strong>不会有碎片问题， 外存利用率高</strong>。</p><p><strong>隐式链接</strong>——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。<br><strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高。<br><strong>缺点</strong>：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p><hr><ul><li><strong><u>链接分配——显式链接</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_12-00-40.png" alt=""></p><p>把用于链接文件各物理块的指针显式地存放在一张表中。即<strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）</p><p>目录中只需记录文件的起始块号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_12-01-24.png" alt=""></p><p>假设某个新创建的文件“aaa”依次存放在磁盘块 2 →5 →0 →1<br>假设某个新创建的文件“bbb”依次存放在磁盘块 4 →23 →3<br>【结果如上图】</p><p><strong>注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻内存</strong>。 FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“<strong>物理块号</strong>”字段<strong>可以是隐含的</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>如何实现文件的逻辑块号到物理块号的转变？</p><p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</p><p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT， 往后找到 i 号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</p><p><strong>结论</strong>：采用<strong>链式分配（显式链接）</strong> 方式的文件，支持顺序访问，也支持<strong>随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1 号逻辑块</strong>），由于块号转换的过程不需要访问磁盘，因此相比于隐式 链接来说，访问速度快很多。</p><p>显然，显式链接也<strong>不会产生外部碎片</strong>，<strong>也可以很方便地对文件进行拓展</strong>。</p><hr><ul><li><strong><u>链接分配（总结）</u></strong></li></ul><p><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</p><p><strong>隐式链接</strong>——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。<br><strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高。<br><strong>缺点</strong>：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p>【考试题目中遇到未指明隐式/显式的“链接 分配”，<strong>默认</strong>指的是<strong>隐式链接</strong>的链接分配】</p><p><strong>显式链接</strong>——把用于链接文件各物理块的指针显式地存放在一张表中，即 <strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并<strong>常驻内存</strong>。<br><strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。<br><strong>缺点</strong>：文件分配表的需要占用一定的存储空间。</p><hr><h2 id="4-1-4-文件的物理结构（下）">4.1.4 文件的物理结构（下）</h2><blockquote><p>即：文件数据应该怎样存放在外存中？</p></blockquote><ul><li><strong><u>文件分配方式——索引分配</u></strong></li></ul><p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-10-16.png" alt=""></p><p>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2→5→13→9 。 7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。</p><p>注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而 索引分配方式中，索引表是一个文件对应一张。</p><p>可以用固定的长度表示物理块号（如： 假设磁盘总容量为1TB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span></span></span></span>B，磁盘块大小为1KB，则共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span></span></span></span>个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-13-31.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>如何实现文件的逻辑块号到物理块号的转变？</p><p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只 i 号逻辑块在外存中的存放位置。</p><p>可见，<strong>索引分配方式可以支持随机访问</strong>。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是<strong>索引表需要占用一定的存储空间</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p><p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256 个索引项。<br>如果一个文件的大小超过了256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？<br>①链接方案; ②多层索引; ③混合索引.</p><ol><li><strong>链接方案</strong></li></ol><p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256 个索引项。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-20-20.png" alt=""></p><p>若一个文件大小为 256*256KB = 65,536 KB = 64MB</p><p>该文件共有 256*256 个块，也就对应 256*256个索引项，也就需要 256 个 索引块来存储，这些索引块用链接方案连起来。</p><p>若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用 指针链接起来的，因此必须先顺序地读入前 255 个索引块。</p><p>这显然是很低效的。如何解决呢？</p><ol start="2"><li><strong>多层索引</strong></li></ol><p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-30-04.png" alt=""></p><p>若某文件采用<strong>两层索引</strong>，则该<strong>文件的最大长度</strong>可以到 256*256*1KB = 65,536 KB = 64MB【常考计算】</p><p>可根据逻辑块号算出应该查找索引表中的哪个表项。 如：要访问 1026 号逻辑块，则<br>1026/256 = 4，1026%256 = 2<br>因此可以先将一级索引表调入内存，查询 4 号表项， 将其对应的二级索引表调入内存，再查询二级索引表 的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。 <strong>访问目标数据块，需要3次磁盘I/O</strong>。</p><p>若采用三层索引，则文件的最大长度为 256*256*256*1KB = 16GB 类似的，访问目标数据块，需要4次磁盘I/O</p><p>【<strong>规律</strong>】采用K层索引结构，<strong>且顶级索引表未调入内存</strong>，则访问一个数据块只需要K+1次读磁盘操作</p><ol start="3"><li><strong>混合索引</strong></li></ol><p><strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-36-23.png" alt=""></p><p>这种结构的索引支持的最大文件长度为8 + 256 + 256 * 256 = 65800KB</p><p>若顶级索引表<strong>还没读入内存</strong><br>访问0-7号逻辑块：两次读磁盘<br>访问8-263：三次读磁盘<br>访问264~65799：四次读磁盘</p><p>对于小文件，只需较少的读磁盘次数就可以访问目标数据块（一般计算机中小文件更多）</p><hr><ul><li><strong><u>索引分配（总结）</u></strong></li></ul><p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系） 。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>若文件太大，索引表项太多，可以采取以下三种方法解决：<br>① <strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<strong>缺点</strong>：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。</p><p>② <strong>多层索引</strong>：建立多层索引（<strong>原理类似于多级页表</strong>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且<strong>顶级索引表未调入内存</strong>，则访问 一个数据块只需要 K + 1 次读磁盘操作。<strong>缺点</strong>：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p>③ <strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含<strong>一级间接索引</strong>（指向单层索引表）、还包含<strong>两级间接索引</strong>（指向两层索引表） 。 <strong>优点</strong>：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p><strong><u>超级超级超级重要考点</u></strong>：<br>①要会根据多层索引、混合索引的结构计算出文件的最大长度（<strong>Key</strong>：各级索 引表最大不能超过一个块）；<br>②要能自己分析访问某个数据块所需要的读磁盘次数（<strong>Key</strong>：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要<strong>注意题目条件——顶级索引块是否已调入内存</strong>）</p><hr><ul><li><strong><u>知识点回顾与重要考点</u></strong></li></ul><table><thead><tr><th></th><th>How?</th><th>目录项内容</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>为文件分配的必须是连续的磁盘块</td><td>起始块号、文件长度</td><td>顺序存取速度快，支持随机访问</td><td>会产生碎片，不利于文件拓展</td></tr><tr><td>链接分配<br />隐式链接</td><td>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针</td><td>起始块号、结束块 号</td><td>可解决碎片问题，外存利用率高，文件拓展实现方便</td><td>支持随机访问，易于实现文件的拓展</td></tr><tr><td>链接分配<br />显式链接</td><td>建立一张文件分配表(FAT)，显式记录盘块的先后关系（开机后FAT常驻内存）</td><td>起始块号</td><td>除了拥有隐式链接的优点之外，还可通过查询内存中的FAT实现随机访问</td><td>FAT需要占用一定的存储空间</td></tr><tr><td>索引分配</td><td>为文件数据块建立索引表。若文件太大，可采用链接方案、多层索引、混合索引</td><td>链接方案记录的是第一个索引块的块号，多层/混合索引记录的是顶级索引块的块号</td><td>支持随机访问，易于实现文件的拓展</td><td>索引表需占用一定的存储空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块时可能需要很多次读磁盘操作。</td></tr></tbody></table><hr><h2 id="4-1-5-逻辑结构Vs物理结构">4.1.5 逻辑结构Vs物理结构</h2><p>我觉得有基础不用看了，挺简单的，明确两个点就好了：</p><ul><li><strong>逻辑结构是用户看的</strong>，用户可以自己设计怎么存储，但是真正怎么分配内存的时候还是得看操作系统</li><li><strong>物理结构是给操作系统看的</strong></li></ul><p>还有一个懵逼点是要明确顺序文件是什么，简单来说，<strong>顺序文件</strong>就是有结构的，<strong>文件内容有一定顺序</strong>的文件</p><p><a href="https://www.bilibili.com/video/BV1YE411D7nH?p=63&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">4.1_5_逻辑结构VS物理结构_哔哩哔哩_bilibili</a></p><hr><h2 id="4-1-6-文件存储空间管理">4.1.6 文件存储空间管理</h2><blockquote><p>学习时要注意从三个方面进行理解：</p><ol><li>用什么方式记录，组织空闲快？</li><li>如何分配磁盘块</li><li>如何回收磁盘块</li></ol></blockquote><ul><li><strong><u>存储空间的划分与初始化</u></strong></li></ul><p>eg: 安装 Windows 操作系统的时候，一个必经步骤是–为磁盘分区 (C:盘、D:、E: 盘等)<br>【存储空间的划分: 将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)】</p><p>存储空间的初始化:将各个文件卷划分为目录区、文件区</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-06-57.png" alt=""></p><p>目录区主要存放文件目录信息、用于磁盘存储空间管理的信息<br>文件区用于存放文件数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-08-37.png" alt=""></p><hr><ul><li><strong><u>存储空间管理——空闲表法</u></strong></li></ul><p>适合”连续分配方式“</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-11-58.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-12-08.png" alt=""></p><p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样可采用<strong>首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p><p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——<br>① 回收区的前后都没有相邻空闲区；<br>② 回收区的前后都是空闲区；<br>③ 回收区前面是空闲区；<br>④ 回收区后面是空闲区。<br><strong>总之，回收时需要注意表项的合并问题。</strong></p><hr><ul><li><strong><u>空闲链表法</u></strong><ul><li><strong>空闲盘块链</strong><br>以盘块为单位组成一条空闲链</li><li><strong>空闲盘区链</strong><br>以盘区为单位组成一条空闲链</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-23-16.png" alt=""></p><ul><li><strong>空闲盘块链</strong></li></ul><p>操作系统保存着<strong>链头</strong>、<strong>链尾指针</strong><br><strong>如何分配</strong>：若某文件申请 K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。<br><strong>如何回收</strong>：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><p>【适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作】</p><ul><li><strong>空闲盘区链</strong></li></ul><p>操作系统保存着<strong>链头</strong>、<strong>链尾指针</strong><br><strong>如何分配</strong>：若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据<br><strong>如何回收</strong>：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p><p>【离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高】</p><hr><ul><li><strong><u>存储空管理——位示图法</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-27-29.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-27-43.png" alt=""></p><p><strong>位示图</strong>：每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中个字的字长是16位，字中的每一位对应一个盘块。因此<strong>可以用 (字号，位号) 对应一个盘块号。当然有的题目中也描述为(行号，列号</strong>)</p><p><strong><u>重要重要重要</u></strong>：要能自已推出盘块号与(字号位号)相转换的公式。<strong>注意题目条件:盘块号、字号、位号</strong>到底是从o开始还是从1开始</p><p>如本例中盘块号、字号、位号从0开始，若n表示字长，则…<br>(字号,位号)=(i,j) 的二进制位对应的 盘块号 b = ni +j<br>b号盘块对应的字号i= b/n，位号j= b%n</p><p><strong>如何分配</strong>：若文件需要K个块，① 顺序扫描位示图，找到K个相邻或不相邻的“0”，② 根据字号、位号算出对应的盘块号，将相应盘块分配给文件，③ 将相应位设置为“1”<br><strong>如何回收</strong>: ① 根据回收的盘块号计算出对应的字号、位号; ② 将相应进制位设为“0”</p><hr><ul><li><strong><u>存储空间管理——成组链接法</u></strong><br>【不方便用文字描述也很难作为考题】</li></ul><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理。</p><p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时需要将<strong>超级块读入内存</strong>。并且要保证内存与外存中的“超级块”<strong>数据一致</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-49-02.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-52-38.png" alt=""></p><p>注意：成组链接法的每个分组是有上限的，本例中是100</p><p><strong>如何分配</strong>?<br>Eg：需要1个空闲块<br>① 检查第一个分组的块数是否足够。1&lt;100，因此是足够的。<br>② 分配第一个分组中的1个空闲块【最后一个，上图中的201】，<br>③ 并修改相应数据【超级块：100→99】</p><p>Eg：需要100个空闲块<br>检查第一个分组的块数是否足够。100=100，是足够的。<br>分配第一个分组中的100个空闲块。但是<strong>由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</strong>【相当于300号成了新的超级块】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-07-45.png" alt=""></p><p><strong>如何回收</strong>?<br>Eg: 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块<br><strong>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-13-51.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-20-49.png" alt=""></p><hr><h2 id="4-1-7-文件的基本操作">4.1.7 文件的基本操作</h2><blockquote><p><strong>向上提供的几个最基本的功能</strong>：</p><ul><li><strong>创建文件（ create 系统调用）</strong></li><li><strong>读文件（ read 系统调用）</strong></li><li><strong>写文件（ write 系统调用）</strong></li><li><strong>删除文件（ delete系统调用）</strong></li><li><strong>打开文件（ open系统调用）</strong><br>读/写文件之前，需要“打开文件”</li><li><strong>关闭文件（ close系统调用）</strong><br>读/写文件结束之后， 需要“关闭文件”</li></ul></blockquote><ul><li><strong><u>创建文件</u></strong></li></ul><p>可以“<strong>创建文件</strong>”， （点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p><p>进行 Create 系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小（如：一个盘块，即1KB）</li><li>文件存放路径（“D:/Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ol><p>操作系统在处理 Create 系统调用时，主要做了两件事：</p><ol><li><strong>在外存中找到文件所需的空间</strong>（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ol><hr><ul><li><strong><u>删除文件</u></strong></li></ul><p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“删除文件”功能，即 <strong>delete 系统调用</strong>，将文件数据从外存中删除）</p><p>进行 Delete 系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li></ol><p>操作系统在处理 Delete 系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。 （回收磁盘块时，根据空闲表法、空闲链表法、 位图法等管理策略的不同，需要做不同的处理）</li><li>从目录表中<strong>删除文件对应的目录项</strong>。</li></ol><hr><ul><li><strong><u>打开文件</u></strong></li></ul><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用 “打开文件”，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li><li>要对文件的操作类型（如：r 只读； rw 读写等）</li></ol><p>操作系统在处理 open 系统调用时，主要做了几件事：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-56-27.png" alt=""></p><ol><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限。</li><li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-58-55.png" alt=""></p><p><strong>读/写指针</strong>：记录了该进程对文件的读/写操作进行到的位置<br><strong>访问权限</strong>：如果打开文件时声明的是 “只读”，则该进程不能对文件进行写操作<br><strong>打开计数器</strong>：记录此时有多少个进程打开了此文件</p><p>系统的打开文件表可以方便实现某些文件管理的功能。例如：在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本” 进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。</p><hr><ul><li><strong><u>关闭文件</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-04-02.png" alt=""></p><p>进程使用完文件后，要“关闭文件” 操作系统在处理 Close 系统调用时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count 减1，若 count = 0，则删除对应表项。</li></ol><hr><ul><li><strong><u>读文件</u></strong></li></ul><p>可以“读文件”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>读文件</strong>”功能，即 <strong>read 系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p><p>读/写文件之前，需要“打开文件”：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-06-20.png" alt=""></p><p>进程使用 read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的<strong>索引号</strong>【看”打开文件“的图】即可），还需要指明要读入多少数据（如：读入1KB）、指明读入 的数据要放在内存中的什么位置。 操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><hr><ul><li><strong><u>写文件</u></strong></li></ul><p>可以“写文件”，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>写文件</strong>”功能，即 <strong>write 系统调用</strong>， 将文件数据从内存写回外存）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-06-20.png" alt=""></p><p>进程使用 write 系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的<strong>索引号</strong>即可），还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的 外存。</p><hr><ul><li><strong><u>知识点与重要考点</u></strong></li></ul><p>打开文件时并不会把文件数据直接读内存。“索引号”也称“<strong>文件描述符</strong>”<br>【只是把文件目录项复制到内存中（知识点回顾：一个FCB就是一个文件目录项）】</p><p>“读/写文件”用“文件描述符”即可指明文件， 不再需要用到“文件名”</p><p>读/写文件的时候才把文件从外存读入内存</p><hr><h2 id="4-1-8-文件共享">4.1.8 文件共享</h2><blockquote><p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</p><p><strong>注意</strong>：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。<br>如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p></blockquote><ul><li><strong><u>基于索引结点的共享方式（硬链接）</u></strong></li></ul><p>知识回顾：索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-15-10.png" alt=""></p><p>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p><p>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。 若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的 count值减 1。</p><p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当 count = 0 时系统负 责删除文件。</p><hr><ul><li><strong><u>基于符号链的共享方式（软链接）</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-20-22.png" alt=""></p><p>【Link 类型的文件，记录了文件1的存放路径 “C:/User1/aaa”。 类似于 Windows 操作系统的“<strong>快捷方式</strong>”】</p><p>当 User3 访问“ccc”时，操作系统判断文件“ccc”属于 Link 类型文件，于是会根据其中记录的路径层层查找目录，最终找到 User1 的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p><p>Link 类型的文件名可以不同</p><p>例如QQ快捷方式：双击快捷方式图标打开时，操作系统判断这个文件是Link类型的 “快捷方式”文件，于是会根据其中记录的“路径 信息”检索目录，最终找到“QQScLauncher.exe”</p><p>但是如果QQScLauncher.exe已经删除，不存在了，QQ快捷方式打开时会提示错误。</p><hr><h2 id="4-1-10-文件保护">4.1.10 文件保护</h2><ul><li><strong><u>口令保护</u></strong></li></ul><p>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p><p>【口令一般存放在文件对应的 FCB 或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比， 如果正确，则允许该用户访问文件】</p><p><strong>优点</strong>：保存口令的空间开销不多，验证口令的时间开销也很小。</p><p><strong>缺点</strong>：正确的“口令”存放在系统内部【被入侵】，不够安全。</p><hr><ul><li><strong><u>加密保护</u></strong></li></ul><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><p><strong>Eg</strong>：一个最简单的加密算法——异或加密<br>假设用于加密/解密的“密码”为“01001”</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-22-13.png" alt=""></p><p><strong>优点</strong>：保密性强，不需要在系统中存储“密码”</p><p><strong>缺点</strong>：编码/译码，或者说加密/解密要花费一定时间。</p><hr><ul><li><strong><u>访问控制</u></strong></li></ul><p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List, <strong>ACL</strong>），该表中记录了各个用户可以对该文件执行哪些操作。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-24-46.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-24-51.png" alt=""></p><p>有的计算机可能会有很多个用户， 因此访问控制列表可能会很大，可以用<strong>精简的访问列表</strong>解决这个问题</p><p><strong>精简的访问列表</strong>：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。 如：分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组。<br>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。【系统需要管理分 组的信息】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-26-47.png" alt=""></p><p>若想要让某个用户能够读取文件，只需要把该用户放入 “文件主的伙伴” 这个分组即可</p><p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p><hr><ul><li><strong><u>Windows 的访问控制</u></strong></li></ul><p><a href="https://www.bilibili.com/video/BV1YE411D7nH?p=67&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">4.1_9_文件保护_哔哩哔哩_bilibili </a> 08:38~11:55</p><hr><h2 id="4-3-1-文件系统的层次结构">4.3.1 文件系统的层次结构</h2><blockquote><p>说明：<strong>408大纲不要求考察本节内容</strong></p><p>本视频中介绍的“文件系统层次结构”，主要参考了<strong>国内教材</strong>；23版王道书介绍的“文件系统层次结构”，主要参考了<strong>国外教材</strong>。因此，二者看起来会有一些差异</p><p>不同的学者对文件系统的层次结构划分方法不同，本视频与王道书介绍的两种分层方法都是正确的，大家简要了解即可，<strong>不用追求“标准答案</strong>“</p></blockquote><ul><li><strong><u>文件系统的层次结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-36-02.png" alt=""></p><p><strong>用户接口</strong>：文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求（Read、Write、Open、 Close 等系统调用）</p><p><strong>文件目录系统</strong>：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如：管理活跃的文件目录表、管理打开文件表等。</p><p><strong>存取控制模块</strong>：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能。</p><p><strong>逻辑文件系统与文件信息缓冲区</strong>：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址</p><p><strong>物理文件系统</strong>：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址</p><p><strong>辅助分配模块</strong>：负责文件存储空间的管理，即负责分配和回收存储空间</p><p><strong>设备管理模块</strong>：直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘</p><p>调度、启动设备、释放设备等</p><p>【用一个例子来辅助记忆文件系统的层次结构】<br>假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求<br>——<strong>用户接口</strong></li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项<br>——<strong>文件目录系统</strong></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限<br>——<strong>存取控制模块（存取控制验证层）</strong></li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址<br>——<strong>逻辑文件系统与文件信息缓冲区</strong></li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址<br>——<strong>物理文件系统</strong></li><li>要删除这条记录，必定要对磁盘设备发出请求<br>——<strong>设备管理程序模块</strong></li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收<br>——<strong>辅助分配模块</strong></li></ol><hr><h2 id="4-3-2-文件系统的全局结构（布局）">4.3.2 文件系统的全局结构（布局）</h2><ul><li><strong><u>原始磁盘</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-49-08.png" alt=""></p><hr><ul><li><strong><u>物理格式化后</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-48-14.png" alt="·"></p><p>物理格式化，即低级格式化–划分扇区，检测坏扇区，并用备用扇区替换坏扇区</p><p>【坏扇区的存在对于操作系统来说也是透明的；当操作系统要访问一个坏扇区时，（磁盘驱动器格式化后，知道这是个坏的）磁盘驱动器会用备用扇区来替代扇区】</p><hr><ul><li><strong><u>逻辑格式化后</u></strong><br>又叫 <strong>高级格式化</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-55-43.png" alt=""></p><p><strong>逻辑格式化</strong>后，磁盘分区 (分卷 Volume)完成各分区的文件系统初始化</p><p>注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据<br>注：“主引导记录MBR、引导块”的作用，可结合第一章“操作系统引导”小节来学习</p><p>【说明：i节点——索引节点】</p><hr><ul><li><strong><u>文件系统在内存中的结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-02-26.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-03-23.png" alt=""></p><p>注：近期访问过的目录文件会线存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</p><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-07-11.png" alt=""></p><hr><h2 id="4-3-3-虚拟文件系统">4.3.3 虚拟文件系统</h2><ul><li><strong><u>普通文件系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-22-37.png" alt=""></p><p>有好几个不同的接口，对程序员不友好</p><hr><ul><li><strong><u>虚拟文件系统</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-25-02.png" alt=""></p><p>虚拟文件系统的特点:</p><ol><li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li>VFS要求下层的文件系统必须实现某些规定的函数功能，如:open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-28-32.png" alt=""></p><p>存在的问题：不同的文件系统，表示文件数据结构各不相同打开文件后，其在内存中的表示就不同</p><p>解决：打开文件就在主存中创建<code>vnode</code>结点</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-30-05.png" alt=""></p><ol start="3"><li>每打开一个文件，VFS就在主存（内存）中新建一个 <code>vnode</code>，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。</li></ol><p>注意: <code>vnode</code> 只存在于主存中，而 <code>inode</code>（i结点（索引结点）） 既会被调入主存，也会在外存中存储</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-35-15.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-35-20.png" alt=""></p><p>打开文件后，创建<code>vnode</code>，并将文件信息复制到<code>vnode</code>中，<code>vnode</code>的功能指针指向具体文件系统的函数功能。</p><hr><ul><li><strong><u>文件系统挂载（mounting）</u></strong></li></ul><p>文件系统挂载(mounting)，即文件系统安装/装载——如何将文件系统挂载到操作系统中?</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-25-02.png" alt=""></p><p>文件系统挂载要做的事:</p><ol><li>在VFS中注册新挂载的文件系统<strong>内存中的挂载表</strong> (mount table) 包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li><li>新挂载的文件系统，要向VFS提供一个<strong>函数地址列表</strong></li><li>将新文件系统加到<strong>挂载点</strong> (<strong>mount point</strong>)，也就是将新文件系统挂载在某个父目录下</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-40-34.png" alt=""></p><hr><h1>第五章 输入/输出（I/O）管理</h1><h2 id="5-1-1-I-O设备的概念和分类">5.1.1 I/O设备的概念和分类</h2><blockquote><p>前情回顾</p><p><strong>操作系统的功能和目标——作为系统资源的管理者</strong></p><ul><li>提供的功能：<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li><strong>设备管理</strong></li></ul></li><li>目标：<ul><li>安全、高效</li></ul></li></ul></blockquote><ul><li><strong><u>什么是I/O设备</u></strong></li></ul><p>“I/O” 就是 “输入/输出”（Input/Output）</p><p>I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>鼠标、键盘——典型的输入型设备：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-03.png" alt=""></p><p>显示器——输出型设备：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-14.png" alt=""></p><p>移动硬盘——即可输入、又可输出的设备：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-23.png" alt=""></p><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<br>Write操作：向外部设备写出数据<br>Read操作：从外部设备读入数据</p><hr><ul><li><strong><u>I/O设备的分类——按使用特性</u></strong><ul><li><strong>人机交互类外部设备</strong>：数据传输速度慢<br>鼠标、键盘、打印机等——用于人机交互</li><li><strong>存储设备</strong>：数据传输速度快<br>移动硬盘、光盘等——用于数据存储</li><li><strong>网络通信设备</strong>：数据传输速度介于 上述二者之间<br>调制解调器等——用于网络通信</li></ul></li></ul><hr><ul><li><strong><u>I/O设备的分类——按传输速率分类</u></strong><ul><li><strong>低速设备</strong><br>鼠标、键盘等——传输速率为每秒几个到几百字节</li><li><strong>中速设备</strong><br>如激光打印机等——传输速率为每秒数千至上万个字节</li><li><strong>高速设备</strong><br>如磁盘等—— 传输速率为每秒数千字节至千兆字节的设备</li></ul></li></ul><hr><ul><li><strong><u>I/O设备的分类——按信息交换的单位分类</u></strong><ul><li><strong>块设备</strong>：传输速率较高，可寻址，即对它可随机地读/写任一块<br>如磁盘等——数 据传输的基本单位是“块”</li><li><strong>字符设备</strong>：传输速率较慢，不可寻址，在输入/输出时常采用<strong>中断驱动方式</strong>【一种I/O控制方式】<br>鼠标、键盘 等——数据传输的基本单位 是字符。</li></ul></li></ul><hr><h2 id="5-1-2-I-O控制器">5.1.2 I/O控制器</h2><blockquote><p>I/O设备由机械部件和电子部件组成</p></blockquote><ul><li><strong><u>I/O设备的机械部件</u></strong></li></ul><p>I/O设备的<strong>机械部件</strong>主要用来执行具体I/O操作。<br>如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</p><p>I/O设备的<strong>电子部件</strong>通常是一块插入主板扩充槽的印刷电路板。</p><hr><ul><li><strong><u>I/O设备的电子部件（I/O控制器）</u></strong></li></ul><p>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“<strong>中介</strong>”，用于实现CPU对设备的控制。</p><p>这个电子部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。</p><p><strong>I/O控制器的功能</strong>：</p><ol><li><strong>接受和识别CPU发出的命令</strong><br>如CPU发来的 read/write 命令，I/O 控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li><li><strong>向CPU报告设备状态</strong><br>I/O控制器中会有相应的<strong>状态寄存器</strong>，用于记录I/O设备的当前状态。如：1表示空闲，0表示忙碌</li><li><strong>数据交换</strong><br>I/O控制器中会设置相应的<strong>数据寄存器</strong>。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</li><li><strong>地址识别</strong><br>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器。</li></ol><hr><ul><li><strong><u>I/O控制器的组成</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-06-23.png" alt=""></p><p>值得注意的小细节：<br>① 一个I/O控制器可能会对应多个设备；<br>② 数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I/O</strong>；另一些计算机则采用I/O专用地址，即<strong>寄存器独立编址</strong>。</p><hr><ul><li><strong><u>内存映像I/O v.s. 寄存器独立编址</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-18-07.png" alt=""></p><hr><h2 id="5-1-3-I-O控制方式">5.1.3 I/O控制方式</h2><blockquote><p><strong>I/O控制方式</strong>，即：用什么样的方式来控制 I/O设备的数据读/写</p><p>需要注意的问题：</p><ol><li>完成一次读/写操作的流程；</li><li>CPU干预的频率；</li><li>数据传送的单位；</li><li>数据的流向；</li><li>主要缺点和主要优点。</li></ol></blockquote><ul><li><strong><u>程序直接控制方式</u></strong></li></ul><p><strong>key word：轮询</strong><br>完成一次读/写操作的流程（以<strong>读操作</strong>为例）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-27-08.png" alt=""></p><ol><li>完成一次读/写操作的流程（见下图，<strong>Key word：轮询</strong>）</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-35-04.png" alt=""></p><p>【问题】：将CPU寄存器中的内容写到内存中？请看以下例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;<span class="comment">// a存放在内存中</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);<span class="comment">// 输入的数据最终要放到内存中（a变量存放在内存中）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);<span class="comment">// 同理，输出的数据也存放在内存中，需要从内存取出</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>CPU干预的频率<br>很频繁，I/O操作开始之前、完成之后需要CPU介入，并且<strong>在等待I/O完成的过程中CPU需要不断地轮询检查</strong>。</p></li><li><p>数据传送的单位<br>每次读/写<strong>一个字</strong></p></li><li><p>数据的流向<br>读操作（数据输入）：I/O设备→CPU【指的是CPU 的寄存器】→内存<br>写操作（数据输出）：内存→CPU→I/O设备<br>每个字的读/写都需要CPU的帮助</p></li><li><p>主要缺点和主要优点<br>优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）<br><strong>缺点</strong>：<strong>CPU和I/O设备只能串行工作，CPU需要一直轮询检查， 长期处于“忙等”状态</strong> ，CPU利用率低。</p></li></ol><hr><ul><li><strong><u>中断驱动方式</u></strong></li></ul><p>引入<strong>中断机制</strong>。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将<strong>等待I/O的进程阻塞</strong>，先切换到别的进程执行。当I/O 完成后，控制器会向CPU发出一个中断信号，CPU<strong>检测到中断信号后</strong>，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，<strong>CPU恢复等待I/O的进 程（或其他进程）的运行环境，然后继续执行</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-11-55.png" alt=""></p><p>注意：<br>① CPU会在每个指令周期的末尾检查中断；<br>② 中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生 的频率太高，也会降低系统性能。</p><ol><li>完成一次读/写操作的流程（见右图，<strong>Key word：中断</strong>）</li><li>CPU干预的频率<br>每次I/O操作开始之前、完成之后需要CPU介入。<br><strong>等待I/O完成的过程中CPU可以切换到别的进程执行</strong>。</li><li>数据传送的单位<br>每次读/写<strong>一个字</strong></li><li>数据的流向<br>读操作（数据输入）：I/O设备→CPU【指的是CPU 的寄存器】→内存<br>写操作（数据输出）：内存→CPU→I/O设备</li><li>主要缺点和主要优点<br>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。<strong>CPU和I/O设备可并行工作</strong>，CPU利用率得到明显提升。<br><strong>缺点</strong>：每个字在I/O设备与内存之间的传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的CPU时间</strong>。</li></ol><hr><ul><li><strong><u>DMA方式</u></strong></li></ul><p>与“中断驱动方式”相比，<strong>DMA方式</strong>（ Direct Memory Access，<strong>直接存储器存取</strong>。主要用于块设备的I/O控制）有这样几个改进：<br>① <strong>数据的传送单位是“块”</strong> 。不再是一个字、一个字的传送；<br>② 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。<br>③ 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-17-16.png" alt=""></p><p>【CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）】<br>【控制器会根据CPU提出的要求完成数据的读/写工作，整块数据的传输完成后，才向CPU发出中断信号】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-19-02.png" alt=""></p><p><strong>DR</strong> （Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。<br><strong>MAR</strong> （Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么 位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。<br><strong>DC</strong> （Data Counter，数据计数器）：表示剩余要读/写的字节数。<br><strong>CR</strong>（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。</p><p>【由图，DMA和内存之间可以直接进行读写，不再经过CPU】<br>【DMA其实也是<strong>一个字</strong>一个字读的，先读到DR里面，再写入内存】</p><ol><li>完成一次读/写操作的流程）</li><li>CPU干预的频率<br>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li><li>数据传送的单位<br>每次读/写<strong>一个或多个块</strong>（注意：每次读写的只能是连续的多个块， 且这些块读入内存后在内存中也必须是连续的） 【离散的块也是需要CPU多次干预的】</li><li>数据的流向（<strong>不再需要经过CPU</strong>）<br>读操作（数据输入）：I/O设备→内存<br>写操作（数据输出）：内存→I/O设备</li><li>主要缺点和主要优点<br>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。<br><strong>缺点</strong>：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。<br>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</li></ol><hr><ul><li><strong><u>通道控制方式</u></strong></li></ul><p><strong>通道</strong>：一种<strong>硬件</strong>，可以理解为是 “<strong>弱鸡版的CPU</strong>”。通道可以识别并执行一系列<strong>通道指令</strong><br>【与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-31-06.png" alt=""></p><ol><li>完成一次读/写操作的流程（见下图）</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-32-05.png" alt=""></p><ol start="2"><li>CPU干预的频率<br>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</li><li>数据传送的单位<br>每次读/写<strong>一组数据块</strong></li><li>数据的流向（<strong>在通道的控制下进行</strong>）<br>读操作（数据输入）：I/O设备→内存<br>写操作（数据输出）：内存→I/O设备</li><li>主要缺点和主要优点<br>缺点：实现复杂，需要专门的通道硬件支持<br><strong>优点：CPU、通道、I/O设备可并行工作，资源利用率很高</strong>。</li></ol><hr><ul><li><u><strong>知识点回顾与重要考点</strong></u></li></ul><p>难点理解：<br>通道=弱鸡版CPU<br>通道程序=任务清单</p><table><thead><tr><th></th><th>完成一次读/写的过程</th><th>CPU干预频率</th><th>每次I/O的数据传输单位</th><th>数据流向</th></tr></thead><tbody><tr><td>程序直接控制方式</td><td>CPU发出I/O命令后需要不断轮询</td><td>极高</td><td>字</td><td>I/O设备→CPU→内存 <br/>内存→CPU→I/O设备</td></tr><tr><td>中断驱动方式</td><td>CPU发出I/O命令后可以做其他事，本次I/O完成后设备控制器发出中断信号</td><td>高</td><td>字</td><td>I/O设备→CPU→内存 <br/>内存→CPU→I/O设备</td></tr><tr><td>DMA方式</td><td>CPU发出I/O命令后可以做其他事，本次I/O完成后DMA控制器发出中断信号</td><td>中</td><td>块</td><td>I/O设备→内存 <br />内存→I/O设备</td></tr><tr><td>通道控制方式</td><td>CPU发出I/O命令后可以做其他事。通道会执行通道程序以完成I/O，完成后通道向CPU发出中断信号</td><td>低</td><td>一组块</td><td>I/O设备→内存 <br/>内存→I/O设备</td></tr></tbody></table><p><strong>优缺点</strong>：每一个阶段的优点都是解决了上一阶段的最大缺点。 总体来说，整个发展过程就是要尽量减少CPU对I/O过程的干预，把CPU从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。</p><hr><h2 id="5-1-4-I-O软件层次结构">5.1.4 I/O软件层次结构</h2><blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-48-28.png" alt=""></p><p>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）</p></blockquote><ul><li><strong><u>用户层软件</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-51-42.png" alt=""></p><p>【有的题目中也会称设备独立性软件为系统调用处理层】</p><p>Windows 操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用（Windows API）</p><hr><ul><li><strong><u>设备独立性软件</u></strong></li></ul><p><strong>设备独立性软件</strong>，又称<strong>设备无关性软件</strong>。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要实现的功能：<br>① 向上层提供统一的调用接口（如 read/write 系统调用）；<br>② 设备的保护；</p><p>原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权 限也不一样。</p><p>③ 差错处理</p><p>设备独立性软件需要对一些设备的错误进行处理【差错类型太多了，基本没法考】</p><p>④ 设备的分配与回收</p><p>⑤ 数据缓冲区管理</p><p>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p><p>⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p><p>用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名（eg：去学校打印店打印时，需要选择打印机1/打印机2/打印机3 ，其实这些都是<strong>逻辑设备名</strong>）</p><p><strong>设备独立性软件</strong>需要通过“<strong>逻辑设备表（LUT，Logical Unit Table</strong>）”来确定逻辑设备对应的<strong>物理设备</strong>，并找到该设备对应的<strong>设备驱动程序</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-01-03.png" alt=""></p><p>操作系统系统可以采用两种方式管理<strong>逻辑设备表（LUT</strong>）：<br><strong>第一种方式</strong>，<strong>整个系统只设置一张LUT</strong>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。<br><strong>第二种方式</strong>，<strong>为每个用户设置一张LUT</strong>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p><hr><ul><li><strong><u>思考：为何不同的设备需要不同 的设备驱动程序？</u></strong></li></ul><p>各式各样的设备，外形不同，其内部的电子部件（I/O控制器）也有可能不同</p><p>eg：<br>佳能打印机的厂家规定状态寄存器为 0 代表空闲，1代表忙碌。有两个数据寄存器<br>惠普打印机的厂家规定状态寄存器为 1代表空闲，0代表忙碌。有一个数据寄存器</p><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p><hr><ul><li><strong><u>设备驱动程序</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-06-19.png" alt=""></p><p>注：驱动程序一般会以一个独立进程的方式存在。如下图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-01-03.png" alt=""></p><hr><ul><li><strong><u>中断处理程序</u></strong></li></ul><p>当I/O任务完成时，I/O控制器会发送一个<strong>中断信号</strong>，系统会<strong>根据中断信号类型</strong>找到相应的<strong>中断处理程序</strong>并执行。中断处理程序的处理流程如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-13-38.png" alt=""></p><hr><ul><li><strong><u>知识点回顾与重要考点</u></strong></li></ul><table><thead><tr><th style="text-align:center">层次</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>用户层软件</strong></td><td>实现与用户交互的接口，向上提供方便易用的库函数</td></tr><tr><td style="text-align:center"><strong>设备独立性软件</strong></td><td>① 向上层提供统一的调用接口（如 read/write 系统调用）； <br />② 设备的保护；<br />③ 差错处理；<br />④ 设备的分配与回收；<br />⑤ 数据缓冲区管理；<br />⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序…</td></tr><tr><td style="text-align:center"><strong>设备驱动程序</strong></td><td>设置设备寄存器、检查设备状态</td></tr><tr><td style="text-align:center"><strong>中断处理程序</strong></td><td>进行中断处理</td></tr><tr><td style="text-align:center"><strong>硬件</strong></td><td>执行I/O操作，有机械部件、电子部件组成（参考“I/O控制器”小节的视频）</td></tr></tbody></table><p>理解并记住I/O软件<strong>各个层次之间的顺序</strong>，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可：<strong>直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</strong>）</p><hr><h2 id="5-1-5-输入-输出应用程序接口和设备驱动程序接口">5.1.5 输入/输出应用程序接口和设备驱动程序接口</h2><ul><li><strong><u>输入/输出应用程序接口</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-21-42.png" alt=""></p><p>显然，用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的I/O</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-27-53.png" alt=""></p><ul><li><p><strong>字符设备接口</strong>：<br>get put 系统调向字符设备读/写一个字符</p></li><li><p><strong>块设备接口</strong>：<br>read/write 系统调用：向块设备的<strong>读写指针位置</strong>读/写多个字符；<br>seek系统调用：<strong>修改读写指针位置</strong></p></li><li><p><strong>网络设备接口</strong>，又称“<strong>网络套接字(socket)接口</strong>：<br>socket 系统调用：<strong>创建一个网络套接字</strong>，需指明网络协议 (TCP? UDP?)<br>bind：将套接字绑定到某个本地“<strong>端口</strong>“<br>connect：将套接字连接到远程地址<br>read/write：从套接字读/写数据</p></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-42-10.png" alt=""></p><hr><ul><li><strong><u>阻塞/非阻塞 I/O</u></strong></li></ul><p>阻塞I/O：应用程序发出I/O系统调用，<strong>进程需转为阻塞态等待</strong>。<br>eg：字符设备接口——从键盘读一个字符 get【scanf()】</p><p>非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，<strong>进程无需阻寒等待</strong>。<br>eg：块设备接口——往磁盘写数据 write</p><hr><ul><li><strong><u>设备驱动程序接口</u></strong></li></ul><p>若各公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-49-19.png" alt=""></p><hr><ul><li><strong><u>统一标准的设备驱动程序接口</u></strong></li></ul><p>操作系统规定好设备驱动程序的接口标准，各厂商必须按要求开发设备驱动程序</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-49-24.png" alt=""></p><p>不同的操作系统，对设备驱动程序接口的标准各不相同</p><p>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用。eg:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-52-00.png" alt=""></p><hr><h2 id="5-2-1-I-O核心子系统">5.2.1 I/O核心子系统</h2><blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-48-28.png" alt=""></p><p>因此I/O核心子系统要实现的功能其实就是中间三层要实现的功能 （参考上节）</p><p>考研中，我们需要重点理解和掌握的功能是：I/O调度、设备保护、假脱机技术 （SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存）这些功能要在哪个层次实现？</p></blockquote><ul><li><strong><u>这些功能要在哪个层次实现？</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-31-28.png" alt=""></p><p>注：假脱机技术（SPOOLing 技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。但是<strong>408大纲又将假脱机技术归为“I/O核心子系统” 的功能，因此考试时还是以大纲为准</strong>。</p><hr><ul><li><strong><u>I/O调度</u></strong></li></ul><p><strong>I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求。</strong></p><p>如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、 C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序。</p><hr><ul><li><strong><u>设备保护</u></strong></li></ul><p>操作系统需要实现<strong>文件保护功能</strong>，不同的用户对各个文件有不同的访问权限（如：只读、读和 写等）。</p><p>在UNIX系统中，<strong>设备被看做是一种特殊的文件</strong>，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。（参考“文件保护”小节）</p><hr><h2 id="5-2-2-假脱机技术">5.2.2 假脱机技术</h2><ul><li><strong><u>什么是脱机技术</u></strong></li></ul><p>手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-38-38.png" alt=""></p><p>批处理阶段引入了<strong>脱机输入/输出技术</strong>（用磁带完成）：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-41-08.png" alt=""></p><p>在外围控制机的控制下， 慢速输入设备的数据先被输入到更快速的磁带上。 之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾</p><p>Tips：为什么称为“脱机”——脱离主机的控制进行的输入/输出操作。</p><p>引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备1正在忙碌，也可以提前将数据输出到磁带。</p><hr><ul><li><strong><u>假脱机技术——输入井和输出井</u></strong></li></ul><p>“<strong>假脱机技术</strong>”，又称“<strong>SPOOLing 技术</strong>”是用软件的方式模拟脱机技术。 SPOOLing 系统的组成如下：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-43-19.png" alt=""></p><p>在磁盘上开辟出两个 存储区域——“<strong>输入井</strong>”和“<strong>输出井</strong>”</p><p>“输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据</p><p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</p><p>“输入进程”模拟脱机输入时的外围控制机</p><p>“输出进程”模拟脱机输出时的外围控制机</p><p>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</p><p>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</p><p>在输出进程的控制下，“输出缓冲区”用于暂存从输出 井送来的数据，之后再传送到输出设备上</p><hr><ul><li><strong><u>共享打印机原理分析</u></strong></li></ul><p>独占式设备——<strong>只允许各个进程串行使用的设备</strong>。一段时间内只能满足一个进程的请求。<br>共享设备——<strong>允许多个进程“同时”使用的设备</strong>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p><p>打印机是种“独占式设备”，但是可以用 SPOOLing 技术改造成“共享设备”</p><p>独占式设备的例子：若进程1 正在使用打印机，则进程2 请求使用打印机时必然阻塞等待</p><p><strong>共享打印机原理分析如下</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-57-17.png" alt=""></p><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们， 而是由假脱机管理进程为每个进程做两件事：</p><p>（1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</p><p>（2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</p><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数 据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p><p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><p>SPOOLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，<strong>可将独占式设备改造成共享设备</strong>。</p><hr><h2 id="5-2-3-设备的分配与回收">5.2.3 设备的分配与回收</h2><ul><li><strong><u>设备分配时应考虑的因素</u></strong><ul><li><strong>设备的固有属性</strong></li><li><strong>设备的分配算法</strong></li><li><strong>设备分配中的安全性</strong></li></ul></li></ul><p><strong>设备的固有属性</strong>可分为三种：独占设备、共享设备、虚拟设备。<br><strong>独占设备</strong>——一个时段只能分配给一个进程（如打印机）<br><strong>共享设备</strong>——可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。<br><strong>虚拟设备</strong>——采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</p><p><strong>设备的分配算法</strong>：<br>先来先服务<br>优先级高者优先<br>短任务优先<br>……</p><p>从<strong>进程运行的安全性</strong>上考虑，设备分配有两种方式：</p><ul><li><p><strong>安全分配方式</strong>：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。</p><p>一个时段内每个进程只能使用一个设备<br>优点：破坏了“请求和保持”条件，不会死锁<br>缺点：对于一个进程来说，CPU和I/O设备只能串行工作</p></li><li><p><strong>不安全分配方式</strong>：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。（eg：考虑进程请求打印机打印输出的例子）</p><p>一个进程可以同时使用多个设备<br>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进<br>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）【银行家算法……】</p></li></ul><hr><ul><li><strong><u>静态分配和动态分配</u></strong></li></ul><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源<br>【破坏了“请求和保持”条件，不会发生死锁】</p><p>动态分配：进程运行过程中动态申请设备资源</p><hr><ul><li><strong><u>设备分配管理中的数据结构</u></strong></li></ul><p>“设备、控制器、通道”之间的关系：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-10-28.png" alt=""></p><p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p><p><strong>设备控制表（DCT）</strong> ：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-14-28.png" alt=""></p><p>注：“进程管理”章节中曾经提到过“系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中”</p><p><strong>控制器控制表（COCT）</strong> ：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-18-28.png" alt=""></p><p><strong>通道控制表（CHCT）</strong> ：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-19-07.png" alt=""></p><p><strong>系统设备表（SDT）</strong> ：记录了<strong>系统中全部设备</strong>的情况，每个设备对应一个表目。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-20-00.png" alt=""></p><hr><ul><li><strong><u>设备分配的步骤</u></strong></li></ul><p>① 根据进程请求的<strong>物理设备名</strong>查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-20-56.png" alt=""></p><p>② 根据SDT找到DCT，若<strong>设备</strong>忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-21-37.png" alt=""></p><p>③ 根据DCT找到COCT，若<strong>控制器</strong>忙碌则将进程PCB挂到<strong>控制器等待队列</strong>中，不忙碌则将<strong>控制器</strong>分配给进程。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-22-09.png" alt=""></p><p>④ 根据COCT找到CHCT，若<strong>通道</strong>忙碌则将进程PCB挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-26-41.png" alt=""></p><p><strong>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</strong></p><p>【一个通道控制多个控制器， 一个控制器控制多个设备】</p><hr><ul><li><strong><u>设备分配步骤的改进</u></strong></li></ul><p>之前的缺点：<br>① 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程<br>② 若换了一个物理设备，则程序无法运行<br>③ 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p><p>改进过程：<br>① 根据进程请求的<strong>逻辑设备名</strong>查找SDT（<strong>注：用户编程时提供的逻辑设备名其实就是“设备类型</strong>”）<br>② 查找SDT，找到用户进程<strong>指定类型的、并且空闲</strong>的设备，将其分配给该进程。操作系统<strong>在逻辑设备表（LUT）中新增一个表项</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-35-10.png" alt=""></p><p>剩下的一样：<br>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。<br>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p><strong>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系</strong>。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在 LUT中增加相应表项。</p><p><strong>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</strong>。</p><p>逻辑设备表的设置问题：<br>整个系统只有一张LUT：各用户所用的<strong>逻辑设备名不允许重复</strong>，适用于单用户操作系统<br>每个用户一张LUT：不同用户的<strong>逻辑设备名可重复</strong>，适用于多用户操作系统</p><hr><h2 id="5-2-4-缓冲区管理">5.2.4 缓冲区管理</h2><ul><li><strong><u>什么是缓冲区？有什么作用？</u></strong></li></ul><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用<strong>硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器【快表】，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p><p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“设备独立性软件”的缓冲区管理就是要组织管理 好这些缓冲区</p><p><strong>缓冲区的作用</strong>：</p><ul><li>缓和CPU和I/O设备之间速度不匹配的矛盾</li></ul><p>CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事<br>慢速的I/O设备可以慢慢从缓冲区取走数据<br>数据输入时类似</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-59-36.png" alt=""></p><ul><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li></ul><p>如果是字符型设备，则每输出完一个字符就要向CPU发送一次中断信号</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-00-16.png" alt=""></p><ul><li>解决数据粒度不匹配的问题</li></ul><p>如：输出进程每次可以生成一块数据，但I/O设备每次只能输出一个字符</p><ul><li>提高CPU与I/O设备之间的并行性</li></ul><hr><ul><li><strong><u>单缓冲</u></strong></li></ul><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会在<strong>主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p><p>【用户进程的内存空间中，会分出一片工作区来接受输入/输出数据（一般也默认工作区大小与缓冲区相同）】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-04-18.png" alt=""></p><p><strong>常考题型</strong>：计算每处理一块数据平均需要多久？<br><strong>技巧</strong>：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间。</p><p>在“单缓冲”题型中，可以假设初始状态为工作区满，缓冲区空。<br>[分析1]：【如上图，T M C表示的都是时间】<br>初始状态：工作区满，缓冲区空<br><strong>假设T&gt;C</strong>【因此CPU处理完数据后暂时不能将下一块数据传送到工作区，必须等待缓冲区中冲满数据】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-09-45.png" alt=""></p><p>所以处理一块数据的平均用时 = T+M</p><p>[分析2]：<br>初始状态：工作区满，缓冲区空<br><strong>假设T&lt;C</strong>【因此缓冲区中冲满数据后暂时不能继续冲入下一块数据， 必须等待CPU处理结束后将数据从缓冲区 传送到工作区】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-12-53.png" alt=""></p><p>所以处理一块数据的平均用时 = C+M</p><p><strong>结论：采用单缓冲策略，处理一块数据平均耗时 Max(C, T) + M</strong></p><hr><ul><li><strong><u>双缓冲</u></strong></li></ul><p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-18-05.png" alt=""></p><p>双缓冲题目中，假设初始状态为：<strong>工作区空，其中一个缓冲区满，另一个缓冲区空</strong></p><p>[分析1]：<br><strong>假设T&gt;C+M</strong><br>【状态分析（缓冲区1，缓冲区2）0：（满，空）T：（空，满）2T：（满，空）】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-22-51.png" alt=""></p><p>处理一块数据的平均用时 = T</p><p>[分析2]：<br><strong>假设T&lt;C+M</strong>【没办法周期的回到初始状态了，之前的方法不适用】<br>假设2T&lt;2M+C，则I/O设备将缓冲区1冲满时，缓冲区2的数据尚未取空，因此I/O设备暂时不能冲入数据，结果如下图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-26-19.png" alt=""></p><p>注：M(1) 表示“将缓冲区1中的数据传送到工作区”； M(2) 表示“将缓冲区2中的数据传送到工作区”</p><p>总之，T&lt;C+M 意味着<strong>设备输入数据块的速度要比处理机处理数据块的速度更快</strong>。每处理一个数据块平均耗时C+M</p><p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为 Max(T, C+M)</strong></p><hr><ul><li><strong><u>使用单/双缓冲在通信时的区别</u></strong></li></ul><p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。</p><p>显然，若两个相互通信的机器只设置<strong>单缓冲区</strong>，在任一时刻只能实现数据的单向传输。如下图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-32-51.png" alt=""></p><p>若两个相互通信的机器设置<strong>双缓冲区</strong>，则同一时刻可以实现双向的数据传输。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-34-30.png" alt=""></p><p><strong>注：管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</strong></p><hr><ul><li><strong><u>循环缓冲区</u></strong></li></ul><p>将多个<strong>大小相等</strong>的缓冲区链接成一个<strong>循环队列</strong>。</p><p>注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-36-51.png" alt=""></p><hr><ul><li><strong><u>缓冲池</u></strong></li></ul><p><strong>缓冲池</strong>由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-38-18.png" alt=""></p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-39-05.png" alt=""></p><p>原理分析：</p><p>① 输入进程请求输入数据</p><p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-46-00.png" alt=""></p><p>② 计算进程想要取得一块输入数据</p><p>从输入队列中取得一块冲满输入数据的缓冲区作 “提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-47-24.png" alt=""></p><p>③ 计算进程想要将准备好的数据冲入缓冲区</p><p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-48-34.png" alt=""></p><p>④ 输出进程请求输出数据</p><p>从输出队列中取得一块冲满输出数据的缓冲区作为 “提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-49-23.png" alt=""></p><hr><h2 id="5-3-1-磁盘结构">5.3.1 磁盘结构</h2><ul><li><strong><u>磁盘、磁道、扇区</u></strong></li></ul><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-07-19.png" alt=""></p><p>如下图：<br>磁盘的盘面被划分成一个个磁道这样的一个“圈”就是一个磁道<br>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同 (如1KB)<br>最内侧磁道上的扇区面积最小，因此数据密度最大</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-14-35.png" alt=""></p><hr><ul><li><strong><u>如何在磁盘中读/写数据</u></strong></li></ul><p>需要把“磁头”移动到想要读/写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-16-19.png" alt=""></p><hr><ul><li><strong><u>盘面、柱面</u></strong></li></ul><p>一个盘片可能会有两个盘面【正反面】</p><p>每个盘面对应一个磁头</p><p>所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退“</p><p>所有盘面中相对位置相同的磁道组成柱面【下图的黄色磁道】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-21-30.png" alt=""></p><hr><ul><li><strong><u>磁盘的物理地址</u></strong></li></ul><p>可用 <strong>(柱面号，盘面号，扇区号)</strong> 来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成(柱面号，盘面号，扇区号)的地址形式</p><p>可根据该地址读取一个“块”</p><ol><li>根据“柱面号”移动磁臂，让磁头指向指定柱面;</li><li>激活指定盘面对应的磁头;</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li></ol><hr><ul><li><strong><u>磁盘的分类</u></strong></li></ul><p>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-24-08.png" alt=""></p><p>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头【下图中别的盘面中的磁头<strong>只是没画出来</strong>】</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-25-52.png" alt=""></p><p>盘片可以更换的称为<strong>可换盘磁盘</strong><br>盘片不可更换的称为<strong>固定盘磁盘</strong></p><hr><h2 id="5-3-2-磁盘的调度算法">5.3.2 磁盘的调度算法</h2><ul><li><strong><u>一次磁盘读/写需要的时间</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-42-43.png" alt=""></p><p><strong>寻找时间 (寻道时间)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">T_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 在读/写数据前，将磁头移动到指定磁道所花的时间。</p><ol><li><strong>启动磁头臂</strong>是需要时间的。假设耗时为s;</li><li><strong>移动磁头</strong>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越n条磁道。则:<br><strong>寻道时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">T_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= s + m*n</strong></li></ol><p><strong>延迟时间</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。: 通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r (单位:转/秒，或转/分)，则：<br><strong>平均所需的延迟时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = (1/2)*(1/r) = 1/2r</strong></p><p><strong>传输时间</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的之节数为 N。则:<br><strong>传输时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= (1/r) * (b/N) = b/(rN)</strong><br>【每个磁道要可存 N 字节的数据，因此 b 字节的数据需要 b/N 个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间 1/r】</p><p>总的平均存取时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + 1/2r + b/(rN)</p><p>延迟时间和传输时间与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此<strong>操作系统也无法优化延迟时间和传输时间</strong></p><p>但是操作系统的磁盘调度算法会直接影响<strong>寻道时间</strong></p><hr><ul><li><strong><u>先来先服务算法（FCFS）</u></strong></li></ul><p>根据进程请求访问磁盘的先后顺序进行调度。</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p><p>按照 FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184 号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-56-45.png" alt=""></p><p>磁头总共移动了45+3+19+21+72+70+10+112+146 = 498 个磁道</p><p>响应一个请求平均需要移动 498/9 = 55.3 个磁道(平均寻找长度)</p><p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去。</p><p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。【相当于随机访问了】</p><hr><ul><li><strong><u>最短寻找时间优先 （SSTF）</u></strong></li></ul><p>SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。 (其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_23-01-37.png" alt=""></p><p>磁头总共移动了 (100-18)+(184-18) = 248 个磁道</p><p>响应一个请求平均需要移动 248/9 = 27.5个磁道(平均寻找长度)</p><p>优点：性能较好，平均寻道时间短</p><p>缺点：可能产生“<strong>饥饿</strong>”现象<br>Eg：本例中，如果在处理18号磁道的访问请求时又来了个38号磁道的访问请求，处理38号的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的 18号、38号磁道的访问请求到来的话，150、160、184 号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。<br>【产生饥饿的原因在于：磁头在一个小区域内来回来去地移动】</p><hr><ul><li><strong><u>扫描算法（SCAN）</u></strong></li></ul><p>SSTF 算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。这就是扫描算法 (SCAN) 的<strong>思想</strong>。由于磁头移动的方式很像电梯，因此也叫<strong>电梯算法</strong>。</p><p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头<strong>正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-04-24.png" alt=""></p><p>磁头总共移动了(200-100) +(200-18) = 282 个磁道</p><p>响应一个请求平均需要移动 282/9 =31.3 个磁道(平均寻找长度)</p><p>优点：性能较好，平均寻道时间较短，<strong>不会产生饥饿现象</strong></p><p>缺点：<br>① 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。<br>② SCAN算法对于各个位置磁道的响应频率不平均（如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应 184 号磁道的请求了)</p><hr><ul><li><strong><u>LOOK 调度算法</u></strong></li></ul><p><strong>扫描算法（SCAN）</strong> 中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</p><p><strong>LOOK 调度算法</strong>就是为了解决这个问题，<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。 (边移动边观察，因此叫 LOOK)</p><p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头<strong>正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-12-47.png" alt=""></p><p>磁头总共移动了 (184-100)+(184-18)= 250个磁道</p><p>响应一个请求平均需要移动 250/9 = 27.5个磁道(平均寻找长度)</p><p>优点：比起 SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p><hr><ul><li><strong><u>循环扫描算法（C-SCAN）</u></strong></li></ul><p>SCAN算法对于各个位置磁道的响应频率不平均，而 <strong>C-SAN 算法</strong>就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>。</p><p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且<strong>此时磁头正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-17-25.png" alt=""></p><p>磁头总共移动了(200-100)+(200-) +(90-0)= 390个磁道</p><p>响应一个请求平均需要移动 390/9 = 43.3 个磁道(平均寻找长度)</p><p>优点：比起SCAN 来，对于各个位置磁道的响应频率很平均。</p><hr><ul><li><strong><u>C-LOOK 调度算法</u></strong></li></ul><p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。<strong>C-LOOK 算法</strong>就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且<strong>此时磁头正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-29-49.png" alt=""></p><p>磁头总共移动了 (184-100) +(184-18) +(90-18)= 322 个磁道</p><p>响应一个请求平均需要移动 322/9 =35.8个磁道(平均寻找长度)</p><p>优点：比起 C-SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时问进一步缩短</p><hr><ul><li><strong><u>知识点回顾与重要考点</u></strong></li></ul><p>磁盘调度算法影响的指标：<strong>移动磁头的时间</strong></p><p>若题目中无特别说明,则<br>SCAN 就是 LOOK,<br>C-SCAN 就是C-LOOK</p><hr><h2 id="5-3-3-减少磁盘延迟时间的方法">5.3.3 减少磁盘延迟时间的方法</h2><blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-04-15.png" alt=""></p><p>假设要连续读取橙色区域的 2、3、4扇区：磁头读取一块的内容(也就是一个扇区的内容)后，需要一小段时间处理，而盘片又在不停地旋转</p><p>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区，必须等盘片继续旋转，3号扇区<strong>再次</strong>划过磁头，才能完成扇区读入</p><p><strong>结论</strong>：<strong>磁头读入一个扇区数据后需要一小段时间处理</strong>，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间“</p></blockquote><ul><li><strong><u>减少延迟时间的方法：交替编号</u></strong></li></ul><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-0-49.png" alt=""></p><hr><ul><li><strong><u>磁盘地址结构设计</u></strong></li></ul><p>思考：为什么磁盘的物理地址是(柱面号，盘面号，扇区号)，而不是 (盘面号，柱面号，扇区号)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-11-29.png" alt=""></p><p>假设某磁盘有8个柱面/磁道(假设最内侧柱面/磁道号为0)，4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p><ul><li><p><strong>若物理地址结构是(盘面号，柱面号，扇区号)</strong> ，且需要连续读取物理地址 (00,000,000) ~ (00,001,111)的扇区:</p><p>(00,000,000) ~ (00,000,111) 转两圈可读完</p><p>之后再读取物理地址相邻的区域，即(00,001,000) ~ (00,001,111)，<strong>需要启动磁头臂</strong>，<strong>将磁头移动到下一个磁道</strong></p></li><li><p><strong>若物理地址结构是(柱面号，盘面号，扇区号)</strong> ，且需要连续读取物理地址 (000,00,000) ~ (000,01,111)的扇区:</p><p>(000,00,000) ~ (000,00,111) 由盘面0的磁头读入数据</p><p>之后再读取物理地址相邻的区域，即(000,01,000) ~ (000,01,111)，<strong>由于柱面号/磁道号相同只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</strong></p></li></ul><p>所以：答：读取地址连续的磁盘块时，采用(柱面号,盘面号，扇区号) 的地址结构<strong>可以减少磁头移动消耗的时间</strong>【可能考选择题】</p><hr><ul><li><strong><u>减少延迟时间的方法：错位命名</u></strong></li></ul><p>注意，所有盘面都是一起连轴转的</p><p><strong>方案一</strong>：若相邻的盘面相对位置相同处扇区编号相同</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-24-31.png" alt=""></p><p>读取完磁盘块 (000, 00, 111) 之后，需要短暂的时间处理，而盘面又在不停地转动，因此当(000, 01, 000)第一次划过磁头下方时读取数据，只能再等该扇区再次划过磁头</p><p><strong>方案二</strong>：<strong>错位命名</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-33-08.png" alt=""></p><p>由于采用错位命名法，因此读取完磁盘块(000, 00,111) 之后，还有一段时间处理，当 (000, 01,000)第一次划过1号盘面的磁头下方时，就可以直接读取数据，减少了延迟时间</p><hr><h2 id="5-3-4-磁盘的管理">5.3.4 磁盘的管理</h2><ul><li><strong><u>磁盘初始化</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-12.png" alt=""></p><p><strong>Step 1</strong>：进行<strong>低级格式化(物理格式化)</strong> 【出厂之前】，将磁盘的各个磁道<strong>划分为扇区</strong>。一个扇区通常可分为 头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码(如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-23.png" alt=""></p><p><strong>Step 2</strong>：将磁盘分区，每个分区由若干柱面组成(即分为我们熟悉的 C盘、D盘、E盘)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-17.png" alt=""></p><p><strong>Step 3</strong>：进行<strong>逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如位示图、空闲分区表)</p><hr><ul><li><strong><u>引导块</u></strong></li></ul><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<strong>初始化程序</strong> (<strong>自举程序</strong>) 完成的</p><p>初始化程序可以放在<strong>ROM</strong> (<strong>只读存储器</strong>) 中。ROM中的数据在出厂时就写入了，并且<strong>以后不能再修改</strong></p><p>注：ROM一般是出厂时就集成在主板上的</p><p>初始化程序程序(自举程序) 放在ROM中存在什么问题?<br>万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p><p>解决：ROM中只存放很小的“自举装入程序”；<br>完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置；<br>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化。</p><p>拥有启动分区的磁盘称为<strong>启动磁盘或系统磁盘(C:盘)</strong></p><hr><ul><li><strong><u>坏块的管理</u></strong></li></ul><p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它</p><p>对于简单的磁盘，可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在 FAT 表上标明。 (在这种方式中，<strong>坏块对操作系统不透明</strong>)</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br>在磁盘出厂前进行低级格式化(物理格式化)时就将坏块链进行初始化。<br>会保留一些“备用扇区“，用于替换坏块。这种方案称为<strong>扇区备用</strong>。且这种处理方式中，<strong>坏块对操作系统透明</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-50-59.png" alt=""></p><hr><h2 id="5-3-5-固态硬盘SSD">5.3.5 固态硬盘SSD</h2><blockquote><p>计组，操作系统考研大纲<strong>新考点</strong></p><p>操作系统：<br>固态硬盘；读写性能特性，磨损均衡</p><p>计算机组成原理：固态硬盘(SSD)</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-39-25.png" alt=""></p><hr><ul><li><strong><u>机械硬盘 vs 固态硬盘</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-40-55.png" alt=""></p><hr><ul><li><strong><u>固态硬盘的结构</u></strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-47-12.png" alt=""></p><p>每个闪存芯片由若干块组成，比如块大小:16KB~512KB</p><p>每个块再拆解为一个一个页，比如页大小，512B~4KB</p><p>系统读写以 页 为单位，磁盘中则是块（扇区），这里作区分</p><hr><ul><li><strong><u>理想情况下，固态硬盘的寿命</u></strong></li></ul><p>某固态硬盘采用磨损均衡技术，大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span></span></span></span>B=1TB，闪存块的擦写寿命只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>=1K次。某男子平均每天会对该固态硬盘写<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>37</mn></msup></mrow><annotation encoding="application/x-tex">2^{37}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">37</span></span></span></span></span></span></span></span></span></span></span></span>B=128GB数据。在最理想的情况下，这个固态硬盘可以用多久?</p><p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。</p><p>1TB/128GB =8<br>因此，平均每8天，每个闪存块需要擦除一次。每个闪存块可以被擦除1K次，因此，经过8K天，约23年后，该固态硬盘被男子玩坏</p><p>所以没那么容易坏</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树学习笔记</title>
      <link href="/2023/04/12/%E4%BA%8C%E5%8F%89%E6%A0%91x/"/>
      <url>/2023/04/12/%E4%BA%8C%E5%8F%89%E6%A0%91x/</url>
      
        <content type="html"><![CDATA[<h1>二叉树</h1><p>内容来源于<a href="https://www.programmercarl.com/">代码随想录</a></p><h2 id="二叉树的递归遍历">二叉树的递归遍历</h2><h3 id="递归推理的三个思考点">递归推理的三个思考点</h3><ul><li>确定递归的参数和返回值：哪些参数是递归过程需要考虑的</li><li>确定终止条件：操作系统使用一个栈结构来保存每一层递归的信息</li><li>确定单层递归的逻辑</li></ul><p>二叉树的深度搜索三个方法：前序、中序、后序就是使用递归遍历：</p><p>首先是二叉树的创建：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" alt=""></p><p>输入样例：1 5 8 0 0 0 6 0 0</p><p>这个采用的是先根遍历的方式创建的：首先读入根节点，然后一路向左创建新的节点，再向左搜索直至没有左节点，接着回溯至上一根节点寻找右节点，若无结束当层节点的递归，再返回上一个节点。这边要特别注意记得返回的是当前节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t = (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">t-&gt;val = num;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;, t-&gt;val);</span></span><br><span class="line">t-&gt;left = create_tree(t-&gt;left);</span><br><span class="line">t-&gt;right = create_tree(t-&gt;right); </span><br><span class="line">&#125;<span class="keyword">return</span> t;</span><br></pre></td></tr></table></figure><p><code>return t</code> 特别注意</p><p>接下来就是根据先根中跟后跟的口诀来依次递归：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> * <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>* <span class="title">root</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> treenode * <span class="title function_">create</span><span class="params">(<span class="keyword">struct</span> treenode * root)</span>&#123;</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> * <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d)!= EOF)&#123;</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">node = (<span class="keyword">struct</span> treenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> treenode));</span><br><span class="line">node-&gt;data = d;</span><br><span class="line">node-&gt;left = create(node-&gt;left);</span><br><span class="line">node-&gt;right = create(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_first</span><span class="params">(<span class="keyword">struct</span> treenode *node)</span>&#123;<span class="comment">//先根</span></span><br><span class="line">       <span class="keyword">if</span>(node == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">   travel_first(node-&gt;left);</span><br><span class="line">   travel_first(node-&gt;right);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_second</span><span class="params">(<span class="keyword">struct</span> treenode *node)</span>&#123;<span class="comment">//中跟</span></span><br><span class="line">       <span class="keyword">if</span>(node ==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">   travel_second(node-&gt;left);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">   travel_second(node-&gt;right);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">travel_third</span><span class="params">(<span class="keyword">struct</span> treenode *node)</span>&#123;<span class="comment">//后根</span></span><br><span class="line">       <span class="keyword">if</span>(node ==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">   travel_third(node-&gt;left);</span><br><span class="line">   </span><br><span class="line">   travel_third(node-&gt;right);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>* <span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">     r = create(r);</span><br><span class="line">     travel_first(r);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     travel_second(r);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     travel_third(r);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的非递归遍历">二叉树的非递归遍历</h2><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为了方便说明，先附上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel_first</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">stack</span>[100];</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = r;</span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">tmp</span>;</span></span><br><span class="line">    tmp = <span class="built_in">stack</span>[top];</span><br><span class="line">    <span class="built_in">stack</span>[top]=<span class="literal">NULL</span>;</span><br><span class="line">    top--;</span><br><span class="line">    result[++toper] = tmp-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)<span class="built_in">stack</span>[++top] = tmp-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)<span class="built_in">stack</span>[++top] = tmp-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先建立一个树节点的临时栈，将根节点压入栈中，然后再将值压入结果栈中，再先压右子树进入栈中，后压左子树（这点非常的重要），再打印result数组。</p><p>强调：临时栈弹出后一定要清空！然后打印数组时一定要打印到top指向的位置而不是前一位！</p><p>后根遍历改变压栈顺序先左后右然后逆序输出result数组即可，这边不再强调。</p><ul><li><strong>中根遍历</strong></li></ul><ol><li><strong>处理：将元素放进result数组中</strong></li><li><strong>访问：遍历节点</strong></li></ol><p>这个时候需要一个指针用来存储临时遍历的节点，直至遍历到左子树最下面的一个叶子节点：我们常常把对根节点的处理作为递归出口，然后使用临时栈来判断循环条件。</p><p>这边要特别注意不能直接将临时栈中的数据直接取出来存入结果数组中，因为这样子树的链表连接就直接断开了，在这一步和上面相同的是要更新这个临时节点指向的数据，将其更新为栈顶元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel_first</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">stack</span>[100];</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">temp</span> =</span> r;</span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">0</span>||temp != <span class="literal">NULL</span>)&#123;<span class="comment">//根节点为空、栈为空 </span></span><br><span class="line">       <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;<span class="comment">//temp代表的是一路向左的指针，有可能本身为空，不要写成temp-&gt;left </span></span><br><span class="line">       <span class="built_in">stack</span>[++top] = temp;</span><br><span class="line">       temp = temp-&gt;left;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;<span class="comment">//这个地方特别注意这个节点的传递</span></span><br><span class="line">   temp = <span class="built_in">stack</span>[top]; </span><br><span class="line">   <span class="built_in">stack</span>[top] = <span class="literal">NULL</span>;</span><br><span class="line">     top--;</span><br><span class="line">     result[++toper] = temp-&gt;val;</span><br><span class="line">     temp = temp-&gt;right;</span><br><span class="line">   &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一迭代法">统一迭代法</h3><p>统一迭代法使用一个空指针作为标记，用以区分访问过的节点和决定弹出的顺序；根后面跟着一个空指针，然后压入顺序记得颠倒：</p><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel_first</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">stack</span>[100];</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = root;<span class="comment">//将根节点放入栈中，不放会是空栈，死循环 </span></span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">0</span>)&#123;<span class="comment">//根节点为空、栈为空 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">temp</span> =</span> <span class="built_in">stack</span>[top];<span class="comment">//统一迭代法中的临时节点实际上是指针，谁访问的节点由谁决定 </span></span><br><span class="line">       <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;<span class="comment">//temp不为空的时候代表一种标记，不必弹栈</span></span><br><span class="line">        <span class="built_in">stack</span>[top] = <span class="literal">NULL</span>;</span><br><span class="line">        top--;<span class="comment">//弹栈</span></span><br><span class="line"><span class="keyword">if</span>(temp-&gt;right != <span class="literal">NULL</span>)<span class="built_in">stack</span>[++top] = temp-&gt;right;</span><br><span class="line"><span class="built_in">stack</span>[++top] = temp; </span><br><span class="line">       <span class="built_in">stack</span>[++top] = <span class="literal">NULL</span>;<span class="comment">//根节点后做标记</span></span><br><span class="line">       <span class="keyword">if</span>(temp-&gt;left != <span class="literal">NULL</span>)<span class="built_in">stack</span>[++top] = temp-&gt;left;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;<span class="comment">//遇到NULL则弹栈</span></span><br><span class="line">   top--;<span class="comment">//开始弹出节点</span></span><br><span class="line">   temp = <span class="built_in">stack</span>[top]; </span><br><span class="line">   <span class="built_in">stack</span>[top] = <span class="literal">NULL</span>;</span><br><span class="line">     top--;</span><br><span class="line">     result[++toper] = temp-&gt;val;</span><br><span class="line">   &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序和后序改变两个if语句的顺序即可。</p><h2 id="二叉树的层序遍历">二叉树的层序遍历</h2><h3 id="广度优先搜索">广度优先搜索</h3><p>利用辅助队列，每层节点按顺序进入队列，接着分别判断左右节点是否为空，若不为空则分别进入队列，再按顺序依次弹出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leverOrder</span><span class="params">(<span class="keyword">struct</span> node * r)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">queue</span>[100];</span></span><br><span class="line"><span class="type">int</span> front= <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(r != <span class="literal">NULL</span>)<span class="built_in">queue</span>[++rear] = r;</span><br><span class="line"><span class="comment">//front = rear;</span></span><br><span class="line"><span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line"><span class="type">int</span> size = rear-front;<span class="comment">//size实际上是每层节点的数目 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">tmp</span> =</span> <span class="built_in">queue</span>[front+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//这边要注意出队的时候我们记录的是front+1 </span></span><br><span class="line">result[++toper] = tmp-&gt;val;</span><br><span class="line">            front++;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)<span class="built_in">queue</span>[++rear] = tmp-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)<span class="built_in">queue</span>[++rear] = tmp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="二叉树的深度-max-min">二叉树的深度(max,min)</h2><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），<u>使用<strong>前序</strong>求的就是<strong>深度</strong>，使用<strong>后序</strong>求的是<strong>高度</strong>。</u></p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数</li></ul><p>注意：使用递归求取最大深度，（后序遍历）分别对左子树和右子树求，然后再返回左右子树中深度最大的。不可直接返回左右子树求出来的那个值：原因不详。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">depth</span><span class="params">(<span class="keyword">struct</span> node * r)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> leftdepth = depth(r-&gt;left);</span><br><span class="line"><span class="type">int</span> rightdepth = depth(r-&gt;right);</span><br><span class="line"><span class="type">int</span> max = leftdepth &gt; rightdepth ?leftdepth:rightdepth;</span><br><span class="line"><span class="keyword">return</span> max+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有两种解决办法：通过先序遍历来求解深度（回溯）以及通过层次遍历来求解：层次遍历思路较为简单，详情参见上面层次遍历的模板，在计算每层节点数时顺便让深度depth+1即可。</p><p>先度遍历：先检测根节点，再监测左子树，不为空就加一，回溯到底则让深度把借过来的一还回去，接着再求解最大值，此处先暂时省略（我有时间一定敲）QAQ</p><h2 id="二叉树的高度（平衡二叉树判断）">二叉树的高度（平衡二叉树判断）</h2><p>本题采用后序遍历，仍然是采用递归的三个思想，应该传入什么参数（我个人觉得刷到现在都是传入根的节点）</p><p>1.明确递归函数的参数和返回值</p><p>参数：当前传入节点。<br>返回值：以当前传入节点为根节点的树的高度。</p><p>2.明确终止条件</p><p>递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0</p><p>3.明确单层递归逻辑</p><p>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_height</span><span class="params">(<span class="keyword">struct</span> node * r)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> leftheight = get_height(r-&gt;left);<span class="comment">//这边不需要判断该节点的左子树 是否为空 </span></span><br><span class="line"><span class="keyword">if</span>(leftheight == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> rightheight = get_height(r-&gt;right);</span><br><span class="line"><span class="keyword">if</span>(rightheight == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(leftheight-rightheight) &gt;<span class="number">1</span>? <span class="number">-1</span>:<span class="number">1</span>+max(leftheight,rightheight);<span class="comment">//这个语句的语法最好还是记一下挺常见的 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的所有路径">二叉树的所有路径</h2><p>dfs+回溯（本题我并没有看懂这个网站的解法，所以自己思考加上参考别人的思路最终敲出来的代码）</p><p>注意：1.本题真正的终止条件是访问到的节点是个叶子节点，在这个时候递归与回溯是配套的，所以我们要使用一个配套的存储数组stack，来<strong>暂时保存该条路径所有访问过的节点</strong>。</p><p>​           2.本题第二个麻烦的是输出路径必然为char数组，鉴于动态分配我实在是没学会，我就还是选择将数组开大一点然后一次存储路径。</p><p>​           3.本题采用的是先根序列的方式，前面我们提到一般求深度的时候首选先根，所有路径的起点均为根，所以我们还是选择了先根序列。</p><p>​           4.单层递归思路，往左一直走，走到没有路了将这条路记录给stack，这边要注意的是stack是个int 整型而我们需要一个临时字符串数组来存储，这边借助了别人的方法来使用sprintf函数，值得一提的是，它的头文件正是<code>include&lt;stdio.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[<span class="number">1001</span>];<span class="comment">//存储单条路径访问过的节点 </span></span><br><span class="line"><span class="type">int</span> top;    </span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="keyword">struct</span> node* root,<span class="type">char</span> result[][<span class="number">101</span>],<span class="type">int</span>* <span class="built_in">stack</span>, <span class="type">int</span> top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">101</span>];<span class="comment">//tmp最终记录当前叶子节点对应得路径 </span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++) <span class="comment">//将栈中所有暂存的点全部输出出来 </span></span><br><span class="line">        &#123;<span class="comment">//按照顺序输出节点 </span></span><br><span class="line">            len += <span class="built_in">sprintf</span>(tmp + len, <span class="string">&quot;%d-&gt;&quot;</span>, <span class="built_in">stack</span>[i]);<span class="comment">//sprintf返回的是该字符串的长度，len是这个路径字符串的长度，</span></span><br><span class="line"><span class="comment">//tmp是字符串的指针，要向后移动多少长度才能把stack中包括箭头加入进来 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp + len, <span class="string">&quot;%d&quot;</span>, root-&gt;val);<span class="comment">//记得加入最后一个节点 </span></span><br><span class="line">        <span class="built_in">strcpy</span>(result[count++],tmp);  <span class="comment">// 把路径加入到答案中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>[top++] = root-&gt;val;  <span class="comment">// 当前节点不是叶子节点，继续递归遍历</span></span><br><span class="line">        dfs(root-&gt;left, result, <span class="built_in">stack</span>, top);</span><br><span class="line">        dfs(root-&gt;right, result, <span class="built_in">stack</span>, top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>for(int i = 0;i &lt; count;i++)printf(&quot;%s\n&quot;, result[i]);</code></p><h2 id="二叉树的路径和">二叉树的路径和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>这道题还是常规的回溯，但是它是依次减去根节点的数值，从而来判断是否符合给出的目标值。</p><p>注意：本题给出的解答并未将根节点的数值进行录入，如果考虑输入输出情况需要在主函数中判断根节点是否为空，如果不为空将目标值减去根节点的数值然后再进行求解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sum_tree</span><span class="params">(<span class="keyword">struct</span> node *r, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r-&gt;left == <span class="literal">NULL</span> &amp;&amp; r-&gt;right == <span class="literal">NULL</span> &amp;&amp; target == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//符合路径和 </span></span><br><span class="line"><span class="keyword">if</span>(r-&gt;left == <span class="literal">NULL</span> &amp;&amp; r-&gt;right == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//遇到叶子节点直接返回 </span></span><br><span class="line"><span class="keyword">if</span>(r-&gt;left)&#123;</span><br><span class="line">target -= r-&gt;left-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(sum_tree(r-&gt;left,target))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">target+=r-&gt;left-&gt;val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r-&gt;right)&#123;</span><br><span class="line">target -= r-&gt;right-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(sum_tree(r-&gt;right,target))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">target += r-&gt;right-&gt;val; <span class="comment">//记得每次回溯要加回去，才能去检测下一条路径 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所有路径走完均没有找到符合条件的值，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树线索化">二叉树线索化</h2><p>介个是我们老师课内拓展的内容–为了强化记忆我特意还原了老师pdf内的算法。首先结构体内会多出两部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> Lthread;</span><br><span class="line"><span class="type">int</span> Rthread;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230129_214705.jpg" alt=""></p><p>先描述如何将一个二叉树线索化：首先它的基本思路就是中序遍历：在中序遍历的基础上进行修改。访问完左子树后，对左子树进行判断，为空进行线索化，此时我们需要借助一个父节点用来实时更新左子树指向的位置。同理对于右子树，我们利用了pre这一节点来进行判断是否需要线索化，当满足pre不为空且右子树为空（这边一开始错了改了半个点QAQ）从而来实现线索化，最后尤其注意更新pre的位置，将其变化为下一个节点，再递归进行右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">travel_second</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">travel_second(r-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(r-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">r-&gt;Lthread = <span class="number">1</span>;</span><br><span class="line">r-&gt;left = pre;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> r-&gt;Lthread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>)&#123;<span class="comment">//</span></span><br><span class="line">    pre-&gt;Rthread = <span class="number">1</span>;</span><br><span class="line">    pre-&gt;right = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre != <span class="literal">NULL</span>)pre-&gt;Rthread = <span class="number">0</span>;</span><br><span class="line">pre = r;</span><br><span class="line">travel_second(r-&gt;right);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来关于中序线索二叉树的遍历，我主要描述利用找首个节点和下一节点的方法，对于找最后节点和前一节点，将左子树改为右子树即可，不再详细赘述。</p><p>首个节点：一路向左，直至没有左子树返回</p><p>下个节点：当Rthread=1时，意味着它的右指针指向下个节点，直接返回</p><p>​                    否则，则返回它右子树的第一个节点。</p><p>那么利用上述两个函数，我们最终写出了遍历的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node* <span class="title function_">first_order</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(r-&gt;Lthread == <span class="number">0</span>)&#123;</span><br><span class="line">r = r-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> node* <span class="title function_">next_order</span><span class="params">(<span class="keyword">struct</span> node *t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;Rthread ==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> t-&gt;right;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,t-&gt;right-&gt;val);</span></span><br><span class="line"><span class="keyword">return</span> first_order(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(<span class="keyword">struct</span> node *r)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">tmp</span> =</span> r;</span><br><span class="line">tmp = first_order(r);</span><br><span class="line"><span class="keyword">while</span>(tmp!= <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp-&gt;val);</span><br><span class="line">tmp = next_order(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的公共祖先">二叉树的公共祖先</h2><p><strong>归纳三点</strong>：</p><ol><li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，<strong>依然要把其他节点遍历完</strong>，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果</li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230130_221716.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//根节点为空直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(root==p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span> =</span>lowestCommonAncestor (root-&gt;left,p,q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">NULL</span>)<span class="keyword">return</span> right;<span class="comment">//可以看上图中2和4，</span></span><br><span class="line">    <span class="comment">//在5这一层递归时left == NULL,于是在右侧查找，找到2时返回right,而这个时候返回的值为3这一层的左值</span></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">NULL</span>)<span class="keyword">return</span> left;<span class="comment">//同理可得</span></span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//左右子树同时不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树">二叉搜索树</h2><p>概念：二叉查找树中任一结点P，其左子树中结点的关键词都小于P的关键词，右子树中结点的关键词都大于P的关键词，且结点P左右子树也都是二叉查找树。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230131_102811.jpg" alt=""></p><h3 id="查找算法：">查找算法：</h3><p>要强调的就是返回值的问题，如果发现不需要记录沿途的路径值，就直接返回它查找得到的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">searchBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> root;<span class="comment">//这个地方要返回的是root，而不是NULL会出现野指针</span></span><br><span class="line">         <span class="keyword">if</span>(root-&gt;val == val)<span class="keyword">return</span> root;</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;val &gt; val)<span class="keyword">return</span> searchBST(root-&gt;left,val);</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;val &lt; val)<span class="keyword">return</span> searchBST(root-&gt;right,val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入算法：">插入算法：</h3><p>一个是递归终点的判断错误，不是找到叶子节点就结束，而是找到叶子结点下一位并对此新分配新的空间。</p><p>还有就是递归返回的判断错误：这边是要返回当前节点左子树和右子树的位置，也没有判断正确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">insertIntoBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">tmp</span> =</span>(<span class="keyword">struct</span> TreeNode* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">             tmp-&gt;val = val;</span><br><span class="line">             tmp-&gt;left = tmp-&gt;right = <span class="literal">NULL</span>;<span class="comment">//没有对左右指针赋值会出现问题在力扣</span></span><br><span class="line">             <span class="keyword">return</span> tmp;<span class="comment">//回溯，层层上交</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">             root-&gt;right =  insertIntoBST(root-&gt;right, val);<span class="comment">//只有让root的位置一直在才能回溯</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;val)</span><br><span class="line">             root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除算法：">删除算法：</h3><p>删除算法整体逻辑不变，就是找到后记得分五种情况处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> root;<span class="comment">//大框架还是找到了，比它大比它小</span></span><br><span class="line">          <span class="keyword">if</span>(root-&gt;val == key)&#123;<span class="comment">//这里是在找到这个节点下要删除的四种情况</span></span><br><span class="line">              <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)<span class="keyword">return</span> root-&gt;right;</span><br><span class="line">              <span class="comment">//左子树为空，右子树可空可不空，直接返回右子树</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)<span class="keyword">return</span> root-&gt;left;<span class="comment">//右子树为空返回左子树</span></span><br><span class="line">              <span class="keyword">else</span>&#123;<span class="comment">//最复杂的是左右子树都不为空，这个时候我们要先找到这个点右子树最小的点，就是最左边</span></span><br><span class="line">              <span class="comment">//然后将根的左子树变为这个点的左子树</span></span><br><span class="line">              <span class="comment">//临时记录根的位置，然后让根删除</span></span><br><span class="line">                  <span class="keyword">struct</span> TreeNode * cur = root-&gt;right;</span><br><span class="line">                  <span class="keyword">while</span>(cur-&gt;left != <span class="literal">NULL</span>) cur = cur-&gt;left;</span><br><span class="line">                  cur-&gt;left = root-&gt;left;</span><br><span class="line">                  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">tmp</span> =</span> root;</span><br><span class="line">                root = root-&gt;right;<span class="comment">//此时这个已经失去左子树，只剩右子树，让右子树的根覆盖它即可</span></span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录刷题代码</title>
      <link href="/2023/04/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
      <url>/2023/04/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>【<a href="https://www.programmercarl.com/">代码随想录</a>】</p><h1>一、数组</h1><h2 id="704-二分查找">704.二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> center = <span class="number">0</span>;    <span class="comment">// 二分位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            center = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[center] == target) <span class="keyword">return</span> center;</span><br><span class="line">            <span class="keyword">if</span> (nums[center] &gt; target) right = center - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[center] &lt; target) left = center + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --查找失败--</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)<br>分析：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>=</mo><mi>n</mi><mo>→</mo><mi>x</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>→</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^x = n \to x = log_2n\to O(log\,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：O(1)<br>？怎么分析的</li></ul><h2 id="27-移除元素">27.移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><p><strong>1、暴力解法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nowLength = nums.<span class="built_in">size</span>();  <span class="comment">// 记录现在长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nowLength; i++) &#123;</span><br><span class="line">            <span class="comment">// --逐个查找--</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="comment">// --删除元素--</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nowLength - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// --改变上界--</span></span><br><span class="line">                nowLength--;</span><br><span class="line">                <span class="comment">// --由于数组左移，所以再次查看当前位置--</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --返回删除后的长度--</span></span><br><span class="line">        <span class="keyword">return</span> nowLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><p><strong>2、快慢指针</strong>：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();  <span class="comment">// 执行一次</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// --看n次，值为val的舍弃（即需要值不为val的选出来放到新位置（slow）上）--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; len; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="977-有序数组的平方">977.有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>1、平方后排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --快排--</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)</p><p><strong>2、双指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// --长度为len，初值为0--</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt = len;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="comment">// --前进左边--</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[--cnt] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --前进右边--</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[--cnt] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><h2 id="209-长度最小的子数组">209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>快慢指针</strong>（滑动窗口）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;     </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;    <span class="comment">// 总和</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt;= len; fast++) &#123;</span><br><span class="line">            <span class="comment">// --和小于target，加上右边--</span></span><br><span class="line">            <span class="keyword">if</span> (fast &lt; len &amp;&amp; sum &lt; target) &#123;</span><br><span class="line">                sum += nums[fast];</span><br><span class="line">                <span class="comment">// printf(&quot;[sum:%d slow:%d, fast:%d, ans=%d]\n&quot;, sum, slow, fast, ans);</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --和大于等于target，最小值更新；减去左边，slow向前移动，fast暂时不动--</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                ans = (fast - slow) &lt; ans ? (fast - slow) : ans;</span><br><span class="line">                sum -= nums[slow++];</span><br><span class="line">                fast--;</span><br><span class="line">                <span class="comment">// printf(&quot;[sum:%d slow:%d, fast:%d, ans=%d]\n&quot;, sum, slow, fast, ans);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0x7fffffff</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="59-螺旋矩阵II">59.螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>1、一个一个看，走满就换方向</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;RIGHT, DOWN, LEFT, UP&#125;d;</span><br><span class="line">    <span class="comment">// --是否越界--</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isOver</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> maxX, <span class="type">int</span> maxY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= maxX || y &gt;= maxY) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --转向--</span></span><br><span class="line">    <span class="function">Direction <span class="title">changeDirection</span><span class="params">(Direction d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">            <span class="keyword">case</span> RIGHT: d = DOWN; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:  d = LEFT; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:  d = UP;   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UP:    d = RIGHT;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// n*n，初值为0</span></span><br><span class="line">        d = RIGHT;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++) &#123;</span><br><span class="line">            <span class="comment">// --&#123;延伸&#125;或者&#123;转向 + 暂停一次位置&#125;</span></span><br><span class="line">            <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">                <span class="keyword">case</span> RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isOver</span>(x, y, n, n) &amp;&amp; ans[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans[x][y] = i;</span><br><span class="line">                        y++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = <span class="built_in">changeDirection</span>(d);</span><br><span class="line">                        <span class="comment">// printf(&quot;1(%d,%d,[%d])\n&quot;, x, y, d);</span></span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="comment">// --放到正确的位置上--</span></span><br><span class="line">                        y--; x++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isOver</span>(x, y, n, n) &amp;&amp; ans[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans[x][y] = i;</span><br><span class="line">                        x++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = <span class="built_in">changeDirection</span>(d);</span><br><span class="line">                        <span class="comment">// printf(&quot;2(%d,%d,[%d])\n&quot;, x, y, d);</span></span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="comment">// --放到正确的位置上--</span></span><br><span class="line">                        x--; y--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEFT:</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isOver</span>(x, y, n, n) &amp;&amp; ans[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans[x][y] = i;</span><br><span class="line">                        y--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = <span class="built_in">changeDirection</span>(d);</span><br><span class="line">                        <span class="comment">// printf(&quot;3(%d,%d,[%d])\n&quot;, x, y, d);</span></span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="comment">// --放到正确的位置上--</span></span><br><span class="line">                        y++; x--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isOver</span>(x, y, n, n) &amp;&amp; ans[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans[x][y] = i;</span><br><span class="line">                        x--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = <span class="built_in">changeDirection</span>(d);</span><br><span class="line">                        <span class="comment">// printf(&quot;4(%d,%d,[%d])\n&quot;, x, y, d);</span></span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="comment">// --放到正确的位置上--</span></span><br><span class="line">                        x++; y++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li></ul><p><strong>2、分圈，一圈看四条边<a href="https://www.programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">【代码随想录】</a></strong></p><h1>二、链表</h1><h2 id="203-移除链表元素">203.移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><p><strong>增加哨兵节点</strong>（养成删除内存的习惯）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --初值为空的情况--</span></span><br><span class="line">        <span class="keyword">if</span> (!head)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// --增加一个哨兵节点--</span></span><br><span class="line">        ListNode* head0 = <span class="keyword">new</span> ListNode;</span><br><span class="line">        head0-&gt;next = head;</span><br><span class="line">        ListNode* tmp = head0;</span><br><span class="line">        <span class="comment">// --遍历--</span></span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="comment">// --删除--</span></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;next &amp;&amp; tmp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;   <span class="comment">// 不然会跳判</span></span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head0-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><h2 id="707-设计链表">707.设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><p>遇到tmp-&gt;next，还是判一下tmp吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --单链表--</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">    &#125; *head;</span><br><span class="line">    <span class="comment">// --初始化--</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="comment">// --哨兵节点--</span></span><br><span class="line">        head = <span class="keyword">new</span> ListNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --获取index位置的值，不存在返回-1--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tmp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tmp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --加到开头--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --加到结尾--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;next) tmp = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --加到index位置前--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; tmp) tmp = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span> || !tmp) <span class="keyword">return</span>;</span><br><span class="line">        newNode-&gt;next = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --删除index节点--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode *tmp = head;</span><br><span class="line">        <span class="comment">// --目标为tmp-&gt;next</span></span><br><span class="line">        <span class="keyword">while</span> (index-- &amp;&amp; tmp) tmp = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span> || !tmp || !tmp-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *need2Delete = tmp-&gt;next;</span><br><span class="line">        tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> need2Delete;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表">206.反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>1、双指针法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// --一次记录两个节点--</span></span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        ListNode *tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// --第一个先指向空--</span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            <span class="comment">// --改为：后一个指向前一个--</span></span><br><span class="line">            tmp = fast-&gt;next;</span><br><span class="line">            fast-&gt;next = slow;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><p>2、递归法</p><h2 id="24-两两交换链表中的节点">24.两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// --添加一个哨兵节点--</span></span><br><span class="line">        <span class="comment">// --一次记录三个节点--</span></span><br><span class="line">        ListNode *head0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *pre = head0;</span><br><span class="line">        ListNode *key1 = head, *key2 = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// --改变结构--</span></span><br><span class="line">            pre-&gt;next = key2;</span><br><span class="line">            key1-&gt;next = key2-&gt;next;</span><br><span class="line">            key2-&gt;next = key1;</span><br><span class="line">            <span class="comment">// --准备下一次操作--</span></span><br><span class="line">            pre = key1;</span><br><span class="line">            key1 = key1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!key1) <span class="keyword">return</span> head0-&gt;next;</span><br><span class="line">            key2 = key1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!key2) <span class="keyword">return</span> head0-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><h2 id="19-删除链表的倒数第N个节点">19.删除链表的倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><p><strong>1、循环两次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --计数--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --倒数化为正数--</span></span><br><span class="line">        n = <span class="built_in">count</span>(head) - n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// --只有一个的话，n也只能为1了--</span></span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --增加一个哨兵节点--</span></span><br><span class="line">        ListNode *head0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *fast = head0, *slow = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> fast;</span><br><span class="line">        <span class="keyword">return</span> head0-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(2n)</li></ul><p><strong>2、双指针【进阶】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --增加一个哨兵节点--</span></span><br><span class="line">        ListNode *head0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *fast = head0, *slow = head0;</span><br><span class="line">        <span class="comment">// --fast比slow块n个，fast都是有效节点，slow-&gt;next是最后要删除的节点--</span></span><br><span class="line">        <span class="comment">// --fast先前进n次--</span></span><br><span class="line">        <span class="keyword">while</span> (n--) fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">// --fast和slow一起前进，知道fast取到最后一个有效节点--</span></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --删除slow-&gt;next--</span></span><br><span class="line">        ListNode *need2Delete = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> need2Delete;</span><br><span class="line">        <span class="keyword">return</span> head0-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><h2 id="面试题-02-07-链表相交">面试题 02.07. 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>同：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表 - 力扣（Leetcode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --计数--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --传入的值nA &gt;= nB--</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">findAnsNode</span><span class="params">(<span class="type">int</span> nA, <span class="type">int</span> nB, ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --headA先前进nA - nB个--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nA - nB; i++) headA = headA-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB) <span class="keyword">return</span> headA;</span><br><span class="line">        <span class="keyword">while</span> (nB--) &#123;</span><br><span class="line">            <span class="comment">// --走到最后都没有相等--</span></span><br><span class="line">            <span class="keyword">if</span> (!headA-&gt;next || !headB-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// --目标是-&gt;next--</span></span><br><span class="line">            <span class="keyword">if</span> (headA-&gt;next == headB-&gt;next) <span class="keyword">return</span> headA-&gt;next;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nA = <span class="built_in">count</span>(headA), nB = <span class="built_in">count</span>(headB);</span><br><span class="line">        <span class="keyword">if</span> (nA &gt;= nB) <span class="keyword">return</span> <span class="built_in">findAnsNode</span>(nA, nB, headA, headB);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findAnsNode</span>(nB, nA, headB, headA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(n + m)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h2 id="142-环形链表II">142.环形链表II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p><strong>找到相遇点</strong></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210318165123581.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// --slow移动一步， fast移动两步--</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// --相遇了--</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// --x：起始点到环入口的距离--</span></span><br><span class="line">                <span class="comment">// --y：环入口到相遇点的距离--</span></span><br><span class="line">                <span class="comment">// --z：相遇点到环入口的距离--</span></span><br><span class="line">                <span class="comment">// --2(x + y) = x + y + n(y + z)-- </span></span><br><span class="line">                <span class="comment">// --x = n(y + z) - y--</span></span><br><span class="line">                <span class="comment">// --slow从起点开始，fast从相遇点开始--</span></span><br><span class="line">                slow = head; </span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --出现了终点--</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>三、哈希表</h1><h2 id="242-有效的字母异位词">242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">charSet</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>(), nt = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ns; i++) &#123;</span><br><span class="line">            charSet[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123;</span><br><span class="line">            charSet[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charSet[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集">349.两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接</a></p><p>1、哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums1_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : nums2) &#123;</span><br><span class="line">            <span class="comment">// --在nums1中，但是不重复出现--</span></span><br><span class="line">            <span class="keyword">if</span> (nums1_set.<span class="built_in">find</span>(item) != nums1_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、数组做哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 初始化为0</span></span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>(), n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            record[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[nums2[i]]) ans.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="202-快乐数">202.快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接</a></p><p>1、快慢指针 + 递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --计算位平方和--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --递归 + 快慢指针求解--</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> fast, <span class="type">int</span> slow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --fast计算两次，slow计算一次--</span></span><br><span class="line">        fast = <span class="built_in">getSum</span>(<span class="built_in">getSum</span>(fast));</span><br><span class="line">        slow = <span class="built_in">getSum</span>(slow);</span><br><span class="line">        <span class="comment">// --重复出现--</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(fast, slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --计算位平方和--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n, unordered_set&lt;<span class="type">int</span>&gt;&amp; cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(n) != cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt.<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">getSum</span>(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(n, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --哈希表（元素不重复）--</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(n, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和">1.两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="comment">// --查找差是否在map中--</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record.<span class="built_in">find</span>(target - nums[i]) != record.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, record.<span class="built_in">find</span>(target - nums[i])-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --不在则记到map中--</span></span><br><span class="line">            record.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="454-四数相加II">454.四数相加II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>(), n2 = nums2.<span class="built_in">size</span>(), n3 = nums3.<span class="built_in">size</span>(), n4 = nums4.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                map[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l : nums4) &#123;</span><br><span class="line">                <span class="comment">// --在map中--</span></span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(<span class="number">0</span> - k - l) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ans += map[<span class="number">0</span> - k - l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="383-赎金信">383.赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mCnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 记录杂志字母出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : magazine)</span><br><span class="line">            mCnt[i - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : ransomNote) &#123;</span><br><span class="line">            mCnt[i - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// --单词不够了--</span></span><br><span class="line">            <span class="keyword">if</span> (mCnt[i - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和">15.三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><h2 id="18-四数之和">18.四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接</a></p><h1>四、字符串</h1><h2 id="344-反转字符串">344.反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="541-反转字符串II">541.反转字符串II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --修改了344.反转字符串的代码--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();   <span class="comment">// 获取长度</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;      <span class="comment">// 第几2k的起止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="comment">// --判断一下剩余字符--</span></span><br><span class="line">            <span class="type">int</span> left = n - i;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; k) &#123;</span><br><span class="line">                <span class="built_in">reverseString</span>(s, begin, n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; <span class="number">2</span> * k) &#123;</span><br><span class="line">                <span class="built_in">reverseString</span>(s, begin, begin + k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --开始翻转--</span></span><br><span class="line">            <span class="built_in">reverseString</span>(s, begin, begin + k - <span class="number">1</span>);</span><br><span class="line">            begin += <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指Offer-05-替换空格">剑指Offer 05.替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接</a></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --计算空格数--</span></span><br><span class="line">        <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oldSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --扩大数组，加上所有空格的大小（本来就占用一个了）--</span></span><br><span class="line">        s.<span class="built_in">resize</span>(oldSize + cnt *<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> newSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// --slow遍历，fast指向下一个存放的位置--</span></span><br><span class="line">        <span class="type">int</span> slow = oldSize - <span class="number">1</span>, fast = newSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[slow] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[fast--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[fast--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[fast--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s[fast--] = s[slow--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="151-翻转字符串里的单词">151.翻转字符串里的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --修改了344.反转字符串的代码--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --处理多余空格--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;   <span class="comment">// 1；遇到过单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; n; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                s[slow++] = s[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// --前面有单词，加一个空格--</span></span><br><span class="line">                <span class="keyword">if</span> (flag) s[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --最后有一个空格，或者没有--</span></span><br><span class="line">        <span class="keyword">if</span> (s[slow - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) s.<span class="built_in">resize</span>(slow - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --首先将多余空格处理完--</span></span><br><span class="line">        <span class="built_in">processSpaces</span>(s);</span><br><span class="line">        <span class="comment">// --整体翻转--</span></span><br><span class="line">        <span class="built_in">reverseString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// --每个单词进行翻转--</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="comment">// --区间为[begin, end - 1]--</span></span><br><span class="line">            <span class="keyword">if</span> (s[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverseString</span>(s, begin, end - <span class="number">1</span>);</span><br><span class="line">                begin = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --最后一个单词没被翻转，加上--</span></span><br><span class="line">        <span class="built_in">reverseString</span>(s, begin, end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指Offer58-II-左旋转字符串">剑指Offer58-II.左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接</a></p><p>不开辟新的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --修改了344.反转字符串的代码--</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --目的：0 ~ k移动到k + 1 ~ n - 1(这里k = n, n = size)---</span></span><br><span class="line">        <span class="comment">// --先各自翻转，再整体翻转就是答案了--</span></span><br><span class="line">        <span class="built_in">reverseString</span>(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverseString</span>(s, n, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverseString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="28-实现-strStr">28.实现 strStr()</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --获取模式串s的next数组--</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 大小和初值</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// --j + 1指向前缀的末尾，i指向后缀的末尾--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// --不匹配，j回退--</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --匹配，同时前进--</span></span><br><span class="line">            <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">            <span class="comment">// --记录next数组--</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --对于本题可以不写--</span></span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNext</span>(needle);</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// --不匹配，j回退--</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; needle[j + <span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --匹配，前进--</span></span><br><span class="line">            <span class="keyword">if</span> (needle[j + <span class="number">1</span>] == haystack[i]) j++;</span><br><span class="line">            <span class="comment">// --完全匹配，结束--</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="459-重复的子字符串">459.重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --来自28. 实现 strStr()--</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 大小和初值</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// --j + 1指向前缀的末尾，i指向后缀的末尾--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// --不匹配，j回退--</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --匹配，同时前进--</span></span><br><span class="line">            <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">            <span class="comment">// --记录next数组--</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNext</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (next[next.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="number">-1</span> </span><br><span class="line">        &amp;&amp; s.<span class="built_in">size</span>() % (next.<span class="built_in">size</span>() - next[next.<span class="built_in">size</span>() - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>五、双指针法（同上）</h1><h2 id="27-移除元素-2">27.移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><h2 id="344-反转字符串-2">344.反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></p><h2 id="剑指Offer-05-替换空格-2">剑指Offer 05.替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接</a></p><h2 id="151-翻转字符串里的单词-2">151.翻转字符串里的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a></p><h2 id="206-反转链表-2">206.反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><h2 id="24-两两交换链表中的节点-2">24. 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><h2 id="19-删除链表的倒数第N个节点-2">19.删除链表的倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><h2 id="面试题-02-07-链表相交-2">面试题 02.07. 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>同：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表 - 力扣（Leetcode）</a></p><h2 id="142-环形链表II-2">142.环形链表II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p>15.三数之和</p><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><p>18.四数之和</p><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接</a></p><h1>六、栈与队列</h1><h2 id="232-用栈实现队列">232.用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// -- 输入栈、输出栈 --</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stackIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stackOut;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stackIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// -- 输出栈为空，将输入栈的元素全部取出，放入输出栈 --</span></span><br><span class="line">        <span class="keyword">if</span> (stackOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stackOut.<span class="built_in">push</span>(stackIn.<span class="built_in">top</span>());</span><br><span class="line">                stackIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -- 输出栈为空，输入栈为空，报错 --</span></span><br><span class="line">        <span class="keyword">if</span> (stackOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前没有元素\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -- 输出栈不为空，直接输出 --</span></span><br><span class="line">        <span class="type">int</span> res = stackOut.<span class="built_in">top</span>();</span><br><span class="line">        stackOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --使用了自身的函数，但是pop删除了元素，需要恢复--</span></span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        stackOut.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackOut.<span class="built_in">empty</span>() &amp;&amp; stackIn.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈">225.用队列实现栈</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接</a></p><p><strong>1、两个队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --q1作为输入输出栈，q2作为辅助备份栈--</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --q1为空，q2为空，报错--</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">empty</span>()) <span class="built_in">printf</span>(<span class="string">&quot;当前没有元素\n&quot;</span>);</span><br><span class="line">        <span class="comment">// --q1所有元素放到q2，除了最后一个元素--</span></span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --最后一个元素就是栈顶--</span></span><br><span class="line">        <span class="type">int</span> res = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// --q1为空，q2不为空，q2变换为q1，q1变换为q2--</span></span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">empty</span>()) <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// --使用了自身的函数，但是pop删除了元素，需要恢复--</span></span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q1.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>2、一个队列（优化）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --把前n个重新入队，则最后一个变为第一个，删除即可--</span></span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --调用自己的pop，将弹出的添加回去--</span></span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="20-有效的括号">20.有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="comment">// --放入对应的括号，匹配问题变成了相等问题--</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// --1、栈为空--</span></span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// --2、匹配上--</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">top</span>() == s[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// --3、不匹配--</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --4、执行完了，栈不为空--</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项">1047.删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">// 指向栈顶的下一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// --1、栈为空--</span></span><br><span class="line">            <span class="keyword">if</span> (slow == <span class="number">0</span>) &#123;</span><br><span class="line">                s[slow++] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --2、不相同--</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[slow - <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">                s[slow++] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --3、相同--</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值">150.逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --转为整数--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">str2int</span><span class="params">(<span class="type">const</span> string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 1:负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + i - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? <span class="number">0</span> - res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --数字栈, 力扣修改了后台测试数据，需要用longlong--</span></span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (string i : tokens) &#123;</span><br><span class="line">            <span class="comment">// --是数字, 考虑负数--</span></span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span> || i[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; i.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">str2int</span>(i));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d压入栈\n&quot;</span>, <span class="built_in">str2int</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --是符号--</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// --弹出两个操作数，计算--</span></span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> key2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> key1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    tmp = key1 + key2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    tmp = key1 - key2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    tmp = key1 * key2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    tmp = key1 / key2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// --压入计算结果--</span></span><br><span class="line">                st.<span class="built_in">push</span>(tmp);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, key1, i[<span class="number">0</span>], key2, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>七、二叉树</h1><h2 id="递归遍历-迭代遍历">递归遍历/迭代遍历</h2><h3 id="144-二叉树的前序遍历">144.二叉树的前序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">力扣题目链接</a></p><p><strong>1、递归遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *node, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;left, ans);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;right, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">traverse</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、迭代遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *tmp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            st.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历">145.二叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">力扣题目链接</a></p><p><strong>1、递归遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *node, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;left, ans);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;right, ans);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">traverse</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、迭代遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// --修改前序，将顺序变为中右左，最后再翻转就是答案--</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *tmp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            st.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            st.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历">94.二叉树的中序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">力扣题目链接</a></p><p><strong>1、递归遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *node, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;left, ans);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;right, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">traverse</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、迭代遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (root || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(root);</span><br><span class="line">                <span class="comment">// printf(&quot;%d进栈\n&quot;, root-&gt;val);</span></span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root = st.<span class="built_in">top</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// printf(&quot;%d出栈\n&quot;, root-&gt;val);</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="589-N-叉树的前序遍历">589.N 叉树的前序遍历</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);   <span class="comment">// 前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;children[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="590-N-叉树的后序遍历">590.N 叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/submissions/425568531/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;children[i]);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);   <span class="comment">// 后</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="层序遍历">层序遍历</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E6%88%91%E8%A6%81%E6%89%93%E5%8D%81%E4%B8%AA.gif" alt=""></p><h3 id="102-二叉树的层序遍历">102.二叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curAns;     <span class="comment">// 记录当前层答案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                TreeNode *tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                curAns.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层序遍历-II">107.二叉树的层序遍历 II</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/submissions/425573189/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curAns;     <span class="comment">// 记录当前层答案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                TreeNode *tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                curAns.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());    <span class="comment">// 翻转就行了</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="199-二叉树的右视图">199. 二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/submissions/425644101/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> n = que.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// --把每一层的最后一个记录下来后弹出，其他弹出即可--</span></span><br><span class="line">            <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()-&gt;val);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值">637.二叉树的层平均值</h3><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> curSum = <span class="number">0</span>; <span class="comment">// 当前层数的和</span></span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                curSum += que.<span class="built_in">front</span>()-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curSum / size);   <span class="comment">// 写入平均值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="429-N叉树的层序遍历">429.N叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;Node *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curAns;     <span class="comment">// 记录当前层答案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                Node *tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                curAns.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// --压入孩子节点--</span></span><br><span class="line">                <span class="keyword">for</span> (Node* j : tmp-&gt;children) </span><br><span class="line">                    <span class="keyword">if</span> (j) que.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="515-在每个树行中找最大值">515.在每个树行中找最大值</h3><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curMax = INT_MIN; <span class="comment">// 当前层的最大值</span></span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                curMax = curMax &lt; que.<span class="built_in">front</span>()-&gt;val ? que.<span class="built_in">front</span>()-&gt;val : curMax;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curMax);   <span class="comment">// 写入答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="116-填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                Node *tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// --如果是最后一个--</span></span><br><span class="line">                <span class="keyword">if</span> (i == curSize - <span class="number">1</span>) tmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span> tmp-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="117-填充每个节点的下一个右侧节点指针II">117.填充每个节点的下一个右侧节点指针II</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                Node *tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// --如果是最后一个--</span></span><br><span class="line">                <span class="keyword">if</span> (i == curSize - <span class="number">1</span>) tmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span> tmp-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度">104.二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度">111.二叉树的最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="comment">// --是否是叶子节点，是的话后面都没必要执行了--</span></span><br><span class="line">                <span class="keyword">if</span> (!que.<span class="built_in">front</span>()-&gt;left &amp;&amp; !que.<span class="built_in">front</span>()-&gt;right) <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树">226.翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣题目链接</a></p><p><strong>1、递归法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、迭代法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *tmp = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="built_in">swap</span>(tmp-&gt;left, tmp-&gt;right);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right) st.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left) st.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="100-相同的树">100.相同的树</h2><p><a href="https://leetcode.cn/problems/same-tree/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --1. 子树都为空--</span></span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// --2. 子树有一个不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; !q || !p &amp;&amp; q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// --3. 子树都不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == q-&gt;val      <span class="comment">// 自己是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)  <span class="comment">// p左子树和q左子树是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right))  <span class="comment">// p右子树和q右子树是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树">101.对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">preOrdertraverse</span><span class="params">(TreeNode *t1, TreeNode *t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --1. 子树都为空--</span></span><br><span class="line">        <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// --2. 子树有一个不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; !t2 || !t1 &amp;&amp; t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// --3. 子树都不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;val == t2-&gt;val      <span class="comment">// 自己是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">preOrdertraverse</span>(t1-&gt;left, t2-&gt;right)  <span class="comment">// t1左子树和t2右子树是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">preOrdertraverse</span>(t1-&gt;right, t2-&gt;left))  <span class="comment">// t1右子树和t2左子树是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preOrdertraverse</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另一棵树的子树">572.另一棵树的子树</h2><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/description/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --来自 100.相同的树 --</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --1. 子树都为空--</span></span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// --2. 子树有一个不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; !q || !p &amp;&amp; q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// --3. 子树都不为空--</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == q-&gt;val      <span class="comment">// 自己是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)  <span class="comment">// p左子树和q左子树是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right))  <span class="comment">// p右子树和q右子树是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(root, subRoot) </span><br><span class="line">            || <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) </span><br><span class="line">            || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="559-n叉树的最大深度">559.n叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;Node *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="type">int</span> curSize = que.<span class="built_in">size</span>();  <span class="comment">// 当前层有多少个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node* j : que.<span class="built_in">front</span>()-&gt;children)</span><br><span class="line">                    <span class="keyword">if</span> (j) que.<span class="built_in">push</span>(j);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数">222.完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">力扣题目链接</a></p><p><strong>1、当做普通二叉树遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            TreeNode *tmp = st.<span class="built_in">top</span>();   <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right) st.<span class="built_in">push</span>(tmp-&gt;right);    <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left) st.<span class="built_in">push</span>(tmp-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><strong>2、完全二叉树</strong></p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。<br>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。<br>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> lenLeft = <span class="number">0</span>, lenRight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// --统计左边深度--</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            lenLeft++;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --统计右边深度--</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            lenRight++;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --左边深度 等于 右边深度，说明这里完全二叉树是满二叉树--</span></span><br><span class="line">        <span class="keyword">if</span> (lenLeft == lenRight) <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; lenLeft) - <span class="number">1</span>;   <span class="comment">// 右移相当于*2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n × log n)</li><li>空间复杂度：O(log n)</li></ul><h2 id="110-平衡二叉树">110.平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --返回深度--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">postOrderTravese</span><span class="params">(TreeNode *t, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> depth - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lenLeft = <span class="built_in">postOrderTravese</span>(t-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lenRight = <span class="built_in">postOrderTravese</span>(t-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(lenLeft - lenRight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="built_in">max</span>(lenLeft, lenRight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">postOrderTravese</span>(root, <span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径">257.二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode *t, string s, vector&lt;string&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --是叶子节点--</span></span><br><span class="line">        <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// --左子树不为空--</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) <span class="built_in">postOrderTraverse</span>(t-&gt;left, s + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(t-&gt;left-&gt;val), ans);</span><br><span class="line">            <span class="comment">// --右子树不为空--</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) <span class="built_in">postOrderTraverse</span>(t-&gt;right, s + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(t-&gt;right-&gt;val), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">postOrderTraverse</span>(root, <span class="built_in">to_string</span>(root-&gt;val), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="404-左叶子之和">404.左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                    <span class="comment">// --是左子树，判断是否是叶子结点--</span></span><br><span class="line">                    <span class="keyword">if</span> (!que.<span class="built_in">front</span>()-&gt;left-&gt;left &amp;&amp; !que.<span class="built_in">front</span>()-&gt;left-&gt;right)</span><br><span class="line">                        ans += que.<span class="built_in">front</span>()-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值">513.找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// --更新为这一层的第一个即可--</span></span><br><span class="line">            ans = que.<span class="built_in">front</span>()-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;left) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">front</span>()-&gt;right) que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="112-路径总和">112.路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode *t, <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        curSum += t-&gt;val;</span><br><span class="line">        <span class="comment">// --是叶子节点并且，curSum 为目标值</span></span><br><span class="line">        <span class="keyword">if</span> (curSum == targetSum &amp;&amp; !t-&gt;left &amp;&amp; !t-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(t-&gt;left, targetSum, curSum) </span><br><span class="line">            || <span class="built_in">traverse</span>(t-&gt;right, targetSum, curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树">106.从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --返回key的索引--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRoot</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> key, <span class="type">int</span> inbegin, <span class="type">int</span> inend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = inbegin; i &lt;= inend; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == key) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">preOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inbegin, <span class="type">int</span> inend, </span></span></span><br><span class="line"><span class="params"><span class="function">                vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> postbegin, <span class="type">int</span> postend)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;[%d, %d], [%d, %d]\n&quot;, inbegin, inend, postbegin, postend);</span></span><br><span class="line">        <span class="comment">// --没有节点了--</span></span><br><span class="line">        <span class="keyword">if</span> (inbegin &gt; inend) <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="comment">// --在中根序中找到根节点--</span></span><br><span class="line">        <span class="type">int</span> inRoot = <span class="built_in">findRoot</span>(inorder, postorder[postend], inbegin, inend);</span><br><span class="line">        <span class="comment">// --构造节点，改变区间接着递归--</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postend], <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">preOrder</span>(inorder, inbegin, inRoot - <span class="number">1</span>, postorder, postbegin, postbegin + (inRoot - <span class="number">1</span> - inbegin)),    <span class="comment">// 左子树</span></span><br><span class="line">        <span class="built_in">preOrder</span>(inorder, inRoot + <span class="number">1</span>, inend, postorder, postend - <span class="number">1</span> - (inend - inRoot - <span class="number">1</span>) ,postend - <span class="number">1</span>));   <span class="comment">// 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preOrder</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="654-最大二叉树">654.最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">力扣题目地址</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --返回最大值的索引--</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRoot</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxVal = INT_MIN, index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) </span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> indexRoot = <span class="built_in">findRoot</span>(nums, begin, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[indexRoot],    <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">construct</span>(nums, begin, indexRoot - <span class="number">1</span>),  <span class="comment">// 左子树</span></span><br><span class="line">        <span class="built_in">construct</span>(nums, indexRoot + <span class="number">1</span>, end));   <span class="comment">// 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">construct</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树">617.合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --1、两个都为空--</span></span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// --2、有一个为空--</span></span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; root2) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root1 &amp;&amp; !root2) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="comment">// --3、都不为空--</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索">700.二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">力扣题目地址</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// --本节点是--</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        TreeNode *left = <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树">98.验证二叉搜索树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* t, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(t-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(t-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --将中根序放入数组中，检查是否有序即可--</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="keyword">if</span> (res[i - <span class="number">1</span>] &gt;= res[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="530-二叉搜索树的最小绝对差">530.二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* t, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(t-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(t-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// --将中根序放入数组中，计算最小差值即可--</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="type">int</span> minDiff = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = res[i] - res[i - <span class="number">1</span>];</span><br><span class="line">            minDiff = minDiff &gt; tmp ? tmp : minDiff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数">501.二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; majority; <span class="comment">// 记录当前找到的众数</span></span><br><span class="line">    <span class="type">int</span> curMSize = <span class="number">0</span>;     <span class="comment">// 记录当前找到的众数,它有多少个</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;          <span class="comment">// 记录当前重复元素</span></span><br><span class="line">    <span class="type">int</span> pre = INT_MIN;    <span class="comment">// 上一个元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// --与上一个元素相同，意味着重复了--</span></span><br><span class="line">        <span class="keyword">if</span> (pre == root-&gt;val) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, curMSize, cnt);</span><br><span class="line">        <span class="keyword">if</span> (curMSize == cnt) majority.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (curMSize &lt; cnt) &#123;</span><br><span class="line">            <span class="comment">// --将所有元素清空，将这个众数放入--</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(majority);</span><br><span class="line">            majority.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            curMSize = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; !right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作">701.二叉搜索树中的插入操作</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">// --看左子树--</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">                root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --看右子树--</span></span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;right) </span><br><span class="line">                root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统原理</title>
      <link href="/2023/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题型">题型</h2><h3 id="ER图">ER图</h3><p><strong>画图</strong></p><p>多值属性加上<code>&#123;属性&#125;</code><br>派生属性不存储，只是计算时需要求出来，表示为<code>属性()</code><br>复合属性加一个缩进</p><p>冗余：<br>两个实体集建立关系集时，冗余属性要删除</p><p>映射关系：<br>说明了具体几个到几个，例如：2…*, 0…*<br>就用<code>l..h</code>表示，这种方式都只需要一条直线，然后标记在直线上<br>否则就用单线，双线，箭头表示。<br>非二元关系，只允许一个箭头<br>双线表示全部参与</p><p><strong>转换为关系模式</strong></p><p>强实体集：<br>属性直接写下来，主码加下划线，复合属性拆开写，多值属性单独成表再取来原表的主码（特殊情况：如果原表只剩下一个主码，则删除原表），派生属性直接不写</p><p>弱实体集：<br>同上，在加上强实体集的主码作为外键，和自己的分辨符作为主码</p><p>联系集：<br>1-1：先取两个关系的主码，再加上联系集的关系，合成关系，再并入任意一端<br>1-n：先取两个关系的主码，再加上联系集的关系，合成关系，再并入n端<br>m-n：先取两个关系的主码，再加上联系集的关系，合成关系，单独成表</p><h3 id="范式">范式</h3><p>是否是BCNF、3NF？<br>了解：1NF：属性都不可分；2NF不存在部分依赖；3NF没有传递依赖；BCNF不存在主属性和候选码的依赖关系<br>计算：<br>BCNF：平凡依赖？超码？<br>3NF：平凡依赖？超码？依赖右部属性是否都出现在任意候选键中</p><p>范式的分解？<br>分解成3NF：1、正则覆盖，2、先求出所有候选键，3、每个函数依赖单独成表（n个关系），完全冗余的关系删除（完全包含在另一个关系中），4、再看这n个关系中是否包含由原表的一个候选键，若有则算法结束（n），没有则任意补充一个候选键作为一个关系（n+1）<br>分解成BCNF：<a href="https://www.bilibili.com/video/BV1eE411a79r?t=3.3">【视频】</a></p><p>正则覆盖？<br>1、使用合并规则，左边相同的合并<br>2、左边右边都是去掉一部分再计算闭包，没变化就是无关属性，去掉无关属性；先解决左边的，再解决右边的<br>3、重复执行，直到不再变化</p><h3 id="SQL或关系代数的增删改查">SQL或关系代数的增删改查</h3><h3 id="串行化调度">串行化调度</h3><p>都是画图，看有没有回路，没有回路再串行化</p><p>冲突可串行化：<br>写写，读写，写读次序不可变</p><p>视图可串行化<br>最开始读的要最开始读<br>最后写的要最后写<br>写读不行变，读写可以</p><h3 id="简答题">简答题</h3><p><strong>1、简述varchar与char的区别</strong><br>char是一种固定长度的类型，varchar则是一种可变长度的类型。</p><p><strong>2、什么是数据库索引？</strong><br>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p><p><strong>3、数据库索引一般采用什么结构？</strong><br>索引的实现通常使用B树及其变种B+树。</p><p><strong>4、事物的四种特性指的是什么？</strong><br>原子性，一致性，隔离性，持久性。</p><p><strong>5、在大学数据中，用SQL语句查询名字’g’的学生的学号、姓名</strong><br>Select ID, name from student where name like ‘%g%’;</p><p><strong>6、简述函数与触发器之间的异同</strong><br>函数和触发器都是存储在数据库当中的一段代码。差别是函数需要显式调用，有返回值，触发器需要有触发事件，系统自动调用，无返回值。</p><p><strong>7、distinct的作用是什么？</strong><br>删除查询结果中的重复记录。</p><p><strong>8、若关系R所有的属性都是不可分的数据项，则该关系最低满足第几范式</strong><br>第一范式</p><p><strong>9、简述用户自定义类型与域之间的差别</strong><br>类型是强类型检查，无法定义约束；域是弱类型检查，可以定义约束；</p><p><strong>10、AB-&gt;C能蕴含A-&gt;C，B-&gt;C吗？</strong><br>不能</p><p><strong>11、说明事物的ACID特征</strong><br>原子性：要么全成功，要么全失败，数据库中不能出现事务部分执行后产生的结果<br>持久性：一旦通知用户事务执行完毕，结果必须永久保存在数据库中，即使出现软件或硬件故障<br>一致性：比如：交易执行时，A和B的总和不变。事务执行过程中可能出现临时的不一致性，但是一旦事务执行成功后，数据库必须是满足一致性的<br>隔离性：虽然多个事务可以并发执行，但每个事务必须不知道其他并发执行的事务。中间事务结果必须对其他并发执行的事务隐藏</p><p><strong>12、说明视图和关系表的区别和联系</strong><br>视图是从一个或几个基本表导出的，视图本身不独立存储在数据库中，是一个虚表。即数据库只存放视图的定义而不存放视图对应的数据，这些数据仍存放在基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以再视图的基础上再定义视图。<br>引进视图的优点：（1）视图能够简化用户的操作（2）视图能够使用户多角度的看待同一数据（3）视图对重构数据库提供一定程度的逻辑独立性（4）视图能够对机密数据提供安全和保护</p><p><strong>13、系统开发人员通过层次抽象来对用户进行屏蔽复杂性，请根据层次由低到高列出各个层次，并说明DBA(数据管理员)主要使用哪个抽象层次</strong><br>物理层、逻辑层、视图层。逻辑层</p><p><strong>14、解释一下物理数据独立性，说明数据库语言的分类以及基本用途，并说明哪种类型的语言放在数据字典中。</strong><br>物理数据独立性：应用程序如果不依赖于物理模式，它们就被称为是具有物理数据独立性，因此即使数据模式改变了，它们也无需重写。数据库语言的分类及其用途：数据库定义语言（DDL），用于定义数据库模式；数据库操纵语言（DML），用于表达数据库的查询和更新。DDL的输出放在数据字典中。</p><p><strong>15、简述空值（null）的含义</strong><br>空值表示这个值不存在或者未知，未知值可能是缺失了或者不知道。</p><p><strong>16、为什么要在数据库中引入事务的概念？</strong><br>要在数据库并发控制下保持数据库的一致性。</p><p><strong>17、为什么要数据库的调度进行可串行化判别，其实际意义是什么？</strong><br>通过保证所执行的调度的效果与没有并发执行的调度效果一样，可以确保数据库的一致性。</p><p><strong>18、若对数据库进行BCNF范式的分解，从而导致没有保持依赖，在数据库中要如何解决</strong><br>改为第三范式分解</p><p><strong>19、数据库中，实体的完整性是如何被保证的</strong><br>not null, unique, check, primary, 参照完整性(foreign key)。</p><p><strong>20、如何降低数据库中的数据的冗余度</strong><br>设计选择：更小的模式；<br>选择合适的范式</p><p><strong>21、如何标识一个弱实体集</strong><br>没有足够的属性以形成主码的实体集称作弱实体集，在E-R图中弱实体集的分辨符以虚下划线标明</p><p><strong>22、在SQL语句中，如何表示除法运算</strong><br>利用Where子句，A/B，表示为 not exists(B  except A)</p><p><strong>23、在关系代数中，与等值连接相比，自然连接的缺点是什么？</strong><br>自然连接是在笛卡尔积的基础上保留相同属性下取值相同的元组，而等值连接可以在笛卡尔积的基础上自由选择比较的属性。</p><p><strong>24、如果关系r®和s(S)中不含有任何相同属性，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">R\cap S=\empty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi mathvariant="normal">∞</mi><mi>s</mi><mo>=</mo><mi>r</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r ∞ s = r × s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">∞</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>.</strong><br>由于r和s的自然连接是在迪卡尔积的基础上进行相同属性的取值相同进行筛选元组，所以没有相同的属性就不用删除元组了，所以最终结果和笛卡尔积结果一样。</p><p><strong>25、某人在使用移动支付系统时，输入了正确的支付密码并提交后，发现了断网情况，导致支付失败，分析该事务经历了那几个状态？</strong><br>活动状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 部分提交状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 失败状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 中止</p><p><strong>26、某学校教务管理系统为每个学院提供了固定的上课教室，系统规定不同学院的教务负责人员登录本系统后，只能有权支配各自学院的教师资源，请问需要定义哪种数据库对象实现此需求？为什么？</strong><br>学校教务管理系统首先创建每个学院单独的视图，然后将对应学院的视图的权限赋给对应的教务负责人。</p><p><strong>27、某学院教务管理系统有学生表”（学号，姓名，出生日期，学员编号）“和选课信息表（学号，课程编号，成绩）”。现有如下规定：如果某学生退学的话，则自动删除该生的所有选课记录，该如何定义此业务逻辑？</strong><br>利用触发器，触发事件是delete from 学生 where 学号=“***”；然后就删除选课信息表中学号是退学学生的学号的元组。</p><p><strong>28、数据库管理系统中DDL所能完成的操作包括哪些？</strong><br>create drop alter</p><p><strong>29、关系数据库设计中，至少应满足的规范化条件是什么？</strong><br>1NF</p><p><strong>30、判断分解后的关系模式是否合理的两个重要标志</strong><br>无损分解和保持依赖</p><p><strong>31、基于多表的视图，可以完成哪些操作，不能完成哪些操作？</strong><br>可以查询，不能更新。</p><p><strong>32、实体之间的联系有哪几种？</strong><br>一对一 多对多 一对多 多对一</p><p><strong>33、简述等值连接和自然连接的异同。</strong><br>等值连接是通过on把两个选中该属性值相等的元组合并。<br>自然连接也是合并，但是是只能遇到同名属性列进行连接，它们两个都是在笛卡尔乘积的情况下进行筛选。</p><p><strong>34、简述where子句和having子句的区别。</strong><br>都是用于进行筛选，where对一般属性，用在group by前；having 对聚集属性列进行判断，用在group by后。</p><p><strong>35、简述数据库中为何要进行并发控制？</strong><br>当多个事务在数据库中并发地执行时，数据的一致性可能不再维持，系统有必要控制各事务之间的相互作用。<br>并发控制机制存在的目的是为了获得高度的并发性，同时保证所产生的调度是冲突可串行化的或视图可串行化可恢复的，并且无级联的。</p><p><strong>36、吉林大学的BBS系统，用户可以以游客的身份游览其他人的留言贴，但是如果想要发言或者回复留言，则必须先登陆方可留言，为什么？在数据库端如何实现？</strong><br>进行了身份的验证，只有成为正式用户，才会被赋予留言的权限。在数据库端对用户赋予权限grant insert update delete on jluBBS to user</p><p><strong>37、支付宝账号通常与某一银行卡绑定，该卡不可透支，若目前卡内余额100元，假设一人在网上使用该支付宝账号付款100元的同时，另外一人使用绑定银行卡刷卡消费100元，能否支付成功？若不可以，在数据库端如何控制？</strong><br>不可以。使用串行化控制</p><p><strong>38、学校所有学生的数据都存在于同一个表中，但各个学院的教务管理人员登陆后只能看到自己学院的学生，请问，在数据库端是如何实现的。</strong><br>基于这张表创建各个学院的视图，然后对不同学院的用户分配相应权限。</p><p><strong>39、在学生表中，将学号 (ID)和姓名 (name)的组合设计为该表的主键是否合理?为什么?</strong><br>不合理。因为这种情况下，允许有多个姓名不同的学生对应相同学号的情况。</p><p><strong>40、如果张三想通过汇款的方式转给李四 200 元。张三的账户已经减掉 200美元后系统发生故障，并没有在李四账户中增加 200 美元，请问数据库出现了什么样的状态?这个问题该怎么解决?数据库通过什么手段实现该操作?</strong><br>数据库处于不一致的状态。应该进行事务回滚，即将张三账户中减掉的200元再加回来。利用日志实现。</p><p><strong>41、请用阿姆斯特朗三定律 (分解律、增强律和传递律) 证明合并律。每步骤的依据。</strong><br>分解率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mo separator="true">,</mo><mi>α</mi><mo>→</mo><mi>γ</mi><mo>⇒</mo><mi>α</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha\to\beta,\alpha\to\gamma\Rightarrow\alpha\to\beta\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span><br>证明：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>γ</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha\gamma\to\beta\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>α</mi><mo>→</mo><mi>α</mi><mi>γ</mi><mo separator="true">,</mo><mtext>即</mtext><mi>α</mi><mo>→</mo><mi>α</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha\alpha\to\alpha\gamma, 即\alpha\to\alpha\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">αα</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">即</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span><br>所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha\to\beta\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span></p><p><strong>42、数据库中常用的完整性约束包括哪些？</strong><br>not null unique check primary key foreign key</p><p><strong>43、简述数据库系统与文件系统的主要区别。</strong><br>  这两个系统都包含了数据集合和一组程序。数据库协调数据的物理和逻辑访问，当文件系统只能协调物理访问。<br>  数据库系统通过确保所有程序都可以使用一块物理数据来减少数据重复的数量。而在文件系统中的一个程序的数据在写的时候可能无法被另一个程序所读取。<br>  数据库系统被设计允许对数据进行灵活的访问（即查询），当文件系统的设计目的是为了允许预先确定的访问（即编译程序）。<br>  数据库管理系统被设计用来协调多用户管理相同的数据，文件处理系统通常被设计成允许一个或多个程序同时访问相同的数据。文件处理系统通常被设计成一个或多个程序同时访问不同的数据文件。在文件系统中，只有当两个程序对文件操作权限都是只读的时候才可以同时访问。</p><p><strong>44、一般情况下，关系R与关系S要进行自然连接，需要满足什么条件？</strong><br>至少有一个同名属性列。</p><p><strong>45、已知视图 faculty的定义：create view faculty as select id, name,dept name from instructor;当发布 insert into faculty values(130765’,‘Green,(Music’))命令时，数据库系统如何执行？</strong><br>这个插入必须被表示为对instructor的插入，这样必须给出salary的值，为此数据库有两种执行方案<br>1.拒绝插入，并向用户返回一个错误信息。<br>2.向instructor关系插入元组（‘130765’,‘Green,(Music’),null）</p><p><strong>46、用基本关系代数表达式来表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\cap S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></strong><br>R∩S=R−(R−S)</p><p><strong>47、关系数据库中，超码、候选码、主码有什么区别？</strong><br>超码就一个或多个属性的集合，这些属性的组合可以在一个关系中唯一地标识一个元组。如果一个超码的任意真子集都不能称为一个超码，那它就是一个候选码，候选码是最小的超码。数据库设计者从候选码中任意选取一个码，叫做主码。</p><p><strong>48、关系代数中，选择操作的功能是什么？</strong><br>选择运算选出满足给定谓词的元组。</p><p><strong>49、数据库中，调度指的是什么？</strong><br>调度指的是指令在系统中执行的时间顺序，一组事务的一个调度一定包含了这组事务的所有指令，而且必须保持指令在各个事务中出现的时间顺序。</p><p><strong>50、事务由哪几个状态组成？判断当手机支付已提交，但由于网络信号消失而导致支付失败，此时，事务处于何种状态？</strong><br>由活动的、部分提交的、失败的、中止的、提交的<br>事务处于失败状态。</p><p><strong>51、在MySQL中定义foreign key时，与标准SQL有何区别？</strong><br>主外键约束在标准SQL下体现的是一种一对多的关系，但是经过MySQL的拓展之后可以表现出“多对多”的关系。</p><p><strong>52、MySQL 中不支持 INTERSECT语句，可以用哪些语句来代替？</strong><br>有关系R S，求R INTERSECT S语句，可以这样（即R ∩ S = R − ( R − S )）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> R <span class="keyword">EXCEPT</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> R <span class="keyword">EXCEPT</span> S</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>53、什么样的调度一定能够保证数据的一致性？</strong><br>可串行化调度</p><p><strong>54、为什么事务非正常结束时会影响数据库数据的正确性，请举例说明。</strong><br>如果在A转账给B的过程中，A扣款成功了，但是此时事务非正常结束，此时B没有收到欠款，数据库处于不一致状态，这影响了数据库数据的正确性。</p><p><strong>55、两个人分别在去哪儿网和携程网上购买2017年7月2日，CZ6147次航班，从长春飞往北京，但该航班的经济舱只剩一张票，两个人同时下单，数据库中要如何控制？</strong><br>使用事务并发控制，对这两个事务进行可串行化调度。</p><p><strong>56、很多在线手机游戏都支持离线操作，即当网络不通时，可以离线玩，等联网之后再进行数据同步，在这个过程中，可能涉及数据库的哪些概念？</strong><br>涉及事务管理，补偿事务，一致性，持久性。</p><p><strong>57、用户到银行开了一个储蓄账户（account表），可以随时对该账户进行存钱、取钱等管理，分别对应数据库中的什么操作？在ATM机上取钱，当卡内余额不足时，ATM机不做任何支付，如何将此规则定义在该表上？</strong> 存取都钱对应UPDATE操作，对account的余额balance添加域约束check(balance&gt;=0);在执行扣款事务的时候，余额不足余额会小于0，这时事务会失败并回滚。</p><p><strong>58、吉林大学一卡通实现了与银行的绑定，当一卡通内余额小于某一设定的金额的时候，可以通过银行卡直接转账，请问如何实现自动转账？转账的金额在数据库端如何设定？</strong><br>创建一个触发器，当一卡通内余额被修改时启动触发器，如果修改过后余额小于设定金额，就执行转账事务。</p><p><strong>59、某银行为不同储蓄金额执行不同利率：低于10万元一年支付4.2%的利息，10万元以上（包括10万）一年支付4.5%的利息。假设储蓄账户表 account(aid（account_id）,balance, branch_name),写出与上述业务相对应的SQL语句，如何保证其执行结果的正确性？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account</span><br><span class="line"><span class="keyword">SET</span> balance<span class="operator">=</span> <span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> balance<span class="operator">&lt;</span><span class="number">100000</span> <span class="keyword">THEN</span> balance<span class="operator">*</span><span class="number">1.042</span></span><br><span class="line"><span class="keyword">ELSE</span> balance<span class="operator">*</span><span class="number">1.045</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>CASE结构的存在可以被利用来在一条UPDATE语句中执行前面的两种更新，避免前面发生的问题！这样就能保证其执行结果的正确性，如果不使用case语句，考虑到加上利息后余额可能超过10万，应该先更新大于10万的，再更新小于十万的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account</span><br><span class="line"><span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">*</span><span class="number">1.045</span></span><br><span class="line"><span class="keyword">WHERE</span> balance<span class="operator">&gt;=</span><span class="number">100000</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account</span><br><span class="line"><span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">*</span><span class="number">1.042</span></span><br><span class="line"><span class="keyword">WHERE</span> balance<span class="operator">&lt;</span><span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>复习，case结构一般如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line"> <span class="keyword">when</span> pred1 <span class="keyword">then</span> result1</span><br><span class="line"> <span class="keyword">when</span> pred2 <span class="keyword">then</span> result2</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">when</span> predn <span class="keyword">then</span> resultn</span><br><span class="line"> <span class="keyword">else</span> result0</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能（东软）</title>
      <link href="/2023/02/20/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%9E%E8%AE%AD(%E4%B8%9C%E8%BD%AF)/"/>
      <url>/2023/02/20/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%9E%E8%AE%AD(%E4%B8%9C%E8%BD%AF)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="老师信息">老师信息</h3><p>老师：吴法春<br>学校：山大（10年毕业）<br>工作：<br>TCL c语言 单片机 2.5年 深圳<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> vetch C++开发 ARM平台 3年<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 青岛 山科智汇 java平台端 Android 3年<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 东软 java方向 python人工智能</p><hr><h3 id="学习安排">学习安排</h3><p>前置基础：python基础，python数据处理和可视化基础</p><p><strong>五天</strong></p><p><strong>第一阶段</strong>（2天）<br>机器学习，深度学习，框架（tensorflow/pytorch）</p><p><strong>第二阶段</strong>（2-2.5天）<br>项目实训（分组 3-4人）</p><p><strong>第三阶段</strong>（0.5-1天）<br>答辩（ppt，代码演示，15分钟左右）介绍，项目演示，代码演示</p><hr><h3 id="成绩">成绩</h3><p>平时成绩30%（考勤为主，有事请假）<br>项目成绩70%（项目内容为主，答辩为辅，不能来要提前说）</p><hr><h3 id="上课时间">上课时间</h3><p>上午：8-12点</p><p>下午：13-17点</p><hr><h3 id="上课方式">上课方式</h3><p>每节课都录屏发群里<br>课件发群里<br>笔记发群里<br>环境搭建也发群里</p><hr><h3 id="项目">项目</h3><p>分类任务（数据任选，模型任选）<br>回归任务（任选）<br>模式识别（数据任选）<br>其他项目</p><p>要求：<br>数据、算法、模型、训练（不能直接拿网上的结果）、效果（指标，可视化）</p><p>答辩：<br>PPT（团队介绍、项目介绍、项目说明、效果展示）<br>成果物（数据、源码、或者其他）<br>实训模板（没有要求，吉大的或者网上的）</p><p>提交：<br>以上三个，答辩完成以后，以小组为单位打包提交即可。</p><hr><h3 id="框架">框架</h3><p>以前：tensorflow<br>现在：pytorch<br>没讲，看发的资料</p><hr><h2 id="环境搭建">环境搭建</h2><p>建议在自己电脑上搭建环境<br>环境：<strong>anaconda</strong> + <strong>pycharm</strong><br>按照老师的给的文档安装</p><p><strong>anaconda</strong><br>带各种包：数据分析、机器学习等等的环境</p><p><strong>pycharm</strong><br>编辑器，社区版免费，破解版没必要（费劲）</p><hr><h2 id="机器学习">机器学习</h2><blockquote><p>主演教四个算法演示机器学习的流程</p></blockquote><h3 id="1、概述">1、概述</h3><p><strong>AI</strong>：<br>1956年第一次提出AI的概念。算力等等限制，受到打击</p><p><strong>实现核心</strong>：<br>机器学习<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 神经网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> 机器学习<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 深度学习 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> 神经网络，RNN、CNN</p><p><strong>数据</strong>：<br>清洗，筛选<br>整理结果：数据矩阵的样子</p><p><strong>算法</strong>：<br>参数</p><p><strong>模型</strong>：</p><p>输入新数据，推测结果</p><p>数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>输入</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{输入}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">输入</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 算法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>新数据</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{新数据}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">新数据</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 模型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>推测</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{推测}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">推测</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> 结果</p><p><strong>算法重要还是数据重要？</strong><br>曲线图（纵轴效果，横轴数据、算法）</p><p><strong>分类、回归</strong>：<br>回归：预测具体数值<br>分类：预测属于哪一类（KNN算法：判断病人的肿瘤属于良性还是恶性的）</p><hr><h3 id="1、KNN算法">1、KNN算法</h3><h4 id="1-1、简介">1.1、简介</h4><p><strong>优点</strong>：</p><ul><li>思想极度简单</li><li>应用数学知识少(近乎为零)</li><li>效果好(缺点?)</li><li>可以解释机器学习算法使用过程中的很多细节问题</li><li>更完整的刻画机器学习应用的流程</li></ul><p>原理案例介绍</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-33-35.png" alt=""></p><p>假设现在设计一个程序判断一个新的肿瘤病人是良性肿瘤还是恶性肿瘤。</p><p>先基于原有的肿瘤病人的发现时间和肿瘤大小（特征）对应的良性/恶性（值）建立了一张散点图，横坐标是肿瘤大小，纵坐标是发现时间，红色代表良性，蓝色代表恶性，现在要预测的病人的颜色为绿色。</p><ol><li><p>首先需要取一个k值（这个k值的取法后面会介绍），然后找到距离要预测的病人的点（绿点）距离最近的k个点。</p></li><li><p>然后用第一步中取到的三个点进行投票，比如本例中投票结果就是蓝：红 = 3：0 ,3&gt;0,所以判断这个新病人幻的事恶性肿瘤。</p></li><li><p><strong>本质</strong>：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p></li></ol><hr><h4 id="1-2、简单实现">1.2、简单实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 9:24</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 特征</span></span><br><span class="line">raw_data_x = [[<span class="number">3.393533211</span>,<span class="number">2.331273381</span>],    <span class="comment"># 肿瘤信息: 大小、时间</span></span><br><span class="line">             [<span class="number">2.110073483</span>,<span class="number">1.781539638</span>],</span><br><span class="line">             [<span class="number">1.343808831</span>,<span class="number">3.368360954</span>],</span><br><span class="line">             [<span class="number">3.582294042</span>,<span class="number">4.679179110</span>],</span><br><span class="line">             [<span class="number">2.280362439</span>,<span class="number">2.866990263</span>],</span><br><span class="line">             [<span class="number">7.423436942</span>,<span class="number">4.696522875</span>],</span><br><span class="line">             [<span class="number">5.745051997</span>,<span class="number">3.533989803</span>],</span><br><span class="line">             [<span class="number">9.172168622</span>,<span class="number">2.511101045</span>],</span><br><span class="line">             [<span class="number">7.792783481</span>,<span class="number">3.424088941</span>],</span><br><span class="line">             [<span class="number">7.939820817</span>,<span class="number">0.791637231</span>]</span><br><span class="line">            ]</span><br><span class="line"><span class="comment"># 所属类别</span></span><br><span class="line">raw_data_y = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]      <span class="comment"># 0/1 恶性的还是良性的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成numpy数组</span></span><br><span class="line">X_train = np.array(raw_data_x)</span><br><span class="line">y_train = np.array(raw_data_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要预测的点</span></span><br><span class="line">x = np.array([<span class="number">8.093607318</span>,<span class="number">3.365731514</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">0</span>,<span class="number">0</span>],X_train[y_train == <span class="number">0</span>,<span class="number">1</span>],color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">1</span>,<span class="number">0</span>],X_train[y_train == <span class="number">1</span>,<span class="number">1</span>],color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.scatter(x[<span class="number">0</span>],x[<span class="number">1</span>],color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>欧拉距离：计算超平面两个点的距离</p><p><strong>KNN 实现过程简单编码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 9:35</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 特征</span></span><br><span class="line">raw_data_x = [[<span class="number">3.393533211</span>,<span class="number">2.331273381</span>],    <span class="comment"># 肿瘤信息: 大小、时间</span></span><br><span class="line">             [<span class="number">2.110073483</span>,<span class="number">1.781539638</span>],</span><br><span class="line">             [<span class="number">1.343808831</span>,<span class="number">3.368360954</span>],</span><br><span class="line">             [<span class="number">3.582294042</span>,<span class="number">4.679179110</span>],</span><br><span class="line">             [<span class="number">2.280362439</span>,<span class="number">2.866990263</span>],</span><br><span class="line">             [<span class="number">7.423436942</span>,<span class="number">4.696522875</span>],</span><br><span class="line">             [<span class="number">5.745051997</span>,<span class="number">3.533989803</span>],</span><br><span class="line">             [<span class="number">9.172168622</span>,<span class="number">2.511101045</span>],</span><br><span class="line">             [<span class="number">7.792783481</span>,<span class="number">3.424088941</span>],</span><br><span class="line">             [<span class="number">7.939820817</span>,<span class="number">0.791637231</span>]</span><br><span class="line">            ]</span><br><span class="line"><span class="comment"># 所属类别</span></span><br><span class="line">raw_data_y = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]      <span class="comment"># 0/1 恶性的还是良性的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成numpy数组</span></span><br><span class="line">X_train = np.array(raw_data_x)</span><br><span class="line">y_train = np.array(raw_data_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要预测的点</span></span><br><span class="line">x = np.array([<span class="number">8.093607318</span>,<span class="number">3.365731514</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line"><span class="comment"># plt.scatter(X_train[y_train == 0,0],X_train[y_train == 0,1],color=&#x27;g&#x27;)</span></span><br><span class="line"><span class="comment"># plt.scatter(X_train[y_train == 1,0],X_train[y_train == 1,1],color=&#x27;r&#x27;)</span></span><br><span class="line"><span class="comment"># plt.scatter(x[0],x[1],color=&#x27;b&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================================</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">distances = []  <span class="comment"># 存计算出来的距离</span></span><br><span class="line"><span class="keyword">for</span> x_train <span class="keyword">in</span> X_train:</span><br><span class="line">    <span class="comment"># 欧拉</span></span><br><span class="line">    <span class="comment"># **2 求平方</span></span><br><span class="line">    d = sqrt(np.<span class="built_in">sum</span>((x_train - x)**<span class="number">2</span>))</span><br><span class="line">    distances.append(d)</span><br><span class="line"><span class="comment"># 生成表达式</span></span><br><span class="line"><span class="comment"># distances = [sqrt(np.sum((x_train - x)**2)) for x_train in X_train]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;distances=&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(distances)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回排序后的结果的索引,也就是距离测试点距离最近的点的排序坐标数组</span></span><br><span class="line">nearset = np.argsort(distances)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nearset=&#x27;</span>)   <span class="comment"># argsort()沿着指定的轴，对输入数组的元素值进行排序，并返回排序后的元素索引数组</span></span><br><span class="line"><span class="built_in">print</span>(nearset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 投票</span></span><br><span class="line">k = <span class="number">6</span></span><br><span class="line"><span class="comment"># print(&#x27;投票结果=&#x27;)</span></span><br><span class="line"><span class="comment"># print([1 if key &gt;= k else 0 for key in nearset])</span></span><br><span class="line"><span class="comment"># 求出距离测试点最近的6个点的类别</span></span><br><span class="line">topK_y = [y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearset[:k]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;topK_y=&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(topK_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># collections的Counter方法可以求出一个数组的相同元素的个数，返回一个dict【key=元素名，value=元素个数】</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># most_common方法求出最多的元素对应的那个键值对</span></span><br><span class="line">votes = Counter(topK_y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;votes=&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(votes)</span><br><span class="line"></span><br><span class="line">mc1 = votes.most_common(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mc1=&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mc1)</span><br><span class="line"><span class="comment"># mc2 = votes.most_common(2)</span></span><br><span class="line"><span class="comment"># print(&#x27;mc2=&#x27;)</span></span><br><span class="line"><span class="comment"># print(mc2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测: 最多的元素对应的那个键值对的键</span></span><br><span class="line">predict = mc1[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict=&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(predict)</span><br></pre></td></tr></table></figure><hr><h4 id="1-3、机器学习套路">1.3、机器学习套路</h4><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-38-11.png" alt=""></p><p>可以说KNN是一个不需要训练过程的算法 k近邻算法是非常特殊的，可以被认为是没有模型的算法。为了和其他算法统一，可以认为训练数据集就是模型</p><hr><h4 id="1-4、判断机器学习算法的性能">1.4、判断机器学习算法的性能</h4><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-41-02.png" alt=""></p><p><strong>训练数据集，测试数据集</strong><br>不能用训练数据集来测试，所以要划分数据集为训练数据集，测试数据集。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-41-38.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 10:55</span></span><br><span class="line"><span class="comment"># permutation(n) 给出从0到n-1的一个随机排列</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets    <span class="comment"># 导入数据集</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data[:,:<span class="number">2</span>]     <span class="comment"># 前两个特征</span></span><br><span class="line">y = iris.target</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目的：随机 拆分出 训练集 测试集</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========================================================&#x27;</span>)</span><br><span class="line">shuffle_indexes = np.random.permutation(<span class="built_in">len</span>(X))</span><br><span class="line"><span class="built_in">print</span>(shuffle_indexes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据集的比例</span></span><br><span class="line">test_ratio = <span class="number">0.2</span></span><br><span class="line"><span class="comment"># 获取测试数据集</span></span><br><span class="line">test_size = <span class="built_in">int</span>(<span class="built_in">len</span>(X) * test_ratio)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_indexes = shuffle_indexes[:test_size]</span><br><span class="line">train_indexes = shuffle_indexes[test_size:]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========================================================&#x27;</span>)</span><br><span class="line">X_train = X[train_indexes]</span><br><span class="line">y_train = y[train_indexes]</span><br><span class="line"><span class="built_in">print</span>(X_train)</span><br><span class="line"><span class="built_in">print</span>(y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========================================================&#x27;</span>)</span><br><span class="line">X_test = X[test_indexes]</span><br><span class="line">y_test = y[test_indexes]</span><br><span class="line"><span class="built_in">print</span>(X_test)</span><br><span class="line"><span class="built_in">print</span>(y_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========================================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape)</span><br><span class="line"><span class="built_in">print</span>(y_train.shape)</span><br><span class="line"><span class="built_in">print</span>(X_test.shape)</span><br><span class="line"><span class="built_in">print</span>(y_test.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="1-5、加载鸢尾花数据集">1.5、加载鸢尾花数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 10:38</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets    <span class="comment"># 导入数据集</span></span><br><span class="line"><span class="comment"># 代码下载150条，官网更多</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="built_in">print</span>(iris.DESCR)   <span class="comment"># 描述</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;===================================================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(iris.data)    <span class="comment"># 数据</span></span><br><span class="line"><span class="built_in">print</span>(iris.data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;===================================================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(iris.feature_names)   <span class="comment"># 特征名称</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;===================================================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(iris.target)  <span class="comment"># 标记信息</span></span><br><span class="line"><span class="built_in">print</span>(iris.target.shape)</span><br><span class="line"><span class="built_in">print</span>(iris.target_names)    <span class="comment"># 标记名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">X = iris.data[:,:<span class="number">2</span>]     <span class="comment"># 前两个特征</span></span><br><span class="line"><span class="comment"># plt.scatter(X[:,0], X[:,1])</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">y = iris.target</span><br><span class="line"><span class="comment"># plt.scatter(X[y == 0,0], X[y == 0,1], color=&quot;red&quot;)</span></span><br><span class="line"><span class="comment"># plt.scatter(X[y == 1,0], X[y == 1,1], color=&quot;blue&quot;)</span></span><br><span class="line"><span class="comment"># plt.scatter(X[y == 2,0], X[y == 2,1], color=&quot;green&quot;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.scatter(X[y == 0,0], X[y == 0,1], color=&quot;red&quot;, marker=&quot;o&quot;)</span></span><br><span class="line"><span class="comment"># plt.scatter(X[y == 1,0], X[y == 1,1], color=&quot;blue&quot;, marker=&quot;+&quot;)</span></span><br><span class="line"><span class="comment"># plt.scatter(X[y == 2,0], X[y == 2,1], color=&quot;green&quot;, marker=&quot;x&quot;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">X = iris.data[:,<span class="number">2</span>:]     <span class="comment"># 后两个特征</span></span><br><span class="line">plt.scatter(X[y == <span class="number">0</span>,<span class="number">0</span>], X[y == <span class="number">0</span>,<span class="number">1</span>], color=<span class="string">&quot;red&quot;</span>, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">plt.scatter(X[y == <span class="number">1</span>,<span class="number">0</span>], X[y == <span class="number">1</span>,<span class="number">1</span>], color=<span class="string">&quot;blue&quot;</span>, marker=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">plt.scatter(X[y == <span class="number">2</span>,<span class="number">0</span>], X[y == <span class="number">2</span>,<span class="number">1</span>], color=<span class="string">&quot;green&quot;</span>, marker=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="1-6、手写字数据集">1.6、手写字数据集</h4><p><a href="http://xn--11-knn-nw2jt75dxjobnhclxqy7f.py">11-knn手写数字测试.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 12:48</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line"><span class="built_in">print</span>(digits.keys())</span><br><span class="line"><span class="built_in">print</span>(digits.DESCR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line">X = digits.data</span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line"><span class="built_in">print</span>(X[:<span class="number">10</span>])</span><br><span class="line">y = digits.target</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="built_in">print</span>(y[:<span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line">some_digit = X[<span class="number">666</span>]</span><br><span class="line">some_digit_image = some_digit.reshape(<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.imshow(some_digit_image, cmap=matplotlib.cm.binary)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================</span></span><br><span class="line"><span class="keyword">from</span> playML.module_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> playML.KNN <span class="keyword">import</span> KNNClassifier</span><br><span class="line"><span class="comment"># MyKnn = __import__(&#x27;04-MyKnn&#x27;)</span></span><br><span class="line"></span><br><span class="line">X_train, y_train, X_test, y_test = train_test_split(X, y, test_radio=<span class="number">0.2</span>, seed=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">my_knn_clf = KNNClassifier(k=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># my_knn_clf = MyKnn.KNNClassifier(k=3)</span></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">my_knn_clf.fit(X_train, y_train)</span><br><span class="line">y_predict = my_knn_clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准确率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(y_predict == y_test) / <span class="built_in">len</span>(y_test))</span><br></pre></td></tr></table></figure><hr><h4 id="1-7、超参数和模型参数">1.7、超参数和模型参数</h4><ul><li><strong>超参数</strong>: 在算法运行前需要决定的参数</li><li><strong>模型参数</strong>: 算法过程中学习的参数</li></ul><p>kNN算法没有模型参数<br>kNN算法中的k是典型的超参数</p><ul><li><strong>寻找好的超参数</strong><ul><li>领域知识</li><li>经验数值</li><li>实验搜索</li></ul></li></ul><p><strong>寻找最好的k</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 20:00</span></span><br><span class="line"><span class="comment"># 思路，遍历1-11，分别拿每一个k去调用算法，得出分数，取得分最高的那个k</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0.0</span></span><br><span class="line">best_k = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    knn_clf = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line">    knn_clf.fit(X_train, y_train)</span><br><span class="line">    score = knn_clf.score(X_test, y_test)</span><br><span class="line">    <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">        best_k = k</span><br><span class="line">        best_score = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管警告</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_k =&quot;</span>, best_k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_score =&quot;</span>, best_score)</span><br></pre></td></tr></table></figure><ul><li><strong>kNN的另外一个超参数：距离的权重</strong></li></ul><p>一般情况下使用距离的导数作为权证</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-50-41.png" alt=""></p><p>考虑距离:红色:1蓝色: 1/3+ 1/4 =7/12红色胜</p><p><strong>考虑距离？不考虑距离</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 20:00</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">666</span>)</span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line">best_method = <span class="string">&quot;&quot;</span></span><br><span class="line">best_score = <span class="number">0.0</span></span><br><span class="line">best_k = -<span class="number">1</span></span><br><span class="line"><span class="comment"># 考虑距离？不考虑距离</span></span><br><span class="line"><span class="keyword">for</span> method <span class="keyword">in</span> [<span class="string">&quot;uniform&quot;</span>,<span class="string">&quot;distance&quot;</span>]:</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        knn_clf = KNeighborsClassifier(n_neighbors=k,weights=method)</span><br><span class="line">        knn_clf.fit(X_train,y_train)</span><br><span class="line">        score = knn_clf.score(X_test,y_test)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_k = k</span><br><span class="line">            best_score = score</span><br><span class="line">            best_method = method</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管警告</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_k=&quot;</span>,best_k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_score=&quot;</span>,best_score)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_method=&quot;</span>,best_method)</span><br></pre></td></tr></table></figure><p><strong>什么是距离？</strong></p><ul><li><strong>欧拉距离</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{\sum^n_{i=1}(X_i^{(a)}-X_i^{(b)})^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1568em;vertical-align:-1.2777em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8791em;"><span class="svg-align" style="top:-5.1168em;"><span class="pstrut" style="height:5.1168em;"></span><span class="mord" style="padding-left:1.056em;"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.8391em;"><span class="pstrut" style="height:5.1168em;"></span><span class="hide-tail" style="min-width:0.742em;height:3.1968em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='3.1968em' viewBox='0 0 400000 3196' preserveAspectRatio='xMinYMin slice'><path d='M702 80H40000040H742v3062l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667219 661 l218 661zM702 80H400000v40H742z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>曼哈顿距离</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n|X_i^{(a)}-X_i^{(b)}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></p><ul><li><strong>两种距离的整理对比</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><mi mathvariant="normal">∣</mi><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mn>1</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">(\sum_{i=1}^n|X_i^{(a)}-X_i^{(b)}|)^{\frac{1}{1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">(\sum_{i=1}^n|X_i^{(a)}-X_i^{(b)}|^2)^{\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mi mathvariant="normal">∣</mi><mi>p</mi></msup><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">(\sum_{i=1}^n|X_i^{(a)}-X_i^{(b)}|^p)^{\frac{1}{p}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0368em;"><span style="top:-3.4458em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4829em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>明克夫斯基距离</strong>Minkowski Distance</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi mathvariant="normal">∣</mi><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mi mathvariant="normal">∣</mi><mi>p</mi></msup><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">(\sum_{i=1}^n|X_i^{(a)}-X_i^{(b)}|^p)^{\frac{1}{p}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0368em;"><span style="top:-3.4458em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4829em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>到这里，我们获得了一个新的<strong>超参数 p</strong></p><p><strong>搜索明可夫斯基距离相应的p</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># 创建时间：2023-02-20 13:08</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">666</span>)</span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line">best_p = -<span class="number">1</span></span><br><span class="line">best_score = <span class="number">0.0</span></span><br><span class="line">best_k = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">        knn_clf = KNeighborsClassifier(n_neighbors=k,weights=<span class="string">&#x27;distance&#x27;</span>,p=p)</span><br><span class="line">        knn_clf.fit(X_train,y_train)</span><br><span class="line">        <span class="comment"># 只有一个标准 score, 实际情况一定不止一个</span></span><br><span class="line">        score = knn_clf.score(X_test,y_test)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_k = k</span><br><span class="line">            best_score = score</span><br><span class="line">            best_p = p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_p=&quot;</span>,best_p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_k=&quot;</span>,best_k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;best_score=&quot;</span>,best_score)</span><br></pre></td></tr></table></figure><hr><h4 id="1-8、网格搜索Grid-Search">1.8、网格搜索Grid Search</h4><p>找最优参数</p><hr><h4 id="1-9、数据归一化处理">1.9、数据归一化处理</h4><p>样本间的距离被一个字段所主导</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_20-56-30.png" alt=""></p><p>解决方案 ：将所有的数据映射到同一尺度</p><ul><li><strong>最值归一化 normalization</strong>：把所有数据映射到 0-1 之间</li></ul><p>适合数值分布比较均匀，有边界的数据集</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">x_{scale}=\frac{x-x_{min}}{x_{max}-x_{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">sc</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ol><li>将这个数据映射到0~Xmax-Xmin 之间</li><li>然后对于每个x相比于整个范围所占的比例</li></ol><p>适用于分布有明显边界的情况；<br>受<strong>outlier</strong>影响较大</p><ul><li><strong>均值方差归一化 standardization</strong>（常用）</li></ul><p>把所有数据归一到均值为0方差为1的分布中<br>适用于数据分布没有明显边界；有可能存在极端情况值</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">x_{scale}=\frac{x-x_{mean}}{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">sc</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">an</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><hr><h4 id="1-10、对测试数据集如何归一化？">1.10、对测试数据集如何归一化？</h4><p>测试数据是模拟真实环境</p><ul><li>真实环境很有可能无法得到所有测试数据的均值和方差</li><li>对数据的归一化也是算法的一部分</li></ul><p>在scikit-learn中使用Scaler</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_21-00-18.png" alt=""></p><hr><h4 id="1-11、KNN的缺点">1.11、KNN的缺点</h4><p>最大的缺点：效率低下<br>如果训练集有m个样本，n个特征，则预测每一个新的数据，需要O(m*n)</p><hr><h3 id="2、线性回归算法">2、线性回归算法</h3><h4 id="2-1、简介">2.1、简介</h4><ul><li>解决回归问题</li><li>思想简单，实现容易</li><li>许多强大的非线性模型的基础</li><li>结果具有很好的可解释性</li><li>蕴含机器学习中的很多重要思想</li></ul><p>线性回归算法以一个坐标系里一个维度为结果，其他维度为特征（如二维平面坐标系中横轴为特征，纵轴为结果），无数的训练集放在坐标系中，发现他们是围绕着一条执行分布。线性回归算法的期望，就是寻找一条直线，最大程度的“拟合”样本特征和样本输出标记的关系</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_14-14-41.png" alt=""></p><h4 id="实现简单线性回归法">实现简单线性回归法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line">y = np.array([<span class="number">1.</span>, <span class="number">3.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">5.</span>])</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3、梯度下降法">3、梯度下降法</h3><ul><li>不是一个机器学习算法</li><li>是一种基于<strong>搜索</strong>的最优化方法</li><li>作用：最小化一个损失函数</li><li>梯度上升法:最大化一个效用函数</li></ul><p>以下是定义了一个损失函数以后，参数theta对应的损失函数J的值对应的示例图，我们需要找到使得损失函数值J取得最小值对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>（这里是二维平面，也就是我们的参数只有一个）</p><p>在直线方程中，导数代表斜率 在曲线方程中，导数代表切线斜率 导数代表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>单位变化时，J相应的变化</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_16-19-53.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>称为学习率(learning rate)；<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>的取值影响获得最优解的速度；<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>取值不合适，甚至得不到最优解；<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>是梯度下降法的一个超参数。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">η</mi></mrow><annotation encoding="application/x-tex">\mathbf{\eta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><strong>取值的影响</strong>：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_16-23-13.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_16-23-33.png" alt=""></p><p><strong>其他注意事项</strong>：</p><p>并不是所有函数都有唯一的极值点</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_16-27-17.png" alt=""></p><p>解决方案：<br>多次运行，随机化初始点；<br>梯度下降法的初始点也是一个超参数。</p><p><strong>线性回归法的损失函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mo stretchy="false">(</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m(y^{(i)}-\hat{y}^{(i)})^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1877em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>具有唯一的最优解</strong>。</p><h4 id="多元线性回归中的梯度下降法">多元线性回归中的梯度下降法</h4><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/ai2023learning/Snipaste_2023-02-20_16-55-39.png" alt=""></p><p>套路</p><p>模型<br>数学推导（其他方法）损失函数或者效应函数</p><h2 id="深度学习">深度学习</h2><h3 id="1、感知机">1、感知机</h3><h3 id="2、神经网络">2、神经网络</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPARKS</title>
      <link href="/2023/02/07/SPARKS/"/>
      <url>/2023/02/07/SPARKS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SPARKS 语言是一种<strong>算法描述语言</strong>，这种语言具有精简易懂的特点，适用于模块化程序设计过程中对于各模块的算法进行描述交流，通过使用SPARKS 语言，在模块细化的过程中，可以忽略模块的细节而将关键的算法思想表达出来。</p></blockquote><h2 id="1、基本数据类型">1、基本数据类型</h2><p>整型、实型、布尔型、字符型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">integer x,y;</span><br><span class="line"></span><br><span class="line">double z,w;</span><br><span class="line"></span><br><span class="line">boolean a,b;</span><br><span class="line"></span><br><span class="line">char c,d;</span><br></pre></td></tr></table></figure><h2 id="2、赋值语句">2、赋值语句</h2><p>将y的值赋给x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-y</span><br></pre></td></tr></table></figure><h2 id="3、两个布尔值">3、两个布尔值</h2><p><code>true   false</code></p><p>为了产生这两个布尔值，设置了<strong>逻辑运算符</strong></p><p><code>and   or   not</code></p><p>和<strong>关系运算符</strong></p><p><code>&lt;   &lt;=   =   !=   &gt;=   &gt;</code></p><h2 id="4、数组表示">4、数组表示</h2><p>一个n维的数组可以用以下形式说明:<br><code>integer A(l1:u1, l2:u2, ..., ln,un)</code><br>其<strong>下界为li</strong>，<strong>上界为ui</strong>，1&lt;= i &lt;= n。li和ui都是整数或整型变量，如果某一维的下界为1，则下界li可以不写出。</p><p>例如：<br><code>integer A(5,7:20)</code></p><h2 id="5、-条件语句">5、 条件语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if cond then</span><br><span class="line">     S1</span><br><span class="line">else</span><br><span class="line">     S2</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>其中cond是一个布尔表达式。假设布尔表达式按照“短路”方式求值。</p><p>另一种语句是<strong>case语句</strong>，此语句可以很容易地把数个选择对象区别开来，而无需使用多重if-then-else语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">     :cond1: S1</span><br><span class="line">     :cond2: S2</span><br><span class="line">     ......</span><br><span class="line">     :condn: Sn</span><br><span class="line">     :else   : Sn+1</span><br><span class="line">endcase</span><br></pre></td></tr></table></figure><p>其中else子句并不是必需的。</p><h2 id="6、循环语句">6、循环语句</h2><p><strong>while循环语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while cond do</span><br><span class="line">     S</span><br><span class="line">repeat</span><br></pre></td></tr></table></figure><p>当cond为true的时候，循环，S有可能不会被执行</p><p><strong>loop-until-repeat循环语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop</span><br><span class="line">     S</span><br><span class="line">until cond repeat</span><br></pre></td></tr></table></figure><p>当cond为false的时候循环，S至少执行一次</p><p><strong>for循环语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for vble&lt;-start to finish by increment do</span><br><span class="line">     S</span><br><span class="line">repeat</span><br></pre></td></tr></table></figure><p>其中by incerment不是必须的，<strong>默认为+1</strong>。vble是变量，start、finish、increment可以是整型、实型变量，或算术表达式。</p><p><strong>loop循环语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop</span><br><span class="line">     S</span><br><span class="line">repeat</span><br></pre></td></tr></table></figure><p>可以使用go to label退出，或使用exit退出，exit相当于C语言值的break。</p><h2 id="7、过程">7、过程</h2><p>一个完整的sparts程序是一个或多个过程的集合，第一个过程作为主程序。单个过程形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure NAME(&lt;形参表&gt;)</span><br><span class="line">   &lt;说明部分&gt;</span><br><span class="line">   S</span><br><span class="line">end NAME</span><br></pre></td></tr></table></figure><p>过程可以是纯子例行程序，也可以是一个函数。函数中，返回值由放在紧接return的一对括号中的值来表示。例如<br>return (&lt;表达式&gt;)</p><h2 id="8、输入输出">8、输入输出</h2><p><code>read a,b</code></p><p>输入的数据依次送给a，b</p><p><code>print x,y</code></p><p>依次输出x，y</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5</title>
      <link href="/2023/01/27/html/"/>
      <url>/2023/01/27/html/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV14J4114768?t=3.3">【pink老师视频yyds】</a></p><h2 id="一、HTML简介">一、HTML简介</h2><h3 id="1、网页">1、网页</h3><ul><li><strong>什么是网页</strong></li></ul><p><strong>网站</strong>是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</p><p><strong>网页</strong>是网站中的一“页”，通常是 <strong>HTML</strong> 格式的文件，它要通过浏览器来阅读。</p><p><strong>网页是构成网站的基本元素</strong>，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页， 常见以 <strong>.htm</strong> 或 <strong>.html</strong> 后缀结尾的文件，因此将其<strong>俗称为 HTML 文件</strong>。</p><ul><li><strong>什么是 HTML</strong></li></ul><p>HTML 指的是<strong>超文本标记语言 (Hyper Text Markup Language)</strong> ，它是用来描述网页的一种语言。</p><p>HTML 不是一种编程语言，而是一种标记语言 (markup language)。</p><p>标记语言是一套标记标签 (markup tag)。</p><p><strong>所谓超文本，有 2 层含义</strong>：</p><ol><li>它可以加入图片、声音、动画、多媒体等内容（超越了文本限制 ）。</li><li>它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本 ）。</li></ol><ul><li><strong>网页的形成</strong></li></ul><p>网页是由网页元素组成的，这些元素是利用 html 标签描述出来，然后通过浏览器解析来显示给用户的。</p><p>前端人员开发代码 ----&gt; 浏览器显示代码（解析、渲染） -----&gt; 生成最后的 Web 页面</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_18-23-00.png" alt=""></p><h3 id="2、常用浏览器">2、常用浏览器</h3><blockquote><p>  浏览器是网页显示、运行的平台。常用的浏览器有 <strong>IE</strong>、<strong>火狐</strong>（Firefox）、<strong>谷歌</strong>（Chrome）、<strong>Safari</strong>和<strong>Opera</strong>等。 平时称为<strong>五大浏览器</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_18-33-19.png" alt=""></p></blockquote><ul><li>浏览器内核</li></ul><p>浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。</p><table><thead><tr><th style="text-align:left">浏览器</th><th style="text-align:center">内核</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">IE</td><td style="text-align:center">Trident</td><td>IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td style="text-align:left">firefox</td><td style="text-align:center">Gecko</td><td>火狐浏览器内核</td></tr><tr><td style="text-align:left">Safari</td><td style="text-align:center">Webkit</td><td>苹果浏览器内核</td></tr><tr><td style="text-align:left">chrome/Opera</td><td style="text-align:center">Blink</td><td>chrome / opera浏览器内核。Blink 其实是 WebKit 的分支</td></tr></tbody></table><p>目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。</p><h3 id="3、Web-标准（重点）">3、Web 标准（重点）</h3><blockquote><p>Web 标准是由 W3C 组织和其他标准化组织制定的<strong>一系列标准的集合</strong>。<strong>W3C（万维网联盟）</strong> 是国际最著名的标准化组织。</p></blockquote><ul><li><strong>为什么需要Web标准</strong></li></ul><p>浏览器不同，它们显示页面或者排版就有些许<strong>差异</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_18-35-24.png" alt=""></p><p>遵循Web标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下<strong>优点</strong>：</p><ol><li><p>让Web的发展前景更广阔。</p></li><li><p>内容能被更广泛的设备访问。</p></li><li><p>更容易被搜寻引擎搜索。</p></li><li><p>降低网站流量费用。</p></li><li><p>使网站更易于维护。</p></li><li><p>提高页面浏览速度。</p></li></ol><ul><li><strong>Web标准的构成</strong></li></ul><p>主要包括<strong>结构</strong>（Structure）、<strong>表现</strong>（Presentation）和<strong>行为</strong>（Behavior）三个方面。</p><table><thead><tr><th style="text-align:center">标准</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">结构</td><td>结构用于对<strong>网页元素</strong>进行整理和分类，现阶段主要学的是HTML。</td></tr><tr><td style="text-align:center">表现</td><td>表现用于设置网页元素的版式、颜色、大小等<strong>外观样式</strong>，主要指的是CSS</td></tr><tr><td style="text-align:center">行为</td><td>行为是指网页模型的定义及<strong>交互</strong>的编写，现阶段主要学的是Javascript</td></tr></tbody></table><p>Web 标准提出的最佳体验方案：<strong>结构、样式、行为相分离</strong>。</p><p>简单理解：<strong>结构写到HTML 文件中，表现写到CSS 文件中，行为写到JavaScript 文件中</strong>。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_18-42-57.png" alt=""></p><h2 id="二、HTML标签规范">二、HTML标签规范</h2><h3 id="1、基本语法概述">1、基本语法概述</h3><p>（1）HTML 标签是由<strong>尖括号包围的关键词</strong>，例如<code>&lt;html&gt;</code>。</p><p>（2）HTML 标签<strong>通常是成对出现的</strong>，例如<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>  ，我们称为<strong>双标签</strong>。标签对中的第一个标签是开始标签，第二个标签是结束标签。</p><p>（3）有些特殊的标签必须是单个标签（极少情况），例如<code>&lt;br /&gt;</code>，我们称为<strong>单标签</strong>。</p><h3 id="2、标签关系">2、标签关系</h3><p>双标签关系可以分为两类：<strong>包含关系</strong>和<strong>并列关系</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 并列关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、HTML-基本结构标签">3、HTML 基本结构标签</h3><ul><li><strong>一个 HTML 网页</strong></li></ul><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p><p>HTML页面也称为 HTML 文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我的第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello, world </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;&lt;/html&gt;</code></td><td>HTML标签</td><td>页面中最大的标签，我们 称为 <strong>根标签</strong></td></tr><tr><td><code>&lt;head&gt;&lt;/head&gt;</code></td><td>文档头部</td><td>注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><code>&lt;title&gt;&lt;/title&gt;</code></td><td>文档标题</td><td>让页面拥有一个属于自己的网页标题</td></tr><tr><td><code>&lt;body&gt;&lt;/body&gt;</code></td><td>文档主体</td><td>元素包含文档的所有内容，页面内容 基本都是放到body里面的</td></tr></tbody></table><p>HTML 文档的的后缀名必须是 .html 或 .htm ，浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。此时，用浏览器打开这个网页，我们就可以预览我们写的第一个 HTML 文件了</p><h2 id="三、开发工具">三、开发工具</h2><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_19-51-42.png" alt=""></p><h3 id="VSCode的使用">VSCode的使用</h3><p>新建文件，文件后缀为.html</p><p>输入<code>!</code>，然后选择<code>!</code>会自动生成骨架</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_19-57-08.png" alt=""></p><p><strong>骨架中的代码说明</strong></p><ul><li><p><code>&lt;!DOCTYPE html&gt;</code></p><p>&lt;!DOCTYPE&gt; 文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页。</p><p><code>&lt;!DOCTYPE html&gt;</code>这句代码的意思是: <strong>当前页面采取的是HTML5版本来显示网页</strong></p><p><strong>注意</strong>:</p><ol><li><p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，<strong>处于&lt;html&gt;标签之前</strong>。</p></li><li><p>&lt;!DOCTYPE&gt;<strong>不是一个HTML 标签</strong>，它就是文档类型声明标签</p></li></ol></li><li><p><code>&lt;html lang=&quot;en&quot;&gt;</code></p><p>用来定义当前文档显示的语言。</p><p>(1)、<strong>en定义语言为英语</strong></p><p>(2)、<strong>zh-CN定义语言为中文</strong></p><p>简单来说,定义为en就是英文网页, 定义为zh-CN就是中文网页</p><p>其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文</p><p>这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的</p></li><li><p><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></p><p>字符集(Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。</p><p>在标签内，可以通过标签的charset属性来规定HTML 文档应该使用哪种字符编码。</p><p>charset常用的值有：<strong>GB2312</strong> 、<strong>BIG5</strong> 、<strong>GBK</strong>和<strong>UTF-8</strong>，其中UTF-8也被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><p><strong>注意</strong>：上面语法是<strong>必须要写的代码</strong>，否则可能引起乱码的情况。<strong>一般情况下，统一使用“UTF-8”编码</strong>，尽量统一写成标准的&quot;UTF-8&quot;，不要写成&quot;utf8&quot; 或&quot;UTF8&quot;。</p></li></ul><h3 id="VSCode的插件">VSCode的插件</h3><table><thead><tr><th>插件</th><th>作用</th></tr></thead><tbody><tr><td>Chinese (Simplified) LanguagePack for VS Code</td><td>中文( 简体 ) 语言包</td></tr><tr><td>Open in Browser</td><td>右击选择浏览器打开html文件</td></tr><tr><td>JS-CSS-HTMLFormatter</td><td>每次保存，都会自动格式化js css和html代码</td></tr><tr><td>Auto Rename Tag</td><td>自动重命名配对的HTML/XML标签</td></tr><tr><td>CSS Peek</td><td>追踪至样式</td></tr></tbody></table><h2 id="四、HTML常用标签">四、HTML常用标签</h2><blockquote><p>学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。</p><p><strong>根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰</strong>。</p></blockquote><h3 id="1、标题标签-h1-h6">1、标题标签&lt;h1&gt; ~ &lt;h6&gt;</h3><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了6 个等级的网页标题，即<code>&lt;h1&gt; ~ &lt;h6&gt;</code></p><p>单词<strong>head</strong>的缩写，意为头部、标题。</p><p><strong>标签语义</strong>：作为标题使用，并且依据重要性递减</p><p><strong>特点</strong>：</p><ol><li><p>加了标题的文字会变的加粗，字号也会依次变大。</p></li><li><p>一个标题<strong>独占一行</strong>。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一共六级选,<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文字加粗一行显。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>由大到小依次减，<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>从重到轻随之变。<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>语法规范书写后，<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>具体效果刷新见。<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、段落和换行标签">2、段落和换行标签</h3><p>  在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在HTML 标签中，<code>&lt;p&gt;&lt;/p&gt;</code>标签用于定义段落，它可以将整个网页分为若干个段落。</p><p>单词<strong>paragraph</strong>[ˈpærəgræf]的缩写，意为段落。</p><p><strong>标签语义</strong>：可以把HTML 文档分割为若干段落。</p><p><strong>特点</strong>：</p><ol><li><p>文本在一个段落中会根据浏览器窗口的大小<strong>自动换行</strong>。</p></li><li><p>段落和段落之间保有<strong>空隙</strong>。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  在HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签<code>&lt;br /&gt;</code></p><p>单词<strong>break</strong>的缩写，意为打断、换行。</p><p><strong>标签语义</strong>：强制换行。</p><p><strong>特点</strong>：</p><ol><li><p>&lt;br /&gt; 是个单标签。</p></li><li><p>&lt;br /&gt; 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、文本格式化标签">3、文本格式化标签</h3><p>在网页中，有时需要为文字设置<strong>粗体</strong>、<em>斜体</em>或<u>下划线</u>等效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p><p><strong>标签语义</strong>: 突出重要性, 比普通文字更重要.</p><table><thead><tr><th style="text-align:center">语义</th><th style="text-align:center">标签</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>加粗</strong></td><td style="text-align:center"><code>&lt;strong&gt;&lt;/strong&gt;</code>或者<code>&lt;b&gt;&lt;/b&gt;</code></td><td>更推荐使用<code>&lt;strong&gt;</code>标签加粗 语义更强烈</td></tr><tr><td style="text-align:center"><strong>倾斜</strong></td><td style="text-align:center"><code>&lt;em&gt;&lt;/em&gt;</code>或者 <code>&lt;i&gt;&lt;/i&gt;</code></td><td>更推荐使用<code>&lt;em&gt;</code>标签加粗 语义更强烈</td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center"><code>&lt;del&gt;&lt;/del&gt;</code> 或者<code>&lt;s&gt;&lt;/s&gt;</code></td><td>更推荐使用<code>&lt;del&gt;</code>标签加粗 语义更强烈</td></tr><tr><td style="text-align:center">下划线</td><td style="text-align:center"><code>&lt;ins&gt;&lt;/ins&gt;</code>或者 <code>&lt;u&gt;&lt;/u&gt;</code></td><td>更推荐使用<code>&lt;ins&gt;</code>标签加粗 语义更强烈</td></tr></tbody></table><h3 id="4、-div-和-span-标签">4、&lt;div&gt;和&lt;span&gt;标签</h3><p><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>是没有语义的，它们就是一个<strong>盒子</strong>，用来装内容的。</p><p>div 是<strong>division</strong> 的缩写，表示分割、分区。</p><p>span意为跨度、跨距。</p><p><strong>特点</strong>：</p><ol><li><p>&lt;div&gt;标签用来布局，但是现在<strong>一行只能放一个</strong>。大盒子</p></li><li><p>&lt;span&gt;标签用来布局，<strong>一行上可以多个</strong>。小盒子</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>今日价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、图像标签和路径">5、图像标签和路径</h3><p>在HTML 标签中，<code>&lt;img /&gt;</code>标签用于定义HTML 页面中的图像。</p><p>单词<strong>image</strong>的缩写，意为图像。</p><p><strong>src是标签的必须属性</strong>，它用于指定图像文件的路径和文件名。所谓属性：简单理解就是属于这个图像标签的特性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">属性值</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>src</code></td><td style="text-align:center">图片路径</td><td>必须属性</td></tr><tr><td style="text-align:center"><code>alt</code></td><td style="text-align:center">文本</td><td>替换文本。图像不能显示的文字</td></tr><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">文本</td><td>提示文本。鼠标放到图像上，显示的文字</td></tr><tr><td style="text-align:center"><code>width</code></td><td style="text-align:center">像素</td><td>设置图像的宽度</td></tr><tr><td style="text-align:center"><code>height</code></td><td style="text-align:center">像素</td><td>设置图像的高度</td></tr><tr><td style="text-align:center"><code>border</code></td><td style="text-align:center">像素</td><td>设置图像的边框粗细</td></tr></tbody></table><p><strong>注意点</strong>：</p><ul><li><p>图像标签可以拥有<strong>多个</strong>属性，<strong>必须写在标签名的后面</strong>。</p></li><li><p>属性之间<strong>不分先后顺序</strong>，标签名与属性、属性与属性之间均以<strong>空格分开</strong>。</p></li><li><p>属性采取<strong>键值对的格式</strong>，即 key=“value&quot; 的格式，属性 =“属性值”。</p></li></ul><p>**相对路径：**以引用文件所在位置为参考基础，而建立出的目录路径。这里简单来说，<strong>图片相对于 HTML 页面的位置</strong></p><table><thead><tr><th style="text-align:center">相对路径分类</th><th style="text-align:center">符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">同一级路径</td><td style="text-align:center"></td><td>图像文件位于HTML文件同一级 如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td></tr><tr><td style="text-align:center">下一级路径</td><td style="text-align:center"><code>/</code></td><td>图像文件位于HTML文件下一级 如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td></tr><tr><td style="text-align:center">上一级路径</td><td style="text-align:center"><code>../</code></td><td>图像文件位于HTML文件上一级 如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td></tr></tbody></table><p>**绝对路径：**是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p><h3 id="6、超链接标签">6、超链接标签</h3><p>在 HTML 标签中，<code>&lt;a&gt;</code>标签用于定义超链接，作用是从一个页面链接到另一个页面。</p><p>单词 <strong>anchor</strong> [ˈæŋkə®] 的缩写，意为：锚。</p><p><strong>语法格式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">属性</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>href</code></td><td>用于指定链接目标的url地址， (必须属性）当为标签应用href属性时，它就具有了超链接的功能</td></tr><tr><td style="text-align:center"><code>target</code></td><td>用于指定链接页面的打开方式，其中<code>_self</code>为默认值，<code> _blank</code>为在新窗口中打开方式。</td></tr></tbody></table><p><strong>链接分类</strong>:</p><ol><li><p>外部链接: 例如 <code>&lt;a href=&quot;http:// www.baidu.com &quot;&gt;百度&lt;/a&gt;</code>。</p></li><li><p>内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;</code>。</p></li><li><p>空链接: 如果当时没有确定链接目标时，<code>&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;</code> 。</p></li><li><p>下载链接: <strong>如果 href 里面地址是一个文件或者压缩包，会下载这个文件</strong>。</p></li><li><p>网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接.</p></li><li><p><strong>锚点链接</strong>: 点我们点击链接,可以快速定位到页面中的某个位置.</p><ul><li>在链接文本的 href 属性中，设置属性值为<code>#名字</code>的形式，如：<code>&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt;</code></li><li>找到目标位置标签，里面添加一个 <code>id 属性 = 刚才的名字</code> ，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; </code></li></ul></li></ol><h3 id="7、注释">7、注释</h3><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p><p>HTML中的注释以“<code>&lt;!--</code>”开头，以“<code> --&gt;</code>”结束。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是一个注释语句 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8、特殊符号">8、特殊符号</h3><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><p><strong>重点记住：空格 、大于号、 小于号</strong> 这三个， 其余的使用很少，如果需要回头查阅即可</p><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">描述</th><th style="text-align:center">字符代码</th></tr></thead><tbody><tr><td style="text-align:center">&quot; &quot;</td><td style="text-align:center"><strong>空格</strong></td><td style="text-align:center">``</td></tr><tr><td style="text-align:center">“&lt;”</td><td style="text-align:center"><strong>小于号</strong></td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td style="text-align:center">“&gt;”</td><td style="text-align:center"><strong>大于号</strong></td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td style="text-align:center">“&amp;”</td><td style="text-align:center">和号</td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td style="text-align:center">“¥”</td><td style="text-align:center">人名币</td><td style="text-align:center"><code>&amp;yen;</code></td></tr><tr><td style="text-align:center">“©”</td><td style="text-align:center">版权</td><td style="text-align:center"><code>&amp;copy;</code></td></tr><tr><td style="text-align:center">“®”</td><td style="text-align:center">注册商标</td><td style="text-align:center"><code>&amp;reg;</code></td></tr><tr><td style="text-align:center">“°”</td><td style="text-align:center">摄氏度</td><td style="text-align:center"><code>&amp;deg;</code></td></tr><tr><td style="text-align:center">“±”</td><td style="text-align:center">正负号</td><td style="text-align:center"><code>&amp;plusmn;</code></td></tr><tr><td style="text-align:center">“×”</td><td style="text-align:center">乘号</td><td style="text-align:center"><code>&amp;times;</code></td></tr><tr><td style="text-align:center">“÷”</td><td style="text-align:center">除号</td><td style="text-align:center"><code>&amp;divide;</code></td></tr><tr><td style="text-align:center">“²”</td><td style="text-align:center">平方</td><td style="text-align:center"><code>&amp;sup2;</code></td></tr><tr><td style="text-align:center">“³”</td><td style="text-align:center">立方</td><td style="text-align:center"><code>&amp;sup3;</code></td></tr></tbody></table><h2 id="五、HTML其他常用标签">五、HTML其他常用标签</h2><h3 id="1、表格标签">1、表格标签</h3><h4 id="1-1、表格标签">1.1、表格标签</h4><p>建议：表格不是用来布局页面的,而是用来<strong>展示数据</strong>的</p><p>基本语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         ...</span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>&lt;table&gt;&lt;/table&gt;</code>是用于定义<strong>表格</strong>的标签。</p></li><li><p><code>&lt;tr&gt;&lt;/tr&gt;</code>标签用于定义表格中的<strong>行</strong>，必须嵌套在<code>&lt;table&gt;&lt;/table&gt;</code>标签中。</p></li><li><p><code>&lt;td&gt;&lt;/td&gt;</code>用于定义表格中的<strong>单元格</strong>，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。</p></li><li><p>字母 td 指表格数据（<strong>table data</strong>），即数据单元格的内容。</p></li></ol><h4 id="1-2、表头单元格标签">1.2、表头单元格标签</h4><p><strong>一般</strong>表头单元格位于表格的第一<strong>行或第一列</strong>，表头单元格里面的文本内容<strong>加粗居中显示</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">         ...</span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3、表格标签属性">1.3、表格标签属性</h4><p>表格标签这部分属性我们实际开发我们<strong>不常用</strong>，后面通过 CSS 来设置</p><table><thead><tr><th style="text-align:center">属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>align</code></td><td>left、center、right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td style="text-align:center"><code>border</code></td><td>1 或 “”</td><td>规定表格单元是否拥有边框，默认为””，表示没有边框</td></tr><tr><td style="text-align:center"><code>cellpadding</code></td><td>像素值</td><td>规定单元边沿与其内容之间的空白，<strong>默认1像素</strong></td></tr><tr><td style="text-align:center"><code>cellspacing</code></td><td>像素值</td><td>规定单元格之间的空白，<strong>默认2像素</strong></td></tr><tr><td style="text-align:center"><code>width</code></td><td>像素值 或 百分比</td><td>规定表格的宽度</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>21<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_21-46-02.png" alt=""></p><h4 id="1-4、表格结构标签">1.4、表格结构标签</h4><p>使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分。</p><p>在表格标签中，分别用：<code>&lt;thead&gt;</code>标签表格的<strong>头部区域</strong>、<code>&lt;tbody&gt;</code>标签表格的<strong>主体区域</strong>. 这样可以更好的分清表格结构。</p><ol><li><p><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。<code>&lt;thead&gt;</code> 内部必须拥有 <code>&lt;tr&gt;</code> 标签。 一般是位于第一行。</p></li><li><p><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体，主要用于放数据本体 。</p></li><li><p>以上标签都是放在 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>21<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5、合并单元格">1.5、合并单元格</h4><ul><li><p>跨行合并：<strong>rowspan</strong>=“合并单元格的个数”，最上侧单元格为目标单元格, 写合并代码</p></li><li><p>跨列合并：<strong>colspan</strong>=“合并单元格的个数”，最左侧单元格为目标单元格, 写合并代码</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;td&gt;3&lt;/td&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;td&gt;7&lt;/td&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_22-03-32.png" alt=""></p><p><strong>一共三步：</strong></p><ol><li><p>先确定是跨行还是跨列合并。</p></li><li><p>找到目标单元格. 写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。</p></li><li><p>删除多余的单元格。</p></li></ol><h3 id="2、列表标签">2、列表标签</h3><p>表格是用来显示数据的，那么<strong>列表就是用来布局的</strong>。</p><p>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。</p><p>根据使用情景不同，列表可以分为三大类：<strong>无序列表</strong>、<strong>有序列表</strong>和<strong>自定义列表</strong>。</p><h4 id="2-1、无序列表">2.1、无序列表</h4><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使<code>&lt;li&gt;</code> 标签定义。</p><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。</p></li><li><p><code>&lt;ul&gt;&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的。</p></li><li><p><code>&lt;li&gt; 与 &lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有元素。</p></li><li><p>无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS</p></li></ol><h4 id="2-2、有序列表">2.2、有序列表</h4><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。</p><p>在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。</p><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ol&gt;&lt;/ol&gt;</code>标签中输入其他标签或者文字的做法是不被允许的。</p></li><li><p><code>&lt;li&gt; 与 &lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</p></li><li><p>有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。</p></li></ol><h4 id="2-3、自定义列表">2.3、自定义列表</h4><p>自定义列表的使用场景：自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p><p>在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和<code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。</p><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>&lt;dl&gt;&lt;/dl&gt;</code> 里面只能包含 <code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code>。</p></li><li><p><code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code>个数没有限制，经常是一个<code>&lt;dt&gt;</code> 对应多个<code>&lt;dd&gt;</code>。</p></li></ol><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/web/html/Snipaste_2023-01-27_22-19-09.png" alt=""></p><h3 id="3、表单标签">3、表单标签</h3><p>在 HTML 中，一个完整的表单通常由<strong>表单域</strong>、<strong>表单控件</strong>（也称为表单元素）和 <strong>提示信息</strong>3个部分构成</p><h4 id="3-1、表单域">3.1、表单域</h4><p><strong>表单域</strong>是一个包含表单元素的区域。</p><p>在 HTML 标签中， <code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> <strong>会把它范围内的表单元素信息提交给服务器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“url地址”</span> <span class="attr">method</span>=<span class="string">“提交方式”</span> <span class="attr">name</span>=<span class="string">“表单域名称</span>&quot;&gt;</span></span><br><span class="line">     各种表单元素控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">属性值</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>action</code></td><td style="text-align:center">url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址</td></tr><tr><td style="text-align:center"><code>method</code></td><td style="text-align:center">get / post</td><td>用于设置表单数据的提交方式，其取值为get或post。</td></tr><tr><td style="text-align:center"><code>name</code></td><td style="text-align:center">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><h4 id="3-2、表单控件-表单元素">3.2、表单控件(表单元素)</h4><p>在表单域中可以定义各种表单元素，这些表单元素就是允许用户在表单中输入或者选择的内容控件。</p><ul><li><code>&lt;input /&gt;</code></li></ul><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。</p><p>在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>type属性</strong>的属性值及其描述如下：</p><table><thead><tr><th style="text-align:center">属性值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>button</code></td><td>定义可点击按钮 (多数情况下，用于通过JavaScript 启动脚本)。</td></tr><tr><td style="text-align:center"><code>checkbox</code></td><td>定义复选框。</td></tr><tr><td style="text-align:center"><code>file</code></td><td>定义输入字段和“浏览”按钮，供文件上传。</td></tr><tr><td style="text-align:center"><code>hidden</code></td><td>定义隐藏的输入字段。</td></tr><tr><td style="text-align:center"><code>image</code></td><td>定义图像形式的提交按钮。</td></tr><tr><td style="text-align:center"><code>password</code></td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td style="text-align:center"><code>radio</code></td><td>定义单选按钮。</td></tr><tr><td style="text-align:center"><code>reset</code></td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td style="text-align:center"><code>sumbit</code></td><td>定义提交按钮。提交按钮会把表单数据发送到服务器</td></tr><tr><td style="text-align:center"><code>text</code></td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符</td></tr></tbody></table><p>除 type 属性外，<code>&lt;input&gt;</code>标签还有其他很多属性，<strong>其常用属性如下</strong>：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">属性值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>name</code></td><td style="text-align:center">由用户自定义</td><td>定义input元素的名称</td></tr><tr><td style="text-align:center"><code>value</code></td><td style="text-align:center">由用户自定义</td><td>规定input元素的值</td></tr><tr><td style="text-align:center"><code>checked</code></td><td style="text-align:center">checked</td><td>规定此input元素首次加载时应当被选中</td></tr><tr><td style="text-align:center"><code>maxlength</code></td><td style="text-align:center">正整数</td><td>规定输入字段中的字符的最大长度</td></tr></tbody></table><ol><li><p>name 和value 是每个表单元素都有的属性值,主要给后台人员使用.</p></li><li><p>name 表单元素的名字, 要求 <strong>单选按钮和复选框要有相同的name值</strong>.</p></li><li><p><strong>checked属性主要针对于单选按钮和复选框</strong>, 主要作用一打开页面,就要可以默认选中某个表单元素.</p></li><li><p>maxlength 是用户可以在表单元素输入的最大字符数, 一般较少使用.</p></li></ol><p>页面中的表单元素很多，<strong>如何区别不同的表单元素</strong>?</p><p>答: name 属性：当前 input 表单的名字，后台可以通过这个 name 属性找到这个表单。页面中的表单很多，name 的主要作用就是用于区别不同的表单</p><ul><li><code>&lt;label&gt;</code></li></ul><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>核心： <code>&lt;label&gt;</code> 标签的 <code>for</code> 属性应当与相关元素的 id 属性<strong>相同</strong>。</p><ul><li><code>&lt;select&gt;</code></li></ul><p>使用场景: 在页面中，如果有<strong>多个选项</strong>让用户选择，并且想要<strong>节约页面空间</strong>时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。</p><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code> 。</p></li><li><p>在<code>&lt;option&gt;</code> 中定义 <code>selected =“selected&quot;</code> 时，当前项即为默认选中项。</p></li></ol><ul><li><code> &lt;textarea&gt;</code></li></ul><p>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签。</p><p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p><p>使用多行文本输入控件，可以输入更多的文字，该控件常见于<strong>留言板</strong>，<strong>评论</strong>。</p><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框。</p></li><li><p><code>cols=“每行中的字符数”</code> ，<code>rows=“显示的行数”</code>，我们在<strong>实际开发中不会使用，都是用 CSS 来改变大小</strong>。</p></li></ol><h2 id="六、HTML5新特性">六、HTML5新特性</h2><blockquote><p>HTML5 的新增特性主要是针对于以前的不足，增加了一些<strong>新的标签、新的表单</strong>和<strong>新的表单属性</strong>等。</p><p>这些新特性都有兼容性问题，基本是 IE9+ 以上版本的浏览器才支持，如果不考虑兼容性问题，可以大量使用这些新特性。</p><p>声明：新特性增加了很多，但是本节内容专注于开发常用的新特性。</p></blockquote><h3 id="1、新增的语义化标签">1、新增的语义化标签</h3><p>背景：以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。</p><p>新增的<strong>语义化</strong>标签：</p><ul><li><code>&lt;header&gt;</code>：头部标签</li><li><code>&lt;nav&gt;</code>：导航标签</li><li><code>&lt;article&gt;</code>：内容标签</li><li><code>&lt;section&gt;</code>：定义文档某个区域</li><li><code>&lt;aside&gt;</code>：侧边栏标签</li><li><code>&lt;footer&gt;</code>：尾部标签</li></ul><p><img src="C:/Users/GGW_2021/Desktop/%E7%AC%94%E8%AE%B0/web/html/images/Snipaste_2023-02-05_10-42-35.png" alt=""></p><p><strong>注意：</strong></p><ul><li>这种语义化标准主要是针对<strong>搜索引擎</strong>的</li><li>这些新标签页面中可以使用<strong>多次</strong></li><li>在 IE9 中，需要把这些元素转换为<strong>块级元素</strong></li><li>其实，我们移动端更喜欢使用这些标签</li><li>HTML5 还增加了很多其他标签，我们后面再慢慢学</li></ul><h3 id="2、新增的多媒体标签">2、新增的多媒体标签</h3><p>新增的多媒体标签主要包含两个：</p><ol><li><p>音频：<code>&lt;audio&gt;</code></p></li><li><p>视频：<code>&lt;video&gt; </code></p></li></ol><p>使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用 flash 和其他浏览器插件。</p><h4 id="2-1、-视频-video">2.1、 视频&lt;video&gt;</h4><p>HTML5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放，当然，支持的格式是有限的。</p><p>当前 <code>&lt;video&gt;</code> 元素支持三种视频格式： (尽量使用 mp4 格式)</p><table><thead><tr><th style="text-align:center">浏览器</th><th style="text-align:center">MP4</th><th style="text-align:center">WebM</th><th style="text-align:center">Ogg</th></tr></thead><tbody><tr><td style="text-align:center">Internet Explorer</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Chrome</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">Firefox</td><td style="text-align:center">yes<br />从Firefox 21版本开始<br />Linux系统从Firefox 30开始</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">Safari</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Opera</td><td style="text-align:center">yes<br />从Opera 25版本开始</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr></tbody></table><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>兼容写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;move.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;move.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">     您的浏览器暂不支持 <span class="tag">&lt;<span class="name">video</span>&gt;</span> 标签播放视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：浏览器是否支持ogg格式，不支持的话看是否支持MP4格式，都不支持显示：”您的浏览器暂不支持 <code>&lt;video&gt;</code> 标签播放视频“。</p><p><strong>常见属性</strong></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">autoplay</td><td style="text-align:center">autoplay</td><td>视频就绪自动播放 (谷歌浏览器需要添加muted来解决自动播放问题</td></tr><tr><td style="text-align:center">controls</td><td style="text-align:center">controls</td><td>向用户显示播放控件</td></tr><tr><td style="text-align:center">width</td><td style="text-align:center">pixels(像素)</td><td>设置播放器宽度</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">pixels(像素)</td><td>设置播放器高度</td></tr><tr><td style="text-align:center">loop</td><td style="text-align:center">loop</td><td>播放完是否继续播放该视频，循环播放</td></tr><tr><td style="text-align:center">preload</td><td style="text-align:center">preload</td><td>规定是否预加载视频(如果有了autoplay 就忽略该属性</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">url</td><td>视频url地址</td></tr><tr><td style="text-align:center">poster</td><td style="text-align:center">imgurl</td><td>加载等待的画面图片</td></tr><tr><td style="text-align:center">muted</td><td style="text-align:center">muted</td><td>静音播放</td></tr></tbody></table><h4 id="2-2、音频-audio">2.2、音频&lt;audio&gt;</h4><p>HTML5 在不使用插件的情况下，也可以原生的支持音频格式文件的播放，当然，支持的格式是有限的。</p><p>当前 <code>&lt;audio&gt;</code> 元素支持三种音频格式：</p><table><thead><tr><th style="text-align:center">浏览器</th><th style="text-align:center">MP4</th><th style="text-align:center">WebM</th><th style="text-align:center">Ogg</th></tr></thead><tbody><tr><td style="text-align:center">Internet Explorer</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Chrome</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">Firefox</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">Safari</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Opera</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr></tbody></table><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>兼容写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; audio controls=&quot;controls&quot; &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;happy.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;happy.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">您的浏览器暂不支持 <span class="tag">&lt;<span class="name">audio</span>&gt;</span> 标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：浏览器是否支持mpeg格式，不支持的话看是否支持ogg格式，都不支持显示：”您的浏览器暂不支持 <code>&lt;audio&gt;</code> 标签播放视频“。</p><p><strong>常见属性</strong></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">autoplay</td><td style="text-align:center">autoplay</td><td>如果出现该属性，则音频在就绪后马上播放</td></tr><tr><td style="text-align:center">controls</td><td style="text-align:center">controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮</td></tr><tr><td style="text-align:center">loop</td><td style="text-align:center">loop</td><td>如果出现该属性，则每当音频结束时重新开始播放</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">url</td><td>要播放的音频的 URL</td></tr></tbody></table><p><strong>谷歌浏览器把音频和视频自动播放禁止了</strong></p><p><strong>3、多媒体标签总结</strong></p><ul><li>音频标签和视频标签使用方式基本一致</li><li>浏览器支持情况不同</li><li>谷歌浏览器把音频和视频自动播放禁止了</li><li>我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过JavaScript解决）</li><li>视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性</li></ul><h3 id="3、新增的-input-类型">3、新增的 input 类型</h3><p>重点记住： number tel search 这三个。</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">type=“<code>email</code>”</td><td style="text-align:left">限制用户输入必须为Email类型</td></tr><tr><td style="text-align:center">type=“<code>url</code>”</td><td style="text-align:left">限制用户输入必须为URL类型</td></tr><tr><td style="text-align:center">type=“<code>date</code>”</td><td style="text-align:left">限制用户输入必须为日期类型</td></tr><tr><td style="text-align:center">type=“<code>time</code>”</td><td style="text-align:left">限制用户输入必须为时间类型</td></tr><tr><td style="text-align:center">type=“<code>month</code>”</td><td style="text-align:left">限制用户输入必须为月类型</td></tr><tr><td style="text-align:center">type=“<code>week</code>”</td><td style="text-align:left">限制用户输入必须为周类型</td></tr><tr><td style="text-align:center"><strong>type=</strong>“<code>number</code>”</td><td style="text-align:left"><strong>限制用户输入必须为数字类型</strong></td></tr><tr><td style="text-align:center"><strong>type=</strong>“<code>tel</code>”</td><td style="text-align:left"><strong>手机号码</strong></td></tr><tr><td style="text-align:center"><strong>type=</strong>“<code>search</code>”</td><td style="text-align:left"><strong>搜索框</strong></td></tr><tr><td style="text-align:center">type=“<code>color</code>”</td><td style="text-align:left">生成一个颜色选择表单</td></tr></tbody></table><h3 id="4、新增的表单属性">4、新增的表单属性</h3><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">值</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">required</td><td style="text-align:center">required</td><td>表单拥有该属性表示其内容不能为空，必填</td></tr><tr><td style="text-align:center"><strong>placeholder</strong></td><td style="text-align:center">提示文本</td><td>表单的提示信息，存在默认值将不显示</td></tr><tr><td style="text-align:center">autofocus</td><td style="text-align:center">autofocus</td><td>自动聚焦属性，页面加载完成自动聚焦到指定表单</td></tr><tr><td style="text-align:center">autocomplete</td><td style="text-align:center">off/on</td><td>当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项；默认已经打开，如 autocomplete=&quot;on“，关闭 autocomplete =“off”；需要放在表单内，同时加上 name 属性，同时成功提交</td></tr><tr><td style="text-align:center"><strong>multiple</strong></td><td style="text-align:center">multiple</td><td>可以多选文件提交</td></tr></tbody></table><p><strong>可以通过以下设置方式修改placeholder里面的字体颜色：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、查阅文档">七、查阅文档</h2><p>授人以鱼不如授人以渔</p><p><a href="http://www.w3school.com.cn/">【W3C】</a></p><p><a href="https://developer.mozilla.org/zh-CN/">【MDN】</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/01/26/git/"/>
      <url>/2023/01/26/git/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git概述">一、Git概述</h2><blockquote><p>  Git 是一个<strong>免费的</strong>、<strong>开源的分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种 项目。</p><p>  Git 易于学习，占地面积小，性能极快。 它具有<strong>廉价的本地库</strong>，方便的暂存区域和多个工作 流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p></blockquote><p><a href="https://git-scm.com/">【官网】</a></p><h3 id="1、什么是版本控制">1、什么是版本控制</h3><blockquote><p>  版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>  版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本， 方便版本切换。</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-32-13.png" alt=""></p><h3 id="2、为什么需要版本控制">2、为什么需要版本控制</h3><p>个人开发过渡到团队协作。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-33-57.png" alt=""></p><h3 id="3、版本控制工具">3、版本控制工具</h3><ul><li><strong>集中式版本控制工具</strong></li></ul><p>   CVS、<strong>SVN(Subversion)</strong> 、VSS……</p><p>  集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存 所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或 者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>  这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什 么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要 远比在各个客户端上维护本地数据库来得轻松容易。</p><p>  事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕 机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-40-20.png" alt=""></p><ul><li><strong>分布式版本控制工具</strong></li></ul><p>  <strong>Git</strong>、Mercurial、Bazaar、Darcs……</p><p>  像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码 仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用 其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次 对整个文件仓库的完整备份。</p><p>  分布式的版本控制系统出现之后，解决了<strong>集中式版本控制系统的缺陷</strong>:</p><p>    服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</p><p>    每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-42-49.png" alt=""></p><h3 id="4、Git简史">4、Git简史</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-46-46.png" alt=""></p><h3 id="5、Git工作机制">5、Git工作机制</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_18-56-26.png" alt=""></p><h3 id="6、Git和代码托管中心">6、Git和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><p>局域网</p><ul><li>GitLab</li></ul><p>互联网</p><ul><li>GitHub（外网）</li><li>Gitee 码云（国内网站）</li></ul><h2 id="二、Git安装">二、Git安装</h2><p><a href="https://git-scm.com/">【官网下载】</a></p><p>1、查看 <strong>GNU</strong> 协议，可以直接点击下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-03-04.png" alt=""></p><p>2、选择 Git 安装位置，要求是<strong>非中文并且没有空格</strong>的目录，然后下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-04-41.png" alt=""></p><p>3、Git 选项配置，<strong>推荐默认设置</strong>，然后下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-05-43.png" alt=""></p><p>4、Git 安装目录名，<strong>不用修改</strong>，直接点击下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-06-49.png" alt=""></p><p>5、Git 的默认编辑器，<strong>建议使用默认的 Vim 编辑器</strong>，然后点击下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-07-53.png" alt=""></p><p>6、<strong>默认分支名设置</strong>，选择让 Git 决定，分支名<strong>默认为 master</strong>，下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-08-42.png" alt=""></p><p>7、修改 Git 的环境变量，选第一个，不修改环境变量，<strong>只在 Git Bash 里使用 Git</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-09-42.png" alt=""></p><p>8、选择后台客户端连接协议，<strong>选默认值 OpenSSL</strong>，然后下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-10-25.png" alt=""></p><p>9、配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，<strong>选择第一个自动转换</strong>，然后继续下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-11-22.png" alt=""></p><p>10、选择 Git 终端类型，选择<strong>默认的 Git Bash 终端</strong>，然后继续下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-12-17.png" alt=""></p><p>11、选择 Git pull 合并的模式，<strong>选择默认</strong>，然后下一步。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-13-03.png" alt=""></p><p>12、选择 Git 的凭据管理器，<strong>选择默认</strong>的跨平台的凭据管理器，然后下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-13-54.png" alt=""></p><p>13、其他配置，<strong>选择默认</strong>设置，然后下一步</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-14-37.png" alt=""></p><p>14、实验室功能，技术还不成熟，有已知的 bug，<strong>不要勾选</strong>，然后点击右下角的 Install 按钮，开始安装 Git。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-15-25.png" alt=""></p><p>15、点击 Finsh 按钮，<strong>Git 安装成功</strong>！</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-16-11.png" alt=""></p><p>16、右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-18-13.png" alt=""></p><p>17、在 Git Bash 终端里输入 <code>git --version</code> 查看 git 版本，如图所示，说明 Git 安装成功。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_19-21-32.png" alt=""></p><h2 id="三、Git常用命令">三、Git常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git config --global user.name 用户名</code></td><td>设置用户签名</td></tr><tr><td><code>git config --global user.email 邮箱</code></td><td>设置用户签名</td></tr><tr><td><code>git init</code></td><td>初始化本地仓库</td></tr><tr><td><code>git status</code></td><td>查看本地仓库状态</td></tr><tr><td><code>git add</code></td><td>添加到暂存区</td></tr><tr><td><code>git commit -m &quot;日志信息&quot; 文件名</code></td><td>提交到本地库</td></tr><tr><td><code>git reflog</code></td><td>查看历史记录</td></tr><tr><td><code>git reset --hard 版本号</code></td><td>版本穿梭</td></tr></tbody></table><h3 id="1、设置或修改用户签名">1、设置或修改用户签名</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure><p>查看用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>说明：</p><p>  签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看 到，以此确认本次提交是谁做的。<strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号<strong>没有任何关系</strong>。</p><h3 id="2、初始化本地库">2、初始化本地库</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-00-42.png" alt=""></p><h3 id="3、查看本地库状态">3、查看本地库状态</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-09-05.png" alt=""></p><h3 id="4、添加暂存区">4、添加暂存区</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-11-59.png" alt=""></p><h3 id="5、提交本地库">5、提交本地库</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;日志信息&quot;</span> 文件名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-18-19.png" alt=""></p><h3 id="6、修改文件再查看状态">6、修改文件再查看状态</h3><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-24-17.png" alt=""></p><p>git add -&gt; git commit后，本地库状态变为 没有文件需要提交</p><h3 id="7、查看历史版本">7、查看历史版本</h3><p>基本语法</p><p>查看版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>查看版本详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-30-29.png" alt=""></p><h3 id="8、版本穿梭">8、版本穿梭</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_20-40-01.png" alt=""></p><p>Git 切换版本，底层其实是移动的 HEAD 指针，具体原理如下图所示</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_21-27-26.png" alt=""></p><h2 id="四、Git-分支操作">四、Git 分支操作</h2><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_21-33-39.png" alt=""></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git branch 分支名</code></td><td>创建分支</td></tr><tr><td><code>git branch -v</code></td><td>查看分支</td></tr><tr><td><code>git checkout 分支名</code></td><td>切换分支</td></tr><tr><td><code>git merge 分支名</code></td><td>把指定分支合并到当前分支上</td></tr></tbody></table><h3 id="1、什么是分支">1、什么是分支</h3><p>  在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独 分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时 候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是 一个单独的副本。（分支底层其实也是指针的引用）</p><p><strong>分支的好处</strong>：</p><p>  同时并行推进多个功能开发，提高开发效率。各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="2、查看分支">2、查看分支</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_21-44-14.png" alt=""></p><h3 id="3、创建分支">3、创建分支</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_21-47-02.png" alt=""></p><h3 id="4、修改分支">4、修改分支</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_21-54-28.png" alt=""></p><h3 id="5、切换分支">5、切换分支</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-02-50.png" alt=""></p><h3 id="6、合并分支">6、合并分支</h3><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><p><strong>案例：冲突合并</strong></p><p>冲突产生的表现：后面状态为 MERGING</p><p>冲突产生的原因： 合并分支时，两个分支在<strong>同一个文件的同一个位置有两套完全不同的修改</strong>。Git 无法替 我们决定使用哪一个。<strong>必须人为决定</strong>新代码内容。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-18-13.png" alt=""></p><p><strong>解决合并冲突</strong></p><p>1、编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD </span><br><span class="line">当前分支的代码</span><br><span class="line">=======</span><br><span class="line">合并过来的代码 </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span></span><br></pre></td></tr></table></figure><p>2、添加到暂存区，提交到本地库，这样就完成了</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-30-49.png" alt=""></p><h3 id="7、创建分支和切换分支图解">7、创建分支和切换分支图解</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-38-16.png" alt=""></p><p>  master、dog其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。<br>  HEAD 如果指向 master，那么我们现在就在 master 分支上。<br>  HEAD 如果执行 dog，那么我们现在就在 dog 分支上。</p><h2 id="五、团队协作机制">五、团队协作机制</h2><h3 id="1、团队内协作">1、团队内协作</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-49-12.png" alt=""></p><h3 id="2、跨团队协作">2、跨团队协作</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_22-55-05.png" alt=""></p><h2 id="六、github远程库">六、github远程库</h2><h3 id="1、创建仓库">1、创建仓库</h3><p><a href="https://github.com/">【github官网】</a></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_23-03-11.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_23-05-15.png" alt=""></p><h3 id="2、远程仓库操作">2、远程仓库操作</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git remote -V</code></td><td>查看当前所有远程库的别名</td></tr><tr><td><code>git remote add 别名 远程库地址</code></td><td>起别名</td></tr><tr><td><code>git push 别名 分支</code></td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td><code>git clone 远程库地址</code></td><td>将远程仓库的内容克隆到本地</td></tr><tr><td><code>git pull 远程库地址(或别名) 远程分支名</code></td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h3 id="3、邀请加入团队">3、邀请加入团队</h3><p>1、选择邀请合作者</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_23-13-04.png" alt=""></p><p>2、填入想要合作的人</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/git/Snipaste_2023-01-26_23-14-57.png" alt=""></p><p>3、复制地址并发送给这个人（QQ，微信）</p><p>4、这个人点击邀请的链接，接受邀请</p><p>5、这个人可以修改内容并 push 到远程仓库</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-学生学习管理系统</title>
      <link href="/2023/01/19/python-%E5%AD%A6%E6%9C%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/01/19/python-%E5%AD%A6%E6%9C%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wD4y1o7AS?t=236.5&amp;p=135">【B站网课】</a></p><p><a href="https://github.com/ggw2021/StudentSystem">【我的项目文件】</a></p><h2 id="一、需求分析">一、需求分析</h2><p><strong>学生信息管理系统应具备的功能</strong></p><ul><li>添加学术以及添加学生的成绩信息</li><li>将学生信息保存到文件中</li><li>修改和删除学生信息</li><li>查询学生信息</li><li>根据学生成绩进行排序</li><li>统计学生的总分</li></ul><h2 id="二、系统设计">二、系统设计</h2><p><strong>系统功能的六个模块</strong></p><ul><li>1、录入学生信息模块</li><li>2、查找学生信息模块</li><li>3、删除学生信息模块</li><li>4、修改学生信息模块</li><li>5、统计学生总人数模块</li><li>6、显示全部学生信息模块</li></ul><p><strong>系统功能</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-03-41.png" alt=""></p><p><strong>业务流程</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-11-50.png" alt=""></p><p><strong>项目文件</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-20-50.png" alt=""></p><h2 id="三、主函数设计">三、主函数设计</h2><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-14-58.png" alt=""></p><p><strong>实现主函数</strong></p><table><thead><tr><th style="text-align:center">编号</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td>退出系统</td></tr><tr><td style="text-align:center">1</td><td>显示所有的学生信息，调用show()函数</td></tr><tr><td style="text-align:center">2</td><td>录入学生信息，调用insert()函数</td></tr><tr><td style="text-align:center">3</td><td>查找学生信息，调用search()函数</td></tr><tr><td style="text-align:center">4</td><td>删除学生信息，调用delete()函数</td></tr><tr><td style="text-align:center">5</td><td>修改学生信息，调用modify()函数</td></tr><tr><td style="text-align:center">6</td><td>统计学生总人数，调用total()函数</td></tr></tbody></table><h3 id="代码">代码</h3><p>在文件<strong><a href="http://studentsystem.py">studentsystem.py</a></strong>中实现</p><p>菜单函数 <strong>menu()</strong> 在infoQuery.py文件中</p><p>内容在<strong>五、信息查询</strong>中</p><h2 id="四、信息管理">四、信息管理</h2><h3 id="1、录入学生信息">1、录入学生信息</h3><p>可以一直添加再退出</p><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-34-57.png" alt=""></p><h3 id="2、删除学生信息">2、删除学生信息</h3><p>删除完成后，将显示所有学生</p><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-41-10.png" alt=""></p><h3 id="3、修改学生信息">3、修改学生信息</h3><p>所有内容均可修改</p><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-43-22.png" alt=""></p><h3 id="代码-2">代码</h3><p>在文件<strong><a href="http://infoMag.py">infoMag.py</a></strong>中实现</p><h2 id="五、信息查询">五、信息查询</h2><h3 id="1、显示所有学生信息">1、显示所有学生信息</h3><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-38-17.png" alt=""></p><h3 id="2、查找学生信息">2、查找学生信息</h3><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-49-25.png" alt=""></p><h3 id="3、统计学生总人数">3、统计学生总人数</h3><p><strong>预期结果</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/studentsMsg/Snipaste_2023-01-19_22-50-45.png" alt=""></p><h4 id="代码-3">代码</h4><p><strong>在文件infoQuery.py中实现</strong></p><h2 id="六、项目打包">六、项目打包</h2><p><strong>安装第三方模块 PyInstall</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PyInstaller</span><br></pre></td></tr></table></figure><p>结果需要等待下载安装一段时间</p><p><strong>执行打包操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F 主程序文件</span><br></pre></td></tr></table></figure><p>本项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F studentsystem.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows DOS命令\批处理脚本学习(进行中)</title>
      <link href="/2023/01/14/DOS%E5%91%BD%E4%BB%A4%20%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/14/DOS%E5%91%BD%E4%BB%A4%20%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、带入">一、带入</h2><p><a href="https://www.bilibili.com/video/BV1Qv411q7bN?t=137.3">B站视频</a></p><p>由于脚本中 @ECHO 后面没有参数。而没有 参数的 ECHO, 会把当前脚本 ECHO 命令行的状态(ON/OFF)显示出来，显示出的结果也就是：ECHO is off/ECHO is on.</p><p>解决：加上<code>@echo off</code></p><p><strong>清屏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure><h2 id="二-、批处理运算操作">二 、批处理运算操作</h2><h3 id="1、算数运算">1、算数运算</h3><p>（1）命令模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> \a 表达式</span><br></pre></td></tr></table></figure><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_00-07-26.png" alt=""></p><p>（2）文本模式</p><p>案例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> /a var = 1 + 2</span><br><span class="line"><span class="built_in">echo</span> %var%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_00-29-05.png" alt=""></p><h3 id="2、重定向操作运算">2、重定向操作运算</h3><p>（1）&gt;、&gt;&gt; 效果同Linux</p><p>（2）&lt;、&lt;&lt; 效果同Linux</p><p><strong>查看文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> 文件</span><br></pre></td></tr></table></figure><p>案例</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_00-35-45.png" alt=""></p><h3 id="3、多命令运算">3、多命令运算</h3><p><code>&amp;&amp;</code>、<code>||</code> 效果同c语言，使用其短路的特性</p><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_00-40-20.png" alt=""></p><h3 id="4、管道运算">4、管道运算</h3><p><strong>查看当前目录下文件和目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span></span><br></pre></td></tr></table></figure><p><code>|</code>效果同linux</p><h2 id="三、批处理基本命令">三、批处理基本命令</h2><h3 id="1、命令格式">1、命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 子命令 参数 操作</span><br></pre></td></tr></table></figure><p>命令帮助查看<code>/?</code>、<code>/help</code></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_00-52-56.png" alt=""></p><h3 id="2、批处理文件接收参数">2、批处理文件接收参数</h3><p>同linux，格式略微不同%n（n个参数）</p><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_01-04-42.png" alt=""></p><h3 id="3、注释">3、注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rem 注释内容</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:: 注释内容</span><br></pre></td></tr></table></figure><h3 id="4、装逼命令提示符窗口">4、装逼命令提示符窗口</h3><p>没啥用</p><p><strong>颜色命令</strong></p><p>先查看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color /?</span><br></pre></td></tr></table></figure><p>再自己设置成啥样，修改前景色，背景色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color 0a</span><br></pre></td></tr></table></figure><p>变成黑色背景，绿色字体啦（关掉再开就没了）</p><p><strong>修改标题命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title 标题</span><br></pre></td></tr></table></figure><h3 id="5、时间相关的命令">5、时间相关的命令</h3><p><strong>date</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> /t</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-01-14</span><br></pre></td></tr></table></figure><p><strong>time</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time /t</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01:19</span><br></pre></td></tr></table></figure><h3 id="6、启动命令">6、启动命令</h3><p><strong>start</strong></p><p>运行bat文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start .bat文件</span><br></pre></td></tr></table></figure><p>打开一个title为“hello”的cmd窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="7、调用其他bat文件">7、调用其他bat文件</h3><p>同linux，略有区别</p><p>案例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> /a var = %1 + %2</span><br><span class="line"><span class="built_in">echo</span> %var%</span><br><span class="line">call demo.bat %1</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>结果为</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/windows/Snipaste_2023-01-14_01-42-58.png" alt=""></p><p><a href="https://www.bilibili.com/video/BV1Qv411q7bN?t=8.4&amp;p=13">接着看</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析numpy、matplotlib、pandas（pandas还没学）</title>
      <link href="/2023/01/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2023/01/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Jt4y1h7Vt?t=1.4">【视频资源】</a></p><h2 id="一、了解数据分析以及环境安装">一、了解数据分析以及环境安装</h2><h3 id="1、流程">1、流程</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-20_16-10-05.png" alt=""></p><h3 id="2、anaconda">2、anaconda</h3><p><a href="https://www.anaconda.com/">【官网下载】</a></p><p>基本上一路next即可，需要修改的地方自己注意</p><p><strong>如果没有配置环境变量的话：</strong></p><p>经典操作：右键此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量</p><p>先添加一个变量，内容是安装的目录</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-20_18-46-28.png" alt=""></p><p>然后向path变量中添加</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-20_18-47-38.png" alt=""></p><p>测试是否成功，执行结果出现版本号即为成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure><h3 id="3、jupyter">3、jupyter</h3><blockquote><p>Jupyter是一个交互式的开发环境，是基于Web的代码笔记本<br>交互性、探索性的高效环境<br>每一步骤都能看到结果，很方便的查看之前的结果</p></blockquote><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><p>打开：（可以在自己想要的工作目录下输入，只存放相关的为文件，jupyter的根目录就是当前工作路径）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h2 id="二、介绍与安装模块">二、介绍与安装模块</h2><p>以下使用的是清华镜像源</p><ul><li><strong>numpy</strong></li></ul><p>介绍</p><blockquote><p>NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">多维数组</a>对象和用于处理数组的例程集合组成的库。</p><p>使用NumPy，开发人员可以执行以下操作：</p><ul><li>数组的算数和逻辑运算。</li><li>傅立叶变换和用于图形操作的例程。</li><li>与线性代数有关的操作。 NumPy 拥有线性代数和随机数生成的内置函数。</li></ul><p>为什么使用NumPy?</p><ul><li>对于同样的数值计算任务，使用Numpy比直接Python代码实现，优点:<ul><li>代码更简洁: Numpy直接以数组、矩阵为粒度计算并且支撑大量的数学函数，而python需要用for循环从底层实现;</li><li>性能更高效: Numpy的数组存储效率和输入输出计算性能，比Python使用List或者嵌套List好很多;<ul><li>注: Numpy的数据存储和Python原生的List是不一样的</li><li>注: <strong>Numpy的大部分代码都是C语言实现的，这是Numpy比纯Python代码高效的原因</strong></li></ul></li></ul></li><li>Numpy是Python各种数据科学类库的基础库<ul><li>比如: Scipy，Scikit-Learn、TensorFlow，pandas等</li></ul></li></ul></blockquote><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy</span><br></pre></td></tr></table></figure><ul><li><strong>pandas</strong><br>介绍</li></ul><blockquote><p><code>pandas</code> 是对表格数据模型在python上的模拟，它有简单的像<code>SQL</code> 对数据的处理，能够方便的在python上实现。</p></blockquote><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas</span><br></pre></td></tr></table></figure><ul><li><strong>matplotlib</strong></li></ul><p>介绍</p><blockquote><p>Matplotlib 是一个用于在 Python 中绘制数组的 2D 图形库。虽然它起源于模仿 MATLAB 图形命令，但它独立于 MATLAB，可以以 Pythonic 和面向对象的方式使用。虽然 Matplotlib 主要是在纯 Python 中编写的，但它大量使用 NumPy 和其他扩展代码，即使对于大型数组也能提供良好的性能。</p></blockquote><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib</span><br></pre></td></tr></table></figure><h2 id="三、numpy">三、numpy</h2><h3 id="1、Ndarray-对象">1、Ndarray 对象</h3><blockquote><ul><li>NumPy 中定义的<strong>最重要的对象</strong>是称为 <code>ndarray</code> 的 N 维数组类型。 它描述<strong>相同类型的元素集合</strong>。 可以使用基于零的索引访问集合中的项目。</li><li><code>ndarray</code>中的每个元素在内存中使用相同大小的块。 <code>ndarray</code>中的每个元素是数据类型对象的对象（称为 <code>dtype</code>）。</li><li>从<code>ndarray</code>对象提取的任何元素（通过切片）由一个数组标量类型的 Python 对象表示。 下图显示了<code>ndarray</code>，数据类型对象（<code>dtype</code>）和数组标量类型之间的关系。<br><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/ndarray.png" alt=""></li></ul></blockquote><p><strong>创建：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>构造器参数：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>object</code></td><td style="text-align:left">任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。</td></tr><tr><td style="text-align:center"><code>dtype</code></td><td style="text-align:left">数组的所需数据类型，可选。（默认自动识别）</td></tr><tr><td style="text-align:center"><code>copy</code></td><td style="text-align:left">可选，默认为<code>true</code>，对象是否被复制。</td></tr><tr><td style="text-align:center"><code>order</code></td><td style="text-align:left"><code>C</code>（按行）、<code>F</code>（按列）或 <code>A</code>（任意，默认）。</td></tr><tr><td style="text-align:center"><code>subok</code></td><td style="text-align:left">默认情况下，返回的数组被强制为基类数组。 如果为<code>true</code>，则返回子类。</td></tr><tr><td style="text-align:center"><code>ndmin</code></td><td style="text-align:left">指定返回数组的最小维数。</td></tr></tbody></table><p><strong>案例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array1:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="comment"># --- ndim ---------</span></span><br><span class="line">array2 = np.array([<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], ndmin=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array2:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line">array3 = np.array([<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], ndmin=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array3:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array3)</span><br><span class="line"><span class="comment"># --- dtype -----------</span></span><br><span class="line">array4 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=<span class="built_in">complex</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array4:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array4)</span><br><span class="line"><span class="comment"># --- 数据类型不同的话，则都会转变成内存最大的类型 ---</span></span><br><span class="line">array5 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array5:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array5)</span><br><span class="line"><span class="comment"># --- copy (默认为True) -------</span></span><br><span class="line">array6 = np.array(array1)</span><br><span class="line"><span class="comment"># array6 = array1.copy()    # 效果相同</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;copy的结果:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(array1), <span class="built_in">id</span>(array6))</span><br><span class="line"><span class="comment"># --- subok -------</span></span><br><span class="line">mat = np.mat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># 创建一个矩阵</span></span><br><span class="line">array7 = np.array(mat, subok=<span class="literal">False</span>)</span><br><span class="line">array8 = np.array(mat, subok=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;subok:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;为False:&#x27;</span>, <span class="built_in">type</span>(array7))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;为True:&#x27;</span>, <span class="built_in">type</span>(array8))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">array1:</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [2 3 4]]</span><br><span class="line">array2:</span><br><span class="line">[[1 2 3 4 5]]</span><br><span class="line">array3:</span><br><span class="line">[[[1 2 3 4 5]]]</span><br><span class="line">array4:</span><br><span class="line">[1.+0.j 2.+0.j 3.+0.j]</span><br><span class="line">array5:</span><br><span class="line">[&#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27;]</span><br><span class="line">copy的结果:</span><br><span class="line">2963333225808 2963506355824</span><br><span class="line">subok:</span><br><span class="line">为True: &lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line">为False: &lt;class &#x27;numpy.matrix&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="2、NumPy-数据类型">2、NumPy - 数据类型</h3><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">数据类型</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><code>bool</code></td><td>存储为一个字节的布尔值（真或假）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>int</code></td><td>默认整数，相当于 C 的<code>long</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><code>intc</code></td><td>相当于 C 的<code>int</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><code>intp</code></td><td>用于索引的整数，相当于 C 的<code>size_t</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><code>int8</code></td><td>字节（-128 ~ 127）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><code>int16</code></td><td>16 位整数（-32768 ~ 32767）</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><code>int32</code></td><td>32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"><code>int64</code></td><td>64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"><code>uint8</code></td><td>8 位无符号整数（0 ~ 255）</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"><code>uint16</code></td><td>16 位无符号整数（0 ~ 65535）</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"><code>uint32</code></td><td>32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"><code>uint64</code></td><td>64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"><code>float</code></td><td><code>float64</code>的简写</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"><code>float16</code></td><td>半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><code>float32</code></td><td>单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center"><code>float64</code></td><td>双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center"><code>complex</code></td><td><code>complex128</code>的简写</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center"><code>complex64</code></td><td>复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center"><code>complex128</code></td><td>复数，由两个 64 位浮点表示（实部和虚部）</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center"><code>str</code></td><td>字符串类型</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center"><code>string</code></td><td>字符串类型，也就是byte类型</td></tr></tbody></table><p>NumPy 数字类型是<code>dtype</code>（数据类型）对象的实例，每个对象具有唯一的特征。 这些类型可以是<code>np.bool</code>，<code>np.float32</code>等。</p><p><strong>简写</strong></p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">对应类型</th><th style="text-align:center">字符</th><th style="text-align:center">对应类型</th><th style="text-align:center">字符</th><th style="text-align:center">对应类型</th><th style="text-align:center">字符</th><th style="text-align:center">对应类型</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">布尔值</td><td style="text-align:center">i</td><td style="text-align:center">带符号整形</td><td style="text-align:center">u</td><td style="text-align:center">无符号整形</td><td style="text-align:center">f</td><td style="text-align:center">浮点型</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">复数浮点型</td><td style="text-align:center">m</td><td style="text-align:center">时间间隔(timedelta)</td><td style="text-align:center">M</td><td style="text-align:center">日期时间(datatime)</td><td style="text-align:center">O</td><td style="text-align:center">Python对象</td></tr><tr><td style="text-align:center">S, a</td><td style="text-align:center">字符串</td><td style="text-align:center">U</td><td style="text-align:center">Unicode</td><td style="text-align:center">V</td><td style="text-align:center">原始数据类型</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>还可以将两个字符作为参数传给数据类型的构造函数。此时，第一个字符表示数据类型，第二个字符表示该类型在内存中占用的字节数（f2、f4、f8分别表示16、32、64位浮点数）<a href="https://www.bilibili.com/video/BV1Jt4y1h7Vt?t=3.9&amp;p=26">数据类型长度如何选择</a></p><h4 id="数据类型对象-dtype">数据类型对象 (dtype)</h4><blockquote><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li>数据类型（整数、浮点或者 Python 对象）</li><li>数据大小</li><li>字节序（小端或大端）</li><li>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</li><li>如果数据类型是子序列，它的形状和数据类型。</li></ul><p>字节顺序取决于数据类型的前缀<code>&lt;</code>或<code>&gt;</code>。 <code>&lt;</code>意味着编码是小端（最小有效字节存储在最小地址中）。 <code>&gt;</code>意味着编码是大端（最大有效字节存储在最小地址中）。</p></blockquote><p><code>dtype</code>可由一下<strong>语法构造</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure><p>参数为：</p><ul><li><code>Object</code>：被转换为数据类型的对象。</li><li><code>Align</code>：如果为<code>true</code>，则向字段添加间隔，使其类似 C 的结构体。</li><li><code>Copy</code> ： 生成<code>dtype</code>对象的新副本，如果为<code>flase</code>，结果是内建数据类型对象的引用。</li></ul><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用数组标量类型  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">dt1 = np.dtype(np.int32)</span><br><span class="line"><span class="built_in">print</span>(dt1, <span class="built_in">type</span>(dt1))</span><br><span class="line"><span class="comment"># int8，int16，int32，int64 可替换为等价的字符串 &#x27;i1&#x27;，&#x27;i2&#x27;，&#x27;i4&#x27;，以及其他。</span></span><br><span class="line">dt2 = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dt2, <span class="built_in">type</span>(dt2))</span><br><span class="line"><span class="comment"># 使用端记号</span></span><br><span class="line">dt3 = np.dtype(<span class="string">&#x27;&gt;i4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dt3, <span class="built_in">type</span>(dt3))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 &lt;class &#x27;numpy.dtype[int32]&#x27;&gt;</span><br><span class="line">int32 &lt;class &#x27;numpy.dtype[int32]&#x27;&gt;</span><br><span class="line">&gt;i4 &lt;class &#x27;numpy.dtype[int32]&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>以下示例定义名为 <strong>student</strong> 的<strong>结构化</strong>数据类型，其中包含字符串字段<code>name</code>，<strong>整数字段</strong><code>age</code>和<strong>浮点字段</strong><code>marks</code>。 此<code>dtype</code>应用于<code>ndarray</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就类似结构体定义</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S20&#x27;</span>),  (<span class="string">&#x27;age&#x27;</span>,  <span class="string">&#x27;i1&#x27;</span>),  (<span class="string">&#x27;marks&#x27;</span>,  <span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(student)</span><br><span class="line">array = np.array([<span class="built_in">tuple</span>([<span class="string">&#x27;abc&#x27;</span>,  <span class="number">21</span>,  <span class="number">50</span>]),(<span class="string">&#x27;xyz&#x27;</span>,  <span class="number">18</span>,  <span class="number">75</span>)], dtype=student)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;name&#x27;, &#x27;S20&#x27;), (&#x27;age&#x27;, &#x27;i1&#x27;), (&#x27;marks&#x27;, &#x27;&lt;f4&#x27;)]</span><br><span class="line">[(b&#x27;abc&#x27;, 21, 50.) (b&#x27;xyz&#x27;, 18, 75.)]</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array(<span class="built_in">range</span>(<span class="number">10</span>), dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)   <span class="comment"># 输出为 [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">array2 = np.array(<span class="built_in">range</span>(<span class="number">10</span>), dtype=<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)   <span class="comment"># 输出为 [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]</span></span><br></pre></td></tr></table></figure><h3 id="3、NumPy-数组属性">3、NumPy - 数组属性</h3><ul><li><code>shape</code></li></ul><p>这一数组属性返回一个包含数组维度的元组，它也可以用于调整数组大小。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(array.shape, <span class="built_in">id</span>(array))</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 调整数组</span></span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array.shape, <span class="built_in">id</span>(array))</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 没有产生新的对象</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(2, 3) 2083924122672</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">(3, 2) 2083924122672</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br></pre></td></tr></table></figure><ul><li><code>reshape()</code></li></ul><p>NumPy 也提供了<code>reshape()</code>函数来调整数组大小。</p><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">    </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">b = a.reshape(<span class="number">3</span>,<span class="number">2</span>)<span class="comment"># 未改变a</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2] </span><br><span class="line"> [3, 4] </span><br><span class="line"> [5, 6]]</span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>)</span><br><span class="line"><span class="comment"># 现在调整其大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)    <span class="comment"># b 现在拥有三个维度</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[ 0  1  2]</span><br><span class="line">  [ 3  4  5]</span><br><span class="line">  [ 6  7  8]</span><br><span class="line">  [ 9 10 11]]</span><br><span class="line"></span><br><span class="line"> [[12 13 14]</span><br><span class="line">  [15 16 17]</span><br><span class="line">  [18 19 20]</span><br><span class="line">  [21 22 23]]]</span><br></pre></td></tr></table></figure><ul><li><p><code>ndarray.ndim</code></p><p>这一数组属性返回数组的维数。</p></li><li><p><code>numpy.itemsize</code></p><p>这一数组属性返回数组中每个元素的字节单位长度。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], dtype=<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.ndim, array.itemsize)   <span class="comment"># 输出为 2 4</span></span><br></pre></td></tr></table></figure><ul><li><p><code>numpy.size</code></p><p>元素总个数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(array.size)<span class="comment"># 输出为 6</span></span><br></pre></td></tr></table></figure><ul><li><p><code>numpy.dtype</code></p><p>元素类型</p></li><li><p><code>numpy.astype()</code></p><p>numpy数据类型转换，返回数据类型修改后的数据，但是原数据类型不变</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayA = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(arrayA.dtype)                 <span class="comment"># 输出为 int32</span></span><br><span class="line">arrayB = arrayA.astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayA.dtype, arrayB.dtype)   <span class="comment"># 输出为 int32 float64</span></span><br></pre></td></tr></table></figure><h3 id="4、NumPy-创建数组">4、NumPy - 创建数组</h3><blockquote><p>新的<code>ndarray</code>对象可以通过任何下列数组创建例程或使用低级<code>ndarray</code>构造函数构造。</p></blockquote><ul><li><code>numpy.empty()</code></li></ul><p>它创建指定形状和<code>dtype</code>的未初始化数组。 它使用以下构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>shape</code> 空数组的形状，<strong>整数或整数元组</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>dtype</code> 所需的输出数组类型，可选</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>order</code> <code>'C'</code>为按行的 C 风格数组，<code>'F'</code>为按列的 Fortran 风格数组</td></tr></tbody></table><p><strong>案例</strong></p><p>下面的代码展示空数组的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.empty((<span class="number">3</span>,<span class="number">2</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># array1 = np.empty([3,2], dtype=int)   # 效果同上</span></span><br><span class="line"><span class="built_in">print</span>(array1)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[22649312    1701344351] </span><br><span class="line"> [1818321759  1885959276] </span><br><span class="line"> [16779776    156368896]]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：数组元素为随机值，因为它们<strong>未初始化</strong>。</p><ul><li><code>numpy.zeros() </code> /  <code>numpy.ones()</code></li></ul><p>返回特定大小，以 0 / 1 填充的新数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>Shape</code> 空数组的形状，整数或整数元组</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>Dtype</code> 所需的输出数组类型，可选</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>Order</code> <code>'C'</code>为按行的 C 风格数组，<code>'F'</code>为按列的 Fortran 风格数组</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.zeros(<span class="number">5</span>)     <span class="comment"># 含有 5 个 0 的数组，默认类型为 float</span></span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.zeros((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])</span><br><span class="line">array3 = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype=dt)</span><br><span class="line"><span class="built_in">print</span>(array3)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0. 0. 0. 0. 0.]</span><br><span class="line">[[0. 0.]</span><br><span class="line"> [0. 0.]]</span><br><span class="line">[[(b&#x27;&#x27;, 0) (b&#x27;&#x27;, 0)]</span><br><span class="line"> [(b&#x27;&#x27;, 0) (b&#x27;&#x27;, 0)]]</span><br></pre></td></tr></table></figure><h3 id="5、NumPy-来自现有数据的数组">5、NumPy - 来自现有数据的数组</h3><blockquote><p>这一章中，我们会讨论如何从现有数据创建数组。</p></blockquote><ul><li><code>numpy.asarray()</code></li></ul><p>此函数类似于<code>numpy.array</code>，除了它有较少的参数。 这个例程对于将 Python 序列转换为<code>ndarray</code>非常有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.asarray(a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>a</code> 任意形式的输入参数，比如列表、列表的元组、元组、元组的元组、元组的列表</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>dtype</code> 通常，输入数据的类型会应用到返回的<code>ndarray</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>order</code> <code>'C'</code>为按行的 C 风格数组，<code>'F'</code>为按列的 Fortran 风格数组</td></tr></tbody></table><p>下面的例子展示了如何使用<code>asarray</code>函数：</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将列表转换为 ndarray</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">array1 = np.asarray(lst1)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">lst2 = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">array2 = np.asarray(lst2)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3]</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.frombuffer()</code></li></ul><p>此函数将缓冲区解释为一维数组。 暴露缓冲区接口的任何对象都用作参数来返回<code>ndarray</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>buffer</code> 任何暴露缓冲区借口的对象</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>dtype</code> 返回数组的数据类型，默认为<code>float</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>count</code> 需要读取的数据数量，默认为<code>-1</code>，读取所有数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>offset</code> 需要读取的起始位置，默认为<code>0</code></td></tr></tbody></table><p><strong>案例</strong></p><p>下面的例子展示了<code>frombuffer</code>函数的用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lst = <span class="string">b&#x27;helloworld&#x27;</span></span><br><span class="line">array = np.frombuffer(lst, dtype=<span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b&#x27;h&#x27; b&#x27;e&#x27; b&#x27;l&#x27; b&#x27;l&#x27; b&#x27;o&#x27; b&#x27;w&#x27; b&#x27;o&#x27; b&#x27;r&#x27; b&#x27;l&#x27; b&#x27;d&#x27;]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.fromiter()</code></li></ul><p>此函数从任何可迭代对象构建一个<code>ndarray</code>对象，返回一个新的一维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:left"><code>iterable</code> 任何可迭代对象</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:left"><code>dtype</code> 返回数组的数据类型</td></tr><tr><td style="text-align:center">3.</td><td style="text-align:left"><code>count</code> 需要读取的数据数量，默认为<code>-1</code>，读取所有数据</td></tr></tbody></table><p>以下示例展示了如何使用内置的<code>range()</code>函数返回列表对象。 此列表的迭代器用于形成<code>ndarray</code>对象。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从列表中获得迭代器</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lst = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">it = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="comment"># 使用迭代器创建 ndarray</span></span><br><span class="line"><span class="comment"># iter() 方法是python的内置函数，它可以将字符串、列表、元组等容器变成迭代器</span></span><br><span class="line">x = np.fromiter(it, dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)    <span class="comment"># 输出为 [0. 1. 2. 3. 4.]</span></span><br></pre></td></tr></table></figure><h3 id="6、NumPy-来自数值范围的数组">6、NumPy - 来自数值范围的数组</h3><blockquote><p>这一章中，我们会学到如何从数值范围创建数组。</p></blockquote><ul><li><code>numpy.arange()</code></li></ul><p>这个函数返回<code>ndarray</code>对象，包含给定范围内的等间隔值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>start</code> 范围的起始值，默认为<code>0</code></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>stop</code> 范围的终止值（不包含）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>step</code> 两个值的间隔，默认为<code>1</code></td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>dtype</code> 返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table><p>下面的例子展示了如何使用该函数：</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)    <span class="comment"># 输出为 [0 1 2 3 4]</span></span><br><span class="line"><span class="comment"># 设置了 dtype</span></span><br><span class="line">array2 = np.arange(<span class="number">5</span>, dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)    <span class="comment"># 输出为 [0. 1. 2. 3. 4.]</span></span><br></pre></td></tr></table></figure><ul><li><code>numpy.linspace()</code></li></ul><p>此函数类似于<code>arange()</code>函数。 在此函数中，指定了范围之间的均匀间隔数量，而不是步长。 此函数的用法如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num, endpoint, retstep, dtype)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>start</code> 序列的起始值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>stop</code> 序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于序列中</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>num</code> 要生成的等间隔样例数量，默认为<code>50</code></td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>endpoint</code> 序列中是否包含<code>stop</code>值，默认为<code>ture</code></td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><code>retstep</code> 如果为<code>true</code>，返回样例，以及连续数字之间的步长</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><code>dtype</code> 输出<code>ndarray</code>的数据类型</td></tr></tbody></table><p>下面的例子展示了<code>linspace()</code>函数的用法。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)    <span class="comment"># 输出为 [10.  12.5 15.  17.5 20. ]</span></span><br><span class="line">array2 = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)    <span class="comment"># 输出为 [10. 12. 14. 16. 18.]</span></span><br><span class="line"><span class="comment"># 输出 retstep 值 </span></span><br><span class="line">array3 = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint=<span class="literal">False</span>, retstep=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(array3)    <span class="comment"># 输出为 (array([10., 12., 14., 16., 18.]), 2.0)</span></span><br></pre></td></tr></table></figure><ul><li><code>numpy.logspace()</code></li></ul><p>此函数返回一个<code>ndarray</code>对象，其中包含在对数刻度上均匀分布的数字。 刻度的开始和结束端点是某个底数的幂，通常为 10。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.logscale(start, stop, num, endpoint, base, dtype)</span><br></pre></td></tr></table></figure><p><code>logspace</code>函数的输出由以下参数决定：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>start</code> 起始值是<code>base ** start</code>（base：底数）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>stop</code> 终止值是<code>base ** stop</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>num</code> 范围内的数值数量，默认为<code>50</code></td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>endpoint</code> 如果为<code>true</code>，终止值包含在输出数组当中</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><code>base</code> 对数空间的底数，默认为<code>10</code></td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><code>dtype</code> 输出数组的数据类型，如果没有提供，则取决于其它参数</td></tr></tbody></table><p>下面的例子展示了<code>logspace</code>函数的用法。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是 10</span></span><br><span class="line"></span><br><span class="line">array1 = np.logspace(<span class="number">1.0</span>,  <span class="number">2.0</span>, num=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="comment"># 设置底数为 2</span></span><br><span class="line">array2 = np.logspace(<span class="number">1</span>, <span class="number">10</span>, num=<span class="number">10</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 10.          12.91549665  16.68100537  21.5443469   27.82559402</span><br><span class="line">  35.93813664  46.41588834  59.94842503  77.42636827 100.        ]</span><br><span class="line">[   2.    4.    8.   16.   32.   64.  128.  256.  512. 1024.]</span><br></pre></td></tr></table></figure><h3 id="7、NumPy-切片和索引">7、NumPy - 切片和索引</h3><blockquote><p><code>ndarray</code>对象的内容可以通过索引或切片来访问和修改，就像 Python 的内置容器对象一样。<br>如前所述，<code>ndarray</code>对象中的元素遵循基于零的索引。 有三种可用的索引方法类型： <strong>字段访问，基本切片</strong>和<strong>高级索引</strong>。</p></blockquote><ul><li><strong>基本切片</strong></li></ul><p>基本切片是 Python 中基本切片概念到 n 维的扩展。 通过将<code>start</code>，<code>stop</code>和<code>step</code>参数提供给内置的<code>slice()</code>函数来构造一个 Python <code>slice()</code>对象。 此<code>slice</code>对象被传递给数组来提取数组的一部分。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array[s])<span class="comment"># 输出为 [2  4  6]</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>ndarray</code>对象由<code>arange()</code>函数创建。 然后，分别用起始，终止和步长值<code>2</code>，<code>7</code>和<code>2</code>定义切片对象。 当这个切片对象传递给<code>ndarray</code>时，会对它的一部分进行切片，从索引<code>2</code>到<code>7</code>，步长为<code>2</code>。</p><ul><li><strong>冒号分隔的切片</strong></li></ul><p>通过将由冒号分隔的切片参数（<code>start:stop:step</code>）直接提供给<code>ndarray</code>对象，也可以获得相同的结果。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">10</span>)</span><br><span class="line">b = array[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]  </span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment"># 输出为 [2  4  6]</span></span><br></pre></td></tr></table></figure><p>如果只输入一个参数，则将返回与索引对应的单个项目。 如果使用<code>a:</code>，则从该索引向后的所有项目将被提取。 如果使用两个参数（以<code>:</code>分隔），则对两个索引（不包括停止索引）之间的元素以默认步骤进行切片。</p><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对单个元素进行切片  </span></span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">5</span>])     <span class="comment"># 输出为 5</span></span><br><span class="line"><span class="comment"># 对始于索引的元素进行切片</span></span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">2</span>:])    <span class="comment"># 输出为 [2  3  4  5  6  7  8  9]</span></span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">2</span>:<span class="number">5</span>])   <span class="comment"># 输出为 [2  3  4]</span></span><br></pre></td></tr></table></figure><p>上面的描述也可用于多维<code>ndarray</code>。</p><p><strong>案例2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 对始于索引的元素进行切片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;现在我们从索引 a[1:] 开始对数组切片&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;二次索引取得&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">现在我们从索引 a[1:] 开始对数组切片</span><br><span class="line">[[3 4 5]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">二次索引取得</span><br><span class="line">[3 4 5]</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>切片还可以包括省略号（<code>...</code>），来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的<code>ndarray</code>。</p><p><strong>案例3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最开始的数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 这会返回第二列元素的数组：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二列的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array[...,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 现在我们从第二行切片所有元素：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二行的元素是：&#x27;</span> )</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>,...])</span><br><span class="line"><span class="comment"># 现在我们从第二列向后切片所有元素：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二列及其剩余元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array[...,<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">第二列的元素是：</span><br><span class="line">[2 4 5]</span><br><span class="line">第二行的元素是：</span><br><span class="line">[3 4 5]</span><br><span class="line">第二列及其剩余元素是：</span><br><span class="line">[[2 3]</span><br><span class="line"> [4 5]</span><br><span class="line"> [5 6]]</span><br></pre></td></tr></table></figure><h3 id="8、NumPy-高级索引">8、NumPy - 高级索引</h3><blockquote><p>如果一个<code>ndarray</code>是非元组序列，数据类型为整数或布尔值的<code>ndarray</code>，或者至少一个元素为序列对象的元组，我们就能够用它来索引<code>ndarray</code>。高级索引始终返回数据的副本。 与此相反，切片只提供了一个视图。</p></blockquote><p>有两种类型的高级索引：整数和布尔值。</p><h4 id="8-1、整数索引">8.1、整数索引</h4><p>这种机制有助于基于 N 维索引来获取数组中任意元素。 每个整数数组表示该维度的下标值。 当索引的元素个数就是目标<code>ndarray</code>的维度时，会变得相当直接。</p><p>以下示例获取了<code>ndarray</code>对象中每一行指定列的一个元素。 因此，行索引包含所有行号，列索引指定要选择的元素。</p><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line">res = array[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]  <span class="comment"># (0, 0), (1, 1), (2, 0)，(第几行， 第几列)的值</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 输出为 [1  4  5]</span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">[1 4 5]</span><br></pre></td></tr></table></figure><p>下面的示例获取了 4X3 数组中的每个角处的元素。 行索引是<code>[0,0]</code>和<code>[3,3]</code>，而列索引是<code>[0,2]</code>和<code>[0,2]</code>。</p><p><strong>案例2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line">rows1 = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols1 = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">res1 = array[rows1, cols1]    <span class="comment"># 行索引，列索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这个数组的每个角处的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line">cols2 = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">rows2 = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">res2 = array[rows2, cols2]    <span class="comment"># 行索引，列索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这个数组的每个角处的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]]</span><br><span class="line">这个数组的每个角处的元素是：</span><br><span class="line">[[ 0  2]</span><br><span class="line"> [ 9 11]]</span><br><span class="line">这个数组的每个角处的元素是：</span><br><span class="line">[ 0  2  9 11]</span><br></pre></td></tr></table></figure><p>返回的结果是包含每个角元素的<code>ndarray</code>对象。</p><p>高级和基本索引可以通过使用切片<code>:</code>或省略号<code>...</code>与索引数组组合。 以下示例使用<code>slice</code>作为列索引和高级索引。 当切片用于两者时，结果是相同的。 但高级索引会导致复制，并且可能有不同的内存布局。</p><p><strong>案例3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">res1 = array[<span class="number">1</span>:<span class="number">4</span>, <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 行切片，列切片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;切片之后，我们的数组变为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line"><span class="comment"># 对列使用高级索引</span></span><br><span class="line">res2 = array[<span class="number">1</span>:<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>]]  <span class="comment"># 行切片，列索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对列使用高级索引来切片：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]]</span><br><span class="line">切片之后，我们的数组变为：</span><br><span class="line">[[ 4  5]</span><br><span class="line"> [ 7  8]</span><br><span class="line"> [10 11]]</span><br><span class="line">对列使用高级索引来切片：</span><br><span class="line">[[ 4  5]</span><br><span class="line"> [ 7  8]</span><br><span class="line"> [10 11]]</span><br></pre></td></tr></table></figure><h4 id="8-2、布尔索引">8.2、布尔索引</h4><blockquote><p>当结果对象是布尔运算（例如比较运算符）的结果时，将使用此类型的高级索引。<br>提取出为True的元素</p></blockquote><p><strong>案例1</strong></p><p>这个例子中，大于 5 的元素会作为布尔索引的结果返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是:&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(array) </span><br><span class="line"><span class="comment"># 现在我们会打印出大于 5 的元素  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于 5 的元素是:&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(array[array &gt; <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]]</span><br><span class="line">大于 5 的元素是:</span><br><span class="line">[ 6  7  8  9 10 11]</span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>这个例子使用了 <code>~</code>（取补运算符）来过滤<code>NaN</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(array[~np.isnan(array)])<span class="comment"># 输出为 [1. 2. 3. 4. 5.]</span></span><br></pre></td></tr></table></figure><p><strong>案例3</strong></p><p>以下示例显示如何从数组中过滤掉非复数元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([<span class="number">1</span>, <span class="number">2</span> + <span class="number">6j</span>, <span class="number">5</span>, <span class="number">3.5</span> + <span class="number">5j</span>])</span><br><span class="line"><span class="built_in">print</span>(array[np.iscomplex(array)])   <span class="comment"># 输出为 [2. +6.j 3.5+5.j]</span></span><br></pre></td></tr></table></figure><p><strong>案例4</strong></p><ul><li><p><code>numpy.argwhere()</code></p><p>该函数返回数组中非 0 元素的索引，若是多维数组则返回行、列索引组成的索引坐标.</p></li></ul><h3 id="9、NumPy-广播">9、NumPy - 广播</h3><blockquote><p>术语<strong>广播</strong>是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。</p></blockquote><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayA = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">arrayB = np.array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">arrayC = arrayA * arrayB</span><br><span class="line"><span class="built_in">print</span>(arrayC)<span class="comment"># 输出为 [ 10  40  90 160]</span></span><br></pre></td></tr></table></figure><p>如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，<strong>在 NumPy 中仍然可以对形状不相似的数组进行操作</strong>，因为它拥有广播功能。 较小的数组会<strong>广播</strong>到较大数组的大小，以便使它们的形状可兼容。</p><p><strong>如果满足以下规则，可以进行广播</strong>：</p><ul><li><code>ndim</code>较小的数组会在前面追加一个长度为 1 的维度。</li><li>输出数组的每个维度的大小是输入数组该维度大小的最大值。</li><li>如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。</li><li>如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。</li></ul><p>如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为<strong>可广播的</strong>。</p><ul><li>数组拥有相同形状。</li><li>数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。</li><li>数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。</li></ul><p><strong>对于广播规则另一种简单理解</strong></p><ul><li>将两个数组的维度大小右对齐，然后比较对应维度上的数值</li><li>如果数值相等或其中有一个为1或者为空，则能进行广播运算</li><li>输出的维度大小为取数值大的数值。否则不能进行数组运算</li></ul><p><strong>案例2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayA = np.array([[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>], [<span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>], [<span class="number">30.0</span>, <span class="number">30.0</span>, <span class="number">30.0</span>]])</span><br><span class="line">arrayB = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayA)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayB)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组加第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayA + arrayB)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[ 0.  0.  0.]</span><br><span class="line"> [10. 10. 10.]</span><br><span class="line"> [20. 20. 20.]</span><br><span class="line"> [30. 30. 30.]]</span><br><span class="line">第二个数组:</span><br><span class="line">[1. 2. 3.]</span><br><span class="line">第一个数组加第二个数组:</span><br><span class="line">[[ 1.  2.  3.]</span><br><span class="line"> [11. 12. 13.]</span><br><span class="line"> [21. 22. 23.]</span><br><span class="line"> [31. 32. 33.]]</span><br></pre></td></tr></table></figure><p>案例2如何通过广播来兼容</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-21_15-32-04.png" alt=""></p><h3 id="10、NumPy-数组上的迭代">10、NumPy - 数组上的迭代</h3><blockquote><p>NumPy 包包含一个迭代器对象<code>numpy.nditer</code>。 它是一个有效的多维迭代器对象，可以用于在数组上进行迭代。 数组的每个元素可使用 Python 的标准<code>Iterator</code>接口来访问。</p></blockquote><p><strong>案例1</strong></p><p>让我们使用<code>arange()</code>函数创建一个 3X4 数组，并使用<code>nditer</code>对它进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a.shape = (<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代结果为&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始数组是:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">迭代结果为</span><br><span class="line">0 5 10 15 20 25 30 35 40 45 50 55 </span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>迭代的顺序匹配数组的内容布局，而不考虑特定的排序。 这可以通过迭代上述数组的转置来看到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组迭代:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t = array.T</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n转置后:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转置后的数组是:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(t):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原始数组是:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">原数组迭代:</span><br><span class="line">0 5 10 15 20 25 30 35 40 45 50 55 </span><br><span class="line">转置后:</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">转置后的数组是:</span><br><span class="line">0 5 10 15 20 25 30 35 40 45 50 55</span><br></pre></td></tr></table></figure><h4 id="10-1、迭代顺序">10.1、迭代顺序</h4><p>如果相同元素使用 F 风格顺序存储，则迭代器选择以更有效的方式对数组进行迭代。</p><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序:&#x27;</span>)</span><br><span class="line">c = array.copy(order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代（C）:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>),</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n以 F 风格顺序排序:&#x27;</span>)</span><br><span class="line">f = array.copy(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代（F）:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(f):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原始数组是:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">以 C 风格顺序排序:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">迭代（C）:</span><br><span class="line">0 5 10 15 20 25 30 35 40 45 50 55 </span><br><span class="line">以 F 风格顺序排序:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">迭代（F）:</span><br><span class="line">0 20 40 5 25 45 10 30 50 15 35 55 </span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>可以通过显式提醒，来强制<code>nditer</code>对象使用某种顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, order=<span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组是:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">以 C 风格顺序排序:</span><br><span class="line">0 5 10 15 20 25 30 35 40 45 50 55 </span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line">0 20 40 5 25 45 10 30 50 15 35 55 </span><br></pre></td></tr></table></figure><h4 id="10-2、修改数组的值">10.2、修改数组的值</h4><p><code>nditer</code>对象有另一个可选参数<code>op_flags</code>。 其默认值为只读，但可以设置为读写或只写模式。 这将允许使用此迭代器修改数组元素。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line">array[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改左上角为2:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代器修改:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(array, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]):</span><br><span class="line">    <span class="comment"># i = 2 * i     # 这个结果是未得到修改</span></span><br><span class="line">    i[...] = <span class="number">2</span> * i</span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始数组是:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">修改左上角为2:</span><br><span class="line">2</span><br><span class="line">迭代器修改:</span><br><span class="line">[[  4  10  20  30]</span><br><span class="line"> [ 40  50  60  70]</span><br><span class="line"> [ 80  90 100 110]]</span><br></pre></td></tr></table></figure><p><strong>测试</strong>上面的案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">2</span>)</span><br><span class="line">array.shape = (<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组地址元素地址为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第1个元素:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(array[<span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(array[<span class="number">0</span>, <span class="number">0</span>][...]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第2个元素:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(array[<span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(array[<span class="number">1</span>, <span class="number">0</span>][...]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代器结果:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.nditer(array, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>个元素:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(i[...]))</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_16-20-18.png" alt=""></p><h4 id="10-3、外部循环">10.3、外部循环</h4><p><code>nditer</code>类的构造器拥有<code>flags</code>参数，它可以接受下列值：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">参数及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>c_index</code> 可以跟踪 C 顺序的索引</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>f_index</code> 可以跟踪 Fortran 顺序的索引</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>multi-index</code> 每次迭代可以跟踪一种索引类型</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>external_loop</code> 给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table><p><strong>案例</strong></p><p>在下面的示例中，迭代器遍历对应于每列的一维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c_index:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, flags=[<span class="string">&#x27;c_index&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nf_index:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, flags=[<span class="string">&#x27;f_index&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nmulti_index:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, flags=[<span class="string">&#x27;multi_index&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nexternal_loop \&#x27;F\&#x27;:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, flags=[<span class="string">&#x27;external_loop&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nexternal_loop \&#x27;C\&#x27;:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(array, flags=[<span class="string">&#x27;external_loop&#x27;</span>], order=<span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">c_index:</span><br><span class="line">0 20 40 5 25 45 10 30 50 15 35 55 </span><br><span class="line">f_index:</span><br><span class="line">0 20 40 5 25 45 10 30 50 15 35 55 </span><br><span class="line">multi_index:</span><br><span class="line">0 20 40 5 25 45 10 30 50 15 35 55 </span><br><span class="line">external_loop &#x27;F&#x27;:</span><br><span class="line">[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55] </span><br><span class="line">external_loop &#x27;C&#x27;:</span><br><span class="line">[ 0  5 10 15 20 25 30 35 40 45 50 55] </span><br></pre></td></tr></table></figure><h4 id="10-4、广播迭代">10.4、广播迭代</h4><blockquote><p>如果两个数组是<strong>可广播的</strong>，<code>nditer</code>组合对象能够同时迭代它们。 假设数组<code>a</code>具有维度 3X4，并且存在维度为 1X4 的另一个数组<code>b</code>，则使用以下类型的迭代器（数组<code>b</code>被广播到<code>a</code>的大小）。</p></blockquote><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>)</span><br><span class="line">array1 = array1.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line">array2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代结果:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> np.nditer([array1, array2]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>:<span class="subst">&#123;y&#125;</span>&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">第二个数组:</span><br><span class="line">[1 2 3 4]</span><br><span class="line">迭代结果:</span><br><span class="line">0:1 5:2 10:3 15:4 20:1 25:2 30:3 35:4 40:1 45:2 50:3 55:4 </span><br></pre></td></tr></table></figure><h3 id="11、NumPy-数组操作">11、NumPy - 数组操作</h3><blockquote><p>NumPy包中有几个例程用于处理<code>ndarray</code>对象中的元素。 它们可以分为以下类型：</p></blockquote><h4 id="11-0、NumPy的轴">11.0、NumPy的轴</h4><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_21-48-55.png" alt=""></p><h4 id="11-1、修改形状">11.1、修改形状</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">形状及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>reshape</code> 不改变数据的条件下修改形状</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>flat</code> 数组上的一维迭代器</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>flatten</code> 返回折叠为一维的数组副本</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>ravel</code> 返回连续的展开数组</td></tr></tbody></table><ul><li><code>numpy.reshape()</code></li></ul><p>这个函数在不改变数据的条件下修改形状，它接受如下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.reshape(arr, newshape, order)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>arr</code>：要修改形状的数组</li><li><code>newshape</code>：整数或者整数数组，新的形状应当兼容原有形状；(-1, 2)，-1表示行自动变化，2表示两列</li><li><code>order</code>：<code>'C'</code>为 C 风格顺序，<code>'F'</code>为 F 风格顺序，<code>'A'</code>为保留原顺序。</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayA = np.arange(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayA)</span><br><span class="line"><span class="comment"># arrayB = arrayA.reshape(2, 4)</span></span><br><span class="line">arrayB = np.reshape(arrayA, (<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayB)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">修改后的数组:</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.ndarray.flat</code></li></ul><p>该函数返回数组上的一维迭代器，行为类似 Python 内建的迭代器。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 flat 函数之后:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.flat)</span><br><span class="line"><span class="comment"># 返回展开数组中的下标的对应元素</span></span><br><span class="line"><span class="built_in">print</span>(array.flat[<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;for-in 迭代:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array.flat:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line">调用 flat 函数之后:</span><br><span class="line">&lt;numpy.flatiter object at 0x000002E0449B2390&gt;</span><br><span class="line">5</span><br><span class="line">for-in 迭代:</span><br><span class="line">0 1 2 3 4 5 6 7 </span><br></pre></td></tr></table></figure><ul><li><code>numpy.ndarray.flatten()</code></li></ul><p>该函数返回折叠为一维的数组副本，函数接受下列参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndarray.flatten(order)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>order</code>：<code>'C'</code> – 按行，<code>'F'</code> – 按列，<code>'A'</code> – 原顺序，<code>'k'</code> – 元素在内存中的出现顺序。</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># default is column-major</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开的数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.flatten())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序展开的数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.flatten(order=<span class="string">&#x27;F&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line">展开的数组:</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">以 F 风格顺序展开的数组:</span><br><span class="line">[0 4 1 5 2 6 3 7]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.ravel()</code></li></ul><p>这个函数返回展开的一维数组，并且按需生成副本。返回的数组和输入数组拥有相同数据类型。这个函数接受两个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ravel(a, order)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：</p><ul><li><code>order</code>：<code>'C'</code> – 按行，<code>'F'</code> – 按列，<code>'A'</code> – 原顺序，<code>'k'</code> – 元素在内存中的出现顺序。</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 ravel 函数之后:&#x27;</span>)</span><br><span class="line"><span class="comment"># print(a.ravel())  # 效果相同</span></span><br><span class="line"><span class="built_in">print</span>(np.ravel(array))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序调用 ravel 函数之后:&#x27;</span>)</span><br><span class="line"><span class="comment"># print(a.ravel(order=&#x27;F&#x27;))     # 效果相同</span></span><br><span class="line"><span class="built_in">print</span>(np.ravel(array, order=<span class="string">&#x27;F&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line">调用 ravel 函数之后:</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">以 F 风格顺序调用 ravel 函数之后:</span><br><span class="line">[0 4 1 5 2 6 3 7]</span><br></pre></td></tr></table></figure><h4 id="11-2、翻转操作">11.2、翻转操作</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">操作及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>transpose</code> 翻转数组的维度</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>ndarray.T</code> 和<code>self.transpose()</code>相同</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>rollaxis</code> 向后滚动指定的轴</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>swapaxes</code> 互换数组的两个轴</td></tr></tbody></table><ul><li><code>numpy.transpose()</code></li></ul><p>这个函数翻转给定数组的维度。如果可能的话它会返回一个视图。函数接受下列参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：要转置的数组</p><p><code>axes</code>：整数的列表，对应维度，通常所有维度都会翻转。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转置数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.transpose(array))</span><br><span class="line"><span class="comment"># print(array.transpose())    # 效果相同</span></span><br><span class="line"><span class="comment"># print(array.T)              # 效果相同</span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[0 1 2]</span><br><span class="line"> [3 4 5]]</span><br><span class="line">转置数组:</span><br><span class="line">[[0 3]</span><br><span class="line"> [1 4]</span><br><span class="line"> [2 5]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.ndarray.T</code></li></ul><p>该函数属于<code>ndarray</code>类，行为类似于<code>numpy.transpose</code>。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><ul><li><code>numpy.rollaxis()</code></li></ul><p>该函数向后滚动特定的轴，直到一个特定位置。这个函数接受三个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>arr</code>：输入数组</li><li><code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变</li><li><code>start</code>：默认为零，表示完整的滚动。会滚动到特定位置。</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了三维的 ndarray</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 将轴 2 滚动到轴 0（宽度到深度）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 rollaxis 函数:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.rollaxis(array, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 将轴 0 滚动到轴 1:（宽度到高度）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 rollaxis 函数:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.rollaxis(array, <span class="number">2</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[[0 1]</span><br><span class="line">  [2 3]]</span><br><span class="line"></span><br><span class="line"> [[4 5]</span><br><span class="line">  [6 7]]]</span><br><span class="line">调用 rollaxis 函数:</span><br><span class="line">[[[0 2]</span><br><span class="line">  [4 6]]</span><br><span class="line"></span><br><span class="line"> [[1 3]</span><br><span class="line">  [5 7]]]</span><br><span class="line">调用 rollaxis 函数:</span><br><span class="line">[[[0 2]</span><br><span class="line">  [1 3]]</span><br><span class="line"></span><br><span class="line"> [[4 6]</span><br><span class="line">  [5 7]]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.swapaxes()</code></li></ul><p>该函数交换数组的两个轴。对于 1.10 之前的 NumPy 版本，会返回交换后数组的试图。这个函数接受下列参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.swapaxes(arr, axis1, axis2)</span><br></pre></td></tr></table></figure><ul><li><code>arr</code>：要交换其轴的输入数组</li><li><code>axis1</code>：对应第一个轴的整数</li><li><code>axis2</code>：对应第二个轴的整数</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 现在交换轴 0（深度方向）到轴 2（宽度方向）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 swapaxes 函数后的数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.swapaxes(array, <span class="number">2</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[[0 1]</span><br><span class="line">  [2 3]]</span><br><span class="line"></span><br><span class="line"> [[4 5]</span><br><span class="line">  [6 7]]]</span><br><span class="line">调用 swapaxes 函数后的数组:</span><br><span class="line">[[[0 4]</span><br><span class="line">  [2 6]]</span><br><span class="line"></span><br><span class="line"> [[1 5]</span><br><span class="line">  [3 7]]]</span><br></pre></td></tr></table></figure><h4 id="11-3、修改维度">11.3、修改维度</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">维度和描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>broadcast()</code> 产生模仿广播的对象</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>broadcast_to()</code> 将数组广播到新形状</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>expand_dims()</code> 扩展数组的形状</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>squeeze()</code> 从数组的形状中删除单维条目</td></tr></tbody></table><ul><li><code>broadcast()</code></li></ul><p>如前所述，NumPy 已经内置了对广播的支持。 此功能模仿广播机制。 它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><p>该函数使用两个数组作为输入参数。 下面的例子说明了它的用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 对 y 广播 x</span></span><br><span class="line">arrayA = np.broadcast(x, y)</span><br><span class="line"><span class="comment"># 它拥有 iterator 属性，基于自身组件的迭代器元组 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对 y 广播 x:&#x27;</span>)</span><br><span class="line">r, arrayB = arrayA.iters</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(r), <span class="built_in">next</span>(arrayB))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(r), <span class="built_in">next</span>(arrayB))</span><br><span class="line"><span class="comment"># shape 属性返回广播对象的形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;广播对象的形状:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayA.shape)</span><br><span class="line"><span class="comment"># 手动使用 broadcast 将 x 与 y 相加</span></span><br><span class="line">arrayA = np.broadcast(x, y)</span><br><span class="line">arrayB = np.empty(arrayA.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;手动使用 broadcast 将 x 与 y 相加:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayB.shape)</span><br><span class="line">arrayB.flat = [u + v <span class="keyword">for</span> (u, v) <span class="keyword">in</span> arrayA]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 flat 函数:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayB)</span><br><span class="line"><span class="comment"># 获得了和 NumPy 内建的广播支持相同的结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x 与 y 的和:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对 y 广播 x:</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">广播对象的形状:</span><br><span class="line">(3, 3)</span><br><span class="line">手动使用 broadcast 将 x 与 y 相加:</span><br><span class="line">(3, 3)</span><br><span class="line">调用 flat 函数:</span><br><span class="line">[[5. 6. 7.]</span><br><span class="line"> [6. 7. 8.]</span><br><span class="line"> [7. 8. 9.]]</span><br><span class="line">x 与 y 的和:</span><br><span class="line">[[5 6 7]</span><br><span class="line"> [6 7 8]</span><br><span class="line"> [7 8 9]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.broadcast_to()</code></li></ul><p>此函数将数组广播到新形状。 它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出<code>ValueError</code>。</p><p>注意 - 此功能可用于 1.10.0 及以后的版本。</p><p>该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.broadcast_to(array, shape, subok)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">4</span>).reshape(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 broadcast_to 函数之后:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.broadcast_to(array, (<span class="number">4</span>, <span class="number">4</span>)))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[0 1 2 3]]</span><br><span class="line">调用 broadcast_to 函数之后:</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [0 1 2 3]</span><br><span class="line"> [0 1 2 3]</span><br><span class="line"> [0 1 2 3]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.expand_dims()</code></li></ul><p>函数通过在指定位置插入新的轴来扩展数组形状。该函数需要两个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.expand_dims(arr, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：输入数组</p><p><code>axis</code>：新轴插入的位置</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayX = np.array(([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组X:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayX)</span><br><span class="line">arrayY = np.expand_dims(arrayX, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组Y:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayY)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 x 和 y 的形状:&#x27;</span>, arrayX.shape, arrayY.shape)</span><br><span class="line"><span class="comment"># 在位置 1 插入轴</span></span><br><span class="line">arrayY = np.expand_dims(arrayX, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在位置 1 插入轴之后的数组 y:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayY)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x.ndim 和 y.ndim:&#x27;</span>, arrayX.ndim, arrayY.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x.shape 和 y.shape:&#x27;</span>, arrayX.shape, arrayY.shape)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数组X:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">数组Y:</span><br><span class="line">[[[1 2]</span><br><span class="line">  [3 4]]]</span><br><span class="line">数组 x 和 y 的形状: (2, 2) (1, 2, 2)</span><br><span class="line">在位置 1 插入轴之后的数组 y:</span><br><span class="line">[[[1 2]]</span><br><span class="line"></span><br><span class="line"> [[3 4]]]</span><br><span class="line">x.ndim 和 y.ndim: 2 3</span><br><span class="line">x.shape 和 y.shape: (2, 2) (2, 1, 2)</span><br></pre></td></tr></table></figure><ul><li><code>numpy.squeeze()</code></li></ul><p>函数从给定数组的形状中删除一维条目。 此函数需要两个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.squeeze(arr, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：输入数组</p><p><code>axis</code>：整数或整数元组，用于选择形状中单一维度条目的子集</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arrayX = np.arange(<span class="number">9</span>).reshape(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 X:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayX)</span><br><span class="line">arrayY = np.squeeze(arrayX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 Y:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arrayY)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 x 和 y 的形状:&#x27;</span>, arrayX.shape, arrayY.shape)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组 X:</span><br><span class="line">[[[0 1 2]</span><br><span class="line">  [3 4 5]</span><br><span class="line">  [6 7 8]]]</span><br><span class="line">数组 Y:</span><br><span class="line">[[0 1 2]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [6 7 8]]</span><br><span class="line">数组 x 和 y 的形状: (1, 3, 3) (3, 3)</span><br></pre></td></tr></table></figure><h4 id="11-4、数组的连接">11.4、数组的连接</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">数组及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>concatenate()</code> 沿着现存的轴连接数据序列</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>stack()</code> 沿着新轴连接数组序列</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>hstack()</code> 水平堆叠序列中的数组（列方向）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>vstack()</code> 竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><ul><li><code>numpy.concatenate()</code></li></ul><p>数组的连接是指连接。 此函数用于沿指定轴连接相同形状的两个或多个数组。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>a1, a2, ...</code>：<strong>相同类型</strong>的数组序列</p><p><code>axis</code>：沿着它连接数组的轴，默认为 0</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="comment"># 两个数组的维度相同</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 连接两个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((array1, array2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 连接两个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((array1, array2), axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">沿轴 0 连接两个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">沿轴 1 连接两个数组：</span><br><span class="line">[[1 2 5 6]</span><br><span class="line"> [3 4 7 8]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.stack()</code></li></ul><p>此函数沿新轴连接数组序列。 此功能添加自 NumPy 版本 1.10.0。 需要提供以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arrays</code>：<strong>相同形状</strong>的数组序列</p><p><code>axis</code>：返回数组中的轴，输入数组沿着它来堆叠</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 堆叠两个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((array1, array2), <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 堆叠两个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((array1, array2), <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">第二个数组:</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]</span><br><span class="line"> [0 0]]</span><br><span class="line">沿轴 0 堆叠两个数组:</span><br><span class="line">[[[1 2]</span><br><span class="line">  [3 4]</span><br><span class="line">  [5 6]]</span><br><span class="line"></span><br><span class="line"> [[5 6]</span><br><span class="line">  [7 8]</span><br><span class="line">  [0 0]]]</span><br><span class="line">沿轴 1 堆叠两个数组:</span><br><span class="line">[[[1 2]</span><br><span class="line">  [5 6]]</span><br><span class="line"></span><br><span class="line"> [[3 4]</span><br><span class="line">  [7 8]]</span><br><span class="line"></span><br><span class="line"> [[5 6]</span><br><span class="line">  [0 0]]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.hstack()</code></li></ul><p><code>numpy.stack()</code>函数的变体，通过堆叠来生成水平的单个数组。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;水平堆叠:&#x27;</span>)</span><br><span class="line">array3 = np.hstack((array1, array2))</span><br><span class="line"><span class="built_in">print</span>(array3)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">第二个数组:</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]</span><br><span class="line"> [0 0]]</span><br><span class="line">水平堆叠:</span><br><span class="line">[[1 2 5 6]</span><br><span class="line"> [3 4 7 8]</span><br><span class="line"> [5 6 0 0]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.vstack()</code></li></ul><p><code>numpy.stack</code>函数的变体，通过堆叠来生成竖直的单个数组。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;竖直堆叠:&#x27;</span>)</span><br><span class="line">array3 = np.vstack((array1, array2))</span><br><span class="line"><span class="built_in">print</span>(array3)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">第二个数组:</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]</span><br><span class="line"> [0 0]]</span><br><span class="line">竖直堆叠:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]</span><br><span class="line"> [5 6]</span><br><span class="line"> [7 8]</span><br><span class="line"> [0 0]]</span><br></pre></td></tr></table></figure><h4 id="11-5、数组分割">11.5、数组分割</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">数组及操作</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>split()</code> 将一个数组分割为多个子数组</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>hsplit()</code> 将一个数组水平分割为多个子数组（按列）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>vsplit()</code> 将一个数组竖直分割为多个子数组（按行）</td></tr></tbody></table><ul><li><code>numpy.split</code></li></ul><p>该函数沿特定的轴将数组分割为子数组。函数接受三个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>ary</code>：被分割的输入数组</p><p><code>indices_or_sections</code>：可以是整数，表明要从输入数组创建的，等大小的子数组的数量。 如果此参数是一维数组，则其元素表明要创建新子数组的点。</p><p><code>axis</code>：默认为 0</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.arange(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将数组分为三个大小相等的子数组:&#x27;</span>)</span><br><span class="line">array2 = np.split(array1, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将数组在一维数组中表明的位置分割:&#x27;</span>)</span><br><span class="line">array3 = np.split(array1, [<span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(array3)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[0 1 2 3 4 5 6 7 8]</span><br><span class="line">将数组分为三个大小相等的子数组:</span><br><span class="line">[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]</span><br><span class="line">将数组在一维数组中表明的位置分割:</span><br><span class="line">[array([0, 1, 2, 3, 4]), array([5, 6]), array([7, 8])]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.hsplit</code></li></ul><p><code>numpy.hsplit</code>是<code>split()</code>函数的特例，其中轴为 1 表示水平分割，无论输入数组的维度是什么。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;水平分割:&#x27;</span>)</span><br><span class="line">array2 = np.hsplit(array1, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]]</span><br><span class="line">水平分割：</span><br><span class="line">[array([[ 0,  1],</span><br><span class="line">       [ 4,  5],</span><br><span class="line">       [ 8,  9],</span><br><span class="line">       [12, 13]]), array([[ 2,  3],</span><br><span class="line">       [ 6,  7],</span><br><span class="line">       [10, 11],</span><br><span class="line">       [14, 15]])]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.vsplit</code></li></ul><p><code>numpy.vsplit</code>是<code>split()</code>函数的特例，其中轴为 0 表示竖直分割，无论输入数组的维度是什么。下面的例子使之更清楚。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;竖直分割:&#x27;</span>)</span><br><span class="line">array2 = np.vsplit(array1, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]]</span><br><span class="line">竖直分割:</span><br><span class="line">[array([[0, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15]])]</span><br></pre></td></tr></table></figure><h4 id="11-6、添加-删除元素">11.6、添加/删除元素</h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">元素及描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>resize()</code> 返回指定形状的新数组</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>append()</code> 将值添加到数组末尾</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>insert()</code> 沿指定轴将值插入到指定下标之前</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>delete()</code> 返回删掉某个轴的子数组的新数组</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><code>unique()</code> 寻找数组内的唯一元素</td></tr></tbody></table><ul><li><code>numpy.resize()</code></li></ul><p>此函数返回指定大小的新数组。 如果新大小大于原始大小，则包含原始数组中的元素的<strong>重复副本</strong>。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：要修改大小的输入数组</p><p><code>shape</code>：返回数组的新形状</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组的形状:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1.shape)</span><br><span class="line">array2 = np.resize(array1, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组的形状:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array2.shape)</span><br><span class="line"><span class="comment"># 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改第二个数组的大小:&#x27;</span>)</span><br><span class="line">array2 = np.resize(array1, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">第一个数组的形状:</span><br><span class="line">(2, 3)</span><br><span class="line">第二个数组:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">第二个数组的形状:</span><br><span class="line">(3, 2)</span><br><span class="line">修改第二个数组的大小:</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [1 2 3]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.append()</code></li></ul><p>此函数在输入数组的末尾添加值。 附加操作不是原地的，而是分配新的数组。 此外，输入数组的维度必须匹配否则将生成<code>ValueError</code>。</p><p>函数接受下列函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：输入数组</p><p><code>values</code>：要向<code>arr</code>添加的值，比如和<code>arr</code>形状相同（除了要添加的轴）</p><p><code>axis</code>：沿着它完成操作的轴。如果没有提供，两个参数都会被展开。</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;向数组添加元素:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(array, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 添加元素:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(array, [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]], axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 添加元素:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(array, [[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]], axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">向数组添加元素:</span><br><span class="line">[1 2 3 4 5 6 7 8 9]</span><br><span class="line">沿轴 0 添加元素:</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">沿轴 1 添加元素:</span><br><span class="line">[[1 2 3 5 5 5]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.insert()</code></li></ul><p>此函数在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><p><code>insert()</code>函数接受以下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：输入数组</p><p><code>obj</code>：在其之前插入值的索引</p><p><code>values</code>：要插入的值</p><p><code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;未传递 Axis 参数。 在插入之前输入数组会被展开。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(array, <span class="number">3</span>, [<span class="number">11</span>, <span class="number">12</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;传递了 Axis 参数。 会广播值数组来配输入数组。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 广播:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(array, <span class="number">1</span>, [<span class="number">11</span>], axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 广播:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(array, <span class="number">1</span>, <span class="number">11</span>, axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ 1  2  3 11 12  4  5  6]</span><br><span class="line">传递了 Axis 参数。 会广播值数组来配输入数组。</span><br><span class="line">沿轴 0 广播:</span><br><span class="line">[[ 1  2]</span><br><span class="line"> [11 11]</span><br><span class="line"> [ 3  4]</span><br><span class="line"> [ 5  6]]</span><br><span class="line">沿轴 1 广播:</span><br><span class="line">[[ 1 11  2]</span><br><span class="line"> [ 3 11  4]</span><br><span class="line"> [ 5 11  6]]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.delete()</code></li></ul><p>此函数返回从输入数组中删除指定子数组的新数组。 与<code>insert()</code>函数的情况一样，如果未提供轴参数，则输入数组将展开。 该函数接受以下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Numpy.delete(arr, obj, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>arr</code>：输入数组</p><p><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p><p><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;未传递 Axis 参数。 在插入之前输入数组会被展开。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.delete(array, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除第二列:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.delete(array, <span class="number">1</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;包含从数组中删除的替代值的切片:&#x27;</span>)</span><br><span class="line">array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(np.delete(array, np.s_[::<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ 0  1  2  3  4  6  7  8  9 10 11]</span><br><span class="line">删除第二列:</span><br><span class="line">[[ 0  2  3]</span><br><span class="line"> [ 4  6  7]</span><br><span class="line"> [ 8 10 11]]</span><br><span class="line">包含从数组中删除的替代值的切片:</span><br><span class="line">[ 2  4  6  8 10]</span><br></pre></td></tr></table></figure><ul><li><code>numpy.unique()</code></li></ul><p>此函数返回输入数组中的去重元素数组。 该函数能够返回一个<strong>元组</strong>，包含去重数组和相关索引的数组。 索引的性质取决于函数调用中返回参数的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>arr</code>：输入数组，如果不是一维数组则会展开</li><li><code>return_index</code>：如果为<code>true</code>，返回输入数组中的元素下标</li><li><code>return_inverse</code>：如果为<code>true</code>，返回去重数组的下标，它可以用于重构输入数组</li><li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组的去重值:&#x27;</span>)</span><br><span class="line">u = np.unique(array)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重数组的索引数组:&#x27;</span>)</span><br><span class="line">u, indices = np.unique(array, return_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们可以看到每个和原数组下标对应的数值:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重数组的下标:&#x27;</span>)</span><br><span class="line">u, indices = np.unique(array, return_inverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;下标为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用下标重构原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(u[indices])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回去重元素的重复数量:&#x27;</span>)</span><br><span class="line">u, indices = np.unique(array, return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">第一个数组的去重值:</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">去重数组的索引数组:</span><br><span class="line">[1 0 2 4 7 9]</span><br><span class="line">我们可以看到每个和原数组下标对应的数值:</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">去重数组的下标:</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">下标为:</span><br><span class="line">[1 0 2 0 3 1 2 4 0 5]</span><br><span class="line">使用下标重构原数组:</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">返回去重元素的重复数量:</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">[3 2 2 1 1 1]</span><br></pre></td></tr></table></figure><h4 id="11-7、排序">11.7、排序</h4><ul><li><p><code>numpy.sort()</code></p><p>对输入数组执行排序，并返回一个数组副本。</p><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td>要排序的数组</td></tr><tr><td style="text-align:center">axis</td><td>沿着指定轴进行排序，如果没有指定 axis，默认在最后一个轴上排序，若 axis=0 表示按列排序，axis=1 表示按行排序</td></tr><tr><td style="text-align:center">kind</td><td>默认为 quicksort (快速排序)</td></tr><tr><td style="text-align:center">order</td><td>若数组设置了字段，则 order 表示要排序的字段</td></tr></tbody></table></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])</span><br><span class="line">array = np.array([(<span class="string">&#x27;ggw&#x27;</span>, <span class="number">999</span>), (<span class="string">&#x27;xpl&#x27;</span>, <span class="number">998</span>)], dtype=dt)</span><br><span class="line"><span class="built_in">print</span>(array)    <span class="comment"># 输出为 [(b&#x27;ggw&#x27;, 999) (b&#x27;xpl&#x27;, 998)]</span></span><br><span class="line"><span class="comment"># 按年龄字段排序:</span></span><br><span class="line"><span class="built_in">print</span>(np.sort(array, order=<span class="string">&#x27;age&#x27;</span>))  <span class="comment"># 输出为 [(b&#x27;xpl&#x27;, 998) (b&#x27;ggw&#x27;, 999)]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>numpy.argsort()</code></p><p>argsort()沿着指定的轴，对输入数组的元素值进行排序，并返回排序后的元素索引数组。示例如下</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([<span class="number">90</span>, <span class="number">29</span>, <span class="number">89</span>, <span class="number">12</span>])</span><br><span class="line"><span class="built_in">print</span>(array)                <span class="comment"># 输出为 [90 29 89 12]</span></span><br><span class="line">sortIndex = np.argsort(array)</span><br><span class="line"><span class="comment"># 排序结果的索引</span></span><br><span class="line"><span class="built_in">print</span>(sortIndex)            <span class="comment"># 输出为 [3 1 2 0]</span></span><br><span class="line"><span class="comment"># 排序结果</span></span><br><span class="line"><span class="built_in">print</span>(array[sortIndex])     <span class="comment"># 输出为 [12 29 89 90]</span></span><br></pre></td></tr></table></figure><h4 id="11-8、矩阵乘、点乘">11.8、矩阵乘、点乘</h4><ul><li><code>numpy.dot()</code></li></ul><p><strong>案例</strong>：点乘、矩阵乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array1 = np.arange(<span class="number">1</span>, <span class="number">5</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">array2 = np.arange(<span class="number">1</span>, <span class="number">5</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1 * array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;numpy.dot()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array1.dot(array2))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原数组</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">*</span><br><span class="line">[[ 1  4]</span><br><span class="line"> [ 9 16]]</span><br><span class="line">numpy.dot()</span><br><span class="line">[[ 7 10]</span><br><span class="line"> [15 22]]</span><br></pre></td></tr></table></figure><h3 id="12、NumPy-统计">12、NumPy - 统计</h3><h4 id="12-1、平均值和中位数">12.1、平均值和中位数</h4><ul><li><p><code>ndarray.mean()</code></p><p>获得平均值</p><p>参数: <code>axis</code>，值0、1，分别是轴0、轴1的方向</p></li><li><p><code>numpy.median()</code></p><p>中位数（中值）</p></li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array.mean())         <span class="comment"># 输出为 9.5</span></span><br><span class="line"><span class="built_in">print</span>(np.median(array))     <span class="comment"># 输出为 9.5</span></span><br></pre></td></tr></table></figure><h4 id="12-2、标准差和方差">12.2、标准差和方差</h4><ul><li><p><code>ndarray.std()</code></p><p>标准差</p></li><li><p><code>ndarray.var()</code></p><p>方差</p></li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 标准差</span></span><br><span class="line"><span class="built_in">print</span>(array.std())      <span class="comment"># 输出为 5.766281297335398</span></span><br><span class="line"><span class="comment"># 下面将按照传统方法计算   计算结果同上</span></span><br><span class="line"><span class="built_in">print</span>(math.sqrt(np.<span class="built_in">sum</span>((array - array.mean()) ** <span class="number">2</span>) / array.size))</span><br><span class="line"><span class="comment"># 方差</span></span><br><span class="line"><span class="built_in">print</span>(array.var())      <span class="comment"># 输出为 33.25    </span></span><br></pre></td></tr></table></figure><h4 id="12-3、最大值、最小值、和">12.3、最大值、最小值、和</h4><ul><li><p><code>ndarray.max()</code></p><p>最大值</p><p>参数: <code>axis</code>，值0、1，分别是轴0、轴1的方向</p></li><li><p><code>ndarray.min()</code></p><p>最小值</p><p>参数: <code>axis</code>，值0、1，分别是轴0、轴1的方向</p></li><li><p><code>ndarray.sum()</code></p><p>和</p><p>参数: <code>axis</code>，值0、1，分别是轴0、轴1的方向</p></li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># 最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">max</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 最小值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">min</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">min</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line">[[ 0  1  2  3  4]</span><br><span class="line"> [ 5  6  7  8  9]</span><br><span class="line"> [10 11 12 13 14]</span><br><span class="line"> [15 16 17 18 19]]</span><br><span class="line">----------------------</span><br><span class="line">19</span><br><span class="line">[15 16 17 18 19]</span><br><span class="line">[ 4  9 14 19]</span><br><span class="line">----------------------</span><br><span class="line">0</span><br><span class="line">[0 1 2 3 4]</span><br><span class="line">[ 0  5 10 15]</span><br><span class="line">----------------------</span><br><span class="line">190</span><br><span class="line">[30 34 38 42 46]</span><br><span class="line">[10 35 60 85]</span><br></pre></td></tr></table></figure><h4 id="12-4、加权平均值">12.4、加权平均值</h4><ul><li><p><code>numpy.average()</code></p><p>加权平均值</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.average(a, axis=<span class="literal">None</span>, weights=<span class="literal">None</span>, returned=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>对比两位学生的考试成绩</p><table><thead><tr><th style="text-align:center">姓名</th><th style="text-align:center">平时测验</th><th style="text-align:center">期中考试</th><th style="text-align:center">期末考试</th></tr></thead><tbody><tr><td style="text-align:center">ggw</td><td style="text-align:center">95</td><td style="text-align:center">90</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">xpl</td><td style="text-align:center">80</td><td style="text-align:center">90</td><td style="text-align:center">95</td></tr></tbody></table><p>学校规定的学科综合成绩的计算方法：</p><table><thead><tr><th style="text-align:center">平时测验</th><th style="text-align:center">期中考试</th><th style="text-align:center">期末考试</th></tr></thead><tbody><tr><td style="text-align:center">20%</td><td style="text-align:center">30%</td><td style="text-align:center">50%</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">95</span>, <span class="number">90</span>, <span class="number">80</span>], [<span class="number">80</span>, <span class="number">90</span>, <span class="number">95</span>]])</span><br><span class="line">w = [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="built_in">print</span>(np.average(array, axis=<span class="number">1</span>, weights=w))     <span class="comment"># 输出为 [86.  90.5]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">95</span>*<span class="number">0.2</span> + <span class="number">90</span>*<span class="number">0.3</span> + <span class="number">80</span>*<span class="number">0.5</span>)                 <span class="comment"># 输出为 86.0</span></span><br></pre></td></tr></table></figure><h3 id="12、NumPy-文件操作">12、NumPy - 文件操作</h3><ul><li><p><code>loadtxt()</code></p><p>读取txt文本、csv文件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadtxt(fname, dtype=&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;, comments=<span class="string">&#x27;#&#x27;</span>, delimiter=<span class="literal">None</span>, \</span><br><span class="line">        converters=<span class="literal">None</span>, skiprows=<span class="number">0</span>, usercols=<span class="literal">None</span>, unpack=<span class="literal">False</span>, \</span><br><span class="line">        ndmin=<span class="number">0</span>, encoding=<span class="string">&#x27;bytes&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">fname</td><td>指定文件或者字符串。支持压缩文件，包括gz，bz格式。</td></tr><tr><td style="text-align:center">dtype</td><td>数据类型，默认为float。</td></tr><tr><td style="text-align:center">comments</td><td>字符串或字符串组成的列表。表示注释字符集开始的标志，默认为#。</td></tr><tr><td style="text-align:center">delimiter</td><td>字符串。分隔符。</td></tr><tr><td style="text-align:center">converters</td><td>字典。将特定列的数据转换为字典中对应的函数的浮点型数据。例如将空值转换为0，默认为空。</td></tr><tr><td style="text-align:center">skiprows</td><td>跳过特定行数据。例如跳过前1行(可能是标题或注释)。默认为0。</td></tr><tr><td style="text-align:center">usercols</td><td>元组。用来指定要读取数据的列，第一列为0。例如(1， 3， 5)，默认为空。</td></tr><tr><td style="text-align:center">unpack</td><td>布尔型。指定是否转置数组，如果为真则转置，默认为False。</td></tr><tr><td style="text-align:center">ndmin</td><td>整数型。指定返回的数组至少包含特定维度的数组。值域为0、1、2，默认为0。</td></tr><tr><td style="text-align:center">enconding</td><td>编码。确认文件是gbk还是utf-8格式。</td></tr></tbody></table><p>返回值：从文件读出的数组</p><p><a href="https://www.bilibili.com/video/BV1Jt4y1h7Vt?t=865.4&amp;p=28">【具体使用说明】</a></p><ul><li><code>np.savez()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(<span class="string">r&#x27;./data.npz&#x27;</span>, data=data, x=x, y=y)</span><br></pre></td></tr></table></figure><p>将numpy数组data、x、y存储到文件data.npz中，没有设置关键字参数而是直接传参，则变为’arr_0、arr_1、arr_2’</p><ul><li><code>np.load()</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.load(r&#x27;./data.npz&#x27;)</span><br><span class="line">data, x, y = data[&#x27;data&#x27;], data[&#x27;x&#x27;], data[&#x27;y&#x27;]</span><br><span class="line"># print(data.files)# 查看文件</span><br></pre></td></tr></table></figure><p>将文件中的数组加载出来</p><h3 id="13、随机函数">13、随机函数</h3><blockquote><p>NumPy中也有自己的随机函数，包含在random模块中。它能产生特定分布的随机数，如正态分布等。接下来介绍一些常用的随<br>机数。</p></blockquote><ul><li><code>rand()</code><ul><li>rand()函数根据给定维度生成[0,1)之间的数据，包含0，不包含1</li><li>dn表示每个维度</li><li>返回值为指定维度的array</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d0,d1,...,dn)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.random.rand(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array)    <span class="comment"># 输出为 [[0.09504265 0.16277635]]</span></span><br></pre></td></tr></table></figure><ul><li><code>randn()</code><ul><li>randn()函数返回一个或一组样本，具有标准正态分布</li><li>dn表示每个维度</li><li>返回值为指定维度的array</li></ul></li></ul><blockquote><p>标准正态分布又称为u分布，是以0为均值、以1为标难差的正态分布，记为N (0，1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randn(d0,d1,...,dn)</span><br></pre></td></tr></table></figure><ul><li><code>randint()</code><ul><li>返回随机整数，范围区间<code>[low, high)</code>，包括low，不包括high</li><li>参数：<code>low</code>为最小值，<code>high</code>为最大值，<code>size</code>为数组维数大小，<code>dtype</code>为数据类型，默认是int</li><li>high没有填写时，默认生成的是<code>[0, low)</code>范围</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randint(low, high=<span class="literal">None</span>, size=<span class="literal">None</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.random.randint(-<span class="number">5</span>, <span class="number">6</span>, size=(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(array)    <span class="comment"># 输出为 [[2 5 0]]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>sample()</code></p><p>返回半开区间的随机浮点数[0.0, 1.0]</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.sample(size=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.random.sample((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(array)    <span class="comment"># 输出为 [[0.58491274 0.10521267]]</span></span><br></pre></td></tr></table></figure><ul><li><code>seed()</code><ul><li>使用相同的seed()值，则每次生成的随机数都相同,使得随机数可以预测</li><li>但是，只在调用的时候seed()一下并不能使生成的随机数相同，需要每次调用都seed()一下，表示种子相同，从而生成的随机数<br>相同</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.seed()</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">array1 = np.random.sample((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(array1)    <span class="comment"># 输出为 [[0.417022   0.72032449]]</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">array2 = np.random.sample((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(array2)    <span class="comment"># 输出为 [[0.417022   0.72032449]]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>normal()</code></p><p>作用: 返回一个由size指定形状的数组，数组中的值服从 p=loc,o=scale 的正态分布</p><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">loc</td><td>float型或者float型的类数组对象，指定均值(mu)</td></tr><tr><td style="text-align:center">scale</td><td>float型或者float型的类数组对象，指定标准差(sigma)</td></tr><tr><td style="text-align:center">size</td><td>int型或者int型的元组，指定了数组的形状，如果不提供size，且loc和scale为标量(不是类数组对象)，则返回一个服从该分布的随机数。</td></tr></tbody></table></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.random.normal(<span class="number">0.0</span>, <span class="number">1.0</span>, size=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(array)    <span class="comment"># 输出为 [[-2.12634551 -0.82277155]]</span></span><br></pre></td></tr></table></figure><h2 id="四、matplotlib">四、matplotlib</h2><blockquote><p>Matplotlib 是Python中类似 <a href="https://so.csdn.net/so/search?q=MATLAB&amp;spm=1001.2101.3001.7020">MATLAB</a> 的绘图工具，熟悉 MATLAB 也可以很快的上手 Matplotlib。</p><p>优点:</p><ul><li>Matplotlib 提供了一个套面向绘图对象编程的API 接口</li><li>依托于Python，借助Python的强大的可拓展性Matplotlib可以在许多不同的环境中被使用</li><li>基于Matlab的和基于面向对象的,但是它完全免费(Matlab是商业数学软件)</li><li>Matplotlib 实现了几乎是完全自主控制的图形定义功能</li></ul></blockquote><h3 id="1、第一个绘图程序">1、第一个绘图程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_22-29-17.png" alt=""></p><h3 id="2、基本方法">2、基本方法</h3><h4 id="2-1、title">2.1、title()</h4><p>设置图标名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.title(<span class="string">&#x27;y=x^2&#x27;</span>)<span class="comment"># 图标名称为 y=x^2</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_22-54-03.png" alt=""></p><p><strong>修改字体配置(2个问题)</strong></p><p>（1）默认不支持中文（字体丢失），报错为：<code>missing from current font.</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.title(<span class="string">&#x27;y等于x的平方&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_22-51-54.png" alt=""></p><p>解决办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;simhei&#x27;]  # 效果相同，不区分大小写</span></span><br></pre></td></tr></table></figure><p><strong>字体说明</strong></p><table><thead><tr><th style="text-align:center">中文字体</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SimHei</td><td style="text-align:center">中文黑体</td></tr><tr><td style="text-align:center">Kaiti</td><td style="text-align:center">中文楷体</td></tr><tr><td style="text-align:center">LiSu</td><td style="text-align:center">中文隶书</td></tr><tr><td style="text-align:center">FangSong</td><td style="text-align:center">中文仿宋</td></tr><tr><td style="text-align:center">YouYuan</td><td style="text-align:center">中文幼圆</td></tr><tr><td style="text-align:center">STSong</td><td style="text-align:center">华文宋体</td></tr></tbody></table><p>（2）当字体设置支持中文后，必须设置负号，否则数值中出现负值时，符号无法显示</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_22-56-59.png" alt=""></p><p>解决办法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>正常执行的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">&#x27;y等于x的平方&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="2-2、xlabel-、ylabel">2.2、xlabel()、ylabel()</h4><p>设置x轴、y轴的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">&#x27;y等于x的平方&#x27;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x 轴&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y 轴&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_23-01-25.png" alt=""></p><h4 id="2-3、补充">2.3、补充</h4><p>（1）样式</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">fontsize</td><td style="text-align:center">字体大小</td></tr><tr><td style="text-align:center">linewidth</td><td style="text-align:center">线条宽度</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">5</span>)     <span class="comment"># 设置了线条宽度</span></span><br><span class="line">plt.title(<span class="string">&#x27;y等于x的平方&#x27;</span>, fontsize=<span class="number">16</span>)   <span class="comment"># 设置了字体大小</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x 轴&#x27;</span>, fontsize=<span class="number">16</span>)      <span class="comment"># 设置了字体大小</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y 轴&#x27;</span>, fontsize=<span class="number">16</span>)      <span class="comment"># 设置了字体大小</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_23-10-52.png" alt=""></p><p>（2）一张图多个曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y1 = x ** <span class="number">2</span></span><br><span class="line">y2 = <span class="number">10</span> * x</span><br><span class="line">plt.title(<span class="string">&#x27;y等于x的平方&#x27;</span>, fontsize=<span class="number">16</span>)   </span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x 轴&#x27;</span>, fontsize=<span class="number">16</span>)      </span><br><span class="line">plt.ylabel(<span class="string">&#x27;y 轴&#x27;</span>, fontsize=<span class="number">16</span>)  </span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------    </span></span><br><span class="line">plt.plot(x, y1, linewidth=<span class="number">5</span>)     </span><br><span class="line">plt.plot(x, y2, linewidth=<span class="number">5</span>)    </span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------- </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-24_23-15-27.png" alt=""></p><h4 id="2-4、xticks-、yticks">2.4、xticks()、yticks()</h4><p>设置x轴、y轴的刻度（把坐标轴变成自己想要的样子）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(ticks=<span class="literal">None</span>, label=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">ticks</td><td>此参数是xtick<strong>位置</strong>的列表。是一个可选参数。如果将一个空列表作为参数传递，则它将删除所有xticks</td></tr><tr><td style="text-align:center">label</td><td>此参数包含放置在给定刻度线位置的标签。它是一个可选参数</td></tr><tr><td style="text-align:center">**kwargs</td><td>此参数是文本属性，用于控制标签的外观<br /> rotation :旋转角度；如: rotation=45<br /> color: 颜色；如: color=“red”</td></tr></tbody></table><p>如果ticks参数的值是数值型，那么代表的是他本身，而不是索引（位置）</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">date = [<span class="string">f&#x27;1月<span class="subst">&#123;i&#125;</span>日&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)]</span><br><span class="line">salary = np.random.randint(<span class="number">500</span>, <span class="number">900</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">plt.plot(date, salary)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_17-36-48.png" alt=""></p><p>设置x轴刻度后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">date = [<span class="string">f&#x27;1月<span class="subst">&#123;i&#125;</span>日&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)]</span><br><span class="line">salary = np.random.randint(<span class="number">500</span>, <span class="number">900</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 日期隔一个显示，倾斜45°</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(date), <span class="number">2</span>), rotation=<span class="number">45</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.plot(date, salary)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_17-38-58.png" alt=""></p><h4 id="2-5、show">2.5、show()</h4><p>显示所有打开的图形</p><p>注意：jupyter notebooks会自动显示图形（即使没调用）</p><p>如果在jupyter中也想要出现图形操作菜单，可以使用matplotlib中的魔术方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure><p>如果在jupyter中变回原来的模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h4 id="2-6、legend">2.6、legend()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend([loc])</span><br></pre></td></tr></table></figure><p>（1）使用图例前需要在，plot()函数中指定参数label的值</p><p>（2）需要先指定，在执行legend()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">date = [<span class="string">f&#x27;1月<span class="subst">&#123;i&#125;</span>日&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)]</span><br><span class="line">salary = np.random.randint(<span class="number">500</span>, <span class="number">900</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">expenses = np.random.randint(<span class="number">100</span>, <span class="number">500</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(date), <span class="number">2</span>), rotation=<span class="number">45</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 注意, 在使用图例 前 为每个图形设置label参数(plot()在legend()后面执行，将失效)</span></span><br><span class="line">plt.plot(date, salary, label=<span class="string">&#x27;收入&#x27;</span>)</span><br><span class="line">plt.plot(date, expenses, label=<span class="string">&#x27;支出&#x27;</span>)</span><br><span class="line"><span class="comment"># 图例 默认会使用每个图形的label值作为图例的说明</span></span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>设置图例</strong></p><p>（1）默认会选择不遮挡图形的位置来显示图例(loc=best)（位置不定）</p><p>（2）指定图例位置</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">字符串位置值</th><th style="text-align:center">位置值</th></tr></thead><tbody><tr><td style="text-align:center">默认值，自定寻找合适位置</td><td style="text-align:center">best</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">右上角</td><td style="text-align:center">upper right</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">左上角</td><td style="text-align:center">upper left</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">左下角</td><td style="text-align:center">lower left</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">右下角</td><td style="text-align:center">lower right</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">右边中间</td><td style="text-align:center">right</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">左边中间</td><td style="text-align:center">center left</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">右边中间</td><td style="text-align:center">center right</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">中间最下面</td><td style="text-align:center">lower center</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">中间最上面</td><td style="text-align:center">upper center</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">正中心</td><td style="text-align:center">center</td><td style="text-align:center">10</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_19-30-43.png" alt=""></p><h4 id="2-7、text">2.7、text()</h4><p>显示每条数据的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.text(x, y, string, fontsize=<span class="number">15</span>, verticalalignment=<span class="string">&#x27;top&#x27;</span>, horizontalalignment=<span class="string">&#x27;right&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">x, y</td><td>坐标轴上的值</td></tr><tr><td style="text-align:center">string</td><td>说明文字</td></tr><tr><td style="text-align:center">fontsize</td><td>字体大小</td></tr><tr><td style="text-align:center">verticalalignment</td><td>垂直对齐方式(va)，[‘center’ | ‘top’ | ‘bottom’ | ‘baseline’]</td></tr><tr><td style="text-align:center">horizontalalignment</td><td>水平对齐方式(ha)，[‘center’ | ‘right’ | ‘left’]</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">date = [<span class="string">f&#x27;1月<span class="subst">&#123;i&#125;</span>日&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)]</span><br><span class="line">salary = np.random.randint(<span class="number">500</span>, <span class="number">900</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">expenses = np.random.randint(<span class="number">100</span>, <span class="number">500</span>, size=<span class="built_in">len</span>(date))</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(date), <span class="number">2</span>), rotation=<span class="number">45</span>)</span><br><span class="line">plt.plot(date, salary, label=<span class="string">&#x27;收入&#x27;</span>)</span><br><span class="line">plt.plot(date, expenses, label=<span class="string">&#x27;支出&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># plt.text(&#x27;1月1日&#x27;, salary[0], &#x27;第一天的收入&#x27;)     # 有效</span></span><br><span class="line"><span class="keyword">for</span> x, y1, y2 <span class="keyword">in</span> <span class="built_in">zip</span>(date, salary, expenses):</span><br><span class="line">    plt.text(x, y1, <span class="string">f&#x27;<span class="subst">&#123;y1&#125;</span>元&#x27;</span>, fontsize=<span class="number">8</span>, horizontalalignment=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">    plt.text(x, y2, <span class="string">f&#x27;<span class="subst">&#123;y2&#125;</span>元&#x27;</span>, fontsize=<span class="number">8</span>, horizontalalignment=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_19-56-53.png" alt=""></p><h4 id="2-8、plot-线条样式">2.8、plot()线条样式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, color=<span class="string">&#x27;red&#x27;</span>, alpha=<span class="number">0.3</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">5</span>,\</span><br><span class="line">         marker=<span class="string">&#x27;o&#x27;</span>, markeredgecolor=<span class="string">&#x27;r&#x27;</span>, markersize=<span class="string">&#x27;20&#x27;</span>, markeredgewidth=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><p>（1）x, y：plot(y)，x可省略，默认[0,…,N-1]递增，N为y轴元素的个数</p><p>（2）color：可以使用颜色的十六进制，也可以使用线条的颜色英文，还可以使用之前的缩写</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">英文全称</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">蓝色</td><td style="text-align:center">blue</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">绿色</td><td style="text-align:center">green</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">红色</td><td style="text-align:center">red</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">青色</td><td style="text-align:center">cyan</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">品红</td><td style="text-align:center">magenta</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">黄色</td><td style="text-align:center">yellow</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">黑色</td><td style="text-align:center">black</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">白色</td><td style="text-align:center">white</td></tr></tbody></table><p>（3）alpha：0.0-1.0，透明度</p><p>（4）linestyle：线条样式</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">实线</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">虚线</td></tr><tr><td style="text-align:center">-.</td><td style="text-align:center">点划线</td></tr><tr><td style="text-align:center">:</td><td style="text-align:center">虚线</td></tr></tbody></table><p>（5）linewidth：折线的宽度</p><p>（7）marker：标记点</p><table><thead><tr><th style="text-align:center">标记符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">点标记</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">圆圈标记</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">'X’标记</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">钻石标记</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">六角标记</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">正方形标记</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">加号标记</td></tr></tbody></table><p>（7）markeredgecolor：标记点的颜色</p><p>（8）markersize：标记点的大小</p><p>（9）markeredgewidth：标记点的边宽</p><h3 id="3、其他元素的可视性">3、其他元素的可视性</h3><h4 id="3-1、grid">3.1、grid()</h4><p>操作网格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&#x27;——&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="string">&#x27;0,5&#x27;</span>, axis=<span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">True</td><td style="text-align:left">显示网格</td></tr><tr><td style="text-align:center">linestyle</td><td style="text-align:left">线性</td></tr><tr><td style="text-align:center">color</td><td style="text-align:left">颜色</td></tr><tr><td style="text-align:center">linewidth</td><td style="text-align:left">宽度</td></tr><tr><td style="text-align:center">axis</td><td style="text-align:left">x, y, both：显示x、显示y、显示x和y的网格</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(-np.pi, np.pi, endpoint=<span class="literal">True</span>)</span><br><span class="line">c, s = np.cos(x), np.sin(x)</span><br><span class="line">plt.plot(x, c)</span><br><span class="line">plt.plot(x, s)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.grid()</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_20-25-37.png" alt=""></p><h4 id="3-2、gca-，spines">3.2、gca()，spines</h4><p>首先观察画布上面的坐标轴</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_20-50-15.png" alt=""></p><p>上图中，框选出的四条黑色边界框线在Matplotlib中被称为<strong>spines</strong>，中文翻译为脊柱，可以理解为这些框线是坐标轴的”支柱“</p><p>所有的操作在<code>plt.gca()</code>中完成(gca: get current axes（获取当前区域）)</p><p><strong>用法在下面的例子中得到说明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">2500</span>)</span><br><span class="line"><span class="comment"># 获取当前坐标轴</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 通过坐标轴spines，确定top、botom、left、right(分别表示上、下、左、右)</span></span><br><span class="line"><span class="comment"># - 不需要右侧和上面的线条，设置成空颜色</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 在这里，position位置参数有三种: data, axes, outward(向外)</span></span><br><span class="line"><span class="comment"># - data: 数值对应的位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># - axes: 0.0-1.0之间的值，坐标轴的比例</span></span><br><span class="line"><span class="comment"># ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.5))</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_21-12-39.png" alt=""></p><h3 id="4、创建图形对象">4、创建图形对象</h3><blockquote><p>  在 Matplotlib 中，面向对象编程的核心思想是创建图形对象(figure obiect)。通过图形对象来调用其它的方法和属性，这样有助于我们更好地处理多个画布。在这个过程中，pyplot 负责生成图形对象，并通过该对象来添加一个或多个axes 对象(即绘图区)<br>  Matplotib 提供了 matplotlib,figure 图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化figure对象。</p></blockquote><h4 id="figure">figure()</h4><p>创建图形对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(num=<span class="literal">None</span>, figsize=<span class="literal">None</span>, dpi=<span class="literal">None</span>, facecolor=<span class="literal">None</span>, edgecolor=<span class="literal">None</span>, frameon=<span class="literal">True</span>, **kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">num</td><td>图像编号或名称，数字为编号 ，字符串为名称</td></tr><tr><td style="text-align:center">figsize</td><td>指定figure的宽和高，单位为英寸;</td></tr><tr><td style="text-align:center">dpi</td><td>指定绘图对象的分辨率，即每英寸多少个像素，缺省值为72</td></tr><tr><td style="text-align:center">facecolor</td><td>背景颜色</td></tr><tr><td style="text-align:center">edgecolor</td><td>边框颜色</td></tr><tr><td style="text-align:center">frameon</td><td>是否显示边框</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">fig = plt.figure(<span class="string">&#x27;f1&#x27;</span>, figsize=(<span class="number">4</span>, <span class="number">2</span>), dpi=<span class="number">100</span>, facecolor=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_22-30-05.png" alt=""></p><h3 id="5、绘制多子图">5、绘制多子图</h3><blockquote><p>  fiqure是绘制对象(可理解为一个空白的画布)，一个figure对象可以包含多个Axes子图，一个Axes是一个绘图区域，不加设置时，Axes为1，且每次绘图其实都是在figure上的Axes上绘图。<br>  我们是在图形对象上面的Axes区域作画</p></blockquote><h4 id="1、add-axes">1、add_axes()</h4><p>添加区域</p><blockquote><p>  Matplotlib 定义了一个 axes 类(轴域类)，该类的对象被称为 axes 对象(即轴域对象)，它指定了一个有数值范围限制的绘图区域。在一个给定的画布 (figure) 中可以包含多个 axes 对象，但是同一个axes 对象只能在一个画布中使用。</p><p>  2D绘图区域（axes）包含两个轴（axis）对象</p></blockquote><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_axes(rect)</span><br></pre></td></tr></table></figure><ul><li>该方法用来生成一个axes 轴域对象，对象的位置由参数rect决定</li><li>rect 是位置参数，接受一个由 4 个元素组成的浮点数列表，形如[left, botom, width, height]，它表示添加到画布中的矩形区<br>域的左下角坐标(x,y)，以及宽度和高度。</li></ul><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 画布背景设置成 pink</span></span><br><span class="line">fig = plt.figure(facecolor=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line"><span class="comment"># ax1 从画布 10%, 10% 的位置开始画，宽高是画布的 80%</span></span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span>])</span><br><span class="line"><span class="comment"># - 当前区域是 ax1, plt.plot()在当前区域作画</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># ax2 从画布 20%, 20% 的位置开始画，宽高是画布的 50%</span></span><br><span class="line">ax2 = fig.add_axes([<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line"><span class="comment"># - 当前区域是 ax2, plt.plot()在当前区域作画</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>])</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">ax2.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>ps：<strong>plt.plot()是在当前区域作画</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_23-01-47.png" alt=""></p><h4 id="2、subplot">2、subplot()</h4><p>均等地划分画布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplot(nrows, ncols, index, *args, **kwargs)</span><br></pre></td></tr></table></figure><p>返回值：区域画布，区域对象</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">nrows</td><td style="text-align:center">行</td></tr><tr><td style="text-align:center">ncols</td><td style="text-align:center">列</td></tr><tr><td style="text-align:center">indes</td><td style="text-align:center">索引</td></tr><tr><td style="text-align:center">**kwargs</td><td style="text-align:center">title、xlabel、ylabel等</td></tr></tbody></table><p>说明：</p><p>nrows 与 ncols 表示要划分几行几列的子区域 (nrows*nclos表示子图数量)，index 的初始值为1，用来选定具体的某个子区域。<br>例如：subplot(233)表示在当前画布的右上角创建一个两行三列的绘图区域，同时，选择在第 3 个位置绘制子图。</p><p><strong>案例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig = plt.figure(facecolor=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 切割成 2*2 份</span></span><br><span class="line"><span class="comment"># - 选择第 1 份</span></span><br><span class="line">ax1 = plt.subplot(<span class="number">221</span>)</span><br><span class="line"><span class="comment"># - 选择第 2 份</span></span><br><span class="line">ax2 = plt.subplot(<span class="number">224</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">ax2.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_23-22-25.png" alt=""></p><p><strong>案例2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">fig = plt.figure(facecolor=&#x27;pink&#x27;)</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">ax1 = plt.subplot(121)</span><br><span class="line">ax2 = plt.subplot(224)</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">ax1.plot([1, 2, 3, 4, 6], [2, 3, 5, 8, 9])</span><br><span class="line">ax2.plot([1, 2, 3, 4, 6], [2, 3, 5, 8, 9])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_23-28-52.png" alt=""></p><h3 id="6、柱状图">6、柱状图</h3><h4 id="1、bar">1、bar()</h4><p>绘制柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(x, height, width:<span class="built_in">float</span>=<span class="number">0.8</span>, bottom=<span class="literal">None</span>, *, align:<span class="built_in">str</span>=<span class="string">&#x27;center&#x27;</span>, data=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td>表示x坐标，数据类型为float类型，一般为np.arange()生成的固定步长列表</td></tr><tr><td style="text-align:center">height</td><td>表示柱状图的高度，也就是y坐标值，数据类型为float类型，一般为一个列表，包含生成柱状图的所有y值</td></tr><tr><td style="text-align:center">width</td><td>表示柱状图的宽度，取值在0-1之间，默认值为0.8</td></tr><tr><td style="text-align:center">bottom</td><td>柱状图的起始位置，也就是y轴的起始坐标，默认值为None</td></tr><tr><td style="text-align:center">align</td><td>柱状图的中心位置，“center”，&quot;lege&quot;边缘，默认值为’center’</td></tr><tr><td style="text-align:center">color</td><td>柱状图颜色，默认为蓝色</td></tr><tr><td style="text-align:center">alpha</td><td>透明度，取值在0~1之间，默认值为1</td></tr><tr><td style="text-align:center">label</td><td>标签，设置后需要调用plt.legend()生成</td></tr><tr><td style="text-align:center">edgecolor</td><td>边框颜色(ec)</td></tr><tr><td style="text-align:center">linewidth</td><td>边框宽度，浮点数或类数组，默认为None (lw)</td></tr><tr><td style="text-align:center">tick_label</td><td>柱子的刻度标签，字符串或字符串列表，默认值为None。</td></tr><tr><td style="text-align:center">linestyle</td><td>线条样式(Is)</td></tr></tbody></table><p><strong>案例1</strong></p><p>基本柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">y = np.random.randint(<span class="number">2</span>, <span class="number">8</span>, size=<span class="number">5</span>)</span><br><span class="line">plt.bar(x, y, color=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_23-49-15.png" alt=""></p><p><strong>案例2</strong></p><p>测试参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">y = np.random.randint(<span class="number">2</span>, <span class="number">8</span>, size=<span class="number">5</span>)</span><br><span class="line">plt.bar(x, y, color=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], bottom=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], \</span><br><span class="line">        edgecolor=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-25_23-58-56.png" alt=""></p><h4 id="2、同位置多柱状图">2、同位置多柱状图</h4><p><strong>案例</strong></p><p>各个国家的奖牌数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国家</span></span><br><span class="line">countries = [<span class="string">&#x27;挪威&#x27;</span>, <span class="string">&#x27;德国&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;瑞典&#x27;</span>]</span><br><span class="line"><span class="comment"># 金牌</span></span><br><span class="line">goldMedal = [<span class="number">16</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 银牌</span></span><br><span class="line">silverMedal = [<span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 铜牌</span></span><br><span class="line">bronzeMedal = [<span class="number">13</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、将x轴转化为数值</span></span><br><span class="line">x = np.arange(<span class="built_in">len</span>(countries))</span><br><span class="line"><span class="comment"># 2、设置图形宽度</span></span><br><span class="line">width = <span class="number">0.2</span></span><br><span class="line"><span class="comment"># 3、设置图形起始位置</span></span><br><span class="line"><span class="comment"># - 金牌</span></span><br><span class="line">goldX = x</span><br><span class="line"><span class="comment"># - 银牌</span></span><br><span class="line">silverX = x + width</span><br><span class="line"><span class="comment"># - 铜牌</span></span><br><span class="line">bronzeX = x + <span class="number">2</span> * width</span><br><span class="line"><span class="comment"># 4、设置 x标签 位置居中，标签变回来，解决乱码问题</span></span><br><span class="line">plt.xticks(x + width, labels=countries)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 5、显示文本高度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(countries)):</span><br><span class="line">    plt.text(goldX[i], goldMedal[i], goldMedal[i], va=<span class="string">&#x27;bottom&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">    plt.text(silverX[i], silverMedal[i], silverMedal[i], va=<span class="string">&#x27;bottom&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">    plt.text(bronzeX[i], bronzeMedal[i], bronzeMedal[i], va=<span class="string">&#x27;bottom&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、绘图</span></span><br><span class="line">plt.bar(goldX, goldMedal, width=width, color=<span class="string">&#x27;gold&#x27;</span>)</span><br><span class="line">plt.bar(silverX, silverMedal, width=width, color=<span class="string">&#x27;silver&#x27;</span>)</span><br><span class="line">plt.bar(bronzeX, bronzeMedal, width=width, color=<span class="string">&#x27;saddlebrown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_01-34-00.png" alt=""></p><h4 id="3、堆叠状图">3、堆叠状图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国家</span></span><br><span class="line">countries = [<span class="string">&#x27;挪威&#x27;</span>, <span class="string">&#x27;德国&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;瑞典&#x27;</span>]</span><br><span class="line"><span class="comment"># 金牌</span></span><br><span class="line">goldMedal = [<span class="number">16</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 银牌</span></span><br><span class="line">silverMedal = [<span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 铜牌</span></span><br><span class="line">bronzeMedal = [<span class="number">13</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、设置图形起始绘制位置</span></span><br><span class="line"><span class="comment"># - 铜牌</span></span><br><span class="line">bronzeBottom = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># - 银牌</span></span><br><span class="line">silverBottom = bronzeBottom + bronzeMedal</span><br><span class="line"><span class="comment"># - 金牌</span></span><br><span class="line">goldBottom = silverBottom + silverMedal</span><br><span class="line"><span class="comment"># 2、解决乱码问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、绘图</span></span><br><span class="line">plt.bar(countries, goldMedal, bottom=goldBottom, color=<span class="string">&#x27;gold&#x27;</span>)</span><br><span class="line">plt.bar(countries, silverMedal, bottom=silverBottom, color=<span class="string">&#x27;silver&#x27;</span>)</span><br><span class="line">plt.bar(countries, bronzeMedal, bottom=bronzeBottom, color=<span class="string">&#x27;saddlebrown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_01-42-51.png" alt=""></p><h4 id="4、barh">4、barh()</h4><p>绘制水平柱状图，和bar()用法基本一致</p><p><strong>区别</strong>：width 和 height参数意义互换， bottom变成left</p><p><strong>案例</strong></p><p>将上面堆叠状图的案例简单修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国家</span></span><br><span class="line">countries = [<span class="string">&#x27;挪威&#x27;</span>, <span class="string">&#x27;德国&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;瑞典&#x27;</span>]</span><br><span class="line"><span class="comment"># 金牌</span></span><br><span class="line">goldMedal = [<span class="number">16</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 银牌</span></span><br><span class="line">silverMedal = [<span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 铜牌</span></span><br><span class="line">bronzeMedal = [<span class="number">13</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、设置图形起始绘制位置</span></span><br><span class="line"><span class="comment"># - 铜牌</span></span><br><span class="line">bronzeBottom = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># - 银牌</span></span><br><span class="line">silverBottom = bronzeBottom + bronzeMedal</span><br><span class="line"><span class="comment"># - 金牌</span></span><br><span class="line">goldBottom = silverBottom + silverMedal</span><br><span class="line"><span class="comment"># 2、解决乱码问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 3、绘图</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.barh(countries, goldMedal, height=<span class="number">0.5</span>, left=goldBottom, color=<span class="string">&#x27;gold&#x27;</span>)</span><br><span class="line">plt.barh(countries, silverMedal, height=<span class="number">0.5</span>, left=silverBottom, color=<span class="string">&#x27;silver&#x27;</span>)</span><br><span class="line">plt.barh(countries, bronzeMedal, height=<span class="number">0.5</span>, left=bronzeBottom, color=<span class="string">&#x27;saddlebrown&#x27;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_01-56-41.png" alt=""></p><h3 id="7、直方图">7、直方图</h3><table><thead><tr><th>柱状图</th><th>直方图</th></tr></thead><tbody><tr><td>柱状图一般用于描述<strong>离散</strong>型分类数据的对比</td><td>直方图一般用于描述<strong>连续</strong>型数据的分布关系</td></tr><tr><td>每根柱子宽度固定，柱子之间会有间距</td><td>每根柱子宽度可以不一样，且一般没有间距</td></tr><tr><td>横轴变量可以任意排序</td><td>横轴变量有一定顺序规则</td></tr></tbody></table><h4 id="hist">hist()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(x, bins=<span class="literal">None</span>, <span class="built_in">range</span>=<span class="literal">None</span>, density=<span class="literal">None</span>, weights=<span class="literal">None</span>, \</span><br><span class="line">        cumulative=<span class="literal">False</span>, bottom=<span class="literal">None</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, align=<span class="string">&#x27;mid&#x27;</span>, \</span><br><span class="line">        orientation=<span class="string">&#x27;vertical&#x27;</span>, rwidth=<span class="literal">None</span>, log=<span class="literal">False</span>, color=<span class="literal">None</span>, \</span><br><span class="line">        label=<span class="literal">None</span>, stacked=<span class="literal">False</span>, normed=<span class="literal">None</span>, *, data=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td>【必选参数】作直方图所要用的数据，必须是一维数组；多维数组可以先进行扁平化再作图。</td></tr><tr><td style="text-align:center">bins</td><td>直方图的柱数，即要分的组数，默认为10。</td></tr><tr><td style="text-align:center">weights</td><td>与x形状相同的权重数组；将x中的每个元素乘以对应权重值再计数；如果normed或density取值为True，则会对权重进行归一化处理。这个参数可用于绘制已合并的数据的直方图。</td></tr><tr><td style="text-align:center">density</td><td>布尔值，可选参数。如果”True”，返回元组的第一个元素将会将计数标准化以形成一个概率密度，也就是说，直方图下的正积(或积分)总和为1。这是通过将计数除以数的数量来实现的观察乘以箱子的宽度而不是除以总数数量的观察。如果叠加也是“真实”的，那么柱状图被规范化为1。(替代normed)</td></tr><tr><td style="text-align:center">bottom</td><td>数组，标量值或None；每个柱子底部相对于y=0的位置。如果是标量值，则每个柱子相对于y=0向上/向下的偏移量相同。如果是数组，则根据数组元素取值移动对应的柱子；即直方图上下便宜距离。</td></tr><tr><td style="text-align:center">histtype</td><td>{‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’}；'bar’是传统的条形直方图；'barstacked’是堆叠的条形直方图；'step’是未填充的条形直方图，只有外边框；‘stepfilled’是有填充的直方图；当histtvpe取值为’step’或’stepfilled’，rwidth设置失效，即不能指定柱子之间的间隔，默认连接在一起。</td></tr><tr><td style="text-align:center">align</td><td>{‘left’, ‘mid’, ‘right’}；‘left’：柱子的中心位于bins的左边缘；‘mid’：柱子位于bins左右边缘之间；‘right’：柱子的中心位于bins的右边缘。</td></tr><tr><td style="text-align:center">color</td><td>具体颜色，数组(元素为颜色)或None。</td></tr><tr><td style="text-align:center">label</td><td>字符串 (序列)或None；有多个数据集时，用label参数做标注区分。</td></tr><tr><td style="text-align:center">normed</td><td>是否将得到的直方图向量归一化，即显示占比，默认为0，不归一化；不推荐使用，建议改用density参数。</td></tr><tr><td style="text-align:center">edgecolor</td><td>直方图边框颜色。</td></tr><tr><td style="text-align:center">alpha</td><td>透明度</td></tr></tbody></table><p><strong>返回值</strong>:</p><p>n：数组或数组列表（直方图的值）</p><p>bins：数组（返回各个bin区间范围）</p><p>patches：列表或列表的列表（返回每个bins里面包含的数据，是一个list）</p><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.random.randint(<span class="number">140</span>, <span class="number">180</span>, size=<span class="number">200</span>)</span><br><span class="line">plt.hist(x, bins=<span class="number">10</span>, edgecolor=<span class="string">&#x27;w&#x27;</span>, color=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_09-54-46.png" alt=""></p><h3 id="8、饼状图">8、饼状图</h3><blockquote><p>饼状图用来显示一个数据系列，具体来说，饼状图显示一个数据系列中各项目的占项目总和的百分比。</p><p>Matplotlib 提供了一个 pie()函数，该函数可以生成数组中数据的饼状图。您可使用 x/sum(x) 来计算各个扇形区域占饼图总和的<br>百分比。</p></blockquote><h4 id="pie">pie()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie(x, explode=<span class="literal">None</span>, labels=<span class="literal">None</span>, colors=<span class="literal">None</span>, autopct=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td>数组序列，数组元素对应扇形区域的数量大小。</td></tr><tr><td style="text-align:center">labels</td><td>列表字符串序列，为每个扇形区域备注一个标签名字。</td></tr><tr><td style="text-align:center">colors</td><td>为每个扇形区域设置颜色，默认按照颜色周期自动设置。</td></tr><tr><td style="text-align:center">autopct</td><td>格式化字符串&quot;fmt%pct”，使用百分比的格式设置每个扇形区的标签，并将其放置在扇形区内。</td></tr><tr><td style="text-align:center">pctdistance</td><td>设置百分比标签与圆心的距离。</td></tr><tr><td style="text-align:center">labeldistance</td><td>设置各扇形标签 (图例)与圆心的距离。</td></tr><tr><td style="text-align:center">explode</td><td>指定饼图某些部分的突出显示，即呈现爆炸式。</td></tr><tr><td style="text-align:center">shadow</td><td>是否添加饼图的阴影效果。</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义饼的标签</span></span><br><span class="line">label = [<span class="string">&#x27;娱乐&#x27;</span>, <span class="string">&#x27;育儿&#x27;</span>, <span class="string">&#x27;饮食&#x27;</span>, <span class="string">&#x27;房贷&#x27;</span>, <span class="string">&#x27;交通&#x27;</span>, <span class="string">&#x27;其他&#x27;</span>]</span><br><span class="line"><span class="comment"># 每个标签所占的数量</span></span><br><span class="line">x = [<span class="number">200</span>, <span class="number">500</span>, <span class="number">1200</span>, <span class="number">7000</span>, <span class="number">200</span>, <span class="number">900</span>]</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;饼图示例：8月份家庭支出&#x27;</span>)</span><br><span class="line"><span class="comment"># %.2f%%显示百分比，保留两位小数</span></span><br><span class="line">plt.pie(x, labels=label, autopct=<span class="string">&#x27;%.2f%%&#x27;</span>, colors=[<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_10-20-14.png" alt=""></p><h3 id="9、散点图">9、散点图</h3><blockquote><p>散点图也叫XY 图，它将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定</p><p>通过观察散点图上数据点的分布情况，我们可以推断出变量间的相关性。如果变量之间不存在相互关系，那么在散点图上就会表现为随机分布的离散的点，如果存在某种相关性，那么大部分的数据点就会相对密集并以某种趋势星现。</p></blockquote><h4 id="scatter">scatter()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, norm=<span class="literal">None</span>, \</span><br><span class="line">            vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, alpha=<span class="literal">None</span>, linewidths=<span class="literal">None</span>, edgecolors=<span class="literal">None</span>, \</span><br><span class="line">            plotnonfinite=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x, y</td><td>散点的坐标</td></tr><tr><td>s</td><td>散点的面积</td></tr><tr><td>c</td><td>散点的颜色(默认值为蓝色，‘b’，其余颜色同plt.plot( ))</td></tr><tr><td>marker</td><td>散点样式(默认值为实心圆，&quot;o，其余样式同plt.plot( ))</td></tr><tr><td>alpha</td><td>散点透明度 ([0,1]之间的数，0表示完全透明，1则表示完全不透明)</td></tr><tr><td>linewidths</td><td>散点的边缘线宽</td></tr><tr><td>edgecolors</td><td>散点的边缘颜色</td></tr><tr><td>cmap</td><td>Colormap，默认 None，标量或者是一个 colormap 的名字，只有c是一个浮点数数组的时候才使用</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.random.rand(<span class="number">50</span>)</span><br><span class="line">y = np.random.rand(<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 生成一个浮点数或者N维浮点数组，取值范围：正态分布的随机样本数</span></span><br><span class="line">s = (<span class="number">100</span> * np.random.randn(<span class="number">50</span>))</span><br><span class="line"><span class="comment"># 颜色随机</span></span><br><span class="line">colors = np.random.rand(<span class="number">50</span>)</span><br><span class="line">plt.scatter(x, y, s, c=colors)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_10-36-18.png" alt=""></p><h3 id="10、词云图">10、词云图</h3><blockquote><p>WordCloud 是一款python环境下的词云图工具包，同时支持python2和python3把关键词数据转换成直观且有趣的图文模式</p></blockquote><p>pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wordcloud</span><br></pre></td></tr></table></figure><p>conda安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge wordcloud</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1Jt4y1h7Vt?t=665.4&amp;p=61">【b站视频】</a></p><h3 id="11、保存图片">11、保存图片</h3><h4 id="savefig">savefig()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(fname, dpi=<span class="literal">None</span>, facecolor=<span class="string">&#x27;w&#x27;</span>, edgecolor=<span class="string">&#x27;w&#x27;</span>, orientation=<span class="string">&#x27;portrait&#x27;</span>, papertype=<span class="literal">None</span>, \</span><br><span class="line">           <span class="built_in">format</span>=<span class="literal">None</span>, transparent=<span class="literal">False</span>, bbox_inches=<span class="literal">None</span>, pad_inches=<span class="number">0.1</span>, frameon=<span class="literal">None</span>, metadata=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">fname</td><td>（字符串或者仿路径或仿文件）如果格式已经设置，这将决定输出的格式并将文件按fname来保存。如果格式没有设置，在fname有扩展名的情况下推断按此保存，没有扩展名将按照默认格式存储为“png”格式，并将适当的扩展名添加在fname后面。</td></tr><tr><td style="text-align:center">dpi</td><td>分辨率，每英寸的点数</td></tr><tr><td style="text-align:center">facecolor</td><td>(颜色或“auto”，默认值:“auto”) : 图形表面颜色。如果是“auto”，使用当前图形的表面颜色</td></tr><tr><td style="text-align:center">edgecolor</td><td>(颜色或“auto”，默认值:“auto”) : 图形边缘颜色。如果是“auto”，使用当前图形的边缘颜色</td></tr><tr><td style="text-align:center">format</td><td>字符串，文件格式，比如“png”，“pdf”，“svg”等，未设置的行为将被记录在fname中</td></tr><tr><td style="text-align:center">transparent</td><td>用于将图片背景设置为透明。图形也会是透明，除非通过关键字参数指定了表面颜色或边缘</td></tr></tbody></table><p><strong>案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">50</span>, <span class="number">51</span>)</span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.savefig(<span class="string">&#x27;第一个绘图程序.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="五、pandas">五、pandas</h2><h3 id="1、series">1、series</h3><blockquote><p>Series 结构，也称 Series 序列，是 Pandas 常用的数据结构之一，它是一种类似于一维数组的结构，由一组<strong>数据值</strong> (value) 和一组<strong>标签</strong>组成，其中标签与数据值具有对应关系。</p><p>标签不必是唯一的，但必须是<strong>哈希类型</strong>。该对象既支持基于整数的索引，也支持基于标签的索引，并提供了许多万法来执行涉及索引的操作。ndarray的统计方法已被覆盖，以自动排除缺失的数据 (目前表示为<strong>NaN</strong>)</p><p>Series 可以保存任何数据类型，比如整数、字符串、浮点数、Pthon 对象等，它的标签默认为整数，从0 开始依次递增。Series的结构图，如下所示:</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/da/Snipaste_2023-01-26_13-48-17.png" alt=""></p></blockquote><h4 id="1-1、创建">1.1、创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>, name=<span class="literal">None</span>, copy=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">data</td><td>输入的数据，可以是列表、常量、ndarray数组等，如果是字典，则保持参数顺序</td></tr><tr><td style="text-align:center">index</td><td>索引值，必须是可散列的(不可变数据类型（str，bytes和数值类型）），并且与数据具有相同的长度，允许使用非唯一索引值。如果未提供，将默认为Rangelndex(0, 1, 2, … , n)</td></tr><tr><td style="text-align:center">dtype</td><td>输出系列的数据类型。如果未指定，将从数据中推断</td></tr><tr><td style="text-align:center">name</td><td>为Series定义一个名称</td></tr><tr><td style="text-align:center">copy</td><td>表示对data进行拷贝，默认为 False，仅影啊Series和ndarray数组</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2023/01/08/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/08/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Linux目录结构">一、Linux目录结构</h2><p>linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录<code>“/”</code>，然后在此目录下再创建其他的目录。</p><p><em><strong>在Linux世界里,一切皆文件</strong></em></p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_13-29-07.png" style="zoom: 80%;" /> <ul><li><p><strong>/bin [常用]</strong> (usr/bin 、 /usr/local/bin)</p><blockquote><p>是Binary的缩写,这个目录存放着最经常使用的命令</p></blockquote></li><li><p><strong>/sbin</strong> (usr/sbin ./usr/local/sbin)</p><blockquote><p>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</p></blockquote></li><li><p><strong>/home [常用]</strong></p><blockquote><p>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名，</p></blockquote></li><li><p><strong>/root [常用]</strong></p><blockquote><p>该目录为系统管理员，也称作超级权限者的用户主目录</p></blockquote></li><li><p><strong>/lib</strong></p><blockquote><p>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</p></blockquote></li><li><p><strong>/lost+found</strong></p><blockquote><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p></blockquote></li><li><p><strong>/etc [常用]</strong></p><blockquote><p>所有的系统管理所需要的配置文件和子目录my.conf</p></blockquote><ul><li><p>/etc/passwd</p><ul><li><p>用户( user）的配置文件，记录用户的各种信息</p></li><li><p>每行的含义 : 用户名:口今:用户标识号:组标识号(gid):注释性描述:主目录:登录Shell</p></li></ul></li><li><p>/etc/shadow</p><ul><li><p>口令的配置文件</p></li><li><p>每行的含义:登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p></li></ul></li><li><p>/etc/group</p><ul><li><p>组(group)的配置文件，记录Linux包含的组的信息</p></li><li><p>每行含义 : 组名:口令:组标识号:组内用户列表</p></li></ul></li></ul></li><li><p><strong>/usr [常用]</strong></p><blockquote><p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</p></blockquote></li><li><p><strong>/boot [常用]</strong></p><blockquote><p>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</p></blockquote></li><li><p><strong>/proc [别动]</strong></p><blockquote><p>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</p></blockquote></li><li><p><strong>/srv [别动]</strong></p><blockquote><p>service缩写，该目录存放一些服务启动之后需要提取的数据</p></blockquote></li><li><p><strong>/sys [别动]</strong></p><blockquote><p>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs</p></blockquote></li><li><p><strong>/tmp</strong></p><blockquote><p>这个目录是用来存放一些临时文件的</p></blockquote></li><li><p><strong>/dev</strong></p><blockquote><p>类似于windows的设备管理器，把所有的硬件用文件的形式存储</p></blockquote></li><li><p><strong>/media [常用]</strong></p><blockquote><p>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p></blockquote></li><li><p><strong>/mnt [常用]</strong></p><blockquote><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上然后进入该目录就可以查看里的内容了。 d:/myshare</p></blockquote></li><li><p><strong>/opt</strong></p><blockquote><p>这是给主机额外安装软件所存放的目录。如安装ORACLE数据库就可放到该目录下。默认为空</p></blockquote></li><li><p><strong>/usr/local [常用]</strong></p><blockquote><p>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序</p></blockquote></li><li><p><strong>/var [常用]</strong></p><blockquote><p>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件</p></blockquote></li><li><p><strong>/selinux [security-enhanced linux]</strong></p><blockquote><p>SELinux是一种安全子系统,它能控制程序只能访问特定文件,有三种工作模式，可以自行设置</p></blockquote></li></ul><h2 id="二、远程">二、远程</h2><h3 id="远程登录">远程登录</h3><p>具体开发中的应用场景:</p><ol><li>linux服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序员需要远程登录到Linux进行项目管理或者开发</li><li>画出简单的网络拓扑示意图(帮助理解)</li><li>远程登录客户端有 Xshell6，Xftp6，其它的远程工具大同小异</li></ol><p><a href="https://www.xshell.com/zh/free-for-home-school/">Xshell6，Xftp6下载</a></p><p><strong>下载流程:</strong> 输入姓名、邮件、勾选两者，然后点击下载，去邮箱里面等待邮件，点击链接即可下载</p><p><strong>使用Xshell连接</strong></p><ul><li>1、获取ip：</li></ul><p>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-03-43.png" style="zoom:80%;" /> <ul><li>2、打开主机命令提示符终端，测试是否是否连通</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.37.129</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-09-08.png" alt=""></p><p>失败的话，检查主机服务</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-14-23.png" style="zoom:67%;" /> <ul><li>3、打开xshell</li></ul><p>新建会话</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-19-11.png" alt=""></p><p>点击创建好的会话</p><p>输入账号密码（也可以在新建会话的时候，选择左边用户身份验证，输入账号密码）</p><p>后面的弹窗选择接受并保存（中间那个）</p><p>结果：</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-25-28.png" style="zoom:80%;" />  <h3 id="远程文件传输">远程文件传输</h3><p><strong>使用xftp</strong></p><p>1、新建会话</p><p>乱码注意第五步，或者右键建立好的会话，选择属性</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_15-36-59.png" style="zoom:50%;" /> <h2 id="三、vi、vim">三、vi、vim</h2><blockquote><p>Linux 系统会内置 vi 文本编辑器<br>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p></blockquote><h3 id="模式">模式</h3><ul><li><p><strong>正常模式</strong></p><p>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用[上下左右] 按键来移动光标，你可以使用[删除字符]或[删除整行]来处理档案内容 ，也可以使用[复制、粘贴]来处理你的文件数据。</p></li><li><p><strong>插入模式</strong></p><p>按下<strong>i,l,o,o,a,A,R</strong>等任何一个字母之后才会进入编辑模，<strong>一般来说按i即可</strong>.</p></li><li><p><strong>命令行模式</strong></p><p>在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的!</p></li></ul><p><strong>模式切换</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_22-02-42.png" alt=""></p><p><strong>:w</strong>：保存文件但不退出vi</p><p><strong>:w file</strong>： 将修改另外保存到file中，不退出vi</p><p><strong>:w!</strong>： 强制保存，不推出vi</p><p><strong>:wq</strong>： 保存文件并退出vi</p><p><strong>:wq!</strong>： 强制保存文件，并退出vi</p><p><strong>:q</strong>： 不保存文件，退出vi</p><p><strong>:q!</strong>： 不保存文件，强制退出vi</p><p><strong>:e!</strong>： 放弃所有修改，从上次保存文件开始再编辑</p><h3 id="快捷键">快捷键</h3><table><thead><tr><th style="text-align:center">效果</th><th style="text-align:left">使用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>复制</strong></td><td style="text-align:left">【正常模式】yy：复制光标所在的一行，nyy：复制多行，例如：5yy就是复制光标开始以下5行</td></tr><tr><td style="text-align:center"><strong>粘贴</strong></td><td style="text-align:left">【正常模式】p：粘贴内容</td></tr><tr><td style="text-align:center"><strong>删除</strong></td><td style="text-align:left">【正常模式】dd：删除光标所在的一行，ndd：删除多行，例如：5dd就是删除光标开始以下5行</td></tr><tr><td style="text-align:center"><strong>查找</strong></td><td style="text-align:left">【命令行模式】/关键字，回车，按下n（查找下一个）</td></tr><tr><td style="text-align:center"><strong>行号</strong></td><td style="text-align:left">【命令行模式】:set nu：打开行号；:set nonu：关闭行号</td></tr><tr><td style="text-align:center"><strong>定位</strong></td><td style="text-align:left">【正常模式】G：行尾；gg：行首；n + shift+g：定位到第 n 行</td></tr><tr><td style="text-align:center"><strong>撤回</strong></td><td style="text-align:left">【正常模式】u：撤回</td></tr></tbody></table><h2 id="四、关机重启同步，登录注销">四、关机重启同步，登录注销</h2><p><strong>关机</strong></p><ul><li><p>立即关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">halt</span><br></pre></td></tr></table></figure></li><li><p>一分钟后关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h 1</span><br></pre></td></tr></table></figure></li></ul><p><strong>重启</strong></p><ul><li><p>立即重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ul><p><strong>同步</strong></p><ul><li><p>把内存中的数据同步到磁盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure></li></ul><p>目前的 shutdown/reboot/halt 等命令均已经在关机前进行sync，但是小心驶得万年船，还是在操作前使用一次sync</p><p><strong>登录注销</strong></p><p>登录时<strong>尽量少用 root 帐号登录</strong>，因为它是系统管理员，最大的权限，<strong>避免操作失误</strong>。可以利用普通用户登录，登录后再用”su- 用户名’命令来切换成系统管理员身份</p><ul><li><p>切换用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 用户名</span><br></pre></td></tr></table></figure></li><li><p>注销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-08_23-01-19.png" alt=""></p><h2 id="五、用户管理">五、用户管理</h2><h3 id="用户">用户</h3><p><strong>1、添加用户</strong></p><ul><li>默认目录在/home</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br></pre></td></tr></table></figure><p><strong>细节说明:</strong><br><br>当创建用户成功后，会自动的创建和用户同名的家目录<br></p><ul><li>也可以通过以下命令，给新创建的用户指定家目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -d 指定目录 新的用户名，</span><br></pre></td></tr></table></figure><p><strong>2、设置密码</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><p><strong>3、显示当前用户所在目录</strong></p><p>Print Working Directory</p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>4、删除用户</strong></p><ul><li>基本用法，但是保留了家目录（一般建议保留）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><ul><li>删除用户，以及用户主目录（谨慎使用）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r 用户名</span><br></pre></td></tr></table></figure><p><strong>5、查询用户信息</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> 用户名</span><br></pre></td></tr></table></figure><p><strong>6、切换用户</strong></p><ul><li>权限高到权限低不需要输入密码，反之需要</li><li>返回原来用户使用<code>exit</code> 或者 <code>logout</code></li></ul><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 要切换的用户名</span><br></pre></td></tr></table></figure><p><strong>7、查看当前用户信息</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> am ic</span><br></pre></td></tr></table></figure><h3 id="用户组">用户组</h3><p>结合<strong>第十二节 组</strong> 学习</p><p>系统可以对有共性/权限的多个用户进行统一管理</p><p><strong>1、新增组</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><p><strong>2、删除组</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><p><strong>3、增加用户时，直接指定到用户组</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g 用户组 用户名</span><br></pre></td></tr></table></figure><p><strong>4、修改用户组</strong></p><p>已有的组修改组，没有组的用户指定组</p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d 目录名 用户名</span><br></pre></td></tr></table></figure><p>说明：改变用户登陆的初始目录；[<strong>特别说明</strong>]：用户需要有进入到这个目录的权限才行</p><h2 id="六、运行级别">六、运行级别</h2><p><strong>1、说明</strong></p><table><thead><tr><th style="text-align:center">运行级别</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td>关机</td></tr><tr><td style="text-align:center">1</td><td>单用户[找回丢失密码]</td></tr><tr><td style="text-align:center">2</td><td>多用户状态没有网络服务</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td><strong>多用户状态有网络服务</strong></td></tr><tr><td style="text-align:center">4</td><td>系统未使用保留给用户</td></tr><tr><td style="text-align:center"><strong>5</strong></td><td><strong>图形界面</strong></td></tr><tr><td style="text-align:center">6</td><td>系统重启</td></tr></tbody></table><p><strong>常用运行级别是3和5</strong>，也可以指定默认运行级别 ，后面演示</p><p><strong>2、切换不同的运行级别</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456] </span><br></pre></td></tr></table></figure><p><strong>3、指定默认运行级别</strong></p><p>在/etc/inittab文件中</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-10_11-45-55.png" alt=""></p><h3 id="面试题">面试题</h3><p>如何找回root密码？</p><p>1、centos7以后系统</p><p><strong>[第一步]</strong>、启动系统、进入开机界面、按‘e’进入编辑界面（注意要快）</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-10_12-26-56.png" alt=""></p><p><strong>[第二步]</strong>、在图示位置(UTF-8后面)输入<code>init=/bin/sh</code>，然后按Ctrl + x进入<strong>单用户模式</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-10_12-09-01.png" alt=""></p><p><strong>[第三步]</strong>、</p><ul><li>1、输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure><ul><li>2、回车，再输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>输入要设定的密码，回车再次输入，回车，显示passwd…就说明修改成功了</p><ul><li>3、回车，再输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /.autorelabel</span><br></pre></td></tr></table></figure><ul><li>4、回车，再输入以下命令点击回车，就可以等待系统自动修改密码了，时间会有点长，耐心等待即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> /sbin/init</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-10_12-26-22.png" alt=""></p><h2 id="七、帮助命令">七、帮助命令</h2><p><strong>1、man指令</strong></p><blockquote><p>man命令是Linux下最核心的命令之一。而man命令也并不是英文单词“man”的意思，它是单词manual的缩写，即使用手册的意思。man命令会列出一份完整的说明。 其内容包括命令语法、各选项的意义及相关命令 。更为强大的是，不仅可以查看Linux中命令的使用帮助，还可以查看软件服务配置文件、系统调用、库函数等帮助信息。man手册页文件存放在/usr/share/man目录下。</p></blockquote><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 要查询的指令</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td>在所有的man帮助手册中搜索</td></tr><tr><td style="text-align:center">-d</td><td>主要用于检查，如果用户加入了一个新的文件，就可以用这个参数检查是否出错</td></tr><tr><td style="text-align:center">-f</td><td>显示给定关键字的简短描述信息</td></tr><tr><td style="text-align:center">-p</td><td>指定内容时使用分页程序</td></tr><tr><td style="text-align:center">-M</td><td>指定man手册搜索的路径</td></tr><tr><td style="text-align:center">-w</td><td>显示文件所在位置</td></tr></tbody></table><p><strong>快捷键</strong></p><table><thead><tr><th style="text-align:center">效果</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">退出</td><td style="text-align:center">q</td></tr><tr><td style="text-align:center">按行下翻</td><td style="text-align:center">Enter</td></tr><tr><td style="text-align:center">按页下翻</td><td style="text-align:center">Space</td></tr><tr><td style="text-align:center">上翻一页</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center">/关键字</td></tr></tbody></table><p><strong>2、help指令</strong></p><blockquote><p>help命令用于<strong>显示shell内部命令</strong>的帮助信息。<br>help命令只能显示shell内部命令的帮助信息，而linux系统中绝大多数命令是外部命令，所以help命令的作用非常有限。而对于外部命令的帮助信息可以使man命令或者info命令查看。</p></blockquote><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> 要查询的参数</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-d</td><td>输出每个命令的简短描述</td></tr><tr><td style="text-align:center">-s</td><td>输出短格式的帮助信息</td></tr><tr><td style="text-align:center">-m</td><td>以伪man手册的格式显示帮助信息</td></tr></tbody></table><h2 id="八、文件目录指令">八、文件目录指令</h2><h3 id="pwd-ls-cd-mkdir-rmdir-touch-cp-rm-mv">- pwd|ls|cd|mkdir|rmdir|touch|cp|rm|mv</h3><ul><li><strong>pwd</strong></li></ul><p><strong>功能：显示当前工作目录的绝对路径</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><ul><li><strong>ls</strong></li></ul><p><strong>功能：查看目录下的文件和目录</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 要查看的目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td>都显示，包括隐藏的</td></tr><tr><td style="text-align:center">-l</td><td>以列表的方式显示信息</td></tr></tbody></table><p>也可以组合起来写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">ls</span> -la</span><br></pre></td></tr></table></figure><p>用适合人的方式显示：比如文件大小4，则会显示成4.0k</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure><ul><li><strong>cd</strong></li></ul><p><strong>功能：切换工作目录</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 指定目录</span><br></pre></td></tr></table></figure><p>实例：</p><p>返回用户家目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">或者直接</span><br><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>回到当前目录的上一级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><ul><li><strong>mkdir</strong></li></ul><p><strong>功能：创建目录</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] 要创建的目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-p</td><td>创建多级目录</td></tr></tbody></table><ul><li><strong>rmdir</strong></li></ul><p><strong>功能：删除空目录</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> 要删除的目录</span><br></pre></td></tr></table></figure><p>目录非空则使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf</span><br></pre></td></tr></table></figure><ul><li><strong>touch</strong></li></ul><p><strong>功能：创建空文件</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名</span><br></pre></td></tr></table></figure><ul><li><strong>cp</strong></li></ul><p><strong>功能：拷贝文件到指定目录下</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 需拷贝的文件 指定目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-r</td><td>递归复制整个文件夹</td></tr></tbody></table><p>重复文件强制覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">cp</span> -r 需拷贝的文件 指定目录</span><br></pre></td></tr></table></figure><ul><li><strong>rm</strong></li></ul><p><strong>功能：移除文件或者目录</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [选项] 要删除的目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-r</td><td>递归删除整个文件夹</td></tr><tr><td style="text-align:center">-f</td><td>强制删除不提示</td></tr></tbody></table><ul><li><strong>mv</strong></li></ul><p><strong>功能：移动文件与目录 或 重命名</strong></p><p>基本语法：</p><p>移动文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件或目录 移动到的新目录</span><br></pre></td></tr></table></figure><p>重命名（位置不变即为重命名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件或目录 原目录</span><br></pre></td></tr></table></figure><h3 id="cat-more-less-echo-head-tail">- cat|more|less|echo|head|tail|&gt;|&gt;&gt;</h3><ul><li><strong>cat</strong></li></ul><p><strong>功能：查看文件内容</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [选项] 要查看的文件</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td>显示文件内容并显示行号</td></tr></tbody></table><p>为了浏览方便，一般会带上管道命令 <code>| more</code></p><ul><li><strong>more</strong></li></ul><p><strong>功能:</strong></p><blockquote><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more<br>指令中内置了若干快捷键(交互的指令)</p></blockquote><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure><p><strong>快捷键</strong></p><table><thead><tr><th style="text-align:center">操作</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">space</td><td>下翻一页</td></tr><tr><td style="text-align:center">enter</td><td>下翻一行</td></tr><tr><td style="text-align:center">q</td><td>退出</td></tr><tr><td style="text-align:center">Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td style="text-align:center">Ctrl + B</td><td>返回上一屏</td></tr><tr><td style="text-align:center">=</td><td>输出当前行的行号</td></tr><tr><td style="text-align:center">:f</td><td>输出文件名和当前行行号</td></tr></tbody></table><ul><li><strong>less</strong></li></ul><p><strong>功能:</strong></p><blockquote><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率</strong></p></blockquote><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure><p><strong>快捷键</strong></p><table><thead><tr><th style="text-align:center">操作</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">space</td><td>下翻一页</td></tr><tr><td style="text-align:center">[pagedown]</td><td>下翻一页</td></tr><tr><td style="text-align:center">[pageup]</td><td>上翻一页</td></tr><tr><td style="text-align:center">/关键字</td><td>向下搜寻[关键字]的功能; n: 向下查找; N: 向上查找</td></tr><tr><td style="text-align:center">?关键字</td><td>向上搜寻[关键字]的功能; n: 向上查找; N: 向下查找</td></tr><tr><td style="text-align:center">q</td><td>退出</td></tr></tbody></table><ul><li><strong>echo</strong></li></ul><p><strong>功能：输出内容到控制台</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] 输出内容</span><br></pre></td></tr></table></figure><ul><li><strong>head</strong></li></ul><p><strong>功能：用于显示文件开头部分内容，默认显示10行</strong></p><p>基本语法：</p><p>缺省显示10行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> 文件</span><br></pre></td></tr></table></figure><p>显示n行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 行数n</span><br></pre></td></tr></table></figure><ul><li><strong>tail</strong></li></ul><p><strong>功能：用于显示文件尾部部分内容，默认显示10行</strong></p><p>基本语法：</p><p>缺省显示10行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> 文件</span><br></pre></td></tr></table></figure><p>显示n行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 行数n</span><br></pre></td></tr></table></figure><p>实时追踪该文档的所有更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f 文件</span><br></pre></td></tr></table></figure><ul><li><strong>&gt;、&gt;&gt;</strong></li></ul><p><strong>功能：</strong><br>&gt;: 输出重定向（覆盖）<br>&gt;&gt;: 追加<br>基本语法加案例</p><p>（1）功能描述 : 列表的内容写入文件a.txt中( 覆盖写)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &gt; 文件</span><br></pre></td></tr></table></figure><p>（2）功能描述 : 列表的内容追加到文件aa.txt的末尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al &gt;&gt; 文件</span><br></pre></td></tr></table></figure><p>（3）功能描述 : 将文件1的内容覆盖到文件2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件1 &gt; 文件2</span><br></pre></td></tr></table></figure><p>（4） 追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> “内容<span class="string">&quot; &gt;&gt; 文件 </span></span><br></pre></td></tr></table></figure><h3 id="ln-history-date">- ln|history|date</h3><ul><li><strong>ln</strong></li></ul><p><strong>功能：软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s [源文件或目录] [软链接名]</span><br></pre></td></tr></table></figure><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-10_16-55-06.png" alt=""></p><p>pwd显示的软链接，比如上面的案例，再输入pwd，则会显示/root/demo/ggw软链接</p><ul><li><strong>history</strong></li></ul><p><strong>功能：查看已经执行过历史命令,也可以执行历史指令</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p>查看 n 条最近使用的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> n</span><br></pre></td></tr></table></figure><p>执行历史编号为 n 的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!n</span><br></pre></td></tr></table></figure><h2 id="九、时间日期类">九、时间日期类</h2><ul><li><strong>date</strong></li></ul><p><strong>功能1：显示当前时间</strong></p><p>基本语法：</p><p>（1）显示当前时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> </span><br></pre></td></tr></table></figure><p>（2）显示当前年份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%Y</span><br></pre></td></tr></table></figure><p>（3）显示当前月份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%m</span><br></pre></td></tr></table></figure><p>（4）显示当前是那一天</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%d</span><br></pre></td></tr></table></figure><p>（5）显示当前年月日时分秒</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><p><strong>功能2：设置日期</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -s 字符串时间</span><br></pre></td></tr></table></figure><p>案例：</p><p>设置成：2020-11-03 20:03:21</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2020-11-03 20:03:21&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>cal</strong></li></ul><p><strong>功能：查看日历</strong></p><p>基本语法：</p><p>缺省显示本月日历</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项]</span><br></pre></td></tr></table></figure><p>案例：</p><p>显示某一年的日历</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal 年份(2023)</span><br></pre></td></tr></table></figure><h2 id="十、搜索查找类">十、搜索查找类</h2><ul><li><strong>find</strong></li></ul><p><strong>功能：从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录显示在终端上面</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-name&lt;查询方式&gt;</td><td>按照指定文件名查找模式查找文件</td></tr><tr><td style="text-align:center">-user&lt;用户名&gt;</td><td>查找属于指定用户名的所有文件</td></tr><tr><td style="text-align:center">-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><p>案例:<br></p><p>按文件名:根据名称查找/home 目录下的hello.txt文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name hello.txt</span><br></pre></td></tr></table></figure><p>案例2 : 按拥有者 :查找/opt目录下，用户名称为 nobody的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /opt -user nobody</span><br></pre></td></tr></table></figure><p>案例3 : 查找整个linux系统下大于200M的文件( +n 大于 -n小于 n等于,单位有 k,M,G)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -size +200M</span><br></pre></td></tr></table></figure><ul><li><strong>locate</strong></li></ul><p><strong>功能:</strong></p><blockquote><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻</p></blockquote><p>基本语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate 搜索文件</span><br></pre></td></tr></table></figure><p>特别说明由于locate指令基于数据库进行查询，所以<strong>第一次运行前，必须使用updatedb指令创建locate数据库</strong>.<br>案例: <br>请使用locate指令快速定位 hello.txt 文件所在目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br><span class="line">locate hello.txt</span><br></pre></td></tr></table></figure><ul><li><strong>which</strong></li></ul><p><strong>功能：查看某个指令在那个目录下</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> 指令</span><br></pre></td></tr></table></figure><ul><li><strong>grep和“|”</strong></li></ul><p><strong>功能：grep: 过滤查找; 管道符“|”:表示将前一个命令的处理结果输出传递给后面的命令处理。</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 查找内容 源文件</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td>显示匹配行以及行号</td></tr><tr><td style="text-align:center">-i</td><td>忽略字母大小写</td></tr></tbody></table><p>案例：</p><p>请在hello.txt文件中，查找“yes”所在的行，并显示行号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> hello.txt | grep -n <span class="string">&quot;yes&quot;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&quot;yes&quot;</span> ./hello.txt</span><br></pre></td></tr></table></figure><h2 id="十一、压缩和解压类">十一、压缩和解压类</h2><ul><li><strong>gzip / gunzip</strong></li></ul><p><strong>功能：gzip: 压缩文件; gunzip: 解压</strong></p><p>基本语法：</p><p>描述：压缩文件，但是只能是*.gz文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件</span><br></pre></td></tr></table></figure><p>描述：解压缩文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip 文件.gz</span><br></pre></td></tr></table></figure><ul><li><strong>zip / unzip</strong></li></ul><p><strong>功能：zip: 压缩文件; unzip: 解压; 在项目打包发布中很有用</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] 打包后文件名.zip 要压缩的内容</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [选项] xxx.zip</span><br></pre></td></tr></table></figure><p>unzip<strong>常用选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-d</td><td>指定压缩文件存放目录</td></tr></tbody></table><p>案例</p><p>1、将/home下的所有文件/文件夹进行压缩成myhome.zip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r myhome.zip /home/</span><br></pre></td></tr></table></figure><p>这条命令会把home目录也压缩进去</p><p>2、将myhome.zip解压到/opt/tmp目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -d/opt/tmp /home/myhome.zip</span><br></pre></td></tr></table></figure><ul><li>tar</li></ul><p><em><em>功能：打包指令，最后的文件是</em>.tar.gz</em>*</p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 打包后的文件名.tar.gz 打包内容</span><br></pre></td></tr></table></figure><p>常用选项：</p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-c</td><td>产生.tar打包文件</td></tr><tr><td style="text-align:center">-v</td><td>显示详细信息</td></tr><tr><td style="text-align:center">-f</td><td>指定压缩后的文件名</td></tr><tr><td style="text-align:center">-z</td><td>打包的同时压缩</td></tr><tr><td style="text-align:center">-x</td><td>解压缩.tar文件</td></tr></tbody></table><p>案例：</p><p>1、压缩多个文件，将/home/pig.txt 以及 /home/cat.txt 压缩成 pc.tar.gz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</span><br></pre></td></tr></table></figure><p>2、将/home文件夹压缩成 demo.tar.gz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf demo.tar.gz /home/</span><br></pre></td></tr></table></figure><p>3、将 pc.tar.gz解压到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf pc.tar.gz</span><br></pre></td></tr></table></figure><p>4、将demo.tar.gz解压到 /opt/tmp2目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/tmp2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /home/demo.tar.gz -C /opt/tmp2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_21-05-14.png" alt=""></p><h2 id="十二、组">十二、组</h2><p>结合<strong>第五节 用户管理的用户组</strong> 学习</p><p>在linux中，所有用户都必须属于一个组里面，不能独立于组外</p><h3 id="1、所有者">1、所有者</h3><p>一般为文件的创建者，谁创建了，就自然属于谁</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_21-32-33.png" alt=""></p><ul><li><strong>chown</strong></li></ul><p><strong>功能：修改文件/目录的所有者</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> 用户名 文件/目录</span><br></pre></td></tr></table></figure><p>常用选项</p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-R</td><td>如果是目录则其下所有子文件或目录递归生效</td></tr></tbody></table><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_21-40-46.png" alt=""></p><h3 id="2、所在组">2、所在组</h3><p>当某个用户创建了一个文件后，这个文件就属于用户所在的组</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_21-48-13.png" alt=""></p><ul><li><strong>chgrp</strong></li></ul><p><strong>功能：修改文件所在的组</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> 组名 文件名</span><br></pre></td></tr></table></figure><p>用法与chown类似</p><p>常用选项</p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-R</td><td>如果是目录则其下所有子文件或目录递归生效</td></tr></tbody></table><h3 id="3、权限">3、权限</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_22-12-30.png" alt=""></p><p>0 - 9位说明</p><table><thead><tr><th style="text-align:center">0 - 9位</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">第0位</td><td style="text-align:left">确定文件类型：<br>l 是链接，相当于Windows快捷方式<br>d 是目录，相当于windows文件夹<br>c 是字符设备文件： 鼠标键盘<br>b 是块设备，比如硬盘</td></tr><tr><td style="text-align:center">第1 - 3位</td><td style="text-align:left">确定文件所有者的文件权限</td></tr><tr><td style="text-align:center">第4 - 6位</td><td style="text-align:left">确定文件所属组的权限</td></tr><tr><td style="text-align:center">第7 - 9位</td><td style="text-align:left">确定其他用户拥有的权限</td></tr></tbody></table><ul><li><strong>rwx作用到文件</strong></li></ul><p>1、[r]：代表可读(read)：可以读取,查看<br>2、[w]：代表可写(write)：可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>3、[×]：代表可执行(execute)：可以被执行</p><ul><li><strong>rwx作用到目录</strong></li></ul><p>1、[r]：代表可读(read)：可以读取，ls查看目录内容<br>2、[w]：代表可写(write)：可以修改,对目录内创建文件 + 删除文件 + 重命名目录<br>3、[x]：代表可执行(execute)：可以进入该目录</p><p><strong>rwx还可以用数字表示，r=4，w=2，x=1，则rwx=7</strong></p><p>其他说明：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_22-41-05.png" alt=""></p><p>这个数字代表：文件：则代表的是硬连接数；目录：则代表的是子目录数</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-11_22-46-22.png" alt=""></p><ul><li><strong>chmod</strong></li></ul><p><strong>功能：修改文件或目录权限</strong></p><p>基本语法：</p><p>u: 所有者; g: 所在组; o: 其他人; a: 所有人</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=x 文件名/目录名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> o+w 文件名/目录名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a-x 文件名/目录名</span><br></pre></td></tr></table></figure><p>案例：</p><p>1、给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=rx abc</span><br></pre></td></tr></table></figure><p>用数字表示等同于(rwx = 4 + 3 + 1, rx = 4 + 1, x = 1)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 751 abc</span><br></pre></td></tr></table></figure><p>2、文件的所有者除去执行的权限，增加组写的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u-x,g+w abc</span><br></pre></td></tr></table></figure><h2 id="十三、Shell编程">十三、Shell编程</h2><h3 id="1、了解">1、了解</h3><ul><li><p><strong>为什么要学习Shell编程</strong></p><ul><li>1、linux运维工程师在进行服务器集群管理时，需要编写shell程序来进行服务器管理。</li><li>2、对于JavaEE和Python程序员来说，是工作的需要，上级可能会要求编写一些shell脚本进行型程序或者是去维护服务器，比如编写一个定时备份服务器的脚本。</li><li>对于大数据程序员来说，，需要编写shell程序来管理集群。</li></ul></li><li><p><strong>Shell是什么</strong></p><p>Shell是一个命令解释器，为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，</p><p>用户可以使用Shell来启动、挂起、停止甚至编写一些程序。</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/linux-shell.png" alt=""></p></li></ul><h3 id="2、脚本的执行方式">2、脚本的执行方式</h3><ul><li><p><strong>脚本格式要求</strong></p><ul><li>1、脚本要以#!/bin/bash开头</li><li>2、脚本要有可执行权限</li></ul></li><li><p><strong>脚本常用的执行方式</strong></p><ul><li><p>方式1、输入脚本的绝对路径或相对路径</p><p>说明：首先要赋予脚本可执行权限，再执行脚本</p></li><li><p>方式2、sh + 脚本</p><p>说明：不用赋予脚本权限，直接执行即可</p></li></ul></li></ul><p>案例：创建一个Shell脚本，执行输出hello world</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>使用方式1执行</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_01-22-45.png" alt=""></p><p>使用方式2执行</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_01-25-49.png" alt=""></p><h3 id="3、变量">3、变量</h3><ul><li><strong>变量的介绍</strong></li></ul><p>1、Shell中的变量分为，系统变量和用户自定义变量</p><p>2、系统变量：$HOME, $PWD、$%SHELL、$USER等等</p><ul><li><strong>set</strong></li></ul><p><strong>功能：显示当前shell中的所有变量</strong></p><p>基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><ul><li><strong>Shell变量定义</strong></li></ul><p>基本语法：</p><p>1、定义变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=值</span><br></pre></td></tr></table></figure><p>2、撤销变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset 变量名</span><br></pre></td></tr></table></figure><p>3、声明静态变量(静态变量不能被unset)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly 变量</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;--------------------------&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1、定义变量a</span></span><br><span class="line">a=114514</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出变量要加上$</span></span><br><span class="line">echo a=$a</span><br><span class="line">echo &quot;a=$a&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;--------------------------&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2、撤销变量a</span></span><br><span class="line">unset a</span><br><span class="line">echo &quot;a=$a&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;--------------------------&quot;</span><br><span class="line">readonly b=2</span><br><span class="line">echo &quot;b=$b&quot;</span><br><span class="line">unset b</span><br><span class="line">echo &quot;b=$b&quot;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_10-28-13.png" alt=""></p><ul><li><strong>定义变量的规则</strong></li></ul><p>1、变量可以由字母、数字和下划线组成，但不能以数字开头</p><p>2、等号两侧不能有空格</p><p>3、变量名称一般为大写（上面是负面教材），这是个规范，不是规则</p><ul><li><strong>将命令的放回值赋给变量</strong></li></ul><p>1、使用反引号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=`命令`</span><br></pre></td></tr></table></figure><p>2、$()</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=$(命令)</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=`date`</span><br><span class="line">echo &quot;A=$A&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=2023年 01月 12日 星期四 10:38:58 CST</span><br></pre></td></tr></table></figure><h3 id="4、设置环境变量">4、设置环境变量</h3><p>基本语法：</p><p>1、将shell变量输出为全局变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export 变量名=值</span><br></pre></td></tr></table></figure><p>2、属性，使其立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> 配置文件（/etc/profile）</span><br></pre></td></tr></table></figure><p>案例：</p><p>1、设置并查看环境变量</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_11-30-29.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_11-04-34.png" alt=""></p><h3 id="5、注释">5、注释</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">内容</span><br><span class="line">！</span><br></pre></td></tr></table></figure><h3 id="6、位置参数变量和预定义变量">6、位置参数变量和预定义变量</h3><ul><li><strong>位置参数变量</strong></li></ul><blockquote><p>介绍当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如:<code>./myshell.sh 100 200</code>，这个就是一个执行shell的命令行，可以在myshell 脚本中获取到参数信息</p></blockquote><p>基本语法：</p><p><code>$n</code>：功能描述：n为数字，S0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}</p><p><code>$*</code>：功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体)</p><p><code>$@</code>：功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p><p><code>$#</code>：功能描述：这个变量代表命令行中所有参数的个数</p><p>案例：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_12-00-25.png" alt=""></p><ul><li><strong>预定义变量</strong></li></ul><blockquote><p>就是shell设计者事先已经定义好的变量，可以直接在shell中使用</p></blockquote><p>基本语法：</p><p><code>$$</code>：功能描述：当前进程的进程号（PID）<br><code>$!</code>：功能描述：后台运行的最后一个进程的进程号（PID）<br><code>$?</code>：功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值非0（具体是哪个数，由命令来决定），则证明上一个命令执行不正确。</p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前执行的进程id=$$&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以后台的方式运行一个脚本，并获取他的进程号</span></span><br><span class="line">/home/ggw/shellscripts/demo2.sh &amp;</span><br><span class="line">echo &quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="line">echo &quot;执行的结果是：$?&quot;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_12-24-11.png" alt=""></p><h3 id="7、运算符">7、运算符</h3><p>基本语法：</p><p>1、使用<code>$[运算式]</code>(推荐)、<code>$((运算式))</code>或者<code>expr m + n</code>(expression)</p><p>2、注意expr运算符间要有空格，如果希望将expr的结果赋值给某个变量，要使用``包裹</p><p>3、expr m - n</p><p>4、expr \*，/，%，分别代表乘、除、取余</p><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式一</span></span><br><span class="line">ANS1=$(((2+3)*4))</span><br><span class="line">echo &quot;ANS1=$ANS1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式二</span></span><br><span class="line">ANS2=$[(2+3)*4]</span><br><span class="line">echo &quot;ANS2=$ANS2&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式三</span></span><br><span class="line">TMP=`expr 2 + 3`</span><br><span class="line">ANS3=`expr $TMP \* 4`</span><br><span class="line">echo &quot;TMP=$TMP&quot;</span><br><span class="line">echo &quot;ANS3=$ANS3&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ANS1=20</span><br><span class="line">ANS2=20</span><br><span class="line">TMP=5</span><br><span class="line">ANS3=20</span><br></pre></td></tr></table></figure><h3 id="8、条件判断语句">8、条件判断语句</h3><p>基本语法：</p><p>注意条件两边要有空格，非空返回true，可使用$?验证(0为true, &gt;1为false)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ contition ]</span><br></pre></td></tr></table></figure><p>案例：</p><p><code>[ xxx ]</code>返回true</p><p><code>[]</code>返回false</p><p><code>[ xxx ] &amp;&amp; echo &quot;ok&quot; || echo &quot;hello&quot;</code>条件满足，执行后面的语句</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_15-44-21.png" alt=""></p><ul><li><strong>判断语句</strong></li></ul><p>1、常用判断条件</p><p>（1）<code>=</code> 字符串比较</p><p>（2）两个整数比较</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-eq</td><td style="text-align:center">等于 equal</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">不等于 not equal</td></tr><tr><td style="text-align:center">-lt</td><td style="text-align:center">小于 little</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">小于等于 little equal</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">大于 greater</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">大于等于 greater equal</td></tr></tbody></table><p>（3）按文件权限进行判断</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-r</td><td style="text-align:center">有读的权限</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">有写的权限</td></tr><tr><td style="text-align:center">-x</td><td style="text-align:center">有执行的权限</td></tr></tbody></table><p>（4）按文件类型进行判断</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-f</td><td style="text-align:center">文件存在并且一个常规文件</td></tr><tr><td style="text-align:center">-e</td><td style="text-align:center">文件存在</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">文件存在并且是一个目录</td></tr></tbody></table><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1、<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;1、相等&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2、23是否大于22</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断语句：使用 -gt</span></span><br><span class="line">if [ 23 -gt 22 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;2、大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、判断文件/home/ggw/shellscripts/demo1.sh是否存在</span></span><br><span class="line">if [ -f /home/ggw/shellscripts/demo1.sh ]</span><br><span class="line">then</span><br><span class="line">echo &quot;3、存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、相等</span><br><span class="line">2、大于</span><br><span class="line">3、存在</span><br></pre></td></tr></table></figure><h3 id="9、流程控制">9、流程控制</h3><ul><li><strong>if-fi判断</strong></li></ul><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><strong>if-elif-fi判断</strong></li></ul><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><strong>if-else-fi</strong></li></ul><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">else</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><strong>case语法</strong></li></ul><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">都不是执行此处代码</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">        echo &quot;1&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">        echo &quot;2&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">        echo &quot;nothing&quot;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>输出结果：</p><ul><li><strong>for循环</strong></li></ul><p>基本语法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for KEY in $*</span><br><span class="line">do</span><br><span class="line">        echo &quot;num is $KEY&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;---------------------------&quot;</span><br><span class="line">for KEY in $@</span><br><span class="line">do</span><br><span class="line">        echo &quot;num is $KEY&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;===========================&quot;</span><br><span class="line">for KEY in  &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;num is $KEY&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;---------------------------&quot;</span><br><span class="line">for KEY in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;num is $KEY&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_17-08-40.png" alt=""></p><p>基本语法2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((初始值;循环控制条件;变量变换))</span><br><span class="line">do</span><br><span class="line">代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>案例：</p><p>输出1-100的和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0</span><br><span class="line">for(( i=1; i&lt;=100; i++))</span><br><span class="line">do</span><br><span class="line">        SUM=$[$SUM+$i]  #获取SUM的值才需要加&quot;$&quot;符号</span><br><span class="line">done</span><br><span class="line">echo &quot;1-100的和是$SUM&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-100的和是5050</span><br></pre></td></tr></table></figure><ul><li><strong>while循环</strong></li></ul><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>案例：</p><p>输出1-100的和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le &quot;100&quot; ]</span><br><span class="line">do</span><br><span class="line">SUM=$[SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;1-100的和是$SUM&quot;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-100的和是5050</span><br></pre></td></tr></table></figure><h3 id="10、read读取控制台输入">10、read读取控制台输入</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [选项] 参数</span><br></pre></td></tr></table></figure><p>常用选项：</p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-p</td><td>指定读取值时的提示符</td></tr><tr><td style="text-align:center">-t</td><td>指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</td></tr></tbody></table><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入：&quot; -t 10 RES</span><br><span class="line">echo &quot;输入的结果是：$RES&quot;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_17-41-19.png" alt=""></p><h3 id="11、-函数">11、 函数</h3><blockquote><p>shell编程和其它语言一样，有系统函数，也可以自定义函数。</p></blockquote><p><strong>1、系统函数</strong></p><ul><li><strong>basename</strong></li></ul><p><strong>功能：返回完整路径最后/后面的部分，常用于获取文件名</strong></p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename [pathname] [suffix]</span><br></pre></td></tr></table></figure><p>选项：</p><p>如果加速suffix(后缀)的话，如果suffix被指定，basename会将pathname或string中的suffix去掉</p><p>案例：</p><p>请返回/home/ggw/demo.txt的demo</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_22-06-08.png" alt=""></p><ul><li><strong>dirname</strong></li></ul><p><strong>功能：返回完整路径最后/前面的部分，常用于获取文件名</strong></p><p>案例：</p><p>请返回/home/ggw/demo.txt的/home/ggw</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_22-09-18.png" alt=""></p><p><strong>2、自定义函数</strong></p><p>基本语法：</p><p>定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">Action;</span><br><span class="line">[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funname [值]</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">函数定义</span></span><br><span class="line">function getSum() &#123;</span><br><span class="line">SUM=$[$NUM1+$NUM2]</span><br><span class="line">echo &quot;和是$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line">NUM1=$1</span><br><span class="line">NUM2=$2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用</span></span><br><span class="line">getSum $NUM1 $NUM2</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/linux/Snipaste_2023-01-12_22-38-01.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown数学公式基本语法</title>
      <link href="/2023/01/07/MarkDown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/01/07/MarkDown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、如何添加">一、如何添加</h2><p>与LaTex类似</p><p><strong>（1）行内公式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$公式内容$</span><br></pre></td></tr></table></figure><p>例如：<code>E = mc^2</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>（2）多行公式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">公式内容</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">$$</span><br><span class="line">E = mc^2</span><br><span class="line">$$</span><br><span class="line">效果如下</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="二、希腊字符">二、希腊字符</h2><table><thead><tr><th>名称</th><th>大写</th><th>如何显示</th><th>小写</th><th>如何显示</th></tr></thead><tbody><tr><td>alpha</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></td><td><code>$A$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></td><td><code>$\alpha$</code></td></tr><tr><td>beta</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></td><td><code>$B$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></td><td><code>$\beta$</code></td></tr><tr><td>gamma</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Γ</span></span></span></span></td><td><code>$\Gamma$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span></td><td><code>$\gamma$</code></td></tr><tr><td>delta</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span></td><td><code>$\Delta$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></td><td><code>$\delta$</code></td></tr><tr><td>epsilon</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></td><td><code>$E$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></td><td><code>$\epsilon$</code></td></tr><tr><td>zeta</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></td><td><code>$Z$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ζ</mi></mrow><annotation encoding="application/x-tex">\zeta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07378em;">ζ</span></span></span></span></td><td><code>$\zeta$</code></td></tr><tr><td>eta</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></td><td><code>$H$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span></td><td><code>$\eta$</code></td></tr><tr><td>theta</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span></td><td><code>$\Theta$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></td><td><code>$\theta$</code></td></tr><tr><td>iota</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></td><td><code>$T$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span></td><td><code>$\iota$</code></td></tr><tr><td>kappa</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></td><td><code>$K$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span></td><td><code>$\kappa$</code></td></tr><tr><td>mu</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></td><td><code>$M$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span></td><td><code>$\mu$</code></td></tr><tr><td>nu</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></td><td><code>$N$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi></mrow><annotation encoding="application/x-tex">\nu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.06366em;">ν</span></span></span></span></td><td><code>$\nu$</code></td></tr><tr><td>xi</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ξ</mi></mrow><annotation encoding="application/x-tex">\Xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ξ</span></span></span></span></td><td><code>$\Xi$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span></td><td><code>$\xi$</code></td></tr><tr><td>omicron</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></td><td><code>$O$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ο</mi></mrow><annotation encoding="application/x-tex">\omicron</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ο</span></span></span></span></td><td><code>$\omicron$</code></td></tr><tr><td>pi</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span></td><td><code>$\Pi$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></td><td><code>$\pi$</code></td></tr><tr><td>rho</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></td><td><code>$P$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span></td><td><code>$\rho$</code></td></tr><tr><td>sigma</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span></td><td><code>$\Sigma$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></td><td><code>$\sigma$</code></td></tr><tr><td>tau</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></td><td><code>$T$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></td><td><code>$\tau$</code></td></tr><tr><td>upslion</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Υ</span></span></span></span></td><td><code>$\Upsilon$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>υ</mi></mrow><annotation encoding="application/x-tex">\upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">υ</span></span></span></span></td><td><code>$\upsilon$</code></td></tr><tr><td>phi</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></td><td><code>$\Phi$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td><code>$\phi$</code></td></tr><tr><td>chi</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></td><td><code>$X$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span></td><td><code>$\chi$</code></td></tr><tr><td>psi</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ψ</span></span></span></span></td><td><code>$\Psi$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span></td><td><code>$\psi$</code></td></tr><tr><td>omega</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span></td><td><code>$\Omega$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></td><td><code>$\omega$</code></td></tr></tbody></table><h2 id="三、上下标、根号、分数、括号、上下取整">三、上下标、根号、分数、括号、上下取整</h2><p><strong>!!首先要知道由{}包围的内容只一个小单元!!</strong>，可以用来消除二义性</p><p>本节都只对前后<strong>一个</strong>单元生效</p><p><strong>1、上下标</strong></p><ul><li><p>上标：<strong>^</strong></p></li><li><p>下标：<strong>_</strong></p></li></ul><p><strong>举例：</strong></p><p><code>A^B</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">A^B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></p><p><code>$&#123;AB&#125;^&#123;BC&#125;$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>A</mi><mi>B</mi></mrow><mrow><mi>B</mi><mi>C</mi></mrow></msup></mrow><annotation encoding="application/x-tex">{AB}^{BC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span></span></span></span></span></span></span></span></span></span></span></span></p><p><code>$&#123;AB&#125;^BC$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>A</mi><mi>B</mi></mrow><mi>B</mi></msup><mi>C</mi></mrow><annotation encoding="application/x-tex">{AB}^BC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p><code>A_B</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">A_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p><code>$&#123;AB&#125;_&#123;BC&#125;$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>A</mi><mi>B</mi></mrow><mrow><mi>B</mi><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{AB}_{BC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p><code>$&#123;AB&#125;_BC$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>A</mi><mi>B</mi></mrow><mi>B</mi></msub><mi>C</mi></mrow><annotation encoding="application/x-tex">{AB}_BC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p><strong>2、根号</strong></p><p><code>$\sqrt[a]&#123;b&#125;$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mi>b</mi><mi>a</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[a]{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7099em;"><span style="top:-2.9947em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">b</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span></span></span></span></p><p><strong>举例</strong>：</p><p><code>$\sqrt[a]b$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mi>b</mi><mi>a</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[a]b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7099em;"><span style="top:-2.9947em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">b</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span></span></span></span>$</p><p><code>$\sqrt[a]bc$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mi>b</mi><mi>a</mi></mroot><mi>c</mi></mrow><annotation encoding="application/x-tex">\sqrt[a]bc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7099em;"><span style="top:-2.9947em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">b</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span><span class="mord mathnormal">c</span></span></span></span></p><p><code>$\sqrt[a]&#123;bc&#125;$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mrow><mi>b</mi><mi>c</mi></mrow><mi>a</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[a]{bc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7099em;"><span style="top:-2.9947em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">b</span><span class="mord mathnormal">c</span></span></span><span style="top:-2.8922em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em;"><span></span></span></span></span></span></span></span></span></p><p><strong>3、分数</strong></p><p>1、<code>$\frac&#123;a&#125;&#123;b&#125;$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac {a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 推荐</p><p>2、<code>$a \over b$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">a \over b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>举例：</p><p><code>$a+b \over b$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">a+b \over b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><code>$a+&#123;c&#125; \over b$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>+</mo><mi>c</mi></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">a+{c} \over b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1473em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8023em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><strong>4、括号</strong></p><p><code>$()$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></p><p><code>$[]$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mclose">]</span></span></span></span></p><p><code>$\&#123;\&#125;$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mclose">}</span></span></span></span> 需要转义</p><p><code>$\langle \rangle$</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mclose">⟩</span></span></span></span></p><p><strong>5、上下取整</strong></p><p>向上取整： 使用\lceil和\rceil表示。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>x</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil x \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">x</span><span class="mclose">⌉</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\lceil x \rceil$</code><br>向下取整： 使用\lfloor和\rfloor表示。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>x</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor x \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">x</span><span class="mclose">⌋</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\lfloor x \rfloor$</code></p><h2 id="四、数学运算符与数学符号">四、数学运算符与数学符号</h2><p>1、<code>+ - * / =</code>这五个直接输入即可。</p><p>2、特殊形式的数学运算符与数学符号如下表：</p><table><thead><tr><th>符号</th><th>Tex</th><th>符号</th><th>Tex</th><th>符号</th><th>Tex</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo></mrow><annotation encoding="application/x-tex">\pm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">±</span></span></span></span></td><td><code>$\pm$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∓</mo></mrow><annotation encoding="application/x-tex">\mp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">∓</span></span></span></span></td><td><code>$\mp$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span></td><td><code>$\cdot$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span></td><td><code>$\times$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">÷</span></span></span></span></td><td><code>$\div$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋆</mo></mrow><annotation encoding="application/x-tex">\star</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">⋆</span></span></span></span></td><td><code>$\star$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">\ast</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span></td><td><code>$\ast$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span></span></span></span></td><td><code>$\cup$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span></td><td><code>$\cap$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span></td><td><code>$\vee$ 或者 $\lor$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span></td><td><code>$\wedge$ 或者 $\land$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≃</span></span></span></span></td><td><code>$\simeq$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span></td><td><code>$\oplus$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊗</span></span></span></span></td><td><code>$\otimes$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">∼</span></span></span></span></td><td><code>$\sim$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span></td><td><code>$\circ$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∙</span></span></span></span></td><td><code>$\bullet$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></td><td><code>$\subset$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>△</mo></mrow><annotation encoding="application/x-tex">\bigtriangleup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">△</span></span></span></span></td><td><code>$\bigtriangleup$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>▽</mo></mrow><annotation encoding="application/x-tex">\bigtriangledown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">▽</span></span></span></span></td><td><code>$\bigtriangledown$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊃</mo></mrow><annotation encoding="application/x-tex">\supset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊃</span></span></span></span></td><td><code>$\supset$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∇</span></span></span></span></td><td><code>$\nabla$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∃</span></span></span></span></td><td><code>$\exists$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span></td><td><code>$\subseteq$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi></mrow><annotation encoding="application/x-tex">\partial</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span></td><td><code>$\partial$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></td><td><code>$\infty$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊇</span></span></span></span></td><td><code>$\supseteq$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∀</span></span></span></span></td><td><code>$\forall$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">√</mi></mrow><annotation encoding="application/x-tex">\surd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2em;"></span><span class="mord">√</span></span></span></span></td><td><code>$\surd$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span></td><td><code>$\in$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi></mrow><annotation encoding="application/x-tex">\angle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mord">∠</span></span></span></span></td><td><code>$\angle$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">⊥</span></span></span></span></td><td><code>$\bot$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∋</mo></mrow><annotation encoding="application/x-tex">\owns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∋</span></span></span></span></td><td><code>$\ni$ 或者 $\owns$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span></td><td><code>$\leq$ 或者 $\le$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span></td><td><code>$\geq$ 或者 $ge$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span></span></span></span></td><td><code>$\notin$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≡</span></span></span></span></td><td><code>$\equiv$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span></span></span></span></td><td><code>$\approx$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span></td><td><code>$\neq$ 或者 $\ne$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋘</mo></mrow><annotation encoding="application/x-tex">\lll</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.585em;vertical-align:-0.0352em;"></span><span class="mrel amsrm">⋘</span></span></span></span></td><td><code>$\lll$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋙</mo></mrow><annotation encoding="application/x-tex">\ggg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.585em;vertical-align:-0.0352em;"></span><span class="mrel amsrm">⋙</span></span></span></span></td><td><code>$\ggg$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;"></span><span class="mrel">≅</span></span></span></span></td><td><code>$\cong$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∝</mo></mrow><annotation encoding="application/x-tex">\propto</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel">∝</span></span></span></span></td><td><code>$\propto$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⫋</mo></mrow><annotation encoding="application/x-tex">\varsubsetneqq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0087em;vertical-align:-0.2514em;"></span><span class="mrel amsrm"></span></span></span></span></td><td><code>$\varsubsetneqq$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⫌</mo></mrow><annotation encoding="application/x-tex">\varsupsetneqq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0087em;vertical-align:-0.2514em;"></span><span class="mrel amsrm"></span></span></span></span></td><td><code>$\varsupsetneqq$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span></td><td><code>$\mid$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇛</mo></mrow><annotation encoding="application/x-tex">\Rrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733em;vertical-align:-0.1367em;"></span><span class="mrel amsrm">⇛</span></span></span></span></td><td><code>$\Rrightarrow$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇚</mo></mrow><annotation encoding="application/x-tex">\Lleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733em;vertical-align:-0.1367em;"></span><span class="mrel amsrm">⇚</span></span></span></span></td><td><code>$\Lleftarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∥</mo></mrow><annotation encoding="application/x-tex">\parallel</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∥</span></span></span></span></td><td><code>$\parallel$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↾</mo></mrow><annotation encoding="application/x-tex">\upharpoonright</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8867em;vertical-align:-0.1944em;"></span><span class="mrel amsrm">↾</span></span></span></span></td><td><code>$\upharpoonright$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇂</mo></mrow><annotation encoding="application/x-tex">\downharpoonright</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8867em;vertical-align:-0.1944em;"></span><span class="mrel amsrm">⇂</span></span></span></span></td><td><code>$\downharpoonright$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∵</mo></mrow><annotation encoding="application/x-tex">\because</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∵</span></span></span></span></td><td><code>$\because$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></td><td><code>$\therefore$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span></span></span></span></td><td><code>$\approx$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>x</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor x \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">x</span><span class="mclose">⌋</span></span></span></span></td><td><code>$\lfloor x \rfloor$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>x</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil x \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">x</span><span class="mclose">⌉</span></span></span></span></td><td><code>$\lceil x \rceil$</code></td><td></td><td></td></tr></tbody></table><h2 id="五、注音与标注">五、注音与标注</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\bar&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˊ</mo></mover></mrow><annotation encoding="application/x-tex">\acute{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˊ</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <code>$\acute&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˇ</mo></mover></mrow><annotation encoding="application/x-tex">\check{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6285em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6285em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˇ</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\check&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˋ</mo></mover></mrow><annotation encoding="application/x-tex">\grave{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˋ</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\grave&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\vec&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\hat&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\tilde&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>˘</mo></mover></mrow><annotation encoding="application/x-tex">\breve{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">˘</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\breve&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\dot&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>¨</mo></mover></mrow><annotation encoding="application/x-tex">\ddot{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">¨</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\ddot&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>˚</mo></mover></mrow><annotation encoding="application/x-tex">\mathring{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.3472em;"><span class="mord">˚</span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>   <code>$\mathring&#123;x&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6306em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\overline&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">↔</mo></mover></mrow><annotation encoding="application/x-tex">\overleftrightarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.522em;min-width:0.888em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\overleftrightarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6306em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\underline&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">↔</mo></munder></mrow><annotation encoding="application/x-tex">\underleftrightarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;vertical-align:-0.522em;"></span><span class="mord accentunder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span class="svg-align" style="top:-2.478em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.522em;min-width:0.888em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.522em;"><span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\underleftrightarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">←</mo></mover></mrow><annotation encoding="application/x-tex">\overleftarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\overleftarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">⏞</mo></mover></mrow><annotation encoding="application/x-tex">\overbrace{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0786em;"></span><span class="mord mover"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.5306em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7 5-6 9-10 13-.7 1-7.3 1-20 1H6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M200428 334c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M400000 542l-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z'/></svg></span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\overbrace&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">←</mo></munder></mrow><annotation encoding="application/x-tex">\underleftarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;vertical-align:-0.522em;"></span><span class="mord accentunder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span class="svg-align" style="top:-2.478em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.522em;"><span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\underleftarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">⏟</mo></munder></mrow><annotation encoding="application/x-tex">\underbrace{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0786em;vertical-align:-0.648em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\underbrace&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\overrightarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7306em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.3em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.3em' viewBox='0 0 2364 300' preserveAspectRatio='none'><path d='M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z'/></svg></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\widehat&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">→</mo></munder></mrow><annotation encoding="application/x-tex">\underrightarrow{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9526em;vertical-align:-0.522em;"></span><span class="mord accentunder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span class="svg-align" style="top:-2.478em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.522em;"><span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\underrightarrow&#123;xxx&#125;$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>x</mi><mi>x</mi></mrow><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{xxx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7166em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7166em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">xxx</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.286em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.286em' viewBox='0 0 1033 286' preserveAspectRatio='none'><path d='M344 55.266c-142 0-300.638 81.316-311.5 86.418-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751 181.476 676 181.476c-149 0-189-126.21-332-126.21z'/></svg></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>  <code>$\widetilde&#123;xxx&#125;$</code></p><h2 id="六、省略号、空白间隔">六、省略号、空白间隔</h2><p><strong>1、省略号</strong></p><ul><li><p><code>\dots </code></p><p>使用：<code>$x_1, x_2, \dots, x_n$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, \dots, x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><code>\cdots</code></p><p>使用：<code>$1, 2, \cdots, n$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, 2, \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></p></li><li><p><code>\vdots</code> 竖直省略号，一般用于矩阵中。</p><p>使用：<code>$\vdots$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow><annotation encoding="application/x-tex">\vdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.03em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span></span></p></li><li><p><code>\ddots</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mn>5</mn><mi>o</mi></msup></mrow><annotation encoding="application/x-tex">45^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord">4</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span></span></span></span></span></span></span> 方向省略号，一般用于矩阵中。</p><p>使用：<code>$\ddots$</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋱</mo></mrow><annotation encoding="application/x-tex">\ddots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.823em;"></span><span class="minner">⋱</span></span></span></span></p></li></ul><p><strong>2、空白间隔</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\,$ 3/18em   </span><br><span class="line">$\:$  4/18em  </span><br><span class="line">$\;$ 5/18em </span><br><span class="line">$\quad$ 1em </span><br><span class="line">$\qquad$ 2m </span><br><span class="line">$\!$ -3/18em</span><br></pre></td></tr></table></figure><p>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext></mrow><annotation encoding="application/x-tex">\,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span> 3/18em<br>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext></mrow><annotation encoding="application/x-tex">\:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span></span></span>  4/18em<br>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span> 5/18em<br>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 1em<br>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span> 2m<br>|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> ⁣</mtext></mrow><annotation encoding="application/x-tex">\!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace" style="margin-right:-0.1667em;"></span></span></span></span> -3/18em</p><h2 id="七、字体">七、字体</h2><p>1、使用\it显示<strong>意大利体（公式默认字体）</strong>：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\it{Abc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathit">Abc</span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <code>$\it&#123;Abc&#125;$</code></p><p>2、使用\mathbb或\Bbb显示<strong>黑板粗体（黑板黑体）</strong>:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">A</mi><mi mathvariant="double-struck">b</mi><mi mathvariant="double-struck">c</mi></mrow><annotation encoding="application/x-tex">\mathbb{Abc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbb">A</span><span class="mord mathnormal">b</span><span class="mord mathnormal">c</span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <code>$\mathbb&#123;Abc&#125;$</code></p><p>3、使用\mathbf或\bf显示<strong>黑体</strong>：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi><mi mathvariant="bold">c</mi></mrow><annotation encoding="application/x-tex">\mathbf{Abc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Abc</span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <code>$\mathbf&#123;Abc&#125;$</code></p><p>3、使用\mathtt或\tt显示<strong>打印机字体</strong>：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="monospace">A</mi><mi mathvariant="monospace">b</mi><mi mathvariant="monospace">c</mi></mrow><annotation encoding="application/x-tex">\mathtt{Abc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord"><span class="mord mathtt">Abc</span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <code>$\mathtt&#123;Abc&#125;$</code></p><h2 id="八、分段函数">八、分段函数</h2><p><code>&amp;</code>表示对齐，<code>\\</code>用来表示换行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">函数名=</span><br><span class="line">\begin&#123;cases&#125;  </span><br><span class="line">公式1 &amp; 条件1 \\</span><br><span class="line">公式2 &amp; 条件2 \\</span><br><span class="line">公式3 &amp; 条件3 \\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>函数名</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>公式</mtext><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>条件</mtext><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>公式</mtext><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>条件</mtext><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>公式</mtext><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>条件</mtext><mn>3</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">函数名=\begin{cases}  公式1 &amp; 条件1 \\公式2 &amp; 条件2 \\公式3 &amp; 条件3 \\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">函数名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">公式</span><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">公式</span><span class="mord">2</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">公式</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">条件</span><span class="mord">1</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">条件</span><span class="mord">2</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">条件</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="九、多行公式">九、多行公式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">f(x) &amp; = (a+b)^2 \\</span><br><span class="line">&amp; = a^2+2ab+b^2</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><mi>b</mi><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}f(x) &amp; = (a+b)^2 \\&amp; = a^2+2ab+b^2\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0482em;vertical-align:-1.2741em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7741em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.3859em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2741em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7741em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3859em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2741em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7741em;"><span style="top:-3.7741em;"><span class="pstrut" style="height:2.8641em;"></span><span class="eqn-num"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.8641em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2741em;"><span></span></span></span></span></span></span></span></span></p><h2 id="十、箭头">十、箭头</h2><table><thead><tr><th>效果</th><th>Tex</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span></td><td><code>$\leftarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></td><td><code>$\rightarrow$ 或者 $\to$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇐</mo></mrow><annotation encoding="application/x-tex">\Leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇐</span></span></span></span></td><td><code>$\Leftarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span></td><td><code>$\Rightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↔</span></span></span></span></td><td><code>$\leftrightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo></mrow><annotation encoding="application/x-tex">\Leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇔</span></span></span></span></td><td><code>$\Leftrightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟵</mo></mrow><annotation encoding="application/x-tex">\longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟵</span></span></span></span></td><td><code>$\longleftarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span></td><td><code>$\longrightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟸</mo></mrow><annotation encoding="application/x-tex">\Longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟸</span></span></span></span></td><td><code>$\longleftarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span></td><td><code>$\Longrightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟷</mo></mrow><annotation encoding="application/x-tex">\longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟷</span></span></span></span></td><td><code>$\longleftrightarrow$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟺</mo></mrow><annotation encoding="application/x-tex">\Longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟺</span></span></span></span></td><td><code>$\Longleftrightarrow$</code></td></tr></tbody></table><p><code>$\xrightarrow$</code>和<code>$\xleftarrow$</code>可以根据内容自动调整：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \xleftarrow&#123;x+y+z&#125; \quad \xrightarrow[x&lt;y]&#123;x+y+z&#125; </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow></mpadded></mover><mspace width="1em"/><munderover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow></mpadded><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow></mpadded></munderover></mrow><annotation encoding="application/x-tex">\xleftarrow{x+y+z} \quad \xrightarrow[x&lt;y]{x+y+z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0413em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0303em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.6658em;vertical-align:-0.6355em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0303em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span><span style="top:-2.2006em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6355em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="十一、大型数学运算符">十一、大型数学运算符</h2><table><thead><tr><th>运算符</th><th>Tex</th><th>运算符</th><th>Tex</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span></td><td><code>$\sum$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo></mrow><annotation encoding="application/x-tex">\int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span></span></span></span></td><td><code>$\int$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></td><td><code>$\prod$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∬</mo></mrow><annotation encoding="application/x-tex">\iint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005em;">∬</span></span></span></span></td><td><code>$\iint$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∐</mo></mrow><annotation encoding="application/x-tex">\coprod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span></span></span></span></td><td><code>$\coprod$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∭</mo></mrow><annotation encoding="application/x-tex">\iiint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005em;">∭</span></span></span></span></td><td><code>$\iiint$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋁</mo></mrow><annotation encoding="application/x-tex">\bigvee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋁</span></span></span></span></td><td><code>$\bigvee$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋀</mo></mrow><annotation encoding="application/x-tex">\bigwedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋀</span></span></span></span></td><td><code>$\bigwedge$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⨁</span></span></span></span></td><td><code>$\bigoplus$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⨂</mo></mrow><annotation encoding="application/x-tex">\bigotimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⨂</span></span></span></span></td><td><code>$\bigotimes$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋃</span></span></span></span></td><td><code>$\bigcup$</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\lim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">lim</span></span></span></span></td><td><code>$\lim$</code></td></tr></tbody></table><p>使用：即添加上下标</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\sum_&#123;i=1&#125;^&#123;10&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>10</mn></munderover></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单实用，解决github打不开进不去的问题</title>
      <link href="/2023/01/05/%E8%A7%A3%E5%86%B3github%E6%89%93%E4%B8%8D%E5%BC%80%E8%BF%9B%E4%B8%8D%E5%8E%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/05/%E8%A7%A3%E5%86%B3github%E6%89%93%E4%B8%8D%E5%BC%80%E8%BF%9B%E4%B8%8D%E5%8E%BB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>1、网易UU加速器</strong><br>玩游戏的小伙伴相比都不陌生，但是想不到的是，它也可以帮助我们访问github</p><p><strong>方法：</strong><br>1、搜索”学术“<br>2、点击加速<br>3、打开<a href="https://github.com/">github</a>网址</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/UU%E5%8A%A0%E9%80%9F%E5%99%A8.png" alt=""></p><p>ps：如果没有安装的话下载网址在这里哦<br><strong>下载网址：</strong><code>https://uu.163.com/</code></p></li><li><p>2、<strong>分享一个小工具</strong>，打开即可用</p><p><strong>百度网盘：</strong><br>链接：<code>https://pan.baidu.com/s/19nglQ3vxNPTHct-SL2RueQ</code><br>提取码：<code>kksk</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2023/01/05/python/"/>
      <url>/2023/01/05/python/</url>
      
        <content type="html"><![CDATA[<p>​—— B站 Python 课程自学笔记         <a href="https://www.bilibili.com/video/BV1wD4y1o7AS?p=1&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064&amp;t=1.5">【B站网课】</a></p><h2 id="一、python简介">一、python简介</h2><h3 id="1、简介">1、简介</h3><blockquote><p><strong>python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</strong></p><ul><li><p>Python是<strong>解释型</strong>语言︰这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p></li><li><p>Python是<strong>交互式</strong>语言︰这意味着，您可以在一个Python提示符 <code>&gt;&gt;&gt;</code> 后直接执行代码。</p></li><li><p>Python是<strong>面向对象</strong>语言:这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p></li><li><p>Python是<strong>初学者</strong>的语言:Python对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到wwW浏览器再到游戏。</p></li></ul></blockquote><h3 id="2、Python发展历史">2、Python发展历史</h3><blockquote><p>Python是由<strong>Guido van Rossum</strong>在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。<br>Python本身也是由诸多其他语言发展而来的,这包括ABC、Modula-3、C、C++、Algol-68、SmalTalk、Unix shell和其他的脚本语言等等。<br>像Perl语言一样，Python源代码同样遵循GPL(GNU General Public License)协议。<br>现在Python是由一个核心开发团队在维护，Guido van Rossum仍然占据着至关重要的作用，指导其进展。Python 2.7被确定为最后一个Python 2.x版本，它除了支持 Python 2.x语法外，还支持部分Python 3.1语法。</p></blockquote><h3 id="3、python解释器">3、python解释器</h3><p><a href="https://www.python.org/ftp/python/3.8.0/python-3.8.0-amd64.exe">python3.8.0官网下载</a></p><p><a href="https://pan.baidu.com/s/1lQbQmq6u00__dmrHC48cNQ">python3.8.0百度网盘</a> 提取码：<code>kksk</code></p><p>安装流程：选择自定义安装(Customize installation)，之后的有选项的全选，路径记得修改即可</p><p>安装好后，在命令行窗口输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>如下显示即安装成功</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_10-37-51.png" alt=""></p><p>安装后的说明</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_10-25-32.png" alt=""></p><h3 id="4、Pycharm设置">4、Pycharm设置</h3><p>（1）<a href="https://www.runoob.com/w3cnote/pycharm-windows-install.html">下载教程</a>    <a href="http://www.jetbrains.com/pycharm/download/#section=windows">下载地址</a></p><p>（2）代码模板设置</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_10-58-24.png" alt=""></p><p>设置效果：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_10-58-31.png" alt=""></p><h3 id="5、pip工具">5、pip工具</h3><p>Python自带，支持Python扩展库的安装，升级和卸载等操作</p><table><thead><tr><th>pip命令示例</th><th>说明</th></tr></thead><tbody><tr><td>pip --version</td><td>显示版本和路径</td></tr><tr><td>pip --help</td><td>获取帮助</td></tr><tr><td>pip list</td><td>列出已安装的模块及其版本号</td></tr><tr><td>pip install SomePackage[==version]</td><td>在线安装SomePackage模块的指定版本</td></tr><tr><td>pip install SomePackage. whl</td><td>通过whl文件离线安装扩展库</td></tr><tr><td>pip install Package1, package2 ···</td><td>依此(在线)安装Package1，Package2…</td></tr><tr><td>pip install -U SomePackage</td><td>升级SomePackage模块</td></tr><tr><td>pip uninstall SomePackage</td><td>卸载SomePackage模块</td></tr><tr><td>pip show SomePackage</td><td>显示已安装的包的信息</td></tr></tbody></table><p>常见pip镜像源（国内源）</p><ul><li><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p></li><li><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p></li><li><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p></li><li><p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p></li><li><p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p></li><li><p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p></li></ul><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果存在多个python版本，则pip后面跟版本号，就可以指定使用哪一个，例如<code>pip3.8 ...</code>、<code>pip3.10 ...</code></p><h2 id="二、基础知识">二、基础知识</h2><h3 id="1、转义字符">1、转义字符</h3><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">一个退格</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">tab</td></tr><tr><td style="text-align:center">\\</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">\&quot;</td><td style="text-align:center">&quot;</td></tr></tbody></table><p><strong>原字符</strong>：不希望字符串中的 转义字符 起作用</p><p>使用：就是在字符串前加 <strong>r</strong> 或 <strong>R</strong></p><p>效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nworld&#x27;</span>)   <span class="comment"># 1、\n : 换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\tworld&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;helloooo\nworld&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\rworld&#x27;</span>)   <span class="comment"># world 将 hello 进行了覆盖</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\bworld&#x27;</span>)   <span class="comment"># \b 是一个退格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;https:\\\\www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;老师说：\&quot;大家好\&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;原字符&quot;：不希望字符串中的 转义字符 起作用；使用：就是在字符串前加 r 或 R</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nworld&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意：最后一个字符不能是‘\’,但最后可以是‘\\’</span></span><br><span class="line"><span class="comment"># print(r&#x27;hello\nworld\&#x27;) # 报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nworld\\&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">helloworld</span><br><span class="line">helloooo</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hellworld</span><br><span class="line">https:\\www.baidu.com</span><br><span class="line">老师说：&quot;大家好&quot;</span><br><span class="line">hello\nworld</span><br><span class="line">hello\nworld\\</span><br></pre></td></tr></table></figure><h3 id="2、保留字">2、保留字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="comment"># keyword.kwlist 共35个 </span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keyword.kwlist:</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>):</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(key, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FalseNoneTrueandasassert</span><br><span class="line">asyncawaitbreakclasscontinuedef</span><br><span class="line">delelifelseexceptfinallyfor</span><br><span class="line">fromglobalifimportinis</span><br><span class="line">lambdanonlocalnotorpassraise</span><br><span class="line">returntrywhilewithyiel</span><br></pre></td></tr></table></figure><h3 id="3、标识符">3、标识符</h3><p>变量、函数、类、模块和其它对象的起的名字就叫标识符</p><p>规则:</p><ul><li>字母、数字、下划线_</li><li>不能以数字开头</li><li>不能是保留字</li><li>·严格区分大小写</li></ul><h3 id="4、变量">4、变量</h3><p>变量是内存中一个带标签的盒子</p><p><strong>变量由三部分组成：</strong></p><ul><li><strong>标识</strong>: 表示<strong>对象所存储的内存地址</strong>,使用内置函数 <strong>id(obj)</strong> 来获取</li><li><strong>类型</strong>: 表示的是<strong>对象的数据类型</strong>,使用内置函数  <strong>type(obj)</strong> 来获取</li><li><strong>值</strong>: 表示对象所存储的具体数据，使用print(obj)可以将值进行打印输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;ggw&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/3.png" style="zoom: 67%;" /> <p><strong>在多次赋值后，变量名会指向新的空间</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;马丽亚&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;楚溜冰&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/4.png" style="zoom:67%;" /> <h3 id="5、数据类型">5、数据类型</h3><h4 id="（1）整数类型">（1）整数类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数可以表示为二级制、十进制、八进制、十六进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十进制&#x27;</span>, <span class="number">10086</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;二进制&#x27;</span>, <span class="number">0b10101111</span>)<span class="comment"># 0b...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;八进制&#x27;</span>, <span class="number">0o176</span>)<span class="comment"># 0o...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制&#x27;</span>, <span class="number">0x1EAF</span>)<span class="comment"># 0x...</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十进制 10086</span><br><span class="line">二进制 175</span><br><span class="line">八进制 126</span><br><span class="line">十六进制 7855</span><br></pre></td></tr></table></figure><h4 id="（2）浮点类型">（2）浮点类型</h4><ul><li>使用浮点数进行计算时，可能会出现小数点位数不精确的情况（因为计算机的二进制存储）</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.2</span>)<span class="comment"># 输出为 3.3000000000000003</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.1</span>)<span class="comment"># 输出为 3.2</span></span><br></pre></td></tr></table></figure><ul><li>解决方案：</li></ul><p>导入模块<code>decimal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&#x27;1.1&#x27;</span>) + Decimal(<span class="string">&#x27;2.2&#x27;</span>))<span class="comment"># 输出为 3.3</span></span><br></pre></td></tr></table></figure><h4 id="（3）布尔类型">（3）布尔类型</h4><p>可以转化为整数：True = 1; False = 0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="literal">True</span></span><br><span class="line">f2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(f1 + <span class="number">1</span>)<span class="comment"># 1 + 1 = 2</span></span><br><span class="line"><span class="built_in">print</span>(f2 + <span class="number">1</span>)<span class="comment"># 0 + 1 = 1</span></span><br></pre></td></tr></table></figure><h4 id="（4）字符串类型">（4）字符串类型</h4><ul><li>字符串又被称为不可变的字符序列</li><li>可以使用单引号’ ‘、双引号&quot; &quot;、三引号’‘’ ‘’'或&quot;“” “”&quot;来定义</li><li>单引号和双引号定义的字符串必须在一行</li><li>三引号定义的字符串可以分布在连续的多行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;人生苦短，我用Python&#x27;</span></span><br><span class="line">str2 = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line">str3 = <span class="string">&quot;&quot;&quot;人生苦短，我用Python&quot;&quot;&quot;</span></span><br><span class="line">str4 = <span class="string">&#x27;&#x27;&#x27;人生苦短，</span></span><br><span class="line"><span class="string">2020 =&gt; 疫情</span></span><br><span class="line"><span class="string">2021 =&gt; 疫情</span></span><br><span class="line"><span class="string">2022 =&gt; 疫情</span></span><br><span class="line"><span class="string">2023 =&gt; 疫情</span></span><br><span class="line"><span class="string">我用Python&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1 + <span class="string">&quot;\n&quot;</span> + str2 + <span class="string">&quot;\n&quot;</span> + str3 + <span class="string">&quot;\n&quot;</span> + str4)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">人生苦短，我用Python</span><br><span class="line">人生苦短，我用Python</span><br><span class="line">人生苦短，我用Python</span><br><span class="line">人生苦短，</span><br><span class="line">2020 =&gt; 疫情</span><br><span class="line">2021 =&gt; 疫情</span><br><span class="line">2022 =&gt; 疫情</span><br><span class="line">2023 =&gt; 疫情</span><br><span class="line">我用Python</span><br></pre></td></tr></table></figure><h3 id="6、数据类型转换">6、数据类型转换</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt=""></p><p>（1）<strong>str()</strong></p><p>将其他类型转化成字符串类型；</p><p>（2）<strong>int()</strong></p><p>将其他类型转化成int类型；（抹零取整）</p><p>文字类<code>'123'</code>和小数<code>'12.3'</code>串（是字符串，但是他显示的是一个浮点数）无法转换；</p><p>（3）<strong>float()</strong></p><p>将其他类型转化成float类型；</p><p>文字类无法转；</p><h3 id="7、注释">7、注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;多</span></span><br><span class="line"><span class="string">行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件开头加上中文声明注释，用以指定源码文件的编码格式</span></span><br><span class="line"><span class="comment"># coding：gbk</span></span><br><span class="line"><span class="comment"># coding后面的“：”，必须是中文的</span></span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_12-34-37.png" alt=""></p><h3 id="8、运算符">8、运算符</h3><h4 id="（1）算术运算符">（1）算术运算符</h4><table><thead><tr><th style="text-align:center">运算符</th><th>表示</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td>加</td></tr><tr><td style="text-align:center">-</td><td>减</td></tr><tr><td style="text-align:center">*</td><td>乘</td></tr><tr><td style="text-align:center">/</td><td>除</td></tr><tr><td style="text-align:center">%</td><td>取余</td></tr><tr><td style="text-align:center">**</td><td>幂运算</td></tr><tr><td style="text-align:center">//</td><td>整数（一正一负，向下取整）<code>print(11//2) # 输出为 5</code></td></tr></tbody></table><h4 id="（2）赋值运算符">（2）赋值运算符</h4><ul><li><p>支持链式赋值： a = b = c = 20</p></li><li><p>支持参数赋值：+=、-=、*=、/=、//=、%=</p></li><li><p>支持系列解包赋值：a, b, c = 20, 30, 40</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交换两个变量的值</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span> </span><br><span class="line">a, b = b, a <span class="comment"># a = 20, b = 10 </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）比较运算符">（3）比较运算符</h4><p>结果为bool类型</p><p>比较对象的标识用 is、 is not</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b<span class="comment"># True: a 与 b 的value相同</span></span><br><span class="line">a <span class="keyword">is</span> b<span class="comment"># True: a 与 b 的id标识相同</span></span><br></pre></td></tr></table></figure><h4 id="（4）布尔运算符">（4）布尔运算符</h4><p><strong>and、or、not、in、not in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in、not in</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h4 id="（5）位运算符">（5）位运算符</h4><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/5.png" style="zoom: 67%;" /> <h4 id="（6）运算符优先级">（6）运算符优先级</h4><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/6.png" style="zoom: 67%;" /> <h3 id="9、对象的布尔值">9、对象的布尔值</h3><ul><li><p>Python <strong>—切皆对象</strong> ，所有对象都有一个布尔值。</p></li><li><p>获取对象的布尔值，使用内置函数<strong>bool()</strong></p></li><li><p>以下对象的布尔值为False（其他均为True）</p><ul><li><p>False</p></li><li><p>数值0</p></li><li><p>None</p></li><li><p>空字符串</p></li><li><p>空列表 [] 、list()</p></li><li><p>空元组 () 、tuple()</p></li><li><p>空字典 {} 、dict()</p></li><li><p>空集合 set()</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下输出均为False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0.0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>([]))     <span class="comment"># 空列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="built_in">list</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(()))     <span class="comment"># 空元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="built_in">tuple</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(&#123;&#125;))     <span class="comment"># 空字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="built_in">dict</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="built_in">set</span>()))  <span class="comment"># 空集合</span></span><br></pre></td></tr></table></figure><h3 id="10、pass语句">10、pass语句</h3><p>语句什么都不做，只是一个占位符，用在语法上需要语句的地方<br><strong>什么时候使用</strong>：先搭建语法结构,还没想好代码怎么写的时候</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="built_in">input</span>(<span class="string">&#x27;是否是会员？&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> ans == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="11、内置函数">11、内置函数</h3><p>可以使用下列语句查看所有内置函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(__builtins__)</span><br></pre></td></tr></table></figure><p>可以使用<code>help(函数名)</code>查看某个函数的用法</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_12-58-58.png" alt=""></p><h4 id="（1）print">（1）print()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(*objects, sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">objects</td><td>对象，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔</td></tr><tr><td style="text-align:center">sep</td><td>用来间隔多个对象，默认值是一个空格</td></tr><tr><td style="text-align:center">end</td><td>用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串</td></tr><tr><td style="text-align:center">file</td><td>要写入的文件对象</td></tr><tr><td style="text-align:center">flush</td><td>输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、输出数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10086</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、含有运算符的表达式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、将数据输出到文件中，ps: 盘符要存在, &#x27;a+&#x27;文件不存在则创建，存在则追加</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;C:/Users/GGW_2021/Desktop/笔记/python/text.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;helloworld&#x27;</span>, file=fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、不换行输出（输出内容在同一行上）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/2.png" style="zoom:50%;" /> <p>问题：在运行Python文件时出现<strong>警告：PEP 8: W292 no newline at end of file</strong><br>解决办法：在文件末尾加换行符（按回车即可）</p><h4 id="（2）input">（2）input()</h4><p>变量 = input([提示语])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">present = <span class="built_in">input</span>(<span class="string">&#x27;请输入：&#x27;</span>)<span class="comment"># 返回值为 字符串类型</span></span><br><span class="line"><span class="built_in">print</span>(present)</span><br></pre></td></tr></table></figure><h4 id="（3）range">（3）range()</h4><ul><li>用于生成一个整数序列</li></ul><ul><li><p>返回值是一个迭代器对象</p></li><li><p>range类型的优点：不管range对象表示的整数序列有多长，<strong>所有range对象占用的内存空间都是相同的, 因为仅仅需要存储start,stop和step</strong>，只有当用到range对象时，才会去计算序列中的相关元素</p></li><li><p>in与not in判断整数序列中是否存在(不存在)指定的整数</p></li><li><p><strong>三种创建方式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 1、只有一个参数 &quot;&quot;&quot;</span></span><br><span class="line">r = <span class="built_in">range</span>(<span class="number">10</span>)   <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 默认从 0 开始，默认相差1（步长）</span></span><br><span class="line"><span class="built_in">print</span>(r)        <span class="comment"># range(0, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r))  <span class="comment"># 用于查看 range 对象中的整数序列</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2、两个参数 &quot;&quot;&quot;</span></span><br><span class="line">r = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)   <span class="comment"># range(start, stop, 默认相差1（步长）)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r))     <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 3、三个参数 &quot;&quot;&quot;</span></span><br><span class="line">r = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)   <span class="comment"># range(start, stop, step)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r))        <span class="comment"># [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）eval-待续">（4）eval()待续</h4><h3 id="12、不可变序列与可变序列">12、不可变序列与可变序列</h3><ul><li><p>不变可变序列：字符串、元组</p><p>不变可变序列没有增、删，改的操作</p></li><li><p>可变序列:列表、字典</p><p>可变序列可以对序列执行增、删、改操作，对象地址不发生更改</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">str</span>))  <span class="comment"># 输出为 2464522942832</span></span><br><span class="line"><span class="built_in">str</span> += <span class="string">&#x27; world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">str</span>))  <span class="comment"># 输出为 2464522942832</span></span><br></pre></td></tr></table></figure><h3 id="13、变量的作用域">13、变量的作用域</h3><ul><li>程序代码能访问该变量的区域</li><li>根据变量的有效范围可分为<ul><li>局部变量：<br>在函数内定义并使用的变量，只在函数内部有效</li><li>全局变量：<br>函数体外定义的变量，可作用于函数内外</li></ul></li></ul><p><strong>局部变量使用global声明，这个变量就会就成全局变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">global</span> b</span><br><span class="line">    b = a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(b)    <span class="comment"># 输出为 10</span></span><br></pre></td></tr></table></figure><h3 id="14、编码格式">14、编码格式</h3><p>常见的字符编码格式</p><ul><li>Python的解释器使用的是Unicode（内存)</li><li>py文件在磁盘上使用UTF-8存储（外存)</li><li><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/25.png" style="zoom: 67%;" />  </li></ul><p><strong>指定文件的编码格式，utf-8是默认的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方法1: 在文件开头写上（&#x27;#&#x27;也是要带的）</span><br><span class="line"># coding：gbk</span><br><span class="line"># coding后面的“：”，必须是中文的</span><br><span class="line"></span><br><span class="line"># 方法2: 在文件开头写上（&#x27;#&#x27;也是要带的）</span><br><span class="line"># encoding=gbk</span><br></pre></td></tr></table></figure><h3 id="15、编程规范">15、编程规范</h3><ul><li><code>\</code> 续行符</li></ul><h2 id="三、程序的组织结构">三、程序的组织结构</h2><h3 id="1、顺序结构">1、顺序结构</h3><p>由上往下顺序执行</p><h3 id="2、分支结构">2、分支结构</h3><h4 id="（1）单分支结构">（1）单分支结构</h4><p>一个缩进表示层次结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">条件执行体</span><br></pre></td></tr></table></figure><h4 id="（2）双分支结构">（2）双分支结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">    条件执行体<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件执行体<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="（3）多分支结构">（3）多分支结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">    条件执行体<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    条件执行体<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    条件执行体N</span><br><span class="line">[<span class="keyword">else</span>]:</span><br><span class="line">    条件执行体N + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="（4）嵌套使用if">（4）嵌套使用if</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">    <span class="keyword">if</span> 内层条件表达式:</span><br><span class="line">        内层条件执行体<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        内层条件执行体<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件执行体</span><br></pre></td></tr></table></figure><h4 id="（5）条件表达式">（5）条件表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断条件True: x, False: y </span></span><br><span class="line">x <span class="keyword">if</span> 判断条件 <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><h3 id="3、循环结构">3、循环结构</h3><h4 id="（1）while">（1）while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    条件执行体（循环体）</span><br></pre></td></tr></table></figure><h4 id="（2）for-in">（2）for_in</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 自定义的变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">循环体</span><br></pre></td></tr></table></figure><p>举例</p><p>如果不需要用到自定义变量，可写为’_’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&#x27;python&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  <span class="comment"># range()产生一个整数序列 -&gt; 也是一个可迭代对象</span></span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 如果不需要用到自定义变量，可写为&#x27;_&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;人生苦短，我用python&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p y t h o n </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">人生苦短，我用python</span><br><span class="line">人生苦短，我用python</span><br><span class="line">人生苦短，我用python</span><br></pre></td></tr></table></figure><h4 id="（3）break语句、continue">（3）break语句、continue</h4><ul><li><p>break 用于结束循环；</p></li><li><p>continue 用于结束当前循环，进入下一循环。</p></li></ul><h4 id="（4）else语句和while、for-in搭配使用">（4）else语句和while、for_in搭配使用</h4><ul><li>控制本层循环</li></ul><ul><li><p>循环结束执行else</p></li><li><p>break跳出循环后不执行else</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ...:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> ... <span class="keyword">in</span> ...:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&#x27;python&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;人生苦短，我学python&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我tm学好不好！&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p y t h o n </span><br><span class="line">人生苦短，我学python</span><br><span class="line">人生苦短，我学python</span><br><span class="line">人生苦短，我学python</span><br><span class="line">我tm学好不好！</span><br></pre></td></tr></table></figure><h2 id="四、列表、字典、元组、集合">四、列表、字典、元组、集合</h2><h3 id="1、列表">1、列表</h3><blockquote><p>变量可以存储一个元素，而列表是一个“大容器”可以存储N多个元素，程序可以方便地对这些数据进行整体操作</p></blockquote><h4 id="（1）列表创建的方式">（1）列表创建的方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 1、使用[] &quot;&quot;&quot;</span></span><br><span class="line">lst1 = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">98</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2、使用内置函数list() &quot;&quot;&quot;</span></span><br><span class="line">lst2 = <span class="built_in">list</span>([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">98</span>])</span><br></pre></td></tr></table></figure><h4 id="（2）列表的特点">（2）列表的特点</h4><ul><li><p>列表元素按顺序有序排序</p></li><li><p>是一个<strong>可变序列</strong></p></li><li><p>索引映射唯一个数据</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/7.png" alt=""></p></li><li><p>列表可以存储重复数据</p></li><li><p>任意数据类型混存</p></li><li><p>根据需要<strong>动态分配和回收内存</strong></p></li></ul><h4 id="（3）内存">（3）内存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">98</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">id</span>(lst), <span class="string">&quot;\n&quot;</span>,\</span><br><span class="line">      <span class="built_in">id</span>(lst[<span class="number">0</span>]), <span class="string">&quot;\n&quot;</span>,\</span><br><span class="line">      <span class="built_in">id</span>(lst[<span class="number">1</span>]), <span class="string">&quot;\n&quot;</span>,\</span><br><span class="line">      <span class="built_in">id</span>(lst[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2769239388736 </span><br><span class="line">2769239324848 </span><br><span class="line">2769239325040 </span><br><span class="line">2769238035728 </span><br></pre></td></tr></table></figure><h4 id="（4）获取、切片">（4）获取、切片</h4><ul><li><p>获取列表指定元素的索引 <strong>index()</strong></p><ul><li><p>如查列表中存在N个相同元素，只返回相同元素中的第一个元素的索引</p></li><li><p>如果查询的元素在列表中不存在，则会抛出ValueError</p></li><li><p>还可以在指定的start和stop之间进行查找</p></li><li><p>index(‘目标’, start, end)  # start~end-1 <strong>指定范围</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">98</span>]</span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="string">&#x27;hello&#x27;</span>))   <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="string">&#x27;python&#x27;</span>))<span class="comment"># ValueError: &#x27;python&#x27; is not in list</span></span><br><span class="line"><span class="built_in">print</span>(lst.index(<span class="string">&#x27;hello&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>))<span class="comment"># ValueError: &#x27;hello&#x27; is not in list</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>根据索引获取元素</p><ul><li><p>正向索引从 0 到 N - 1</p></li><li><p>逆向索引从 -N 到 -1</p></li><li><p>指定索引不存，抛出 indexError</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">98</span>]</span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>])   <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">print</span>(lst[-<span class="number">1</span>])  <span class="comment"># 98</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">3</span>])   <span class="comment"># IndexError: list index out of range</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>切片操作</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/8.png" style="zoom: 50%;" />  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原列表&#x27;</span>, <span class="built_in">id</span>(lst))<span class="comment"># 2016570503552</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;新列表&#x27;</span>, <span class="built_in">id</span>(lst[<span class="number">1</span>:<span class="number">6</span>:<span class="number">1</span>]))<span class="comment"># 2016570470144</span></span><br><span class="line"><span class="comment"># 默认步长为 1</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>:<span class="number">6</span>])     <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 默认start</span></span><br><span class="line"><span class="built_in">print</span>(lst[:<span class="number">6</span>:<span class="number">2</span>])    <span class="comment"># [1, 3, 5]</span></span><br><span class="line"><span class="comment"># 默认stop</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>::<span class="number">2</span>])    <span class="comment"># [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; step为负数 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lst[::-<span class="number">1</span>])    <span class="comment"># [8, 7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">7</span>::-<span class="number">2</span>])   <span class="comment"># [8, 6, 4, 2]</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">6</span>:<span class="number">0</span>:-<span class="number">2</span>])  <span class="comment"># [7, 5, 3]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（5）查询列表、遍历">（5）查询列表、遍历</h4><ul><li><p>判断指定元素是否在列表中</p><p><code>元素 in 列表名</code></p><p><code>元素 not in 列表名</code></p></li><li><p>列表元素的遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代对象 <span class="keyword">in</span> 列表名:</span><br><span class="line">    操作</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> lst)         <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> lst)        <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> lst)     <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> lst)    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li></ul><h4 id="（6）添加">（6）添加</h4><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">append()</td><td style="text-align:left">在列表<strong>末尾</strong>添加<strong>一个</strong>元素</td></tr><tr><td style="text-align:center">extend()</td><td style="text-align:left">在列表<strong>末尾</strong>添加<strong>至少一个</strong>元素</td></tr><tr><td style="text-align:center">insert()</td><td style="text-align:left">在列表<strong>任意指定位置</strong>添加<strong>一个</strong>元素</td></tr><tr><td style="text-align:center">切片</td><td style="text-align:left">在列表<strong>任意指定位置</strong>添加<strong>至少一个</strong>元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原列表：&quot;</span>, <span class="built_in">id</span>(lst1))     <span class="comment"># 输出为 1814123508096</span></span><br><span class="line">lst1.append(<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新列表：&quot;</span>, <span class="built_in">id</span>(lst1))     <span class="comment"># 输出为 1814123508096</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line">lst2 = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="comment"># lst1.append(lst2)   </span></span><br><span class="line"><span class="comment"># 将lst2作为一个元素添加到列表的末尾 [10, 20, 30, 40, [&#x27;hello&#x27;, &#x27;world&#x27;]]</span></span><br><span class="line"><span class="comment"># 向列表末尾一次性添加多个元素</span></span><br><span class="line">lst1.extend(lst2)         </span><br><span class="line"><span class="built_in">print</span>(lst1)         <span class="comment"># 输出为 [10, 20, 30, 40, &#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line"><span class="comment"># 指定位置添加元素</span></span><br><span class="line">lst1.insert(<span class="number">1</span>, <span class="number">90</span>)          </span><br><span class="line"><span class="built_in">print</span>(lst1)         <span class="comment"># 输出为 [10, 90, 20, 30, 40, &#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line"><span class="comment"># 在任意位置添加多个元素</span></span><br><span class="line">lst3 = [<span class="string">&#x27;ggw&#x27;</span>, <span class="string">&#x27;xpl&#x27;</span>]</span><br><span class="line">lst1[<span class="number">1</span>:] = lst3 = [<span class="string">&#x27;ggw&#x27;</span>, <span class="string">&#x27;xpl&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst1)         <span class="comment"># 输出为 [10, &#x27;ggw&#x27;, &#x27;xpl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="（7）删除">（7）删除</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">remove()</td><td>一次删除<strong>一个</strong>元素；<br/>重复元素只删除第一个；<br/>元素不存在抛出ValueError；</td></tr><tr><td style="text-align:center">pop()</td><td>删除<strong>一个</strong>指定索引位置上的元素；<br/>指定索引不存在抛出IndexError；<br/>不指定索引，删除列表最后一个元素；</td></tr><tr><td style="text-align:center">切片</td><td>一次<strong>至少删除一个</strong>元素</td></tr><tr><td style="text-align:center">clear()</td><td><strong>清空</strong>列表</td></tr><tr><td style="text-align:center">del</td><td><strong>删除</strong>列表</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>]</span><br><span class="line">lst.remove(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># 输出为 [10, 20, 40, 50, 60, 70, 80]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line">lst.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># 输出为 [10, 40, 50, 60, 70, 80]</span></span><br><span class="line"><span class="comment"># lst.pop(6)</span></span><br><span class="line"><span class="comment"># print(lst)      # IndexError: pop index out of range</span></span><br><span class="line">lst.pop()</span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># 输出为 [10, 40, 50, 60, 70] 默认删除最后一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line">new_lst = lst[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_lst, lst)     <span class="comment"># 输出为 [40, 50] [10, 40, 50, 60, 70]</span></span><br><span class="line"><span class="comment"># 切片删除</span></span><br><span class="line">lst[<span class="number">1</span>:<span class="number">3</span>] = []</span><br><span class="line"><span class="built_in">print</span>(lst)              <span class="comment"># 输出为 [10, 60, 70]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line">lst.clear()</span><br><span class="line"><span class="built_in">print</span>(lst)              <span class="comment"># 输出为 []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line"><span class="comment"># del lst</span></span><br><span class="line"><span class="comment"># print(lst)              </span></span><br><span class="line"><span class="comment"># NameError: name &#x27;lst&#x27; is not defined. Did you mean: &#x27;list&#x27;?</span></span><br></pre></td></tr></table></figure><h4 id="（8）修改">（8）修改</h4><ul><li>为指定索引的元素赋予一个新值</li><li>为指定的切片赋予一个新值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="comment"># 一次修改一个值</span></span><br><span class="line">lst[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出为 [10, 20, 100, 40]</span></span><br><span class="line"><span class="comment"># 一次修改多个值</span></span><br><span class="line">lst[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出为 [10, 200, 300, 40]</span></span><br></pre></td></tr></table></figure><h4 id="（9）排序和列表生成式">（9）排序和列表生成式</h4><p><strong>排序</strong></p><ul><li><p>调用 <strong>sort()</strong> 方法，列有中的所有元素默认按照从小到大的顺序进行排序，可以指定reverse=True，进行降序排序</p></li><li><p>调用内置函数 <strong>sorted()</strong> ，可以指定reverse=True，进行降序排序，原列表不发生改变，产生新的列表对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">98</span>, <span class="number">54</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;排序前&#x27;</span>, lst1, <span class="built_in">id</span>(lst1))    <span class="comment"># 输出为 [20, 40, 10, 98, 54] 1776600150400</span></span><br><span class="line"><span class="comment"># 开始排序，调用列表对象的 sort 方法</span></span><br><span class="line">lst1.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;排序后&#x27;</span>, lst1, <span class="built_in">id</span>(lst1))    <span class="comment"># 输出为 [10, 20, 40, 54, 98] 1776600150400</span></span><br><span class="line"><span class="comment"># 使用参数 reverse = True 降序, 默认为False</span></span><br><span class="line">lst1.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(lst1)                     <span class="comment"># 输出为 [98, 54, 40, 20, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================================================</span></span><br><span class="line">lst2 = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">98</span>, <span class="number">54</span>]</span><br><span class="line">new_lst2 = <span class="built_in">sorted</span>(lst2)</span><br><span class="line"><span class="built_in">print</span>(lst2, <span class="built_in">id</span>(lst2))           <span class="comment"># 输出为 [20, 40, 10, 98, 54] 2450901070336</span></span><br><span class="line"><span class="built_in">print</span>(new_lst2, <span class="built_in">id</span>(new_lst2))   <span class="comment"># 输出为 [10, 20, 40, 54, 98] 2450901022144</span></span><br><span class="line"><span class="comment"># 指定关键字参数，降序</span></span><br><span class="line">desc_lst2 = <span class="built_in">sorted</span>(lst2, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(desc_lst2)                <span class="comment"># 输出为 [98, 54, 40, 20, 10]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>列表生成式</strong></p><p>生成列表的公式</p><p>语法格式：</p>  <img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/9.png" alt=" " style="zoom: 80%;" /> <p>ps：“表示列表元素的表达式&quot;中通常包含自定义变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出为 [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">lst = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出为 [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line">lst = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出为 [2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br></pre></td></tr></table></figure><h3 id="2、字典">2、字典</h3><h4 id="（1）什么是字典">（1）什么是字典</h4><ul><li>Python内置的数据结构之一，与列表一样是一个<strong>可变序列</strong></li><li>以键值对的方式存储数据,字典是一个无序的序列</li></ul><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/10.png" style="zoom:50%;" /> <h4 id="（2）实现原理">（2）实现原理</h4><p>字典的实现原理与查字典类似，查字典是先根据部首或拼音查找应的页码,Python中的字典是根据<strong>key</strong>查找<strong>value</strong>所在的位置</p><p>字典示意图：</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/11.png" alt=""></p><h4 id="（3）创建">（3）创建</h4><ul><li><p><strong>最常用</strong>：使用{}</p><p><code>scores = &#123;'张三': 100, '李四': 98, '王五': 45&#125;</code></p></li><li><p>使用内置函数<strong>dict()</strong></p><p><code>scores = dict(张三='100', 李四='98', 王五='45')</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 1、使用&#123;&#125;创建字典 &quot;&quot;&quot;</span></span><br><span class="line">scores = &#123;<span class="string">&#x27;张三&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;王五&#x27;</span>: <span class="number">45</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores)       <span class="comment"># 输出为 &#123;&#x27;张三&#x27;: 100, &#x27;李四&#x27;: 98, &#x27;王五&#x27;: 45&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(scores)) <span class="comment"># 输出为 &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2、dict() &quot;&quot;&quot;</span></span><br><span class="line">scores = <span class="built_in">dict</span>(张三=<span class="string">&#x27;100&#x27;</span>, 李四=<span class="string">&#x27;98&#x27;</span>, 王五=<span class="string">&#x27;45&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(scores)       <span class="comment"># 输出为 &#123;&#x27;张三&#x27;: &#x27;100&#x27;, &#x27;李四&#x27;: &#x27;98&#x27;, &#x27;王五&#x27;: &#x27;45&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 空字典 &quot;&quot;&quot;</span></span><br><span class="line">scores = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(scores)       <span class="comment"># 输出为 &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）获取">（4）获取</h4><ul><li><p>[]</p><p><code>scores['张三']</code></p></li><li><p>get()</p><p><code>scores.get('张三')</code></p></li><li><p>区别</p><ul><li><p>如果字典中不存在指定的key，抛出keyError异常</p></li><li><p>get()方法取值，如果字典中不存在指定的key，并不会抛出KeyErre<br>None，可以通过参数设置默认的value,以便指定的key不存在时返回</p><p><code>get(key[, 默认值])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;张三&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;王五&#x27;</span>: <span class="number">45</span>&#125;</span><br><span class="line"><span class="comment"># print(scores[&#x27;ggw&#x27;])        # 输出为 KeyError: &#x27;ggw&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(scores.get(<span class="string">&#x27;ggw&#x27;</span>))            <span class="comment"># 输出为 None</span></span><br><span class="line"><span class="built_in">print</span>(scores.get(<span class="string">&#x27;ggw&#x27;</span>, <span class="string">&#x27;不造啊&#x27;</span>))   <span class="comment"># 输出为 不造啊</span></span><br><span class="line"><span class="built_in">print</span>(scores.get(<span class="string">&#x27;ggw&#x27;</span>, <span class="number">404</span>))       <span class="comment"># 输出为 404</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="（5）增删改查">（5）增删改查</h4><ul><li>判断：in \ not in(key)</li><li>删除：del scores[‘张三’]</li><li>新增：scores[‘ggw’] = 99</li><li>修改：scores[‘ggw’] = 100</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;张三&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;王五&#x27;</span>: <span class="number">45</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;张三&#x27;</span> <span class="keyword">in</span> scores)       <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;张三&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> scores)   <span class="comment"># 输出为 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;张三&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(scores)   <span class="comment"># 输出为 &#123;&#x27;李四&#x27;: 98, &#x27;王五&#x27;: 45&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增</span></span><br><span class="line">scores[<span class="string">&#x27;ggw&#x27;</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(scores)   <span class="comment"># 输出为 &#123;&#x27;李四&#x27;: 98, &#x27;王五&#x27;: 45, &#x27;ggw&#x27;: 99&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">scores[<span class="string">&#x27;ggw&#x27;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(scores)   <span class="comment"># 输出为 &#123;&#x27;李四&#x27;: 98, &#x27;王五&#x27;: 45, &#x27;ggw&#x27;: 100&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（6）常用方法">（6）常用方法</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">keys()</td><td>获取字典中所有的key</td></tr><tr><td style="text-align:center">values()</td><td>获取字典中所有的value</td></tr><tr><td style="text-align:center">items()</td><td>获取字典中所有的key, value对</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;张三&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;王五&#x27;</span>: <span class="number">45</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中所有的key</span></span><br><span class="line">keys = scores.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)         <span class="comment"># 输出为 dict_keys([&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(keys))   <span class="comment"># 输出为 &lt;class &#x27;dict_keys&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(keys))   <span class="comment"># 输出为 [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]  转成列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中所有的value</span></span><br><span class="line">values = scores.values()</span><br><span class="line"><span class="built_in">print</span>(values)         <span class="comment"># 输出为 dict_values([100, 98, 45])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(values))   <span class="comment"># 输出为 &lt;class &#x27;dict_values&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(values))   <span class="comment"># 输出为 [100, 98, 45]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中所有的key, value对</span></span><br><span class="line">items = scores.items()</span><br><span class="line"><span class="built_in">print</span>(items)         <span class="comment"># 输出为 dict_items([(&#x27;张三&#x27;, 100), (&#x27;李四&#x27;, 98), (&#x27;王五&#x27;, 45)])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(items))   <span class="comment"># 输出为 &lt;class &#x27;dict_items&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(items))   <span class="comment"># 输出为 [(&#x27;张三&#x27;, 100), (&#x27;李四&#x27;, 98), (&#x27;王五&#x27;, 45)]    转成元组</span></span><br></pre></td></tr></table></figure><h4 id="（7）遍历">（7）遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;张三&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;李四&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;王五&#x27;</span>: <span class="number">45</span>&#125;</span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> scores:</span><br><span class="line">    <span class="built_in">print</span>(item, scores[item], scores.get(item))</span><br><span class="line"><span class="comment"># 输出为 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">张三 100 100</span></span><br><span class="line"><span class="string">李四 98 98</span></span><br><span class="line"><span class="string">王五 45 45</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（8）特点">（8）特点</h4><ul><li>字典中的所有元素都是一个key-value对, <strong>key不允许重复</strong>, value可以重复</li><li>字典中的元素是无序的</li><li>字典中的<strong>key必须是不可变对象</strong>，字典也可以根据需要动态地伸缩</li><li>字典会浪费较大的内存，是一种使用<strong>空间换时间</strong>的数据结构</li></ul><h4 id="（9）字典生成式">（9）字典生成式</h4><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_18-40-09.png" alt=""></p><p><strong>内置函数zip()</strong><br>用于将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="string">&#x27;Fruits&#x27;</span>, <span class="string">&#x27;Books&#x27;</span>, <span class="string">&#x27;Others&#x27;</span>]</span><br><span class="line">prices = [<span class="number">96</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">56</span>, <span class="number">76</span>]</span><br><span class="line">res1 = &#123;item: price <span class="keyword">for</span> item, price <span class="keyword">in</span> <span class="built_in">zip</span>(items, prices)&#125;</span><br><span class="line"><span class="built_in">print</span>(res1)    <span class="comment"># 输出为 &#123;&#x27;Fruits&#x27;: 96, &#x27;Books&#x27;: 33, &#x27;Others&#x27;: 22&#125;</span></span><br><span class="line">res2 = &#123;item.upper(): price <span class="keyword">for</span> item, price <span class="keyword">in</span> <span class="built_in">zip</span>(items, prices)&#125;</span><br><span class="line"><span class="built_in">print</span>(res2)    <span class="comment"># 输出为 &#123;&#x27;FRUITS&#x27;: 96, &#x27;BOOKS&#x27;: 33, &#x27;OTHERS&#x27;: 22&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3、元组">3、元组</h3><p>Python内置的数据结构之一，是一个<strong>不可变序列</strong></p><h4 id="（1）创建">（1）创建</h4><ul><li>小括号()</li><li>使用内置函数 tuple()</li><li>只包含一个元组的元素需要使用逗号和小括号</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、小括号()</span></span><br><span class="line">t1 = (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)       <span class="comment"># 输出为(&#x27;python&#x27;, &#x27;hello&#x27;, 90)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t1)) <span class="comment"># 输出为&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、使用内置函数 tuple()</span></span><br><span class="line">t2 = <span class="built_in">tuple</span>((<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">90</span>))</span><br><span class="line"><span class="built_in">print</span>(t2)           <span class="comment"># 输出为(&#x27;python&#x27;, &#x27;hello&#x27;, 90)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2))     <span class="comment"># 输出为&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、只包含一个元组的元素需要使用逗号和小括号</span></span><br><span class="line">t3 = (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t3)           <span class="comment"># 输出为hello</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3))     <span class="comment"># 输出为&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">t4 = (<span class="string">&#x27;hello&#x27;</span>, )</span><br><span class="line"><span class="built_in">print</span>(t4)           <span class="comment"># 输出为(&#x27;hello&#x27;,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t4))     <span class="comment"># 输出为&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、创建空元组</span></span><br><span class="line">t5 = ()</span><br><span class="line">t6 = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(t5, t6)    <span class="comment"># 输出为 () ()</span></span><br></pre></td></tr></table></figure><h4 id="（2）为什么元组要设计成不可变的序列">（2）为什么元组要设计成不可变的序列</h4><ul><li><p>在多任务环境下，同时操作对象时不需要加锁</p></li><li><p>因此,在程序中尽量使用不可变序列</p></li><li><p><strong>注意事项</strong>: 元组中存储的是对象的引用</p><ul><li>如果元组中对象本身不可对象，则不能再引用其它对象</li><li>如果元组中的对象是可变对象，则可变对象的引用不允许改变，但数据可以改变</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_19-01-13.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">10</span>, [<span class="number">20</span>, <span class="number">30</span>], <span class="number">40</span>)</span><br><span class="line"><span class="comment"># 元组不允许修改元素</span></span><br><span class="line"><span class="comment"># t[1] = 100  # 输出为 TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">35</span>)</span><br><span class="line"><span class="built_in">print</span>(t)    <span class="comment"># 输出为 (10, [20, 30, 35], 40)</span></span><br></pre></td></tr></table></figure><h4 id="（3）获取、遍历">（3）获取、遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">10</span>, [<span class="number">20</span>, <span class="number">30</span>], <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引获取元组元素</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">0</span>])     <span class="comment"># 输出为 10</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])     <span class="comment"># 输出为 [20, 30]</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">2</span>])     <span class="comment"># 输出为 40</span></span><br><span class="line"><span class="comment"># print(t[3])     # 输出为 IndexError: tuple index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h3 id="4、集合">4、集合</h3><ul><li>Python语言提供的内置数据结构</li><li>与列表、字典―样都属于<strong>可变类型</strong>的序列</li><li>集合是没有value的字典</li></ul><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/12.png" style="zoom: 67%;" /> <h4 id="（1）创建-2">（1）创建</h4><ul><li><p>花括号{}</p><p><code>s = &#123;1, 2, 4, 5, 5, 7, 7&#125;</code></p></li><li><p>使用内置函数set()</p><p><code>s = set(range(6))</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 1、花括号&#123;&#125; &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 集合元素不允许重复</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)                            <span class="comment"># 输出为 &#123;1, 2, 4, 5, 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2、使用内置函数set() &quot;&quot;&quot;</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s)                            <span class="comment"># 输出为 &#123;0, 1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">53</span>, <span class="number">56</span>]))          <span class="comment"># 输出为 &#123;56, 3, 4, 53&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>((<span class="number">3</span>, <span class="number">4</span>, <span class="number">53</span>, <span class="number">56</span>)))          <span class="comment"># 输出为 &#123;56, 3, 4, 53&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="string">&#x27;python&#x27;</span>))                <span class="comment"># 输出为 &#123;&#x27;y&#x27;, &#x27;p&#x27;, &#x27;n&#x27;, &#x27;t&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">53</span>, <span class="number">56</span>, <span class="number">4</span>, <span class="number">4</span>&#125;))    <span class="comment"># 输出为 &#123;56, 3, 4, 53&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 3、空集合 &quot;&quot;&quot;</span></span><br><span class="line">s1 = &#123;&#125;</span><br><span class="line">s2 = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(s1, <span class="built_in">type</span>(s1))                 <span class="comment"># 输出为 &#123;&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s2, <span class="built_in">type</span>(s2))                 <span class="comment"># 输出为 set() &lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="（2）增删改查">（2）增删改查</h4><ul><li><p>集合元素的<strong>判断</strong>操作</p><p><code>in或not in</code></p></li><li><p>集合元素的<strong>新增</strong>操作</p><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">add()</td><td>一次添加一个元素</td></tr><tr><td style="text-align:center">update()</td><td>至少添加一个元素</td></tr></tbody></table></li><li><p>集合元素的<strong>删除</strong>操作</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>remove()</td><td>一次删除一个指定元素，如果指定的元素不存在抛出KeyError</td></tr><tr><td>discard()</td><td>一次删除一个指定元素，如果指定的元素不存在不抛出异常</td></tr><tr><td>pop()</td><td>一次只删除一个任意元素</td></tr><tr><td>clear()</td><td>清空集合</td></tr></tbody></table></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">405</span>, <span class="number">60</span>&#125;</span><br><span class="line"><span class="string">&quot;&quot;&quot; 判断操作 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> s)          <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">not</span> <span class="keyword">in</span> s)     <span class="comment"># 输出为 True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 新增操作 &quot;&quot;&quot;</span></span><br><span class="line">s.add(<span class="number">80</span>)</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;80, 20, 405, 10, 60, 30&#125;</span></span><br><span class="line">s.update(&#123;<span class="number">200</span>, <span class="number">400</span>, <span class="number">300</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;200, 10, 300, 80, 400, 20, 405, 60, 30&#125;</span></span><br><span class="line">s.update(([<span class="number">100</span>, <span class="number">99</span>, <span class="number">8</span>]))</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;99, 100, 200, 8, 10, 300, 80, 400, 20, 405, 60, 30&#125;</span></span><br><span class="line">s.update((<span class="number">78</span>, <span class="number">64</span>, <span class="number">56</span>))</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;64, 99, 100, 200, 8, 10, 300, 78, 80, 400, 20, 405, 56, 60, 30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 删除操作 &quot;&quot;&quot;</span></span><br><span class="line">s.remove(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;64, 99, 200, 8, 10, 300, 78, 80, 400, 20, 405, 56, 60, 30&#125;</span></span><br><span class="line"><span class="comment"># s.remove(500)   # 输出为 KeyError: 500</span></span><br><span class="line">s.discard(<span class="number">500</span>)</span><br><span class="line">s.discard(<span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;64, 99, 200, 8, 10, 78, 80, 400, 20, 405, 56, 60, 30&#125;</span></span><br><span class="line">s.pop()     <span class="comment"># 输出为 无参</span></span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 &#123;99, 200, 8, 10, 78, 80, 400, 20, 405, 56, 60, 30&#125;</span></span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># 输出为 set()</span></span><br></pre></td></tr></table></figure><h4 id="（3）集合间的关系">（3）集合间的关系</h4><ul><li><p>两个集合是否相等</p><ul><li>可以使用运算符==或!=进行判断</li></ul></li><li><p>一个集合是否是另一个集合的子集</p><ul><li><p>可以调用方法 <strong>issubset()</strong> 进行判断</p></li><li><p>B是A的子集</p></li></ul></li><li><p>一个集合是否是另一个集合的超集</p><ul><li><p>可以调用方法 <strong>issuperset()</strong> 进行判断·</p></li><li><p>A是B的超集</p></li></ul></li><li><p>两个集合是否没有交集</p><ul><li>可以调用方法 <strong>isdisjoint()</strong> 进行判断，有交集为False</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="string">&quot;&quot;&quot; 两个集合是否相等 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2)             <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(s1 != s2)             <span class="comment"># 输出为 False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 一个集合是否是另一个集合的子集 &quot;&quot;&quot;</span></span><br><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">s3 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.issubset(s1))      <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(s3.issubset(s1))      <span class="comment"># 输出为 False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 一个集合是否是另一个集合的超集 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s2))    <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s3))    <span class="comment"># 输出为 False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 两个集合是否有交集 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s2.isdisjoint(s3))    <span class="comment"># 输出为 False （有交集为False）</span></span><br><span class="line">s4 = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.isdisjoint(s4))    <span class="comment"># 输出为 True （无交集为True）</span></span><br></pre></td></tr></table></figure><h4 id="（4）集合间的数学操作">（4）集合间的数学操作</h4><ol><li><p>交集：<code>s1.intersection(s2)</code> 或者 <code>s1 &amp; s2</code></p></li><li><p>并集：<code>s1.union(s2)</code> 或者 <code>s1 | s2</code></p></li><li><p>差集：<code>s1.difference(s2)</code> 或者 <code>s1 - s2</code></p></li><li><p>对称差集：<code>s1.symmetric_difference(s2)</code>或者 <code>s1 ^ s2</code></p><p><strong>ps：原集合都没有变化</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment"># 1、交集</span></span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)  <span class="comment"># 输出为 &#123;40, 20, 30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、并集</span></span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)  <span class="comment"># 输出为 &#123;40, 10, 50, 20, 30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、差集</span></span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 - s2)  <span class="comment"># 输出为 &#123;10&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、对称差集</span></span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 ^ s2)  <span class="comment"># 输出为 &#123;10, 50&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（5）集合生成式">（5）集合生成式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(s)    <span class="comment"># &#123;0, 1, 64, 4, 36, 9, 16, 49, 81, 25&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5、总结">5、总结</h3><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/13.png" style="zoom: 50%;" /> <h2 id="五、字符串">五、字符串</h2><p>在Python中字符串是基本数据类型，是一个<strong>不可变</strong>的字符序列</p><h3 id="1、字符串的驻留机制">1、字符串的驻留机制</h3><p><strong>仅保存一份相同且不可变字符串</strong>的方法，不同的值被存放在字符串的驻留池中,Python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/14.png" style="zoom: 67%;" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&quot;Python&quot;</span></span><br><span class="line">c = <span class="string">&#x27;&#x27;&#x27;Python&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a, <span class="built_in">id</span>(a))     <span class="comment"># Python 1937251321008</span></span><br><span class="line"><span class="built_in">print</span>(b, <span class="built_in">id</span>(b))     <span class="comment"># Python 1937251321008</span></span><br><span class="line"><span class="built_in">print</span>(c, <span class="built_in">id</span>(c))     <span class="comment"># Python 1937251321008</span></span><br></pre></td></tr></table></figure><ul><li><p>触发驻留机制的几种情况(交互模式)</p><ul><li>字符串的长度为0或1时</li><li>符合标识符的字符串</li><li>字符串只在编译时进行驻留，而非运行时</li><li>[-5,256]之间的整数数字</li></ul></li><li><p>sys中的intern方法强制2个字符串指向同一个对象</p></li></ul><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/15.png" style="zoom: 67%;" /> <ul><li><p>PyCharm对字符串进行了优化处理(只要内容相同即驻留)</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_20-09-43.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-13_20-10-12.png" alt=""></p></li><li><p>字符串驻留机制的<strong>优缺点</strong></p><ul><li>当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存，因此拼接字符串和修改字符串是会比较影响性能的。</li><li>在<strong>需要进行字符串拼接时，建议使用str类型的join方法</strong>，而非+ ,因为join()方法是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率要比&quot;+&quot;效率高</li></ul></li></ul><h3 id="2、字符串的常用操作">2、字符串的常用操作</h3><h4 id="（1）查询">（1）查询</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">index()</td><td>查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr><td style="text-align:center">rindex()</td><td>查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr><td style="text-align:center">find()</td><td>查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回 -1</td></tr><tr><td style="text-align:center">rfind()</td><td>查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回 -1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello, hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&#x27;lo&#x27;</span>))    <span class="comment"># 输出为 3    </span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;lo&#x27;</span>))     <span class="comment"># 输出为 3     </span></span><br><span class="line"><span class="built_in">print</span>(s.rindex(<span class="string">&#x27;lo&#x27;</span>))   <span class="comment"># 输出为 10</span></span><br><span class="line"><span class="built_in">print</span>(s.rfind(<span class="string">&#x27;lo&#x27;</span>))    <span class="comment"># 输出为 10</span></span><br></pre></td></tr></table></figure><h4 id="（2）大小写转换">（2）大小写转换</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">upper()</td><td>把字符串中所有字符都转成大写字母；<br/>产生了新的字符串</td></tr><tr><td style="text-align:center">lower()</td><td>把字符串中所有字符都转成小写字母；<br>产生了新的字符串</td></tr><tr><td style="text-align:center">swapcase()</td><td>把字符串中所有大写字母转成小写字母，把所有小写字母都转成大写字母；<br/>产生了新的字符串</td></tr><tr><td style="text-align:center">capitalize()</td><td>把第一个字符转换为大写，把其余字符转换为小写；<br/>产生了新的字符串</td></tr><tr><td style="text-align:center">title()</td><td>把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写；<br/>产生了新的字符串</td></tr></tbody></table><h4 id="（3）字符串对齐">（3）字符串对齐</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">center()</td><td><strong>居中对齐</strong>，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则则返回原字符串</td></tr><tr><td style="text-align:center">ljust()</td><td><strong>左对齐</strong>，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则则返回原字符串</td></tr><tr><td style="text-align:center">rjust()</td><td><strong>右对齐</strong>，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则则返回原字符串</td></tr><tr><td style="text-align:center">zfill()</td><td><strong>右对齐</strong>，左边用0填充,该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello, python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))    <span class="comment"># 输出为 ***hello, python****</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">10</span>, <span class="string">&#x27;*&#x27;</span>))    <span class="comment"># 输出为 hello, python</span></span><br><span class="line"><span class="built_in">print</span>(s.zfill(<span class="number">20</span>))          <span class="comment"># 输出为 0000000hello, python</span></span><br><span class="line"><span class="built_in">print</span>(s.zfill(<span class="number">10</span>))          <span class="comment"># 输出为 hello, python</span></span><br></pre></td></tr></table></figure><h4 id="（4）字符串的分割">（4）字符串的分割</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">split()</td><td>从字符串的<strong>左</strong>边开始劈分，默认的劈分字符是空格字符串，<strong>返回的值都是一个列表</strong>；<br/>以通过参数sep指定劈分字符串是的劈分符；<br/>通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分</td></tr><tr><td style="text-align:center">rsplit()</td><td>从字符串的<strong>右</strong>边开始劈分，其他同split()</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;hello world python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1.split())                       <span class="comment"># 输出为 [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br><span class="line">s2 = <span class="string">&#x27;hello|world|python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s2.split())                       <span class="comment"># 输出为 [&#x27;hello|world|python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s2.split(sep=<span class="string">&#x27;|&#x27;</span>))                <span class="comment"># 输出为 [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s2.split(sep=<span class="string">&#x27;|&#x27;</span>, maxsplit=<span class="number">1</span>))    <span class="comment"># 输出为 [&#x27;hello&#x27;, &#x27;world|python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(s2.rsplit(sep=<span class="string">&#x27;|&#x27;</span>, maxsplit=<span class="number">1</span>))   <span class="comment"># 输出为 [&#x27;hello|world&#x27;, &#x27;python&#x27;]</span></span><br></pre></td></tr></table></figure><p>ps: 可以这么写<code>'hello|world|python'.split('|')'</code></p><h4 id="（5）判断字符串">（5）判断字符串</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">isidentifier()</td><td>判断指定的家符串是不是合法的标识符</td></tr><tr><td style="text-align:center">isspace()</td><td>判断指定的字符串是否全部由空白字符组成(回车、换行，水平制表符)</td></tr><tr><td style="text-align:center">isalpha()</td><td>判断指定的字符串是否全部由字母组成（汉字也是）</td></tr><tr><td style="text-align:center">isdecimal()</td><td>判断指定字符串是否全部由十进制的数字组成</td></tr><tr><td style="text-align:center">isnumeric()</td><td>判断指定的字符串是否全部由数字组成</td></tr><tr><td style="text-align:center">isalnum()</td><td>判断指定字符串是否全部由字母和数字组成</td></tr></tbody></table><h4 id="（6）字符串的替换与合并">（6）字符串的替换与合并</h4><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">replace()</td><td>第1个参数指定被替换的子串，第2个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化,调用该方法时可以通过第3个参数指定最大替换次数<br>省流：第1个参数：替换什么；第2个参数：替换成什么；第3个参数：最大替换几次；</td></tr><tr><td style="text-align:center">join()</td><td>将<strong>列表或元组</strong>中的字符串合并成一个字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 替换 &quot;&quot;&quot;</span></span><br><span class="line">s = <span class="string">&#x27;hello world python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>))  <span class="comment"># hello world java</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>))       <span class="comment"># hexxo world python 将列表或元组中的字符串合并成一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 合并 &quot;&quot;&quot;</span></span><br><span class="line">lst = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(lst))         <span class="comment"># helloworldpython</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; | &#x27;</span>.join(lst))      <span class="comment"># hello | world | python</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>.join(<span class="string">&#x27;python&#x27;</span>))   <span class="comment"># p*y*t*h*o*n</span></span><br></pre></td></tr></table></figure><h3 id="3、字符串的比较操作">3、字符串的比较操作</h3><ul><li>运算符: &gt;, &gt;=, &lt;, &lt;=, ==, !=</li><li>比较规则:首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较。</li><li>比较原理:两上字符进行比较时，比较的是其ordinal value(原始值)，<strong>调用内置函数 <em>ord()</em></strong> 可以得到指定字符的ordinal value。<strong>与内置函数ord()对应的是内置函数 chr()</strong> ，调用内置函数 <em>chr()</em> 时指定ordinal value可以得到其对应的字符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;abs&#x27;</span>)        <span class="comment"># 输出为 False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span>)            <span class="comment"># 输出为 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;b&#x27;</span>))   <span class="comment"># 输出为 97 98</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>), <span class="built_in">chr</span>(<span class="number">98</span>))     <span class="comment"># 输出为 a b</span></span><br></pre></td></tr></table></figure><h3 id="4、字符串的切片操作">4、字符串的切片操作</h3><ul><li>字符串是不可变类型<ul><li>不具备增、删、改等操作</li><li><strong>切片操作将产生新的对象</strong></li></ul></li></ul><p>切片操作同列表<code>str[start: end: step]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hellopython&#x27;</span></span><br><span class="line">s1 = <span class="built_in">str</span>[:<span class="number">4</span>]</span><br><span class="line">s2 = <span class="built_in">str</span>[<span class="number">5</span>:]</span><br><span class="line">s3 = s1 + <span class="string">&#x27; &#x27;</span> + s2 + <span class="string">&#x27;!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1, <span class="string">&#x27;|&#x27;</span>, s2, <span class="string">&#x27;|&#x27;</span>, s3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, <span class="built_in">id</span>(<span class="built_in">str</span>), <span class="string">&#x27;\n&#x27;</span>, \</span><br><span class="line">      <span class="built_in">id</span>(s1), <span class="string">&#x27;\n&#x27;</span>, \</span><br><span class="line">      <span class="built_in">id</span>(s2), <span class="string">&#x27;\n&#x27;</span>, \</span><br><span class="line">      <span class="built_in">id</span>(s3))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hell | python | hell python!</span><br><span class="line"> 2638999304560 </span><br><span class="line"> 2638999304368 </span><br><span class="line"> 2638999351984 </span><br><span class="line"> 2638999351664</span><br></pre></td></tr></table></figure><h3 id="5、格式化字符串">5、格式化字符串</h3><p>两种方式：</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/16.png" style="zoom: 67%;" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 1、%占位符 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫%s, 今年%d岁&#x27;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2、&#123;&#125;占位符 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#123;0&#125;, 今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(name, age))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 3、f-string &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我叫<span class="subst">&#123;name&#125;</span>, 今年<span class="subst">&#123;age&#125;</span>岁&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 精度 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%10d&#x27;</span> % <span class="number">99</span>)              <span class="comment"># 10表示的是宽度 |        99</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.3f&#x27;</span> % <span class="number">3.1415926</span>)       <span class="comment"># 3表示的是小数点后3位 |3.142</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%10.3f&#x27;</span> % <span class="number">3.1415926</span>)     <span class="comment"># |     3.142</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:.3&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))       <span class="comment"># 3表示的是一个三位 |3.14</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))      <span class="comment"># 3表示的是一个三位小数 |3.142</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10.3f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))    <span class="comment"># |     3.142</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我叫张三, 今年20岁</span><br><span class="line">我叫张三, 今年20岁</span><br><span class="line">我叫张三, 今年20岁</span><br><span class="line">        99</span><br><span class="line">3.142</span><br><span class="line">     3.142</span><br><span class="line">3.14</span><br><span class="line">3.142</span><br><span class="line">     3.142</span><br></pre></td></tr></table></figure><h3 id="6、编码、解码">6、编码、解码</h3><ul><li><p>为什么需要编码转换</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/17.png" style="zoom:67%;" /> </li><li><p>编码解码的方式</p><ul><li>编码：将字符串转换为二进制数据(bytes)，<code>s.encode(encoding='GBK')</code>，<strong>GBK、UTF-8</strong></li><li>解码：将bytes类型的数据转换成字符串类型，<code>byte.decode(encoding='GBK')</code>，编码解码的格式要一致</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;不想学了&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; 编码 &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>))     <span class="comment"># GBK：一个中文占两个字节</span></span><br><span class="line"><span class="comment"># 输出：b&#x27;\xb2\xbb\xcf\xeb\xd1\xa7\xc1\xcb&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>))   <span class="comment"># UTF-8：一个中文占三个字节</span></span><br><span class="line"><span class="comment"># 输出：b&#x27;\xe4\xb8\x8d\xe6\x83\xb3\xe5\xad\xa6\xe4\xba\x86&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 解码 格式要一致&quot;&quot;&quot;</span></span><br><span class="line">byte = s.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;GBK&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出为 不想学了</span></span><br><span class="line">byte = s.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出为 不想学了</span></span><br></pre></td></tr></table></figure><h2 id="六、函数">六、函数</h2><h3 id="1、创建">1、创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[输入参数]</span>):</span><br><span class="line">    函数体</span><br><span class="line">    [<span class="keyword">return</span> 返回值]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 函数创建 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a, b</span>):<span class="comment"># a, b是形参</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 函数调用 &quot;&quot;&quot;</span></span><br><span class="line">res = calc(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(res)<span class="comment"># 输出为 30 </span></span><br></pre></td></tr></table></figure><h3 id="2、函数调用的参数传递">2、函数调用的参数传递</h3><ul><li><strong>位置实参</strong><br>根据形参对应的位置进行实参传递</li><li><strong>关键字实参</strong><br>根据形参名称进行实参传递</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">a, b</span>):     <span class="comment"># a, b是形参</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_put(<span class="number">10</span>, <span class="number">20</span>)        <span class="comment"># a = 10 b = 20</span></span><br><span class="line">_put(b=<span class="number">10</span>, a=<span class="number">20</span>)    <span class="comment"># a = 20 b = 10</span></span><br></pre></td></tr></table></figure><h3 id="3、参数传递的内存分析">3、参数传递的内存分析</h3><p>内存分析图：</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/18.png"  />  <h3 id="4、函数的返回值">4、函数的返回值</h3><ul><li><p>如果函数没有返回值【函数执行完毕之后，不需要给调用处提供数据】return可以省略不写</p><p><strong>如果没有return，则默认返回None</strong></p></li><li><p>函数的返回值如果是1个，直接返回类型</p></li><li><p>函数的返回值<strong>如果是多个</strong>(<code>return a, b</code>)，返回的<strong>结果为元组</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了fun1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了fun2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun1())</span><br><span class="line"><span class="built_in">print</span>(fun2(), <span class="built_in">type</span>(fun2()))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行了fun1</span><br><span class="line">None</span><br><span class="line">执行了fun2</span><br><span class="line">执行了fun2</span><br><span class="line">(10, 20) &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="5、函数参数的定义">5、函数参数的定义</h3><h4 id="（1）默认值参数">（1）默认值参数</h4><p>函数定义时，给形参设置默认值，只有与默认值不符的时候才需要传递实参<br>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>)  <span class="comment"># 输出为 1 10</span></span><br></pre></td></tr></table></figure><h4 id="（2）个数可变的位置参数">（2）个数可变的位置参数</h4><ul><li>定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数</li><li>使用 <strong>*</strong> 定义个数可变的位置形参</li><li>结果为一个<strong>元组</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">put(<span class="number">10</span>)             <span class="comment"># 输出为 (10,)</span></span><br><span class="line">put(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)     <span class="comment"># 输出为 (10, 20, 30)</span></span><br></pre></td></tr></table></figure><h4 id="（3）个数可变的关键字形参">（3）个数可变的关键字形参</h4><ul><li>定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参</li><li>使用 <strong>**</strong> 定义个数可变的关键字形参</li><li>结果为一个<strong>字典</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">**args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_put(a=<span class="number">10</span>)        <span class="comment"># &#123;&#x27;a&#x27;: 10&#125;</span></span><br><span class="line">_put(a=<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>)    <span class="comment"># &#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30&#125;</span></span><br></pre></td></tr></table></figure><p><strong>ps：</strong></p><ul><li>个数可变的位置参数和关键字形参都只能是一个</li><li>可以同时都有，但是个数可变的位置参数必须在写在前面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">*args, *a</span>):<span class="comment"># 报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">**args, **a</span>):<span class="comment"># 报错 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">**args, *a</span>):<span class="comment"># 报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">*args, **a</span>):<span class="comment"># 正确</span></span><br></pre></td></tr></table></figure><h4 id="（4）参数使用总结">（4）参数使用总结</h4><p><a href="https://www.bilibili.com/video/BV1wD4y1o7AS?t=639.3&amp;p=93">视频总结</a></p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/19.png" style="zoom:50%;" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;, b =&#x27;</span>, b, <span class="string">&#x27;, c =&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 将 列表 每个元素转化为 位置实参 传入&quot;&quot;&quot;</span></span><br><span class="line">lst = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="comment"># put(lst)      # 输出为 TypeError</span></span><br><span class="line"><span class="comment"># 解构列表 </span></span><br><span class="line">put(*lst)       <span class="comment"># 输出为 a = 100 , b = 200 , c = 300</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 将 字典 每个元素转化为 关键字实参 传入&quot;&quot;&quot;</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">111</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">222</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">333</span>&#125;</span><br><span class="line"><span class="comment"># put(dic)      # 输出为 TypeError</span></span><br><span class="line">put(*dic)       <span class="comment"># 输出为 a = a , b = b , c = c</span></span><br><span class="line">put(**dic)      <span class="comment"># 输出为 a = 111 , b = 222 , c = 333</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 函数定义时的形参顺序问题 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">a, b, *, c, d</span>):    <span class="comment"># &#x27;*&#x27;后必须使用 关键字实参</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>(<span class="params">a, b, *, c, d, **args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun3</span>(<span class="params">a, b=<span class="number">10</span> ,*args1 ,**args2</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="6、递归函数">6、递归函数</h3><ul><li><p>递归的调用过程：</p><ul><li><p>每递归调用一次函数，都会在栈内存分配一个栈帧，</p></li><li><p>每执行完一次函数，都会释放相应的空间</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">n</span>):                       </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:                    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>                  </span><br><span class="line">    <span class="keyword">else</span>:                         </span><br><span class="line">        <span class="keyword">return</span> n * fac(n - <span class="number">1</span>)     </span><br><span class="line">                                  </span><br><span class="line">                                  </span><br><span class="line"><span class="built_in">print</span>(fac(<span class="number">6</span>))   <span class="comment"># 720 6的阶乘        </span></span><br></pre></td></tr></table></figure><h3 id="7、匿名函数">7、匿名函数</h3><p>使用lambda来创建匿名函数，它是一个可以接收多个任意参数，并返回单个表达式的值的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x, y, z: x * y * z</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))   <span class="comment"># 60 </span></span><br><span class="line">L = <span class="keyword">lambda</span> x: [x**<span class="number">2</span>, x**<span class="number">3</span>, x**<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(L(<span class="number">2</span>))     <span class="comment"># [4, 8, 16]</span></span><br></pre></td></tr></table></figure><h2 id="七、bug、异常处理">七、bug、异常处理</h2><h3 id="1、bug的类型">1、bug的类型</h3><ul><li><p>粗心导致的语法错误</p><ol><li>漏了<strong>末尾的冒号</strong>，如if语句,循环语句,else子句等</li><li><strong>缩进错误</strong>，该缩进的没缩进,不该缩进的瞎缩进</li><li>把<strong>英文符号</strong>写成中文符号，比如说:引号，冒号，括号</li><li>字符串拼接的时候，把<strong>字符串和数字拼在一起</strong></li><li>没有<strong>定义变量</strong>,比如说while的循环条件的变量</li><li>&quot;<strong>==</strong>&quot;比较运算符和”<strong>=</strong>”赋值运算符的混用</li></ol></li><li><p>知识点掌握不熟练</p><ul><li>索引越界</li><li>内置函数还是对象方法</li></ul></li><li><p>逻辑错误</p></li><li><p><strong>被动掉坑</strong></p><p>程序代码逻辑没有错，只是因为用户错误操作或者一些“例外情况&quot;而导致的<strong>程序崩溃</strong></p><p><strong>解决</strong>：Python异常处理机制</p></li></ul><h3 id="2、Python异常处理机制">2、Python异常处理机制</h3><p>Python提供了异常处理机制，可以在异常出现时即时捕获，然后内部“消化”,让程序继续运行。</p><h4 id="（1）try-except">（1）try-except</h4><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/20.png" style="zoom:50%;" /> <h4 id="（2）多个except结构">（2）多个except结构</h4><ul><li><p>捕获异常的顺序按照<strong>先子类后父亲类</strong>的顺序,为了避免遗漏可能出现的异常，可以在最后增加</p><p><strong>BaseException</strong></p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第一个整数:&#x27;</span>))</span><br><span class="line">    n2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第二个整数:&#x27;</span>))</span><br><span class="line">    res = n1 / n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>, res)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入数字&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> BaseException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="（3）try-except-else">（3）try-except-else</h4><p>如果try块中没有抛出异常，则执行else块，如果try中抛出异常，则执行except块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第一个整数:&#x27;</span>))</span><br><span class="line">    n2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第二个整数:&#x27;</span>))</span><br><span class="line">    res = n1 / n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;出错了：&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>, res)</span><br></pre></td></tr></table></figure><h4 id="（4）try-except-else-finally">（4）try-except-else-finally</h4><p>finally块无论是否发生异常都会被执行，能常用来释放try块中申请的资源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第一个整数:&#x27;</span>))</span><br><span class="line">    n2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第二个整数:&#x27;</span>))</span><br><span class="line">    res = n1 / n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;出错了：&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>, res)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行结束&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、Python中常见的异常">3、Python中常见的异常</h3><table><thead><tr><th style="text-align:center">异常类型</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">ZeroDivisionError</td><td>除(或取模)零(所有数据类型)</td></tr><tr><td style="text-align:center">IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td style="text-align:center">KeyError</td><td>映射中没有这个键</td></tr><tr><td style="text-align:center">NameError</td><td>未声明/初始化对象(没有属性)</td></tr><tr><td style="text-align:center">SyntaxError</td><td>Python语法错误</td></tr><tr><td style="text-align:center">ValueError</td><td>传入无效参数</td></tr></tbody></table><h3 id="4、traceback模块">4、traceback模块</h3><p>使用traceback模块打印异常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    num = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><h3 id="5、Pycharm程序调试">5、Pycharm程序调试</h3><p>断点调试</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/21.png" style="zoom: 67%;" /> <h2 id="八、类和对象">八、类和对象</h2><blockquote><p>python中一切皆对象</p></blockquote><h3 id="1、创建类">1、创建类</h3><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line">内容</span><br></pre></td></tr></table></figure><p>类名规范：由一个或多个单词组成，每个单词的首字母大写</p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python中一切皆对象，内存有开空间吗？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student))      <span class="comment"># 输出为 1541726811616</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Student))    <span class="comment"># 输出为 &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Student)          <span class="comment"># 输出为 &lt;class &#x27;__main__.Student&#x27;&gt;</span></span><br></pre></td></tr></table></figure><ul><li>类的组成<ul><li>类属性</li><li>初始化方法</li><li>实例方法</li><li>静态方法</li><li>类方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># 类属性：类里面的变量</span></span><br><span class="line">    native_place = <span class="string">&#x27;福建&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># self.name称为实体属性，将局部变量赋值name给实体属性name</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instanceFun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是一个实例方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticFun</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是一个静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classFun</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是一个类方法&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>ps: self代表实例对象本身</strong></p><h3 id="2、创建对象">2、创建对象</h3><p>又称为类的实例化</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例名 = 类名()</span><br></pre></td></tr></table></figure><p>举例：（使用上面的Student类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ggw = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------| ggw |-----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(ggw))          <span class="comment"># 输出为 2602738007632</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ggw))        <span class="comment"># 输出为 &lt;class &#x27;__main__.Student&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(ggw)              <span class="comment"># 输出为 &lt;__main__.Student object at 0x0000025DFF463E50&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------| Student |-----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student))      <span class="comment"># 输出为 1757065559632</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Student))    <span class="comment"># 输出为 &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Student)          <span class="comment"># 输出为 &lt;class &#x27;__main__.Student&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>输出为</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_13-26-16.png" alt=""></p><h3 id="3、类属性、类方法、静态方法的使用方法">3、类属性、类方法、静态方法的使用方法</h3><h4 id="（1）类属性">（1）类属性</h4><blockquote><p>类中方法外的变量称为类变量，<strong>被该类的所有对象共享(类指针)</strong></p></blockquote><p>举例：（使用上面的Student类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stu1 = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;xpl&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Student.native_place)                     <span class="comment"># 福建</span></span><br><span class="line"><span class="built_in">print</span>(stu1.name, stu2.name)                     <span class="comment"># ggw xpl</span></span><br><span class="line"><span class="built_in">print</span>(stu1.native_place, stu2.native_place)     <span class="comment"># 福建 福建</span></span><br><span class="line">Student.native_place = <span class="string">&#x27;吉林&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.native_place, stu2.native_place)     <span class="comment"># 吉林 吉林</span></span><br></pre></td></tr></table></figure><h4 id="（2）类方法">（2）类方法</h4><blockquote><p>使用<code>@classmethod</code>修饰的方法，<strong>使用类名直接访问的方法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu.classFun()<span class="comment"># 输出为 我是一个类方法</span></span><br><span class="line">Student.classFun()<span class="comment"># 输出为 我是一个类方法</span></span><br></pre></td></tr></table></figure><h4 id="（3）静态方法">（3）静态方法</h4><blockquote><p>使用<code>@staticmethod</code>修饰的方法，<strong>使用类名直接访问的方法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu.staticFun()         <span class="comment"># 输出为 我是一个静态方法</span></span><br><span class="line">Student.staticFun()     <span class="comment"># 输出为 我是一个静态方法</span></span><br></pre></td></tr></table></figure><h4 id="（4）实例方法">（4）实例方法</h4><p>使用1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例名.实例方法名()</span><br></pre></td></tr></table></figure><p>使用2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.实例方法名(实例名)</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu.instanceFun()           <span class="comment"># 输出为 我是一个实例方法</span></span><br><span class="line">Student.instanceFun(stu)    <span class="comment"># 输出为 我是一个实例方法</span></span><br></pre></td></tr></table></figure><h3 id="4、动态绑定属性和方法">4、动态绑定属性和方法</h3><blockquote><p>python是动态语言，在创建对象后，可以动态地绑定属性和方法</p></blockquote><ul><li><strong>动态绑定属性</strong></li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例名.要绑定地属性名 = 值</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;在吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;xpl&#x27;</span>)</span><br><span class="line">stu1.eat()                      <span class="comment"># 输出为 ggw在吃饭</span></span><br><span class="line">stu2.eat()                      <span class="comment"># 输出为 xpl在吃饭</span></span><br><span class="line"><span class="comment"># 动态绑定 属性 gender</span></span><br><span class="line">stu1.gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.name, stu1.gender)   <span class="comment"># 输出为 ggw 男</span></span><br><span class="line"><span class="comment"># print(stu2.name, stu2.gender)   # 报错：AttributeError: &#x27;Student&#x27; object has no attribute &#x27;gender&#x27;</span></span><br></pre></td></tr></table></figure><p>内存图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_18-52-33.png" alt=""></p><ul><li><strong>动态绑定方法</strong></li></ul><p>语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例名.要绑定地方法名 = 方法</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;在吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是新绑定的&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;xpl&#x27;</span>)</span><br><span class="line"><span class="comment"># 动态绑定 方法 myShow</span></span><br><span class="line">stu2.myShow = show</span><br><span class="line">stu2.myShow()   <span class="comment"># 我是新绑定的</span></span><br><span class="line"><span class="comment"># stu1.myShow()   # 报错：AttributeError: &#x27;Student&#x27; object has no attribute &#x27;myShow&#x27;</span></span><br></pre></td></tr></table></figure><p>内存图类似上面的</p><h3 id="5、面向对象的三大特征">5、面向对象的三大特征</h3><ul><li><strong>封装</strong>: 提高程序的安全性<ul><li>将数据 (属性)和行为(法)包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样就无需关心方法内部的具体实现细节，从而隔离了复这样杂度。</li><li>在Python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code></li></ul></li><li><strong>继承</strong>: 提高代码的复用性</li><li><strong>多态</strong>: 提高代码的可扩展性和可维护性</li></ul><h4 id="（1）封装的实现">（1）封装的实现</h4><p>如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code></p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return self.name    # 报错：AttributeError: &#x27;Student&#x27; object has no attribute &#x27;name&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu.getName())    <span class="comment"># 输出为ggw</span></span><br><span class="line"><span class="comment"># print(stu.__name)   # 报错：AttributeError: &#x27;Student&#x27; object has no attribute &#x27;_ _name&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>扩展：就是要访问<code>__name</code>属性</strong></p><p>1、dir(实例名)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_19-28-07.png" alt=""></p><p>2、找到属性并访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(stu._Student__name)<span class="comment"># 输出为 ggw</span></span><br></pre></td></tr></table></figure><p>所以可以访问，但是不要访问就好了</p><h4 id="（2）继承的实现">（2）继承的实现</h4><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类类名</span>(父类<span class="number">1</span>， 父类<span class="number">2.</span>..):</span><br><span class="line">    内容</span><br></pre></td></tr></table></figure><ul><li>如果一个类没有继承任何类，则默认继承<strong>object</strong></li><li>Python支持多继承</li><li>定义子类时，必须在其构造函数中调用父类的构造函数</li></ul><p>案例</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_19-52-14.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):   <span class="comment"># 继承了object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__name, self.__age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, stu_number</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.__stu_number = stu_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getStuNumber</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__stu_number)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, school</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.__school = school</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSchool</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__school)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;114514&#x27;</span>)</span><br><span class="line">teacher = Teacher(<span class="string">&#x27;罗翔&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">student.info()          <span class="comment"># 输出为 张三 18</span></span><br><span class="line">student.getStuNumber()  <span class="comment"># 输出为 114514</span></span><br><span class="line">teacher.info()          <span class="comment"># 输出为 罗翔 38</span></span><br><span class="line">teacher.getSchool()     <span class="comment"># 输出为 xxx</span></span><br></pre></td></tr></table></figure><p><strong>使用 super() 函数来调用父类</strong></p><p>多继承以后再看吧。。。</p><p><strong>方法重写</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 继承了object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getAge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__name, self.__age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, stu_number</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.__stu_number = stu_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">super</span>().getName(), <span class="built_in">super</span>().getAge(), self.__stu_number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, school</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.__school = school</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">super</span>().getName(), <span class="built_in">super</span>().getAge(), self.__school)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;114514&#x27;</span>)</span><br><span class="line">teacher = Teacher(<span class="string">&#x27;罗翔&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">student.info()  <span class="comment"># 输出为 张三 18 114514</span></span><br><span class="line">teacher.info()  <span class="comment"># 输出为 罗翔 38 xxx</span></span><br></pre></td></tr></table></figure><h4 id="（3）多态的实现">（3）多态的实现</h4><blockquote><p>简单地说，多态就是“具有多种形态”，它指的是:即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法</p></blockquote><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物吃食物&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃粮食&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Animal().eat()      <span class="comment"># 输出为 动物吃食物</span></span><br><span class="line">Cat().eat()         <span class="comment"># 输出为 猫吃鱼</span></span><br><span class="line">Dog().eat()         <span class="comment"># 输出为 狗吃骨头</span></span><br><span class="line">Person().eat()      <span class="comment"># 输出为 人吃粮食</span></span><br></pre></td></tr></table></figure><p><strong>静态语言与动态语言</strong></p><ul><li>静态语言(JAVA)和动态语言关于多态的区别静态语言实现多态的三个必要条件<ul><li>继承</li><li>方法重写</li><li>父类引用指向子类对象9</li></ul></li><li>动态语言的多态崇尚“鸭子类型”当看到一只鸟走起来像鸭子、游泳起来像鸭子收起来也像鸭子，那么这只鸟就可以被称为鸭子。在鸭子类型中，不需要关心对象是什么类型，到底是不是鸭子，只关心对象的行为。</li></ul><h3 id="6、object类">6、object类</h3><ul><li>object类是所有类的父类，因此所有类都有object类的属性和方法</li><li><strong>内置函数 dir()</strong> 可以查看指定对象所属性</li><li>Object有一个 <strong>__str__()</strong> 方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮我们查看对象的信息，所以我们经常会对 <strong>__str__()</strong> 进行重写</li></ul><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stusent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;我的名字是<span class="subst">&#123;self.__name&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu = Stusent(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)<span class="comment"># 会默认调用__str__()</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;_Stusent__name&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br><span class="line">我的名字是ggw</span><br></pre></td></tr></table></figure><h3 id="7、特殊的属性和方法">7、特殊的属性和方法</h3><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">特殊属性</td><td style="text-align:center"><code>__dict__</code></td><td style="text-align:left">获得类对象或实例对象所绑定的属性和方法的字典</td></tr><tr><td style="text-align:center">特殊方法</td><td style="text-align:center"><code>__len__()</code></td><td style="text-align:left">通过重写<code>__len__()</code>，让内置函数len()的参数可以是自定义类型</td></tr><tr><td style="text-align:center">特殊方法</td><td style="text-align:center"><code>__add__()</code></td><td style="text-align:left">通过重写<code>__add__()</code>，可是自定义对象具有”+“功能</td></tr><tr><td style="text-align:center">特殊方法</td><td style="text-align:center"><code>__new__()</code></td><td style="text-align:left">用于创建对象</td></tr><tr><td style="text-align:center">特殊方法</td><td style="text-align:center"><code>__init__()</code></td><td style="text-align:left">对创建的对象进行初始化</td></tr></tbody></table><p><strong>特殊属性</strong></p><ul><li><code>__dict__</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance = C(<span class="string">&#x27;xxx&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(instance.__dict__)</span><br><span class="line"><span class="built_in">print</span>(C.__dict__)</span><br><span class="line"><span class="built_in">print</span>(instance.__class__)   <span class="comment"># 输出对象所属的类</span></span><br><span class="line"><span class="built_in">print</span>(C.__bases__)          <span class="comment"># 输出的是父类</span></span><br><span class="line"><span class="built_in">print</span>(C.__mro__)            <span class="comment"># 类的层次结构</span></span><br><span class="line"><span class="built_in">print</span>(A.__subclasses__())   <span class="comment"># 输出子类列表</span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;_C__name&#x27;: &#x27;xxx&#x27;, &#x27;_C__age&#x27;: 20&#125;</span><br><span class="line">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function C.__init__ at 0x000001E0977ECAF0&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">&lt;class &#x27;__main__.C&#x27;&gt;</span><br><span class="line">(&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)</span><br><span class="line">(&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;]</span><br></pre></td></tr></table></figure><p><strong>特殊方法</strong></p><ul><li><code>__add__()</code></li></ul><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">200</span></span><br><span class="line">c = a + b</span><br><span class="line">d = a.__add__(b)</span><br><span class="line"><span class="built_in">print</span>(c, d)     <span class="comment"># 输出为 300 300</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name + other.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&#x27;ggw&#x27;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&#x27;xpl&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1 + stu2)  <span class="comment"># 输出为 ggwxpl</span></span><br></pre></td></tr></table></figure><ul><li><code>__len__()</code></li></ul><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;这是长度&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">50</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst))         <span class="comment"># 输出为 4</span></span><br><span class="line"><span class="built_in">print</span>(lst.__len__())    <span class="comment"># 输出为 4</span></span><br><span class="line"><span class="built_in">print</span>(A().__len__())    <span class="comment"># 输出为 这是长度</span></span><br></pre></td></tr></table></figure><ul><li><code>__new__()</code>和<code>__init__()</code></li></ul><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;__new__()执行了, cls的值的id为<span class="subst">&#123;<span class="built_in">id</span>(cls)&#125;</span>&#x27;</span>)</span><br><span class="line">        obj = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;创建的对象id为<span class="subst">&#123;<span class="built_in">id</span>(obj)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;__init__()执行了, self的id为<span class="subst">&#123;<span class="built_in">id</span>(self)&#125;</span>&#x27;</span>)</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;object这个类对象的id为<span class="subst">&#123;<span class="built_in">id</span>(<span class="built_in">object</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Person这个类对象的id为<span class="subst">&#123;<span class="built_in">id</span>(Person)&#125;</span>&#x27;</span>)</span><br><span class="line">p1 = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p1这个Person类的实例对象id为<span class="subst">&#123;<span class="built_in">id</span>(p1)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object这个类对象的id为140718335637376</span><br><span class="line">Person这个类对象的id为2753193282256</span><br><span class="line">__new__()执行了, cls的值的id为2753193282256</span><br><span class="line">创建的对象id为2753194573392</span><br><span class="line">__init__()执行了, self的id为2753194573392</span><br><span class="line">p1这个Person类的实例对象id为2753194573392</span><br></pre></td></tr></table></figure><p>原理图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_22-48-58.png" alt=""></p><h3 id="8、类的浅拷贝与深拷贝">8、类的浅拷贝与深拷贝</h3><ul><li><p><strong>变量的赋值操作</strong></p><p>只是形成两个变量，实际上指向同一个对象</p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = a1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a1))   <span class="comment"># 输出为 2143666190896</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a2))   <span class="comment"># 输出为 2143666190896</span></span><br></pre></td></tr></table></figure><p>内存图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_23-04-31.png" alt=""></p></li><li><p><strong>浅拷贝</strong></p><p>python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象和拷贝对象会引用同一对象</p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cumputer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpu, disk</span>):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.disk = disk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu = CPU()</span><br><span class="line">disk = Disk()</span><br><span class="line">computer1 = Cumputer(cpu, disk)</span><br><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2 = copy.copy(computer1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(computer1), <span class="built_in">id</span>(computer1.cpu), <span class="built_in">id</span>(computer1.disk))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(computer2), <span class="built_in">id</span>(computer2.cpu), <span class="built_in">id</span>(computer2.disk))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1819258797744 1819258798032 1819258797792</span><br><span class="line">1819258797552 1819258798032 1819258797792</span><br></pre></td></tr></table></figure><p>内存图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-14_23-38-54.png" alt=""></p></li><li><p><strong>深拷贝</strong></p><p>使用copy模块的 <strong>deepcopy()</strong> 函数，递归拷贝对象中包含的子对象、源对象和拷贝对象所有的子对象各不相同</p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cumputer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpu, disk</span>):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.disk = disk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu = CPU()</span><br><span class="line">disk = Disk()</span><br><span class="line">computer1 = Cumputer(cpu, disk)</span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2 = copy.deepcopy(computer1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(computer1), <span class="built_in">id</span>(computer1.cpu), <span class="built_in">id</span>(computer1.disk))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(computer2), <span class="built_in">id</span>(computer2.cpu), <span class="built_in">id</span>(computer2.disk))</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1859713646256 1859713646544 1859713646304</span><br><span class="line">1859713645920 1859713644480 1859713864400</span><br></pre></td></tr></table></figure><p>内存图</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_00-46-43.png" alt=""></p></li></ul><h2 id="九、模块、包">九、模块、包</h2><h3 id="1、什么是模块、模块化编程的好处">1、什么是模块、模块化编程的好处</h3><ul><li>模块英文为<strong>Modules</strong></li><li>函数与模块的关系<ul><li>一个模块中可以包含N多个函数（也可以N个类）</li></ul></li><li>在Python中一个扩展名为 <strong>.py</strong> 的文件就是一个模块</li><li>使用模块的好处<ul><li>方便其它程序和脚本的导入并使用</li><li>避免函数名和变量名冲突</li><li>提高代码的可维护性</li><li>提高代码的可重用性</li></ul></li></ul><h3 id="2、导入模块">2、导入模块</h3><ul><li><p>创建模块</p><ul><li>新建一个 .py 文件，名称尽量不要与Python自带的标准模块名称相同</li></ul></li><li><p>导入模块</p><ul><li><p>只能导入包名和模块名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名称 [<span class="keyword">as</span>别名]</span><br></pre></td></tr></table></figure></li><li><p>可以导入包、模块、函数、变量、类<br>可以减少查询时间，提高访问速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名称 <span class="keyword">import</span> 函数/变量/类</span><br></pre></td></tr></table></figure></li><li><p>可以不用加模块名做前缀，简单但是一般不推荐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名称 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(math))     <span class="comment"># 输出为 2584154507360</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(math))   <span class="comment"># 输出为 &lt;class &#x27;module&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(math)         <span class="comment"># 输出为 &lt;module &#x27;math&#x27; (built-in)&gt;</span></span><br><span class="line"><span class="built_in">print</span>(math.pi)      <span class="comment"># 输出为 3.141592653589793</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="built_in">print</span>(pi)           <span class="comment"># 输出为 3.141592653589793</span></span><br></pre></td></tr></table></figure><p><strong>导入自定义模块</strong></p><p>calc.py文件内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建时间：2023-01-15 1:03</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mult</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;计算结果为:&#x27;</span>, a * b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;计算结果为:&#x27;</span>, a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>导入使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calc</span><br><span class="line">calc.mult(<span class="number">10</span>, <span class="number">20</span>)   <span class="comment"># 输出为 计算结果为: 200</span></span><br><span class="line">calc.div(<span class="number">1</span>, <span class="number">0</span>)      <span class="comment"># 输出为 除数不能为0</span></span><br></pre></td></tr></table></figure><p>文件命名不规范的这样导入(<a href="http://xn--8ov87j.py">没有.py</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyKnn = <span class="built_in">__import__</span>(<span class="string">&#x27;04-MyKnn&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、以主程序方式运行">3、以主程序方式运行</h3><p>在每个模块的定义中都包括一个记录模块名称的变量<code>__name__</code>，程序可以检查该变量,以确定他们在哪个模块中执行。如果一个模块不是被导入到其它程序中执行，那么它可能在解释器的顶级模块中执行。顶级模块的<code>__name__</code>变量的值为<code>__main___</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 只有当点击本程序运行时，才执行运算 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>如果没有这么处理</p><p>calc.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建时间：2023-01-15 1:03</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mult</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;计算结果为:&#x27;</span>, a * b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;计算结果为:&#x27;</span>, a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我是calc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calc</span><br><span class="line">calc.mult(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">calc.div(<span class="number">100</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是calc</span><br><span class="line">计算结果为: 20000</span><br><span class="line">计算结果为: 10.0</span><br></pre></td></tr></table></figure><h3 id="4、包">4、包</h3><ul><li><p>包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下</p></li><li><p>作用:</p><ul><li>代码规范</li><li>避免模块名称冲突</li></ul></li><li><p>包与目录的区别</p><ul><li>包含<code>_init__.py</code>文件的目录称为包_，告诉python将该目录作为一个包来处理</li><li>目录里通常不包含<code>_init__.py</code>文件</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_09-37-24.png" alt=""></p></li><li><p>包的导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><p>案例</p><p>文件结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├───helloworld.py</span><br><span class="line">├───directory</span><br><span class="line">└───package</span><br><span class="line">        calc.py</span><br><span class="line">        __init__.py</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package.calc</span><br><span class="line"></span><br><span class="line">package.calc.mult(<span class="number">100</span>, <span class="number">200</span>)     <span class="comment"># 输出为 计算结果为: 20000输出为 </span></span><br><span class="line">package.calc.div(<span class="number">100</span>, <span class="number">10</span>)       <span class="comment"># 输出为 计算结果为: 10.0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5、Python中常用的内置模块">5、Python中常用的内置模块</h3><table><thead><tr><th style="text-align:center">模块名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">sys</td><td>与Python解释器及其环境操作相关的标准库</td></tr><tr><td style="text-align:center">time</td><td>提供与时间相关的各种函数的标准库</td></tr><tr><td style="text-align:center">os</td><td>提供了访问操作系统服务功能的标准库</td></tr><tr><td style="text-align:center">calendar</td><td>提供与日期相关的各种函数的标准库</td></tr><tr><td style="text-align:center">urllib</td><td>用于读取来自网上（服务器）的数据标准库</td></tr><tr><td style="text-align:center">json</td><td>用于使用JSON序列化和反序列化对象</td></tr><tr><td style="text-align:center">re</td><td>用于在字符串中执行正则表达式匹配和替换</td></tr><tr><td style="text-align:center">math</td><td>提供标准算术运算函数的标准库</td></tr><tr><td style="text-align:center">decimal</td><td>用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算</td></tr><tr><td style="text-align:center">logging</td><td>提供了灵活的记录事件、错误、警告和调试信息等目志信息的功能</td></tr></tbody></table><h3 id="6、第三方模块的安装及使用">6、第三方模块的安装及使用</h3><ul><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/22.png" style="zoom: 50%;" /> <p>未报错，安装成功</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/23.png" style="zoom:50%;" /> </li><li><p>使用</p><p><code>import 模块名</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">schedule.every(<span class="number">3</span>).seconds.do(job)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>模块无法生效</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_10-13-56.png" alt=""></p><h4 id="Pycharm无法解析"><strong>Pycharm无法解析</strong></h4><p>解决：配置Python Interpreter（Python解释器）</p><p>文件 -&gt; 设置 -&gt; 项目xxx -&gt; Python解释器:</p><p>​<img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/24.png" style="zoom:50%;" /></p><h3 id="7、搜索路径">7、搜索路径</h3><p>Python模块的导入需要路径搜索的过程</p><p>搜索路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> sys.path:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>不在同一目录下，需要将包、模块所在的路径添加进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;C:\\Users\\GGW_2021\\Desktop\\笔记\\python&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="十、文件读写">十、文件读写</h2><h3 id="1、文件读写原理">1、文件读写原理</h3><ul><li><p>文件读写俗称&quot;IO操作&quot;</p></li><li><p>文件读写流程</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_10-31-54.png" alt=""></p></li></ul><h3 id="2、文件的读写操作">2、文件的读写操作</h3><ul><li><p>使用内置函数 <strong>open()</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_10-37-29.png" alt=""></p><p>语法格式</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_10-37-58.png" alt=""></p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.readlines())<span class="comment"># 输出为 我是一个文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、常用的文件打开模式">3、常用的文件打开模式</h3><ul><li>文件的类型（按文件的组织形式，文件分为以下两大类）<ul><li><strong>文本文件</strong>： 存储的是普通&quot;字符&quot;文本，默认为unicode字符集，可以使用记事本程序打开</li><li><strong>二进制文件</strong>：把数据内容用&quot;字节&quot;进行存储，无法用记事本打开，必须使用专用的软件打开，举例，mp3音频文件</li></ul></li></ul><table><thead><tr><th style="text-align:center">打开方式</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td>以只读的模式打开文件，文件指针将会放在文件的开头</td></tr><tr><td style="text-align:center">w</td><td>以只写的模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头</td></tr><tr><td style="text-align:center">a</td><td>以追加的模式打开文件，如果文件不存在则创建，文件指针在文件开头；如果文件存在，则在文件末尾追加内容，文件指在原文件的末尾</td></tr><tr><td style="text-align:center">b</td><td>以二进制的方式打开文件，不能单独使用，需要与其他模式一起使用，例如：rb、wb</td></tr><tr><td style="text-align:center">+</td><td>与读写的方式打开文件，不能单独使用，需要与其他模式一起使用，例如：a+</td></tr></tbody></table><h3 id="4、文件对象常用的方法">4、文件对象常用的方法</h3><table><thead><tr><th style="text-align:center">方法</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">read([size])</td><td>从文件中读取size个字节或字符的内容符号，若省略size，则从文件头读取到文件尾，即一次读取文件所有内容</td></tr><tr><td style="text-align:center">readline()</td><td>从文本文件中读取一行内容</td></tr><tr><td style="text-align:center">readlines()</td><td>把文本文件中的每一行作为一个字符串对象，并将这些对象放入列表返回</td></tr><tr><td style="text-align:center">write(str)</td><td>将字符串str内容写入文件</td></tr><tr><td style="text-align:center">writelines(s_list)</td><td>将字符串列表s_list写入文本文件，不添加换行符</td></tr><tr><td style="text-align:center">seek(offset<br>[,whence])</td><td>把文件指针移动到新的位置，offset表示相对于whence的位置（单位是字节）：<br>offset：为正，向结束方向移动；为负，向开始方向移动<br>whence：不同的值代表不同的含义：<br> 0：从文件头开始计算（默认值）<br> 1：从当前位置开始计算<br> 2：从文件尾开始计算</td></tr><tr><td style="text-align:center">tell()</td><td>返回文件指针当前位置</td></tr><tr><td style="text-align:center">flush()</td><td>把缓冲区的内容写入文件，但不关闭文件</td></tr><tr><td style="text-align:center">close()</td><td>把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源</td></tr></tbody></table><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="comment"># print(file.read())      # 全部读取</span></span><br><span class="line"><span class="comment"># print(file.read(2))     # 读取两个字符</span></span><br><span class="line"><span class="comment"># print(file.readline())  # 读取一行</span></span><br><span class="line"><span class="comment"># print(file.readlines()) # 读取多行，放回列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file.write(&#x27;哈哈哈哈&#x27;)      # 写入</span></span><br><span class="line"><span class="comment"># lst = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="comment"># file.writelines(lst)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file.seek(2)</span></span><br><span class="line"><span class="comment"># print(file.tell())</span></span><br><span class="line"><span class="comment"># print(file.read())</span></span><br><span class="line"><span class="comment"># print(file.tell())</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="5、with语句（上下文管理器）">5、with语句（上下文管理器）</h3><blockquote><p>with语句可以自动的管理上下文资源，无论什么原因跳出with块，都能保证文件的正确关闭以此来达到释放资源的目的</p></blockquote><p>语法</p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/python/python-note/Snipaste_2023-01-15_13-34-04.png" alt=""></p><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">print</span>(file.read())</span><br></pre></td></tr></table></figure><p>上下文管理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">MyContentMgr实现了特俗方法__enter__(), __exit__()</span></span><br><span class="line"><span class="string">所以称该类的实例对象遵守了上下文管理器协议</span></span><br><span class="line"><span class="string">该类的实例对象为上下文管理器</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContentMgr</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__enter__()执行了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__exit__()执行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;show()执行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContentMgr() <span class="keyword">as</span> file:</span><br><span class="line">    file.show()</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出为:</span></span><br><span class="line"><span class="string">__enter__()执行了</span></span><br><span class="line"><span class="string">show()执行了</span></span><br><span class="line"><span class="string">__exit__()执行了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="6、os模块">6、os模块</h3><ul><li>os模块是Python内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样。</li><li>os模块与os.path模块用于对目录或文件进行操作</li></ul><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># os.system(&#x27;notepad.exe&#x27;)    # 打开记事本</span></span><br><span class="line"><span class="comment"># os.system(&#x27;calc.exe&#x27;)       # 打开计算器</span></span><br><span class="line"><span class="comment"># 打开可执行文件</span></span><br><span class="line">os.startfile(<span class="string">&#x27;D:\\Tencent Files\\Bin\\QQ.exe&#x27;</span>)   <span class="comment"># 打开QQ</span></span><br></pre></td></tr></table></figure><p><strong>os模块操作目录的相关函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>getcwd()</td><td>返回当前工作目录</td></tr><tr><td>listdir(path)</td><td>返回指定路径下的文件和目录</td></tr><tr><td>mkdir(path[, mode])</td><td>创建目录</td></tr><tr><td>makedirs(path1/path2…[, mode])</td><td>创建多级目录</td></tr><tr><td>rmdir(path)</td><td>删除目录</td></tr><tr><td>removedirs(path1/path2…)</td><td>删除多级目录</td></tr><tr><td>chdir(path)</td><td>将path设置为当前工作目录</td></tr><tr><td>walk(path)</td><td>返回指定路径下的文件和目录，以及子目录下的文件和目录<br>（8、案例中有专门的例子）</td></tr></tbody></table><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># print(os.getcwd())  # 输出为 D:\python\project\demo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(os.listdir(&#x27;./&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.mkdir(&#x27;./目录1&#x27;)   # 创建了目录1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.makedirs(&#x27;./1/2&#x27;)    # 创建了多级目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.rmdir(&#x27;./目录1&#x27;)     # 删除了目录1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.removedirs(&#x27;./1/2&#x27;)  # 删除了多级目录</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;D:\\&#x27;</span>)    <span class="comment"># 修改了当前工作目录</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())  <span class="comment"># 输出为 D:\</span></span><br></pre></td></tr></table></figure><h3 id="7、os-path模块">7、os.path模块</h3><p>相关函数</p><table><thead><tr><th style="text-align:left">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">abspath(path)</td><td>用于获取文件或目录的绝对路径</td></tr><tr><td style="text-align:left">exists(path)</td><td>用于判断文件或目录是否存在，如果存在，返回True，否则返回False</td></tr><tr><td style="text-align:left">join(path, name)</td><td>将目录与目录或者文件名拼接起来</td></tr><tr><td style="text-align:left">split(path)</td><td></td></tr><tr><td style="text-align:left">splitext(path)</td><td>分离文件名和拓展名</td></tr><tr><td style="text-align:left">basename(path)</td><td>从一个目录中提取文件名</td></tr><tr><td style="text-align:left">dirname(path)</td><td>从一个路径中提取文件路径，不包括文件名</td></tr><tr><td style="text-align:left">isdir(path)</td><td>用于判断是否是路径</td></tr></tbody></table><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;data.txt&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;data.txt&#x27;</span>), os.path.exists(<span class="string">&#x27;xxx.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;D:\\python\\project\\demo&#x27;</span>, <span class="string">&#x27;helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.split(<span class="string">&#x27;D:\\python\\project\\demo\\helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.splitext(<span class="string">&#x27;helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.splitext(<span class="string">&#x27;D:\\python\\project\\demo\\helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.basename(<span class="string">&#x27;D:\\python\\project\\demo\\helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(<span class="string">&#x27;D:\\python\\project\\demo\\helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">&#x27;D:\\python\\project\\demo\\helloworld.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">&#x27;D:\\python\\project\\demo&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------</span><br><span class="line">D:\python\project\demo\data.txt</span><br><span class="line">------------------------------------------</span><br><span class="line">True False</span><br><span class="line">------------------------------------------</span><br><span class="line">D:\python\project\demo\helloworld.py</span><br><span class="line">------------------------------------------</span><br><span class="line">(&#x27;D:\\python\\project\\demo&#x27;, &#x27;helloworld.py&#x27;)</span><br><span class="line">------------------------------------------</span><br><span class="line">(&#x27;helloworld&#x27;, &#x27;.py&#x27;)</span><br><span class="line">(&#x27;D:\\python\\project\\demo\\helloworld&#x27;, &#x27;.py&#x27;)</span><br><span class="line">------------------------------------------</span><br><span class="line">helloworld.py</span><br><span class="line">------------------------------------------</span><br><span class="line">D:\python\project\demo</span><br><span class="line">------------------------------------------</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="8、案例">8、案例</h3><p>列出指定目录下的所有.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = os.getcwd()</span><br><span class="line">lst = os.listdir(path)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="comment"># endwith 是不是以什么结尾</span></span><br><span class="line">    <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.py&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(filename)</span><br></pre></td></tr></table></figure><p>walk()的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = os.getcwd()</span><br><span class="line">lst = os.walk(path)</span><br><span class="line"><span class="keyword">for</span> dirpath, dirname, filename <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(dirpath, <span class="string">&#x27;||&#x27;</span>, dirname, <span class="string">&#x27;||&#x27;</span>, filename)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dirname:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(dirpath, key))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(dirpath, key))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;========================================&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;========================================&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">D:\python\project\demo || [&#x27;.idea&#x27;, &#x27;directory&#x27;, &#x27;package&#x27;, &#x27;__pycache__&#x27;] || [&#x27;data.txt&#x27;, &#x27;helloworld.py&#x27;]</span><br><span class="line">D:\python\project\demo\.idea</span><br><span class="line">D:\python\project\demo\directory</span><br><span class="line">D:\python\project\demo\package</span><br><span class="line">D:\python\project\demo\__pycache__</span><br><span class="line">-------------</span><br><span class="line">D:\python\project\demo\data.txt</span><br><span class="line">D:\python\project\demo\helloworld.py</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\.idea || [&#x27;inspectionProfiles&#x27;] || [&#x27;.gitignore&#x27;, &#x27;demo.iml&#x27;, &#x27;encodings.xml&#x27;, &#x27;misc.xml&#x27;, &#x27;modules.xml&#x27;, &#x27;workspace.xml&#x27;]</span><br><span class="line">D:\python\project\demo\.idea\inspectionProfiles</span><br><span class="line">-------------</span><br><span class="line">D:\python\project\demo\.idea\.gitignore</span><br><span class="line">D:\python\project\demo\.idea\demo.iml</span><br><span class="line">D:\python\project\demo\.idea\encodings.xml</span><br><span class="line">D:\python\project\demo\.idea\misc.xml</span><br><span class="line">D:\python\project\demo\.idea\modules.xml</span><br><span class="line">D:\python\project\demo\.idea\workspace.xml</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\.idea\inspectionProfiles || [] || [&#x27;profiles_settings.xml&#x27;, &#x27;Project_Default.xml&#x27;]</span><br><span class="line">-------------</span><br><span class="line">D:\python\project\demo\.idea\inspectionProfiles\profiles_settings.xml</span><br><span class="line">D:\python\project\demo\.idea\inspectionProfiles\Project_Default.xml</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\directory || [] || []</span><br><span class="line">-------------</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\package || [&#x27;__pycache__&#x27;] || [&#x27;calc.py&#x27;, &#x27;__init__.py&#x27;]</span><br><span class="line">D:\python\project\demo\package\__pycache__</span><br><span class="line">-------------</span><br><span class="line">D:\python\project\demo\package\calc.py</span><br><span class="line">D:\python\project\demo\package\__init__.py</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\package\__pycache__ || [] || [&#x27;calc.cpython-310.pyc&#x27;, &#x27;__init__.cpython-310.pyc&#x27;]</span><br><span class="line">-------------</span><br><span class="line">D:\python\project\demo\package\__pycache__\calc.cpython-310.pyc</span><br><span class="line">D:\python\project\demo\package\__pycache__\__init__.cpython-310.pyc</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br><span class="line">D:\python\project\demo\__pycache__ || [] || []</span><br><span class="line">-------------</span><br><span class="line">========================================</span><br><span class="line">========================================</span><br></pre></td></tr></table></figure><h2 id="十一、实操案例">十一、实操案例</h2><h3 id="1、向文件输出内容">1、向文件输出内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 方法一 &#x27;&#x27;&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\GGW_2021\\Desktop\\笔记\\python\\text.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>, file=file)</span><br><span class="line">file.close()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 方法二 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\GGW_2021\\Desktop\\笔记\\python\\text.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;hello world!!&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2、模拟高铁售票系统">2、模拟高铁售票系统</h3><p>安装模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install prettytable</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> prettytable <span class="keyword">as</span> pt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showTable</span>(<span class="params">rowNum</span>):</span><br><span class="line">    table = pt.PrettyTable()  <span class="comment"># 创建对象</span></span><br><span class="line">    table.field_names = [<span class="string">&#x27;行号&#x27;</span>, <span class="string">&#x27;座位1&#x27;</span>, <span class="string">&#x27;座位2&#x27;</span>, <span class="string">&#x27;座位3&#x27;</span>, <span class="string">&#x27;座位4&#x27;</span>, <span class="string">&#x27;座位5&#x27;</span>]  <span class="comment"># 设定表头</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rowNum):</span><br><span class="line">        lst = [<span class="string">f&#x27;第<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>行&#x27;</span>, <span class="string">&#x27;有票&#x27;</span>, <span class="string">&#x27;有票&#x27;</span>, <span class="string">&#x27;有票&#x27;</span>, <span class="string">&#x27;有票&#x27;</span>, <span class="string">&#x27;有票&#x27;</span>]</span><br><span class="line">        table.add_row(lst)</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    showTable(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+-------+-------+-------+-------+</span><br><span class="line">|  行号 | 座位1 | 座位2 | 座位3 | 座位4 | 座位5 |</span><br><span class="line">+-------+-------+-------+-------+-------+-------+</span><br><span class="line">| 第1行 |  有票 |  有票 |  有票 |  有票 |  有票 |</span><br><span class="line">| 第2行 |  有票 |  有票 |  有票 |  有票 |  有票 |</span><br><span class="line">| 第3行 |  有票 |  有票 |  有票 |  有票 |  有票 |</span><br><span class="line">+-------+-------+-------+-------+-------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE</title>
      <link href="/2023/01/05/Java%20SE/"/>
      <url>/2023/01/05/Java%20SE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备">一、准备</h2><p><strong>1、环境搭建、JDK</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/2.png" alt=""></p><ul><li><p>查看版本</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac –version</span><br><span class="line">或者</span><br><span class="line">java –version </span><br></pre></td></tr></table></figure></li></ul><p><strong>2、Java程序</strong></p><blockquote><p>开发 Java 程序，需要三个步骤：编写代码，编译代码，运行代码</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/1.png" alt=""></p><ul><li>编译代码、运行代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p>jdk11开始，可以直接运行</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p><strong>3、IDEA使用</strong></p><ul><li><p>项目结构</p><ul><li>project（项目、工程）</li><li>module（模块）</li><li>package（包）</li><li>class（类）</li></ul></li><li><p>IDEA <strong>常用快捷键</strong></p></li></ul><table><thead><tr><th><strong>快捷键</strong></th><th><strong>功能效果</strong></th></tr></thead><tbody><tr><td>main/psvm、sout、…</td><td>快速键入相关代码</td></tr><tr><td>Ctrl + D</td><td>复制当前行数据到下一行</td></tr><tr><td>Ctrl + Y</td><td>删除所在行，建议用Ctrl + X</td></tr><tr><td>Ctrl + ALT + L</td><td>格式化代码</td></tr><tr><td>ALT + SHIFT + ↑ , ALT + SHIFT + ↓</td><td>上下移动当前代码</td></tr><tr><td>Ctrl + / ,  Ctrl + Shift  + /</td><td>单行注释，多行注释</td></tr></tbody></table><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/10.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/11.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/12.png" alt=""></p><h6 id=""></h6><hr><h2 id="二、基础语法">二、基础语法</h2><h3 id="1、注释">1、注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   多行注释</span></span><br><span class="line"><span class="comment">   注释内容1</span></span><br><span class="line"><span class="comment">   注释内容2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   文档注释：文档注释的内容是可以提取到一个程序说明文档中去的</span></span><br><span class="line"><span class="comment">   注释内容</span></span><br><span class="line"><span class="comment">   注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2、字面量">2、字面量</h3><blockquote><p>计算机是用来处理数据的，字面量就是<strong>告诉程序员</strong>：数据在程序中的<strong>书写格式</strong></p></blockquote><table><thead><tr><th><strong>常用数据</strong></th><th><strong>生活中的写法</strong></th><th><strong>程序中的写法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>整数</td><td>666，-88</td><td>666，-88</td><td>写法一致</td></tr><tr><td>小数</td><td>13.14，-5.21</td><td>13.14，-5.21</td><td>写法一致</td></tr><tr><td>字符</td><td>A, 0, 我</td><td>‘A’，‘0’，   ‘我’</td><td>程序中必须使用单引号，有且仅能一个字符</td></tr><tr><td>字符串</td><td>黑马程序员</td><td>“HelloWorld”，“黑马程序员”</td><td>程序中必须使用双引号，内容可有可无</td></tr><tr><td>布尔值</td><td>真、假</td><td>true 、false</td><td>只有两个值：true：代表真，false：代表假</td></tr><tr><td>空值</td><td></td><td>值是：null</td><td>一个特殊的值，空值(后面会讲解作用，暂时不管)</td></tr></tbody></table><h3 id="3、变量">3、变量</h3><blockquote><p>变量就是内存中的一块区域，用来存储一个数据的，且存储的数据可以被替换</p></blockquote><ol><li><p>变量是什么，有什么作用？</p><ul><li><p><strong>内存中的一块区域。</strong></p></li><li><p><strong>用来存储一个数据的，且存储的数据可以被替换。</strong></p></li></ul></li><li><p>变量的格式</p><ul><li><strong>数据类型 变量名称</strong> <strong>=</strong> <strong>初始值；</strong></li></ul></li><li><p>变量的基本特点</p><ul><li><p><strong>变量中只能存一个值</strong></p></li><li><p><strong>变量中存的值是可以替换的</strong></p></li></ul></li></ol><h3 id="4、关键字">4、关键字</h3><ul><li>Java语言自己用到的一些词，有特殊作用的，我们称之为关键字。</li></ul><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><h3 id="5、标识符">5、标识符</h3><blockquote><p>标志符就是名字。我们写程序时会起一些名字，如<strong>类名、方法名、变量名</strong>，取名时要遵守一定的规则。</p></blockquote><ul><li><p>标识符的要求</p><ul><li>基本要求：由数字、字母、下划线(<strong>_</strong>)和美元符(<strong>$</strong>)等组成</li><li>强制要求：<strong>不能以数字开头</strong>、不能是关键字、区分大小写</li></ul></li><li><p>命名指导规范</p><ul><li><p>变量名称：满足标识符规则，建议全英文、有意义、<strong>首字母小写</strong>，满足“驼峰模式”，</p><p>例如：int studyNumber = 59。</p></li><li><p>类名称： 满足标识符规则，建议全英文、有意义、<strong>首字母大写</strong>，满足“驼峰模式”，</p><p>例如：HelloWorld.java。</p></li></ul></li></ul><h3 id="6、数据类型">6、数据类型</h3><ul><li>引用数据类型（除基本数据类型之外的，如String ，其他的后面学习）</li><li>基本数据类型：<strong>4大类8种</strong></li></ul><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">关键字</th><th>取值范围</th><th style="text-align:center">内存占用（字节数）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>整数</strong></td><td style="text-align:center">byte</td><td>-128~127</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">short</td><td>-32768~32767</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center"><strong>int(默认)</strong></td><td>-2147483648~2147483647 <strong>(10位数)</strong></td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">long</td><td>-9223372036854775808 ~  9223372036854775807 <strong>(19位数)</strong></td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><strong>浮点数</strong></td><td style="text-align:center">float</td><td>1.401298e-45到3.402823e+38</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center"><strong>double（默认）</strong></td><td>4.9000000e-324 到1.797693e+308</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><strong>字符</strong></td><td style="text-align:center">char</td><td>0-65535</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><strong>布尔</strong></td><td style="text-align:center">boolean</td><td>true，false</td><td style="text-align:center">1</td></tr></tbody></table><ul><li>随便写的整数、小数字面值默认什么类型？</li></ul><p>23 ，默认是int类型 <strong>,</strong> <strong>加上L/l</strong>就是<strong>long</strong>类型的数据了。</p><p>23.8，默认是double类型，<strong>加上F/f</strong>就是<strong>float</strong>类型了。</p><h3 id="7、类型转换">7、类型转换</h3><ul><li><p><strong>自动类型转换</strong></p><blockquote><p><strong>类型范围小</strong>的变量，可以<strong>直接赋值</strong>给<strong>类型范围大</strong>的变量。</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/3.png" alt=""></p><p><strong>注意事项：</strong></p><ul><li><p>表达式的<strong>最终结果类型由表达式中的最高类型决定</strong>。</p></li><li><p>在表达式中，<strong>byte、short、char 是直接转换成int类型参与运算</strong>的。</p></li></ul></li><li><p><strong>强制类型转换</strong></p><blockquote><p>可以<strong>强行</strong>将<strong>类型范围大</strong>的变量、数据<strong>赋值</strong>给<strong>类型范围小</strong>的变量。</p></blockquote><ul><li><p><strong>数据类型 变量2 = (数据类型)变量1、数据</strong></p></li><li><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/4.png" alt=""></p></li><li><p><strong>注意事项</strong></p><ul><li><p>强制类型转换<strong>可能</strong>造成数据(丢失)溢出；</p></li><li><p>浮点型强转成整型，直接丢掉小数部分，保留整数部分返回。</p></li></ul></li></ul></li></ul><h3 id="8、运算符">8、运算符</h3><blockquote><p>运算符：对字面量或者变量进行操作的<strong>符号。</strong></p></blockquote><p><strong>（1）算数运算符</strong></p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">作用</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加</td><td>参考小学一年级</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td><td>参考小学一年级</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘</td><td>参考小学二年级，与“×”相同</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除</td><td>与“÷”相同，注意：在Java中两个整数相除结果还是整数。</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余</td><td>获取的是两个数据做除法的余数</td></tr><tr><td style="text-align:center">++</td><td style="text-align:center">自增</td><td>变量自身的值加1</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">自减</td><td>变量自身的值减1</td></tr></tbody></table><p><em><em>“+”<strong>做</strong></em>连接符</em>**</p><blockquote><p>“+”符号<strong>与字符串运算</strong>的时候是用作连接符的，其结果<strong>依然是一个字符串</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span> ;</span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span> + <span class="string">&#x27;a&#x27;</span>);<span class="comment">//        abca</span></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span> + a);<span class="comment">//        abc5</span></span><br><span class="line">System.out.println(<span class="number">5</span> + a);<span class="comment">//        10</span></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span> + <span class="number">5</span> + <span class="string">&#x27;a&#x27;</span>);<span class="comment">//        abc5a</span></span><br><span class="line">System.out.println(<span class="number">15</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">15</span>);<span class="comment">//        15abc15</span></span><br><span class="line">System.out.println(a + <span class="string">&#x27;a&#x27;</span>);<span class="comment">//        102</span></span><br><span class="line">System.out.println(a + <span class="string">&quot;&quot;</span> +<span class="string">&#x27;a&#x27;</span>);<span class="comment">//        5a</span></span><br><span class="line">System.out.println(a + <span class="string">&#x27;a&#x27;</span>+<span class="string">&quot;itheima&quot;</span>);<span class="comment">//        102itheima</span></span><br><span class="line">System.out.println(<span class="string">&quot;itheima&quot;</span>+ a + <span class="string">&#x27;a&#x27;</span>);<span class="comment">//        itheima5a</span></span><br><span class="line">System.out.println(<span class="string">&quot;itheima&quot;</span>+ ( a + <span class="string">&#x27;a&#x27;</span> ));<span class="comment">//        itheima102</span></span><br></pre></td></tr></table></figure><p><strong>（2）赋值运算符</strong></p><ul><li><p>基本赋值运算符</p><p>int a = 10; // 先看“=”右边，把数据10赋值给左边的变量a存储</p></li><li><p>扩展赋值运算符</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">作用</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">+=</td><td style="text-align:center">加后赋值</td><td>a+=b 等价于 a = (a的数据类型)(a+b); 将a + b的值给a</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:center">减后赋值</td><td>a-=b 等价于 a =  (a的数据类型)(a-b); 将a - b的值给a</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:center">乘后赋值</td><td>a*=b 等价于 a =  (a的数据类型)(a*b); 将a *****  b的值给a</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:center">除后赋值</td><td>a/=b 等价于 a =  (a的数据类型)(a/b); 将a <strong>/</strong> b的商给a</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:center">取余后赋值</td><td>a%=b 等价于 a =  (a的数据类型)(a%b); 将a <strong>%</strong> b的商给a</td></tr></tbody></table><p><strong>注意：扩展的赋值运算符隐含了强制类型转换。</strong></p></li></ul><p><strong>（3）关系运算符</strong></p><blockquote><p>是对数据进行条件判断的符号，最终会返回一个比较的布尔结果（false,true）</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td>a==b，判断a和b的值是否相等，成立为true，不成立为false</td></tr><tr><td style="text-align:center">!=</td><td>a!=b，判断a和b的值是否不相等，成立为true，不成立为false</td></tr><tr><td style="text-align:center">&gt;</td><td>a&gt;b，   判断a是否大于b，成立为true，不成立为false</td></tr><tr><td style="text-align:center">&gt;=</td><td>a&gt;=b，判断a是否大于等于b，成立为true，不成立为false</td></tr><tr><td style="text-align:center">&lt;</td><td>a&lt;b，   判断a是否小于b，成立为true，不成立为false</td></tr><tr><td style="text-align:center">&lt;=</td><td>a&lt;=b，判断a是否小于等于b，成立为true，不成立为false</td></tr></tbody></table><p><strong>（4）逻辑运算符</strong></p><blockquote><p>可以把多个条件的布尔结果放在一起运算，最终返回一个布尔结果。</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">介绍</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">逻辑与</td><td>必须都是true，结果才是true; 只要有一个是false，结果一定是false。</td></tr><tr><td style="text-align:center">|</td><td style="text-align:center">逻辑或</td><td>只要有一个为true、结果就是true</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">逻辑非</td><td>你真我假、你假我真。  !true=false 、 !false=  true</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">逻辑异或</td><td>如果两个条件都是false或者都是true则结果是false。两个条件不同结果是true。</td></tr></tbody></table><p><strong>短路逻辑运算符</strong></p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">介绍</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">短路与</td><td>判断结果与“&amp;”一样。过程是<strong>左边为  false</strong>，<strong>右边则不执行</strong>。</td></tr><tr><td style="text-align:center">||</td><td style="text-align:center">短路或</td><td>判断结果与“|”一样。过程是<strong>左边为 true</strong>， <strong>右边则不执行</strong>。</td></tr></tbody></table><p><strong>注意：逻辑与 “&amp;”</strong> 、<strong>逻辑或“|”</strong>；无论左边是 <strong>false</strong>还是<strong>true</strong>，<strong>右边都要执行。</strong></p><p><strong>（5）三元运算符</strong></p><p><code>条件表达式 **?** 值1 **:** 值2;</code></p><blockquote><p>执行流程：首先计算<strong>关系表达式的值，<strong>如果值为</strong>true</strong>，返回<strong>值1</strong>，如果为<strong>false</strong>，返回<strong>值2</strong>。</p></blockquote><p><strong>（6）运算符优先级</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span> &gt; <span class="number">3</span> || <span class="number">10</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span> &lt; <span class="number">3</span>);  <span class="comment">// true</span></span><br><span class="line">System.out.println( (<span class="number">10</span> &gt; <span class="number">3</span> || <span class="number">10</span> &gt; <span class="number">3</span> ) &amp;&amp; <span class="number">10</span> &lt; <span class="number">3</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/5.png" alt=""></p><hr><h6 id="-2"></h6><h2 id="三、流程控制">三、流程控制</h2><h3 id="1、分支结构">1、分支结构</h3><p><strong>（1）if 分支</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">格式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式<span class="number">3</span>：</span><br><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>) &#123;</span><br><span class="line">    语句体<span class="number">3</span>;</span><br><span class="line">&#125; </span><br><span class="line">. . .</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）switch 分支</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        执行代码...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        执行代码...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    … </span><br><span class="line">        <span class="keyword">case</span> 值n-<span class="number">1</span>:</span><br><span class="line">        执行代码...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行代码n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p><strong>表达式类型</strong>只能是byte、short、int、char，JDK5开始支持枚举，JDK7开始支持String、不支持double、float、long。</p></li><li><p>case给出的值<strong>不允许重复</strong>，且只能是字面量，不能是变量。</p></li><li><p>不要忘记写break，否则会出现穿透现象。</p></li></ul><h3 id="2、循环结构">2、循环结构</h3><p><strong>（1）for 循环</strong></p><ul><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句; 循环条件; 迭代语句)  &#123;</span><br><span class="line">    循环体语句(重复执行的代码);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）while 循环</strong></p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">    循环体语句(被重复执行的代码);</span><br><span class="line">    迭代语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）do-while 循环</strong></p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    迭代语句;</span><br><span class="line">&#125; <span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(“Hello World！<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    i++;</span></span><br><span class="line"><span class="string">&#125; while( i &lt; 3);</span></span><br></pre></td></tr></table></figure><p><strong>（4）死循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典做法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="3、跳转控制语句">3、跳转控制语句</h3><ul><li><strong>break  :</strong> 跳出并结束当前所在循环的执行。</li><li><strong>continue:</strong> 用于跳出当前循环的当次执行，进入下一次循环。</li></ul><p><strong>注意事项</strong></p><p>break : 只能用于结束所在循环, 或者结束所在switch分支的执行。</p><p>continue : 只能在循环中进行使用。</p><hr><h6 id="-3"></h6><h2 id="四、数组">四、数组</h2><h3 id="1、数组的定义">1、数组的定义</h3><p><strong>（1）静态初始化</strong></p><blockquote><p>定义数组的时候<strong>直接给数组赋值</strong>。</p></blockquote><ul><li><p><strong>完整格式</strong></p><p><code>数据类型[]  数组名 = new 数据类型[]&#123;元素1，元素2 ，元素3… &#125;;</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] scores = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">89.9</span>, <span class="number">99.5</span>, <span class="number">59.5</span>, <span class="number">88.0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] ages = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>简化格式</strong></p><p><code>数据类型[] 数组名 = &#123; 元素1，元素2 ，元素3，… &#125;;</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>数组变量名中<strong>存储的是数组在内存中的地址</strong>，<strong>数组是引用类型</strong>。</li><li>数组<strong>一旦定义</strong>出来，程序执行的过程中，<strong>长度、类型就固定了</strong>。</li></ul><p><strong>原理：</strong></p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/6.png" style="zoom:50%;" /> <p><strong>（2）动态初始化</strong></p><blockquote><p>定义数组的时候只确定元素的类型和数组的长度，之后再存入具体数据。</p></blockquote><ul><li><p><strong>格式</strong></p><p><code>数据类型[] 数组名 = new 数据类型[长度];</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 后赋值</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ul><li><strong>默认值</strong></li></ul><table><thead><tr><th style="text-align:center">数据类型</th><th>明细</th><th>默认值</th></tr></thead><tbody><tr><td style="text-align:center">基本类型</td><td>byte、short、char、int、long</td><td>0</td></tr><tr><td style="text-align:center">…</td><td>float、double</td><td>0.0</td></tr><tr><td style="text-align:center">…</td><td>boolean</td><td>false</td></tr><tr><td style="text-align:center">引用类型</td><td>类、接口、数组、String</td><td>null</td></tr></tbody></table><p>**（3）**两种格式的写法是独立的，<strong>不可以混用。</strong></p><p><code>int[] arrs = new int[3]&#123;30，40,50&#125;;</code> 是<strong>错误</strong>的</p><h3 id="2、数组的访问">2、数组的访问</h3><p><code>数组名称[索引]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li><strong>数组的长度属性：length</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组的长度（就是数组元素的个数）</span></span><br><span class="line">System.out.println(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>表示数组的<strong>最大索引</strong>：<code>数组名.length - 1//前提：元素个数大于0</code></p><ul><li><strong>遍历</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ages.length; i++) &#123;</span><br><span class="line">    System.out.println(ages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、数组内存">3、数组内存</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/7.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/8.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/9.png" alt=""></p><h3 id="4、常见问题">4、常见问题</h3><ul><li><p>问题1：如果访问的元素位置<strong>超过最大索引</strong>，执行时会出现 <strong>ArrayIndexOutOfBoundsException</strong> (数组索引越界异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// System.out.println(arr[3])  // 出现异常 </span></span><br></pre></td></tr></table></figure></li><li><p>问题2：如果数组变量中没有存储数组的地址，而是null, 在访问数组信息时会出现 <strong>NullPointerException</strong> (空指针异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr); <span class="comment">// null</span></span><br><span class="line">System.out.println(arr.length)  <span class="comment">// 出现异常 </span></span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="-4"></h6><h2 id="五、方法">五、方法</h2><h3 id="1、方法的定义与调用">1、方法的定义与调用</h3><p><strong>（1）定义</strong></p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 (形参列表) &#123;</span><br><span class="line">    方法体代码(需要执行的功能代码)</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法不需要返回结果，则申明返回值类型为<strong>void</strong>；方法不需要参数，则形参列表可以不写。</p><p><code>return; </code> 可以<strong>立即跳出并结束</strong>当前方法的执行。</p><p><strong>（2）调用</strong></p><p><strong>格式</strong></p><p><code>方法名(…);</code></p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><h3 id="2、方法调用的内存图">2、方法调用的内存图</h3><blockquote><p>方法是放在<strong>方法区</strong>中的，被调用的时候，需要进入到<strong>栈内存</strong>中运行</p></blockquote><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/13.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/14.png" alt=""></p><h3 id="3、方法的参数传递机制">3、方法的参数传递机制</h3><blockquote><p>在传输实参给方法的形参的时候，并不是传输实参变量本身， 而是传输实参变量中存储的值，这就是<em><strong>值传递</strong></em>。</p></blockquote><ul><li>基本类型和引用类型的参数在传递的时候有什么不同？<ul><li><strong>都是值传递。</strong></li><li>基本类型的参数传输存储的<strong>数据值</strong>。</li><li>引用类型的参数传输存储的<strong>地址值</strong>。</li></ul></li></ul><h3 id="4、方法的重载">4、方法的重载</h3><blockquote><p>同一个类中，出现<strong><em>多个方法名称</em>相同</strong>，但是<strong><em>形参列表</em>是不同的</strong>，那么这些方法就是重载方法。</p></blockquote><p><strong>方法重载的判定</strong></p><ul><li><p>只要是同一个类中，<strong>方法名称相同、形参列表不同</strong>，那么他们就是重载的方法，<strong>其他都不管！</strong>（如：修饰符，返回值类型都无所谓）</p></li><li><p>形参列表不同指的是：<strong>形参的个数、类型、顺序不同</strong>，不关心形参的名称。</p></li></ul><hr><h6 id="-5"></h6><h2 id="六、面向对象">六、面向对象</h2><blockquote><p>面向对象的<strong>三大</strong>特征：<strong>封装，继承，多态</strong>。</p><p>l面向对象的<strong>四大</strong>特征：<strong>抽象，封装，继承，多态</strong>。</p></blockquote><h3 id="1、定义类">1、定义类</h3><ul><li><p>类名<strong>首字母建议大写</strong>，且有意义，满足“驼峰模式”。</p></li><li><p><strong>一个Java文件中可以定义多个class类，但只能一个类是public修饰</strong>，<strong>而且public修饰的类名必须成为代码文件名</strong>。</p></li><li><p>实际开发中建议还是一个文件定义一个class类。</p></li><li><p><strong>成员变量</strong>的完整定义格式是：<code>修饰符 数据类型 变量名称 = 初始化值；</code>， <strong>一般无需指定初始化值，存在默认值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 属性 (成员变量)</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    <span class="comment">// 行为（方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、对象在内存中的运行机制-回B站看">2、对象在内存中的运行机制(回B站看)</h3><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/15.png" alt=""></p><ul><li><p>对象到底是放在哪个位置的？</p><p><strong>堆内存中</strong></p></li><li><p><code>Car c = new Car();</code> c变量名中存储的是什么？</p><p><strong>存储的是对象在堆内存中的地址。</strong></p></li><li><p>成员变量 <code>(name、price)</code> 的数据放在哪里，存在于哪个位置？</p><p>l<strong>对象中，存在于堆内存中。</strong></p></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/16.png" alt=""></p><p><strong>垃圾回收</strong></p><blockquote><p>当堆内存中的<strong>对象</strong>，没有被任何变量引用（指向）时，就会被判定为内存中的**“垃圾”。**</p></blockquote><h3 id="3、构造器">3、构造器</h3><blockquote><p>定义在类中的，可以用于初始化一个类的对象，并返回对象的地址。</p></blockquote><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 无参数构造器（默认存在的）：初始化对象时，成员变量的数据均采用默认值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span>&#123; ... &#125;        </span><br><span class="line">    <span class="comment">// 有参数构造器        </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String n, <span class="type">double</span> p)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用构造器得到对象的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类 变量名称 = <span class="keyword">new</span> 构造器；</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="type">Car</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奔驰&quot;</span>, <span class="number">39.8</span>);</span><br></pre></td></tr></table></figure><p><strong>构造器的注意事项</strong></p><ul><li><p>任何类定义出来，<strong>默认就自带了无参</strong>数构造器，<strong>写不写都有</strong>。</p></li><li><p><strong>一旦定义了有参数构造器</strong>，那么<strong>无参数构造器就没有了</strong>，如果还想用无参数构造器，此时就<strong>需要自己手写一个无参数构造器</strong>了。</p></li></ul><h3 id="4、this关键字">4、this关键字</h3><blockquote><ul><li><p>可以出现在构造器、方法中</p></li><li><p>代表<strong>当前对象的地址。</strong></p></li></ul></blockquote><h3 id="5、封装">5、封装</h3><blockquote><p>封装：告诉我们，<strong>如何正确设计对象的属性和方法</strong>。</p><p>封装的原则：对象代表什么，就得<strong>封装对应的数据，并提供数据对应的行为</strong>。</p></blockquote><p><strong>如何进行封装更好？</strong></p><ul><li>一般建议对<strong>成员变量使用private</strong>（私有、隐藏）关键字修饰进（private修饰的成员只能在当前类中访问）。</li><li><strong>为每个成员变量提供配套public修饰的的getter、setter方法</strong>暴露其取值和赋值。</li></ul><h3 id="6、JavaBean">6、JavaBean</h3><blockquote><p>也可以称为实体类，其对象可以用于在程序中封装数据</p></blockquote><p><strong>标准JavaBean</strong>须满足如下书写要求：</p><ul><li><p>成员变量使用 <strong>private</strong> 修饰。</p></li><li><p>提供成员变量对应的 <strong>setXxx() / getXxx()方法。</strong></p></li><li><p>必须提供一个<strong>无参构造器；有参数构造器是可写可不写的。</strong></p></li></ul><h3 id="7、static关键字">7、static关键字</h3><blockquote><p>static是静态的意思，可以用来修饰成员变量、成员方法。</p><p>static修饰成员变量之后称为<strong>静态成员变量（类变量）</strong>，修饰方法之后称为<strong>静态方法（类方法）</strong>。</p><p>static修饰后的成员变量，<strong>可以被类的所有对象共享（访问、修改)</strong>。</p></blockquote><ul><li><strong>静态成员变量内存图</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/20.png" alt=""></p><ul><li><p><strong>静态成员变量</strong>（有static修饰，<strong>属于类</strong>、加载一次，内存中只有一份），访问格式</p><ul><li><strong><code>类名.静态成员变量</code>(推荐)</strong></li><li><code>对象.静态成员变量</code>(不推荐)</li></ul></li><li><p><strong>实例成员变量</strong>（无static修饰，<strong>属于对象</strong>），访问格式：</p><ul><li><code>对象.实例成员变量</code></li></ul></li><li><p><strong>静态成员方法</strong>（有static修饰，归属于类），建议用类名访问，也可以用对象访问。</p></li><li><p><strong>实例成员方法</strong>（无static修饰，归属于对象），只能用对象触发访问。</p></li></ul><p><strong>静态成员方法内存图</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/21.png" alt=""></p><p><strong>static访问注意事项：</strong></p><ul><li><p><strong>静态方法只能访问静态的成员</strong>，不可以直接访问实例成员。</p></li><li><p>实例方法可以访问静态的成员，也可以访问实例成员。</p></li><li><p><strong>静态方法中是不可以出现this关键字的</strong>。</p></li></ul><h4 id="工具类"><strong>工具类</strong></h4><blockquote><p><strong>类中都是一些静态方法</strong>，每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用的。</p><p>一是调用方便，二是提高了代码复用（<strong>一次编写，处处可用</strong>）</p></blockquote><p><strong>为什么工具类中的方法不用实例方法做？</strong></p><ul><li><p><strong>实例方法需要创建对象调用。</strong></p></li><li><p><strong>此时用对象只是为了调用方法，这样只会浪费内存。</strong></p></li></ul><p>ps: 由于工具里面都是静态方法，直接用类名即可访问，因此，工具类无需创建对象，<strong>建议将工具类的构造器进行私有</strong>。</p><h4 id="代码块"><strong>代码块</strong></h4><blockquote><p>代码块是类的5大成分之一（成员变量、构造器，方法，<strong>代码块</strong>，内部类），<strong>定义在类中方法外</strong>。</p><p>在Java类下，<strong>使用 { } 括起来的代码被称为代码块</strong> 。</p></blockquote><p>代码块<strong>分为</strong></p><ul><li><p><strong>静态代码块</strong>:</p><ul><li><strong>格式</strong>：static{}</li><li><strong>特点</strong>：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li><li><strong>使用场景</strong>：在类加载的时候做一些静态数据初始化的操作，以便后续使用。</li></ul></li><li><p><strong>构造代码块</strong>（<strong>了解，见的少</strong>）：</p><ul><li><strong>格式</strong>：{}</li><li><strong>特点</strong>：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行</li><li><strong>使用场景</strong>：初始化实例资源。</li></ul></li></ul><p><strong>如果要在启动系统时对静态资源进行初始化，则建议使用静态代码块完成数据的初始化操作。</strong></p><h4 id="单例模式">单例模式</h4><blockquote><p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。</p><p>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。</p></blockquote><ul><li><p><strong>饿汉单例设计模式</strong></p><ul><li><blockquote><p>在用类获取对象的时候，对象已经提前为你创建好了。</p></blockquote></li><li><p>定义一个类，把<strong>构造器私有</strong>。</p></li><li><p>定义一个静态变量存储一个对象。</p></li><li><pre><code class="language-java">/** a、定义一个单例类 */public class SingleInstance &#123;    /** c.定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */    public static SingleInstance instance = new SingleInstance ();    /** b.单例必须私有构造器*/    private SingleInstance ()&#123;        System.out.println(&quot;创建了一个对象&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **懒汉单例设计模式**</span><br><span class="line"></span><br><span class="line">  + &gt; 在真正需要该对象的时候，才去创建一个对象(延迟加载对象)。</span><br><span class="line"></span><br><span class="line">  + 定义一个类，把构造器私有。</span><br><span class="line"></span><br><span class="line">  + 定义一个静态变量存储一个对象。</span><br><span class="line"></span><br><span class="line">  + 提供一个返回单例对象的方法</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    /** 定义一个单例类 */</span><br><span class="line">    class SingleInstance&#123;</span><br><span class="line">        /** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */</span><br><span class="line">        public static SingleInstance instance ; // null</span><br><span class="line">        /** 单例必须私有构造器*/</span><br><span class="line">        private SingleInstance()&#123;&#125;</span><br><span class="line">        /** 必须提供一个方法返回一个单例对象  */</span><br><span class="line">        public static SingleInstance getInstance()&#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new SingleInstance();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="8、继承">8、继承</h3><blockquote><p>Java中提供一个<strong>关键字extends</strong>，用这个关键字，我们可以让<strong>一个类和另一个类建立起父子关系</strong>。</p><p>Student称为<strong>子类（派生类）</strong>，People称为<strong>父类(基类 或超类)</strong>。</p><p><strong>作用</strong>：当子类继承父类后，就<strong>可以直接使用父类公共的属性和方法了</strong></p><p><strong>好处</strong>：<strong>提高代码的复用性，减少代码冗余，增强类的功能扩展性</strong></p><p><strong>格式</strong>：<strong><code>子类 extends 父类</code></strong></p></blockquote><h6 id="-6"></h6><h2 id="七、String、ArrayList">七、String、ArrayList</h2><h3 id="1、String类">1、String类</h3><h4 id="（1）概述">（1）概述</h4><blockquote><p>java.lang.String 类代表字符串，String类定义的变量可以用于指向字符串对象，然后操作该字符串。</p><p>Java 程序中的<strong>所有字符串文字</strong>（例如“abc”）<strong>都为此类的对象</strong>。</p></blockquote><p><strong>String</strong>类的特点详解</p><ul><li>String其实常被称为<strong>不可变字符串类型</strong>，它的<strong>对象在创建后不能被更改</strong>。</li><li>String变量<strong>每次的修改其实都是产生并指向了新的字符串对象</strong></li></ul><p><strong>字符串对象存在哪里？</strong></p><ul><li>在<strong>字符串常量池</strong>中存储。</li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/17.png" alt=""></p><h4 id="（2）字符串的内容比较">（2）字符串的内容比较</h4><p><strong>字符串的内容比较 <em>不适合</em> 用“==”比较。</strong>(<strong>基本数据类型比较时使用</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sysLoginName</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请您输入您的登录名称&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> sc.next();<span class="comment">// itheima</span></span><br><span class="line">System.out.println(sysLoginName == loginName);<span class="comment">// false（bi）</span></span><br></pre></td></tr></table></figure><p><strong>推荐使用String类提供的“equals”比较：只关心内容一样即可</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean <strong>equals (Object anObject)</strong></td><td>将此字符串与指定对象进行比较。只关心字符内容是否一致！</td></tr><tr><td>public boolean <strong>equalsIgnoreCase (String anotherString)</strong></td><td>将此字符串与指定对象进行比较，<strong>忽略大小写</strong>比较字符串。只关心字符内容是否一致！</td></tr></tbody></table><h4 id="（3）String常用API">（3）String常用API</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int <strong>length()</strong></td><td>返回此字符串的长度</td></tr><tr><td>public char <strong>charAt(int index)</strong></td><td>获取某个索引位置处的字符</td></tr><tr><td>public char[] <strong>toCharArray()</strong></td><td>将当前字符串转换成字符数组返回</td></tr><tr><td>public String <strong>substring(int beginIndex, int endIndex)</strong></td><td>根据开始和结束索引进行截取，得到新的字符串（包前不包后）</td></tr><tr><td>public String <strong>substring(int beginIndex)</strong></td><td>从传入的索引处截取，截取到末尾，得到新的字符串</td></tr><tr><td>public String <strong>replace(CharSequence target, CharSequence replacement)</strong></td><td>使用新值，将字符串中的旧值替换，得到新的字符串</td></tr><tr><td>public String[] <strong>split(String regex)</strong></td><td>根据传入的规则切割字符串，得到字符串数组返回</td></tr></tbody></table><h4 id="（4）创建字符串的两种方式">（4）创建字符串的两种方式</h4><ul><li><p>方式一：直接定义</p><p><code>String name = &quot;ggw&amp;xpl&quot;;</code></p></li><li><p>方式二：通过String构造类创建</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public String(String original)</td><td>根据传入的字符串内容，来创建字符串对象</td></tr><tr><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public String(byte[] chs)</td><td>根据字节数组的内容，来创建字符串对象</td></tr></tbody></table></li></ul><p><strong>面试常考</strong>：</p><p>两种方式有什么区别</p><ul><li>以“”方式给出的字符串对象，在字符串常量池中存储，而且<strong>相同内容只会在其中存储一份</strong>。</li><li>通过构造器new对象，<strong>每new一次都会产生一个新对象</strong>，放在堆内存中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/18.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/java/javese/19.png" alt=""></p><h4 id="（5）String常见面试题">（5）String常见面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 创建了两个对象，&quot;abc&quot;已经创建了一个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 指向前一行中常量池&quot;abc&quot;</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">// Java存在编译优化机制，程序在编译时： “a” + “b” + “c” 会直接转成 &quot;abc&quot;</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Arraylist">2、Arraylist</h3><blockquote><p><strong>集合的特点</strong></p><ul><li>集合的<strong>大小不固定</strong>，启动后可以动态变化，<strong>类型也可以选择不固定</strong></li><li>集合非常适合做元素个数不确定，且要进行增删操作的业务场景</li><li>集合还提供了许多丰富、好用的功能，而数组的功能很单一</li><li><strong>集合中存储的元素并不是对象本身，而是对象的地址</strong></li></ul></blockquote><p>ArrayList是集合中的一种，它支持索引</p><h4 id="（1）对象创建">（1）对象创建</h4><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ArrayList()</strong></td><td>创建一个空的集合对象</td></tr></tbody></table><h4 id="（2）增加元素">（2）增加元素</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean <strong>add(E e)</strong></td><td>将指定的元素追加到此集合的末尾</td></tr><tr><td>public void <strong>add(int index,E element)</strong></td><td>在此集合中的指定位置插入指定的元素</td></tr></tbody></table><h4 id="（3）泛型">（3）泛型</h4><blockquote><p>ArrayList<E>：其实就是一个泛型类，可以在编译阶段约束集合对象只能操作某种数据类型。</p></blockquote><p>例如：<code>ArrayList&lt;String&gt;</code> ：此集合只能操作字符串类型的元素。</p><p><strong>注意：泛型只能支持引用数据类型，不支持基本数据类型。</strong></p><h4 id="（4）ArrayList集合常用方法">（4）<strong>ArrayList</strong>集合常用方法</h4><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public E <strong>get(int  index)</strong></td><td>返回指定索引处的元素</td></tr><tr><td>public int  <strong>size()</strong></td><td>返回集合中的元素的个数</td></tr><tr><td>public E <strong>remove(int  index)</strong></td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>public boolean <strong>remove(Object o)</strong></td><td>删除指定的元素，返回删除是否成功</td></tr><tr><td>public E <strong>set(int index,E element)</strong></td><td>修改指定索引处的元素，返回被修改的元素</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023使用picgo + github搭建图床（typora）,解决jsdelivr问题</title>
      <link href="/2023/01/05/2022GitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/01/05/2022GitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图床是什么">一、图床是什么</h2><blockquote><p><strong>图床一般是指储存图片的服务器</strong></p><p>有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p></blockquote><ul><li><p><strong>说人话</strong>： 就是把你博客，或者笔记中的图片存到云端上去，这样文本里面只留存图片链接</p></li><li><p><strong>举个例子</strong>：写<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin">markdown</a>笔记时，图片存储在本地，用相对路径或者绝对路径加载图片，如果要同步笔记或者迁移笔记的话，</p><p>那么是不是要把图片也进行迁移，很麻烦。<br>有人会说可以直接复制整个目录结构，也麻烦不了太多。但是这样是不是将来在两个设备写markdown时，就需要总是同步图片，特别是如果本地写好博客，去发布时，图片链接又该如何让去解决，一张一张处理，效率显然太慢了。</p></li><li><p><strong>图床有什么效果</strong>：例子中那些问题，图床就可以很好的解决</p><ul><li>同步笔记时，利用iCloud，或者其他云盘，就可以直接同步markdown纯文本文件，不需要再考虑图片问题，笔记的体积还小，只需要存储markdown文本文件，去处理图片的体积。</li><li>博客也只需要，将markdown全选 + 复制 + 粘贴 + 发布就好了</li></ul></li></ul><h2 id="二、怎么搭建">二、怎么搭建</h2><p>方法有很多，但是说到底还是选择用什么样的云存储，可以是自己用服务器写API来搭建，也可以使用大厂商提供的对象存储，还有就是本文的白嫖，白嫖<strong>GitHub</strong>。</p><p>而<strong>picgo</strong>只是一个图床管理工具，帮助我们上传图片到图床。同样的应用还有upic，以及其他，都是同样的功能，但图床的方便一定少不了图床管理工具。picgo则是可以配合<a href="http://www.cankaowang.com/question/245966.html">typora</a>使用。</p><h3 id="1、配置GitHub">1、配置GitHub</h3><ul><li><p><strong>（1）创建仓库</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-02-25.png" alt=""></p></li><li><p><strong>（2）生成token私钥</strong></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-11-35.png" alt=""></p><hr><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-13-36.png" alt=""></p><hr><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-18-48.png" alt=""></p><hr><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-23-50.png" style="zoom:80%;" /> <hr><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-19-16.png" alt=""></p><p><strong>ps: 得到的私钥要保存下来，后面github上无法查看</strong></p></li></ul><h3 id="2、配置picgo">2、配置picgo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">picgo下载</a></p><p>还需要配置node.js环境才可以使用。<a href="https://blog.csdn.net/weixin_44893902/article/details/121788104?ops_request_misc=%7B%22request%5Fid%22%3A%22167245108816782425141530%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167245108816782425141530&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121788104-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v1&amp;utm_term=nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&amp;spm=1018.2226.3001.4187">node.js安装及环境配置</a></p><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-33-00.png" alt=""></p><table><thead><tr><th>名称</th><th>填写</th></tr></thead><tbody><tr><td>设定仓库名</td><td>用户名/仓库名</td></tr><tr><td>设定分支名</td><td>分支名，用户main就可以</td></tr><tr><td>设定Token</td><td>这个就是GitHub配置的token私钥</td></tr><tr><td>设定存储路径</td><td>相对于仓库来说，自定义填写</td></tr><tr><td><strong>设定自定义域名</strong></td><td><strong>重要！！！解决jsdelivr CDN加速问题</strong> <strong>如下填写.</strong></td></tr></tbody></table><h4 id="解决jsdelivr-CDN加速问题">解决jsdelivr CDN加速问题</h4><p><strong>这个现在失效了</strong>：<code>https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main</code></p><p><strong>改成：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/gh/[github用户名]/[仓库名]@main</span><br></pre></td></tr></table></figure><p>@后面跟的是填写的分支名，一定要一致</p><h3 id="3、配置typora">3、配置typora</h3><ul><li>打开：<strong>文件 -&gt; 偏好设置 -&gt; 图像</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-49-53.png" alt=""></p><ul><li><strong>使用：</strong></li></ul><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-57-31.png" style="zoom: 67%;" /> <ul><li><strong>效果：</strong></li></ul><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2022-12-31_22-59-42.png" style="zoom:67%;" /> ]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法学习记录</title>
      <link href="/2023/01/05/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/05/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、常用快捷键">1、常用快捷键</h2><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td style="text-align:left">设置标题， 1-6级别</td><td style="text-align:left">Ctrl + 1-6</td></tr><tr><td style="text-align:left">清空标题</td><td style="text-align:left">Ctrl + 0</td></tr><tr><td style="text-align:left">加粗</td><td style="text-align:left">Ctrl + B</td></tr><tr><td style="text-align:left">斜体</td><td style="text-align:left">Ctrl + I</td></tr><tr><td style="text-align:left">下划线</td><td style="text-align:left">Ctrl + U</td></tr><tr><td style="text-align:left">删除线</td><td style="text-align:left">Alt + shift + 5</td></tr><tr><td style="text-align:left">插入代码</td><td style="text-align:left">Ctrl + Shift  + K</td></tr><tr><td style="text-align:left">插入图片</td><td style="text-align:left">Ctrl + Shift + I</td></tr><tr><td style="text-align:left">插入表格</td><td style="text-align:left">Ctrl + T</td></tr><tr><td style="text-align:left">表格: 向下方插入行</td><td style="text-align:left">Ctrl + Enter</td></tr><tr><td style="text-align:left">源码模式/退出源码模式</td><td style="text-align:left">Ctrl + /</td></tr></tbody></table><h2 id="2、基本语法">2、基本语法</h2><h3 id="2-1-字体设置">2.1 字体设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常文字</span><br><span class="line">*倾斜*</span><br><span class="line">_倾斜_</span><br><span class="line">**加粗**</span><br><span class="line">***倾斜加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>正常文字<br><em>倾斜</em><br><em>倾斜</em><br><strong>加粗</strong><br><em><strong>倾斜加粗</strong></em><br><s>删除线</s></p><p><strong>注意：有时候markdown加粗不生效</strong></p><p>例如：<code>**账号：**</code></p><p><strong>原因：</strong></p><p>首先这是正常现象，不是bug。markdown的语法就是这样的。</p><p>加粗的方式是前后一对**标记实现的，前面的叫左定界符，后面的叫右定界符。</p><p><strong>左定界符生效条件：</strong></p><ol><li>后面不能是空白；</li><li>当前面没有空白或标点符号时，后面不能是标点符号。</li></ol><p><strong>右定界符生效条件：</strong></p><ol><li>前面不能是空白；</li><li><strong>当后面没有空白或标点符号时，前面不能是标点符号。</strong></li></ol><p><strong>解决方案：</strong></p><p>一般出现加粗不生效的情况，都是由于 <strong>加粗的内容里最后一位是标点符号</strong> 的原因。只需要在<strong>右定界符后面加一个空格</strong>即可。如<code>|**您好：** |</code>欢迎。</p><h3 id="2-2-分级标题">2.2  分级标题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一共六级</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure> <img src="https://cdn.staticaly.com/gh/ggw2021/images@main/markdown/markdown-note/05.png" style="zoom: 67%;" /> <h3 id="2-3-链接">2.3 链接</h3><p><strong>（1）插入图片</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片路径 <span class="string">&quot;title&quot;</span>)</span><br><span class="line">![图片描述](图片路径)</span><br><span class="line"><span class="attr">ps</span>: 图片描述可不写</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/markdown/markdown-note/01.jpg" alt="举例" style="zoom:25%;" /> <p><strong>（2）自动链接</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Markdown</span> 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， <span class="title class_">Markdown</span> 就会自动把它转成链接。也可以直接写，也是可以显示成链接形式的</span><br></pre></td></tr></table></figure><p><a href="mailto:1653139161@qq.com">1653139161@qq.com</a></p><p><a href="https://badu.com">https://badu.com</a></p><p><strong>（3）文字链接</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行内式链接形式：[超链接文字](url)</span><br><span class="line"></span><br><span class="line">例如：[百度](https://www.baidu.com/)</span><br><span class="line">效果如下：</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度</a></p><p>还可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[超链接文字](#大纲中位置的文字)</span><br><span class="line">既可以前往六个等级标题的地方</span><br><span class="line"></span><br><span class="line">例如：前往快捷键</span><br><span class="line">[点我](#1、快捷键)</span><br></pre></td></tr></table></figure><p><a href="#1%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE">点我</a></p><p>ps: 文字要完全一样，且#后面没有空格</p><p><strong>（4）引用链接</strong></p><blockquote><p>可以先给一个链接取名，然后，如果我们要多次添加这个链接，我们就可以直接使用这个链接的名字，而不用多次使用文字链接的方法。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">取名: [关键词][链接的名称]</span><br><span class="line">使用: [链接的名称]: 链接地址</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[baidu]: https://www.baidu.com/</span><br><span class="line">[百度][baidu]</span><br><span class="line">效果如下：</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度</a></p><h3 id="2-4-分割线">2.4 分割线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线;</span><br><span class="line">行内不能有其他东西。你也可以在星号或是减号中间插入空格。</span><br><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line">效果是一样的</span><br></pre></td></tr></table></figure><hr><hr><hr><h3 id="2-5-代码块">2.5 代码块</h3><p>（1）行内式：如果在一个行内需要引用代码，只要用反引号`引起来就好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个<span class="string">`示例效果`</span></span><br></pre></td></tr></table></figure><p>这是一个<code>示例效果</code></p><p>（2）多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹，就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">console.log(&quot;hello world&quot;)</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>（3）代码块里面包含html代码<br>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。</p><p><strong>注意：简书代码块里不支持html。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>html<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果相当于五级标题</p><h3 id="2-6-公式块">2.6 公式块</h3><p>与LaTex类似</p><p>（1）行内公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$公式内容$</span><br></pre></td></tr></table></figure><p>例如：<code>E = mc^2</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p>（2）多行公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">公式内容</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">$$</span><br><span class="line">E = mc^2</span><br><span class="line">$$</span><br><span class="line">效果如下</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>具体使用看我的另一篇博客 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> [快速链接](<a href="https://gxblogs.netlify.app/2023/01/07/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">MarkDown数学公式基本语法 | ggw和xpl的博客 (gxblogs.netlify.app)</a>)</p><h3 id="2-7-引用">2.7 引用</h3><p>在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。</p><p>（1）基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用</span><br></pre></td></tr></table></figure><blockquote><p>这是引用</p></blockquote><p>（2）引用的嵌套使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用的嵌套</span><br><span class="line">&gt;&gt;引用的嵌套</span><br><span class="line"></span><br><span class="line">&gt;&gt;引用的嵌套</span><br><span class="line">&gt;引用的嵌套</span><br></pre></td></tr></table></figure><blockquote><p>引用的嵌套</p><blockquote><p>引用的嵌套</p></blockquote></blockquote><blockquote><blockquote><p>引用的嵌套<br>引用的嵌套</p></blockquote></blockquote><p>（3）引用其它要素<br>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</p><h3 id="2-8-列表">2.8 列表</h3><p>（1）无序列表<br>使用 *，+，- 表示无序列表。<br>注意：符号后面一定要有一个<strong>空格</strong>，起到缩进的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 列表文字</span><br><span class="line">- 列表文字</span><br><span class="line">- 列表文字</span><br><span class="line"></span><br><span class="line">* 列表文字</span><br><span class="line">* 列表文字</span><br><span class="line">* 列表文字</span><br><span class="line"></span><br><span class="line">+ 列表文字</span><br><span class="line">+ 列表文字</span><br><span class="line">+ 列表文字</span><br></pre></td></tr></table></figure><ul><li>列表文字</li><li>列表文字</li><li>列表文字</li></ul><ul><li>列表文字</li><li>列表文字</li><li>列表文字</li></ul><ul><li>列表文字</li><li>列表文字</li><li>列表文字</li></ul><p>（2）有序列表<br>使用数字和一个英文句点表示有序列表。<br>注意：英文句点后面一定要有一个<strong>空格</strong>，起到缩进的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 列表文字</span><br><span class="line"><span class="number">2.</span> 列表文字</span><br><span class="line"><span class="number">3.</span> 列表文字</span><br></pre></td></tr></table></figure><ol><li>列表文字</li><li>列表文字</li><li>列表文字</li></ol><p>（3）列表和其它要素混合使用<br>列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。</p><p>（4）注意事项<br>在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2002.</span> <span class="number">05</span>. <span class="number">01</span></span><br><span class="line"></span><br><span class="line"><span class="number">2002</span>\. <span class="number">05</span>\. <span class="number">01</span></span><br></pre></td></tr></table></figure><ol start="2002"><li><ol start="5"><li>01</li></ol></li></ol><p>2002. 05. 01</p><h3 id="2-9-表格">2.9 表格</h3><p>表格的基本写法很简单，就跟表格的形状很相似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|学号|姓名|分数|</span><br><span class="line">|-|-|-|</span><br><span class="line">|小明|男|<span class="number">88</span>|</span><br></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>88</td></tr></tbody></table><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|学号|姓名|分数|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|小明|男|<span class="number">88</span>|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">学号</th><th style="text-align:center">姓名</th><th style="text-align:right">分数</th></tr></thead><tbody><tr><td style="text-align:left">小明</td><td style="text-align:center">男</td><td style="text-align:right">88</td></tr></tbody></table><h2 id="3、-常用技巧">3、 常用技巧</h2><h3 id="3-1-换行">3.1 换行</h3><p>方法1: 连续两个以上空格+回车<br>方法2：使用html语言换行标签：<code>&lt;br&gt;</code></p><h3 id="3-2-缩进字符">3.2 缩进字符</h3><p>不断行的空白格  或  半角的空格   或  全角的空格   或</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/markdown/markdown-note/02.png" style="zoom:80%;" />  <h3 id="3-3-特殊符号">3.3 特殊符号</h3><p>（1）对于 Markdown 中的语法符号，前面<strong>加反斜线\即可显示符号本身</strong>。</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/markdown/markdown-note/03.png" style="zoom:80%;" />  <p>（2）其他特殊字符，示例如下：</p><img src="https://cdn.staticaly.com/gh/ggw2021/images@main/markdown/markdown-note/04.png"  /> <p>字符对应的Unicode码：<a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a></p><h3 id="3-4-链接的高级操作">3.4 链接的高级操作</h3><h4 id="（1）参考式链接">（1）参考式链接</h4><p>在文档要插入图片的地方写<code>![图片或网址链接][标记]</code>，在文档的最后写上[标记]:图片地址 “标题”。（最后这个”标题”可以不填写）</p><h4 id="（2）内容目录">（2）内容目录</h4><ul><li><p>在段落中填写<code> [TOC]</code> 以显示全文内容的目录结构。</p></li><li><p>github得使用锚点链接来实现，一般使用工具来生成，例如：VS code的插件。 具体可以用到再查。</p></li><li><p>不同博客平台，各不相同，例如：csdn采用<code>@[toc](文字)</code>，具体得看情况。</p></li></ul><h4 id="（3）锚点">（3）锚点</h4><p>锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。</p><p><strong>注意</strong>：在简书中使用锚点时，点击会打开一个新的当前页面，虽然锚点用的不是很舒服，但是可以用注脚实现这个功能。</p><p><strong>语法说明：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法在文字链接处有使用到，在本文上面</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
