<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王道操作系统 | ggw和xpl的博客</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:type" content="article">
<meta property="og:title" content="王道操作系统">
<meta property="og:url" content="https://gxblogs.netlify.app/posts/54954ebc.html">
<meta property="og:site_name" content="ggw和xpl的博客">
<meta property="og:description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg">
<meta property="article:published_time" content="2023-05-03T11:13:08.565Z">
<meta property="article:modified_time" content="2024-01-16T16:23:30.252Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.netlify.app/posts/54954ebc"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: ggw和xpl的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-17 00:23:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/gh/graingert/WOW@master/dist/wow.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/C5EAC1F2A55D115DB1654F59F20A9934.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggw和xpl的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-03T11:13:08.565Z" title="发表于 2023-05-03 19:13:08">2023-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-16T16:23:30.252Z" title="更新于 2024-01-17 00:23:30">2024-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">100k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>306分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/54954ebc.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/54954ebc.html" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?t=3.0&amp;p=2">【王道考研操作系统】</a></p>
<p>微博大号–@王道咸鱼老师-计算机考研<br>
微博小号–@王道楼楼老师-计算机考研</p>
<h1>第一章 计算机系统概述</h1>
<h2 id="1-1-1-操作系统的概念、功能">1.1.1 操作系统的概念、功能</h2>
<ul>
<li><strong><u>大家都熟悉的操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_18-59-48.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的概念（定义）</strong></u></li>
</ul>
<p>一台电脑的诞生~<br>
Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机）<br>
Step 2：出售前安装操作系统<br>
Step 3：用户安装应用程序（eg：QQ）<br>
Step 4：使用 QQ 聊天</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-16-00.jpg" alt=""></p>
<br>
<p><strong>操作系统</strong>（Operating System， OS）</p>
<ul>
<li>是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>（<u>①操作系统是系统资源的管理者</u>）资源，并合理地组织调度计算机的工作和资源的分配；</li>
<li>以<strong>提供给用户和其他软件方便的接口和环境</strong>（<u>②向上层提供方便易用的服务</u>）；</li>
<li>它是计算机系统中最基本的<strong>系统软件</strong>（<u>③是最接近硬件的一层软件</u>）。</li>
</ul>
<p>直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-25-08.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为系统资源的管理者</strong></u>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>补充知识：执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p>
<p>用QQ和朋友视频聊天的过程：<br>
Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）【逐层打开文件夹，找到QQ.exe 这个程序（可执行文件）的存放位置】<br>
Step 2：双击打开 QQ.exe 【需要把该程序相关数据放入内存】<br>
Step 3：QQ 程序正常运行 【对应的进程被处理机（CPU）处理】<br>
Step 4：开始和朋友视频聊天 【需要将摄像头设备分配给进程】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——向上层提供方便易用的服务</strong></u></li>
</ul>
<p><strong>封装思想</strong>：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-35-16.jpg" alt=""></p>
<p><strong>GUI</strong>：图形化用户接口（Graphical User Interface） 【很多现代操作系统都提供GUI】<br>
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>
例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
<p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口<br>
Step 1：win键+R<br>
Step 2：输入cmd，按回车，打开命令解释器<br>
Step 3：尝试使用 time 命令<br>
【特点：用户说一句， 系统跟着做一句】</p>
<p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口<br>
使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。<br>
【特点：用户说一堆， 系统跟着做一堆】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-40-45.jpg" alt=""></p>
<p>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，<strong>只能</strong>通过程序代码<strong>间接</strong>使用。<br>
如：写C语言“Hello world”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-45-43.jpg" alt=""><br>
系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式。<strong>在有的教材中： 系统调用=广义指令</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-50-22.jpg" alt=""><br>
【有的教材中把命令接口和程序接口统称为“用户接口”，意思就是说狭义的用户接口不包括GUI。】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为最接近硬件的层次</strong></u></li>
</ul>
<p>需要实现<strong>对硬件机器的拓展</strong>；<br>
没有任何软件支持的计算机成为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器；<br>
通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>
<p>类比汽车： 发动机——只会转；轮胎——只会滚；<br>
在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展</p>
<p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</p>
<hr>
<h2 id="1-1-2-操作系统的特征">1.1.2 操作系统的特征</h2>
<blockquote>
<ul>
<li>并发</li>
<li>共享</li>
</ul>
<p>并发和共享是两个最基本的特征，二者互为存在条件。</p>
<ul>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>重要考点：<br>
理解并发和并行的区别<br>
并发和共享互为存在条件<br>
没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</p>
</blockquote>
<ul>
<li><u><strong>操作系统的特征——并发</strong></u></li>
</ul>
<p><strong>并发</strong>：指两个或多个事件在<u><strong>同一时间间隔</strong></u>内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。<br>
常考易混概念——<strong>并行</strong>：指两个或多个事件在<u><strong>同一时刻同时</strong></u>发生。</p>
<p>并发 VS 并行：<br>
eg：假设小渣和老渣每人有两个女朋友。任务1：和一号约会；任务2：和二号约会…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_20-10-44.jpg" alt=""></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。<br>
操作系统就是伴随着“多道程序技术”（后面介绍）而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p>
<p>注意（<strong>重要考点</strong>）：<br>
<strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行<br>
<strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行<br>
比如Intel 的第八代 i3 处理器就是 <strong>4 核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>；【即使是对于4核CPU来说，只要有4个以 上的程序需要“同时”运行，那么并发性依然是必不可少的，因此<strong>并发性是操作系统一个最基本的特性</strong>】</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——共享</strong></u></li>
</ul>
<p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：<br>
互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br>
同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——并发和共享的关系</strong></u></li>
</ul>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。<br>
<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>通过上述例子来看并发与共享的关系：<br>
使用QQ发送文件A，同时使用微信发送文件B。<br>
1.两个进程正在并发执行（并发性） 【如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义】<br>
2.需要共享地访问硬盘资源（共享性）【如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发】</p>
<p><strong>二者互为存在条件。</strong></p>
<hr>
<ul>
<li><strong><u>操作系统的特征——虚拟</u></strong></li>
</ul>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>Yo~用一个例子来理解<br>
背景知识：一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p>
<p>GTA5需要4GB的运行内存，<br>
QQ 需要256MB的内存，<br>
迅雷需要256MB的内存，<br>
网易云音乐需要256MB的内存……<br>
我的电脑：4GB内存<br>
问题：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？<br>
答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>空分复用技术</strong>” 。</p>
<p>某单核CPU的计算机中，用户打开了以下软件。。。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-18-58.jpg" alt=""></p>
<p>问题：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>时分复用技术</strong>” 。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p>
<ul>
<li><strong>虚拟技术</strong>
<ul>
<li><strong>空分复用技术</strong>（如虚拟存储技术）</li>
<li><strong>时分复用技术</strong>（如虚拟处理器）</li>
</ul>
</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——异步</strong></u></li>
</ul>
<p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p>
<p>与一、二号的约会 = 两道并发执行的程序 老渣的心 = 有限的系统资源</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p>
<hr>
<h2 id="1-2-操作系统的发展与分类">1.2 操作系统的发展与分类</h2>
<ul>
<li><strong><u>手工操作阶段</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-40-24.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>批处理阶段——单道批处理系统</u></strong></li>
</ul>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-43-53.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-48-41.jpg" alt=""></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br>
主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
<p><strong>主要特征</strong>：自动性、顺序性、单道性</p>
<hr>
<ul>
<li><strong><u>批处理阶段——多道批处理系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-04.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-54.jpg" alt=""></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统<strong>吞吐量增大</strong>。<br>
主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）</p>
<p><strong>主要特征</strong>：多道、宏观并行、微观串行</p>
<p>多道程序的基本特征：共享性、间断性、制约性</p>
<hr>
<ul>
<li><strong><u>分时操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-14-13.jpg" alt=""></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。<br>
主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br>
主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
<p><strong>主要特征</strong>：同时性、交互性、独立性、及时性</p>
<hr>
<ul>
<li><strong><u>实时操作系统</u></strong>
<ul>
<li>硬实时系统<br>
必须在绝对严格的规定时间内完成处理<br>
如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统<br>
能接受偶尔违反时间规定<br>
如：12306火车订票系统</li>
</ul>
</li>
</ul>
<p>实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<hr>
<ul>
<li><strong><u>其他几种操作系统</u></strong></li>
</ul>
<p><strong>网络操作系统</strong>：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
<p><strong>分布式操作系统</strong>：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
<p>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</p>
<hr>
<h2 id="1-3-1-操作系统的运行机制">1.3.1 操作系统的运行机制</h2>
<blockquote>
<p>Tips：</p>
<ol>
<li>都是高频考点，很重要</li>
<li>初学者不完全理解没关系， 放心大胆地往后学，随着后面章节的学习，理解会逐渐加深</li>
</ol>
</blockquote>
<ul>
<li><strong><u>预备知识：程序是如何运行的？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-19-00.jpg" alt=""></p>
<p>程序运行的过程其实就 是CPU执行一条一条的机器指令的过程</p>
<p>“指令”就是处理器（CPU）能识别、执行的最基本命令</p>
<p>注：很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也 称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别 开。本节中的“指令”指二进制机器指令</p>
<hr>
<ul>
<li><strong><u>内核程序 v.s. 应用程序</u></strong></li>
</ul>
<p>我们普通程序员写的程序就是“<strong>应用程序</strong>”</p>
<p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”<br>
由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong> ” 内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核） 操作系统的功能未必都在内核中，如图形化用户界面 GUI</p>
<hr>
<ul>
<li><strong><u>特权指令 v.s. 非特权指令</u></strong></li>
</ul>
<p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU 执行一条指令前就能判断出其类型</p>
<p>应用程序只能使用“非特权指令”，如： 加法指令、减法指令等，不允许用户直接使用</p>
<p>操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即<strong>操作系统内核</strong>来使用</p>
<hr>
<ul>
<li><strong><u>内核态 v.s. 用户态</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-25-21.jpg" alt=""></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 问题：如何实现CPU状态的切换？</p>
<p>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<br>
处于<strong>内核态时</strong>，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong><br>
处于<strong>用户态时</strong>，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p>
<p>拓展：CPU 中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong> ，其中有个二进制位，1表示 “内核态”，0表示“用户态”</p>
<p><strong>别名</strong>：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></p>
<hr>
<ul>
<li><strong><u>内核态、用户态 的切换</u></strong></li>
</ul>
<table>
    <tr>
        <td>
            一个故事：</br>
    ① 刚开机时，CPU 为“<b>内核态</b>”，操作系统内核程序先上CPU运行</br>
② 开机完成后，用户可以启动某个应用程序</br> 
③ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行</br>
【操作系统内核在让出CPU之前，会<b>用一条特权指令把 PSW 的标志位设置为“用户态”</b>】</br>
④ 应用程序运行在“用户态”</br> 
⑤ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…</br> 
⑥ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”</br> 
⑦ 这个非法事件会引发一个<b>中断信号</b></br>
【<b>CPU检测到中断信号后</b>，会立即<b>变为“核心态”</b>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序】</br> 
⑧ “中断”使操作系统再次夺回CPU的控制权</br> ⑨ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</br>
        </td>
    </tr>    
</table>
<u>内核态</u> → <u>用户态</u>：<u>执行一条特权指令</u>——修改<u>PSW</u>的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权
<u>用户态</u> → <u>内核态</u>：由“<u>中断</u>”引发，<u>硬件自动完成变态过程</u>，触发中断信号意味着操作系统将强行夺回CPU的使用权
【除了非法使用特权指令之外，还有很多事件 会触发中断信号。一个共性是，<u>但凡需要操作系统介入的地方，都会触发中断信号</u>】
<hr>
<ul>
<li><strong><u>补充</u></strong></li>
</ul>
<p>时钟管理的功能：1、计时；2、通过时钟中断的管理，可以实现进程切换</p>
<hr>
<h2 id="1-3-2-中断和异常">1.3.2 中断和异常</h2>
<ul>
<li><strong><u>中断的作用</u></strong><br>
“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
</ul>
<p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>（是整个系统的管理者），一种是<strong>应用程序</strong></p>
<p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）</p>
<p>“中断”是<strong>让操作系统内核夺回CPU使用权</strong>的<strong>唯一</strong>途径</p>
<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序<br>
没有中断机制，就不可能实现操作系统，不可能实现程序并发</p>
<hr>
<ul>
<li><strong><u>中断的类型</u></strong>
<ul>
<li><strong>内中断</strong><br>
与当前执行的指令有关， 中断信号来源于CPU内部</li>
<li><strong>外中断</strong><br>
与当前执行的指令无关， 中断信号来源于CPU外部</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><u><strong>内中断的例子</strong></u></li>
</ul>
<p>例子 1：试图在用户态下执行特权指令<br>
例子 2：执行除法指令时发现除数为 0<br>
【若当前执行的指令是非法的，则会引发一个中断信号】</p>
<p>例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<br>
【执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “<strong>系统调用”就是通过陷入指令完成的</strong>】</p>
<hr>
<ul>
<li><strong><u>外中断的例子</u></strong></li>
</ul>
<p>例子1：时钟中断——由时钟部件发来的中断信号</p>
<p>例子2：I/O中断——由输入/输出设备发来的中断信号</p>
<hr>
<ul>
<li><strong><u>中断的分类</u></strong>【广义的中断】
<ul>
<li>内中断（也称<strong>异常</strong>、例外）
<ul>
<li>陷阱、陷入（trap）【由陷入指令引发，是应用程序故意引发的】</li>
<li>故障（fault）【由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行下去。如：<strong>缺页中断</strong>。】</li>
<li>终止（abort）【由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序， 而是直接终止该应用程序。如： 整数除0、非法使用特权指令】</li>
</ul>
</li>
<li>外中断（也称中断）【狭义的中断】
<ul>
<li>时钟中断</li>
<li>I/O中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常“</p>
<hr>
<ul>
<li><u><strong>中断机制的基本原理</strong></u></li>
</ul>
<p>检测中断信号：</p>
<ul>
<li>内中断：CPU在<strong>执行指令时</strong>会检查是否有异常发生</li>
<li>外中断：<strong>每个指令周期末尾</strong>，CPU都会检查是否有外中断信号需要处理</li>
</ul>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-07-58.jpg" alt=""></p>
<p>显然，中断处理程序<strong>一定</strong>是内核程序，需要运行在“<strong>内核态</strong>”</p>
<hr>
<h2 id="1-3-3-系统调用">1.3.3 系统调用</h2>
<ul>
<li><strong><u>什么是系统调用，有何作用？</u></strong></li>
</ul>
<p>知识点回顾：<br>
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
<hr>
<ul>
<li><strong><u>系统调用与库函数的区别</u></strong></li>
</ul>
<table>
    <tr>
        <td>普通应用程序</td>
        <td>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
    </tr>
    <tr>
        <td>编程语言</td>
        <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>
    </tr>
    <tr>
        <td>操作系统</td>
        <td>向上提供系统调用，使得上层程序能请求内核的服务</td>
    </tr>
    <tr>
        <td>裸机</td>
        <td>—</td>
    </tr>
</table>
<p>不涉及系统调用的库函数：如的“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-21-42.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>小例子：为什么系统调用是必须的？</u></strong></li>
</ul>
<p>生活场景：去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开始工作。<br>
你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p>
<hr>
<ul>
<li><strong><u>什么功能要用到系统调用？</u></strong></li>
</ul>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<ul>
<li><strong>系统调用（按功能分类）</strong>
<ul>
<li><strong>设备管理</strong>：完成设备的 <strong>请求/释放/启动</strong> 等功能</li>
<li><strong>文件管理</strong>：完成文件的 <strong>读/写/创建/删除</strong> 等功能</li>
<li><strong>进程管理</strong>：完成进程的 <strong>创建/撤销/阻塞/唤醒</strong> 等功能</li>
<li><strong>进程通信</strong>：完成进程之间的 <strong>消息传递/信号传递</strong> 等功能</li>
<li><strong>内存管理</strong>：完成内存的 <strong>分配/回收</strong> 等功能</li>
</ul>
</li>
</ul>
<p>拓展：感兴趣的同学可以搜索“Linux 系统调用”，了解 Linux 操作系统提供了哪些系统调用</p>
<hr>
<ul>
<li><strong><u>系统调用的过程</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-36-59.png" alt=""></p>
<p>传递系统调用参数 → 执行<strong>陷入</strong>指令（<strong>用户态</strong>，陷入指令是非特权指令） →  执行相应的内请求核程序处理系统调用（<strong>核心态</strong>） → 返回应用程序</p>
<p>注意：<br>
1.<strong>陷入指令是在用户态执行</strong>的，执行陷入指令之后立即引发一个<strong>内中断</strong>，使CPU进入核心态<br>
2.发出系统调用<strong>请求是在用户态</strong>，而对系统调用的相应处理在核心态下进行</p>
<p>注意别名： 陷入指令 = trap 指令 = 访管指令</p>
<hr>
<h2 id="1-4-1-操作系统的体系结构（上）">1.4.1 操作系统的体系结构（上）</h2>
<ul>
<li><strong><u>操作系统的内核</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-43-27.png" alt=""></p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分。<br>
实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。<br>
<strong>原语</strong>是一种特殊的程序，具有原子性，也就是说这段程序的运行必须一气呵成，不可被“中断”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-45-33.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-46-56.png" alt=""></p>
<p>注意：<br>
操作系统<strong>内核</strong>需要运行在<strong>内核态</strong><br>
操作系统的<strong>非内核</strong>功能运行在<strong>用户态</strong></p>
<p>一个故事：现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-58-30.png" alt=""></p>
<p>注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能<br>
【注意：“变态”在这里是口头表述，考试应该正规表述，例如“状态改变”】</p>
<hr>
<ul>
<li><strong><u>操作系统的体系结构</u></strong>
<ul>
<li>大内核
<ul>
<li>将操作系统的主要功能模块作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核
<ul>
<li>只把最基本功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>典型的大内核/宏内核/单内核 操作系统： Linux、UNIX<br>
典型的 微内核 操作系统： Windows NT</p>
<p>类比：<br>
操作系统的体系结构问题与企业的管理问题很相似。<br>
<strong>内核</strong>就是企业的<strong>管理层</strong>，负责一些重要的工作。只有管理层才能执行<strong>特权指令</strong>，普通员工只能执行<strong>非特权指令</strong>。<strong>用户态</strong>、<strong>核心态</strong>之间的切换相当于普通员工和管理层之间的工作交接<br>
<strong>大内核</strong>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。<br>
<strong>微内核</strong>：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p>
<hr>
<h2 id="1-4-2-操作系统的体系结构（下）">1.4.2 操作系统的体系结构（下）</h2>
<blockquote>
<ul>
<li>大内核（又名：宏内核/单内核）</li>
<li>微内核</li>
<li>分层结构（新增）</li>
<li>模块化（新增）</li>
<li>外核（新增）</li>
</ul>
<p>Tips: 一定是<strong>考简单的选择题</strong>，了解各种体系结构的<strong>特性</strong>，了解各自的<strong>优缺点</strong></p>
</blockquote>
<ul>
<li><strong><u>操作系统结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_15-55-43.png" alt=""></p>
<p>【注：加星号是作者认为更容易考的，红色星号是全新的内容，黄色星号的是老内容（大内核、微内核）】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——分层结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-00-31.png" alt=""></p>
<p>最底层是硬件，最高层是用户接口<br>
每层可调用更低一层【不能跨层调用】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——模块化</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-04-57.png" alt=""></p>
<p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，上图所示为由模块、子模块等组成的模块化操作系统结构。</p>
<hr>
<ul>
<li><strong><u>操作系统结构——外核（exokernel）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-11-27.png" alt=""></p>
<hr>
<h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2>
<blockquote>
<p>操作系统引导(boot)–开机的时候怎么让操作系统运行起来?</p>
</blockquote>
<ul>
<li><strong><u>一个刚买来的磁盘（硬盘）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-25-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>安装操作系统后，操作系统引导（开机过程）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-33-54.png" alt=""></p>
<p>【注释】<br>
根目录：顾名思义，双击C盘看到的那些东西<br>
分区表：实际上是一个数据结构，记录每个盘每个分区多大、地址范围这些信息<br>
BIOS：Basic Input/Output System<br>
ROM引导程序：ROM boot 程序<br>
MBR：告诉CPU去硬件的哪个主分区找操作系统<br>
PBR：寻找根目录下用于引导操作系统的程序（即启动管理器）</p>
<p><strong>操作系统引导</strong>:<br>
① CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序 (先进行硬件自检，再开机)<br>
② 将磁盘的第一块–主引导记录读入内存，执行磁盘引导程序，扫描分区表<br>
③ 从活动分区 (又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序<br>
④ 从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</p>
<hr>
<ul>
<li><strong><u>例: windows 操作系统的初始化程序</u></strong></li>
</ul>
<p>注：完整的操作系统初始化程序 (即 启动管理器) 可在根目录下找到<br>
Eg：windows操作系统完整的开机初始化程序在“根目录/Windows/Boot”下</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-38-37.png" alt=""></p>
<hr>
<h2 id="1-6-虚拟机">1.6 虚拟机</h2>
<ul>
<li><strong><u>传统计算机</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-42-34.png" alt=""></p>
<hr>
<ul>
<li><strong><u>虚拟机</u></strong></li>
</ul>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统</p>
<p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-53-47.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_17-02-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>两类虚拟机管理程序（VMM）的对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对物理资源的控制权</td>
<td>直接运行在硬件上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖Host OS为其分配物理资源</td>
</tr>
<tr>
<td style="text-align:left">资源分配方式</td>
<td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td>
<td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td>性能更好</td>
<td>性能更差，需要Host OS作为“中介”</td>
</tr>
<tr>
<td style="text-align:left">可支持虚拟机的数量</td>
<td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，Host OS本身也需要使用物力资源，Host OS上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td style="text-align:left">虚拟机的可迁移性</td>
<td>更差</td>
<td>更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛</td>
</tr>
<tr>
<td style="text-align:left">运行模式</td>
<td>第一类VMM运行在最高权限级（Ring 0），可以执行最高权限指令</td>
<td>第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用</td>
</tr>
</tbody>
</table>
<hr>
<h1>第二章 进程与线程</h1>
<h2 id="2-1-1-进程的概念、组成、特征">2.1.1 进程的概念、组成、特征</h2>
<ul>
<li><strong><u>进程的概念</u></strong></li>
</ul>
<p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的 可执行文件，就是一系列的指令集合。<br>
进程（Process）：是<strong>动态的</strong>，是程序的一 次执行过程 同一个程序多次执行会对应多个进程；<br>
动态性是进程<strong>最重要</strong>的特性。</p>
<hr>
<ul>
<li><strong><u>进程的组成——PCB</u></strong></li>
</ul>
<p>思考：操作系统是这些进程的管理者，它要怎么区分各个进程？<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <strong>PID</strong>（Process ID，进程ID）</p>
<ol>
<li>操作系统要记录PID、进程所属用户ID（UID）<br>
【基本的进程描述信息，可以让操作系统区分各个进程】</li>
<li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<br>
【可用于实现操作系统对资源的管理】</li>
<li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）<br>
【可用于实现操作系统对进程的控制、调度】</li>
<li>这些信息都被保存在一个数据结构<strong>PCB</strong> （Process Control Block）中，即<strong>进程控制块</strong><br>
操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong></li>
</ol>
<p>【总结】：</p>
<ul>
<li><strong>进程控制块（PCB）</strong> ：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
<ul>
<li><strong>进程描述信息</strong>
<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><strong>进程控制和管理信息</strong>
<ul>
<li>CPU、磁盘、网络流量使用情况统计…</li>
<li>进程当前状态：就绪态 / 阻塞态 / 运行态…</li>
</ul>
</li>
<li><strong>资源分配清单</strong>
<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I/O设备</li>
</ul>
</li>
<li><strong>处理机相关信息</strong>
<ul>
<li>如PSW，PC等等各种寄存器的值（用于实现进程切换）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统对进程进行管理工作所需的信息都存在PCB中</p>
<hr>
<ul>
<li><u><strong>进程的组成——程序段、数据段</strong></u>
<ul>
<li><strong>PCB</strong>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PCB</strong> 是<strong>给操作系统用的</strong>。<br>
<strong>程序段、数据段</strong>是<strong>给进程自己用的</strong>。</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>一条高级语言的代码翻译过来可能会对应多条机器指令<br>
程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-07-33.png" alt=""></p>
<p>一个<strong>进程实体（进程映像）</strong> 由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。 <strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong> 是<strong>静态</strong>的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）</p>
<hr>
<ul>
<li><u><strong>进程的组成</strong></u>【更确切的说，应该 是“进程实体(进程映像)的组成”】
<ul>
<li><strong>PCB</strong>【PCB 是给操作系统用的】
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【程序段、数据段是给进程自己用的， 与进程自身的运行逻辑有关】<br>
【同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）】</p>
<p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong> 引入进程实体的概念后，<br>
可把<strong>进程定义为</strong>： 进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。<br>
【一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行】</p>
<p>“进程实体” 是操作系统中用于管理和存储关于一个进程的信息的<strong>数据结构</strong>，而 “进程” 是一个正在执行的<strong>程序实例</strong>，包含了执行所需的各种资源。</p>
<p>注意：PCB是进程存在的<strong>唯一</strong>标志！</p>
<hr>
<ul>
<li><strong><u>进程的特征</u></strong></li>
</ul>
<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<ol>
<li><strong>动态性</strong>【动态性是进程最基本的特征】<br>
进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性</strong><br>
内存中有多个实体进程，各进程可并发执行</li>
<li><strong>独立性</strong><br>
进程是能独立运行、独立获得资源、独立接受调度的<strong>基本单位</strong></li>
<li><strong>异步性</strong><br>
各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li><strong>结构性</strong><br>
每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<hr>
<h2 id="2-1-2-进程的状态与转换、进程的组织">2.1.2 进程的状态与转换、进程的组织</h2>
<ul>
<li><u><strong>进程的状态——创建态、就绪态</strong></u></li>
</ul>
<p>进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<p>当进程创建完成后，便进入“<strong>就绪态</strong>”， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行</p>
<hr>
<ul>
<li><strong><u>进程的状态——运行态</u></strong></li>
</ul>
<p>系统中可能会有很多个进程都处于就绪态；</p>
<p>当CPU空闲时，操作系统就会选择一个就绪进程， 让它上处理机运行；</p>
<p>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。 CPU会执行该进程对应的程序（执行指令序列）</p>
<hr>
<ul>
<li><strong><u>进程的状态——阻塞态</u></strong></li>
</ul>
<p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p>
<p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</p>
<p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p>
<hr>
<ul>
<li><u><strong>进程的状态——终止态</strong></u></li>
</ul>
<p>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。</p>
<p>此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。</p>
<p>当终止进程的工作完成之后，这个进程就彻底消失了。</p>
<hr>
<ul>
<li><strong><u>进程状态的转换</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-37-42.png" alt=""></p>
<p><strong>注意：不能由阻塞态直接转换为运行态， 也不能由就绪态直接转换为阻塞态</strong>（因为 进入阻塞态是进程主动请求的，必然需要 进程在运行时才能发出这种请求）</p>
<hr>
<ul>
<li><strong><u>进程的状态</u></strong>
<ul>
<li><strong>三种基本状态</strong>【进程的整个生命周期 中，大部分时间都处 于三种基本状态】
<ul>
<li>运行态（Running）【单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态】<br>
占有CPU，并在CPU上运行</li>
<li>就绪态（Ready）<br>
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>
<li>阻塞态（Waiting / Blocked，又称：等待态）<br>
因等待某一事件而暂时不能运行</li>
</ul>
</li>
<li>另外两种状态
<ul>
<li>创建态（New，又称：新建态）<br>
进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（Terminated，又称：结束态）<br>
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程PCB中，会有一个变量 state 来表示进程的当前状态</strong>。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<hr>
<ul>
<li><strong><u>进程的组织——链接方式</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-03-39.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-04-35.png" alt=""></p>
<hr>
<ul>
<li><u><strong>进程的组织——索引方式</strong></u></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-05-33.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程的组织</u></strong>
<ul>
<li><strong>链接方式</strong>
<ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><strong>索引方式</strong>
<ul>
<li>根据进程状态不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数操作系统使用链接方式</p>
<hr>
<h2 id="2-1-3-进程控制">2.1.3 进程控制</h2>
<ul>
<li><strong><u>什么是进程控制？</u></strong></li>
</ul>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<p>简化理解：反正进程控制就是要实现进程状态转换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-15-07.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现进程控制？</u></strong></li>
</ul>
<p>用“原语”实现【第一章提到了】</p>
<p>原语的执行具有“原子性”，一气呵成</p>
<p>思考：为何进程控制（状态转换）的过程要“一气呵成”？<br>
如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</p>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…<br>
假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>
①将PCB2的 state 设为 1<br>
②将PCB2从阻塞队列放到就绪队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-22-47.png" alt=""></p>
<p>但是完成了第一步后收到中断信号，CPU处理中断去了，那么这个时候PCB2 的state=1，但是它却还在阻塞队列里，这是不合理的。</p>
<hr>
<ul>
<li><strong><u>如何实现原语的“原子性”？</u></strong></li>
</ul>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。<br>
可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现<strong>原子性</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-28-05.png" alt=""></p>
<p>如上图：<br>
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</p>
<p>这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子性”</p>
<p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？<br>
假设用户直接在程序开头设置关中断，在程序尾设置开中断，那么这个程序执行时将不能被打断，一直霸占资源，这是不合理的。</p>
<hr>
<ul>
<li><strong><u>进程控制相关的原语</u></strong></li>
</ul>
<ol>
<li><strong>进程的创建</strong>
<ul>
<li><strong>创建原语</strong>【操作系统创建一个进程时使用的原语】
<ul>
<li>申请空白PCB</li>
<li>为新的进程分配资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列【创建态 → 就绪态】</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录<br>
分时系统中，用户登录成功，系统会为其创建一个新的进程</li>
<li>作业调度<br>
多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务<br>
用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求<br>
由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的终止</strong>
<ul>
<li><strong>撤销原语</strong>【就绪态/阻塞态/运行态 → 终止态 → 无】
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程【进程间的关系是树形结构】</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束【进程自己请求终止（exit系统调用）】</li>
<li>异常结束【整数除以0、非法使用特权指令， 然后被操作系统强行杀掉】</li>
<li>外界干预【eg:Ctrl+Alt+delete，用户选择杀掉进程】</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>3.阻塞原语、4.唤醒原语必须成对使用</p>
<ol start="3">
<li><strong>进程的阻塞</strong>
<ul>
<li><strong>阻塞原语</strong>【运行态 → 阻塞态】
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li><strong>保护进程运行现场</strong>，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的唤醒</strong>
<ul>
<li><strong>唤醒原语</strong>【阻塞态 → 就绪态】
<ul>
<li>在事件等待队列找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生【因何事阻塞，就应由何事唤醒】</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的切换</strong>
<ul>
<li><strong>切换原语</strong>【运行态 → 就绪态、就绪态 → 运行态】
<ul>
<li>将<strong>运行环境信息</strong>【进程上下文（Context ）】存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>新进程所需的运行环境</strong></li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>【上接：2.1.1 进程的概念、组成、特征 中的知识滚雪球】</p>
<p>CPU中会设置很多 “寄存器”，用来存放程序运行过程中所需的某些数据。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSW</td>
<td>程序状态字寄存器</td>
</tr>
<tr>
<td>PC</td>
<td>程序计数器，存放下一条指令的地址</td>
</tr>
<tr>
<td>IR</td>
<td>指令寄存器，存放当前正在执行的指令</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>其他一些必 要信息</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<table>
 <tr>
     <td>
         int x = 1;</br>
x++;</br>
…… </br></br>
         指令1: 往内存中某个地方写入变量x的值</br>
指令2: 把变量x的值放到某个寄存器中</br>
指令3: 寄存器中的数值+1</br>
指令4: 把寄存器的值写回变量x的存放位置</br>
……</br>
     </td>
    </tr>  
</table>
<p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p>
<p>思考：执行完指令3后， 另一个进程开始上CPU运行。<br>
注意：另一个进程在运行过程中也会使用各个寄存器</p>
<p>灵魂拷问：之后还怎么切换回之前的进程？？？？<br>
解决办法：在进程切换时<strong>先在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<br>
当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong></p>
<hr>
<ul>
<li><strong><u>学习技巧</u></strong></li>
</ul>
<p>进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息
<ul>
<li>a. 所有的进程控制原语一定都会修改进程状态标志</li>
<li>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>c. 某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<hr>
<h2 id="2-1-4-进程通信">2.1.4 进程通信</h2>
<ul>
<li><strong><u>什么是进程通信？</u></strong><br>
进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-27-27.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong><u>为什么进程通信需要操作系统支持？</u></strong></li>
</ul>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-30-11.png" alt=""></p>
<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<p>下面将介绍三种进程通信方式：<strong>1. 共享存储、2. 消息传递、3. 管道通信</strong></p>
<hr>
<ul>
<li><strong><u>进程通信——共享存储</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-36-25.png" alt=""></p>
<p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。<br>
各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作【后面介绍】)</p>
<p>linux中，如何实现共享内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(...)</span>	<span class="comment">// 通过 shm_open 系统调用，申请一片共享内存区</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(...)</span>	<span class="comment">// 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中(第三章内容)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>共享存储</strong>：</p>
<ul>
<li><strong>基于数据结构</strong>的共享：<br>
比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种<strong>低级通信</strong>方式</li>
<li><strong>基于存储区</strong>的共享：<br>
在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递</u></strong></li>
</ul>
<p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-44-02.png" alt=""></p>
<p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<p><strong>消息传递</strong>：</p>
<ul>
<li><strong>直接通信方式</strong><br>
消息直接挂到接收进程的消息缓冲队列上</li>
<li><strong>间接通信方式</strong><br>
消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（直接通信方式）</u></strong></li>
</ul>
<p>点名道姓的消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-55-43.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（间接通信方式）</u></strong></li>
</ul>
<p>以“信箱”作为中间实体进行消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-01-46.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——管道通信</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-47-19.png" alt=""></p>
<p>那么管道通信和进程通信又有什么区别呢？<br>
管道通信读写要求先进先出（循环队列）；而共享存储存取没有要求，都行</p>
<ol>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。 （由操作系统实现）</li>
<li>当<strong>管道写满</strong>时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当<strong>管道读空</strong>时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：1、<strong>一个管道允许多个写进程，一个读进程</strong> (2014年408真题高教社官方答案)；2、允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)。</li>
</ol>
<hr>
<ul>
<li><strong><u>王道书修正</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-58-27.png" alt=""></p>
<hr>
<h2 id="2-1-5-线程概念-多线程模型">2.1.5 线程概念 多线程模型</h2>
<ul>
<li><strong><u>什么是线程，为什么要引入线程？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_14-48-55.png" alt=""></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p>传统的进程是程序执行流的最小单位。<br>
引入线程后，线程成为了程序执行流的最小单位</p>
<p>可以把线程理解为“轻量级进程”。</p>
<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>， 也是<strong>程序执行流的最小单位</strong>。<br>
引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内 也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）</p>
<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br>
<strong>线程</strong>则作为<strong>处理机的分配单元</strong>。</p>
<hr>
<ul>
<li><strong><u>引入线程机制后，有什么变化？</u></strong></li>
</ul>
<ol>
<li><strong>资源分配、调度</strong>
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，<strong>进程是资源分配的基本单位，线程是调度的基本单位</strong></li>
</ul>
</li>
<li><strong>并发性</strong>
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
</li>
<li><strong>系统开销</strong>
<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>引入线程后，并发所带来的系统开销减小</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的属性</u></strong></li>
</ul>
<ol>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块 (TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ol>
<hr>
<h2 id="2-1-6-线程的实现方式-多线程模型">2.1.6 线程的实现方式 多线程模型</h2>
<ul>
<li><strong><u>线程的实现方式——用户级线程（User-Level Thread, ULT）</u></strong></li>
</ul>
<p>历史背景：早期的操作系统（如：早期Unix）只支持进程， 不支持线程。当时的“线程”是由线程库实现的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-01-10.png" alt=""></p>
<p>eg：将下面进程描述成如下代码</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-02-37.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; 处理文字聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123; 处理文件传输的代码 &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>	<span class="comment">// i = 0, 1, 2, 0, 1, 2...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码的角度看，线程其实就是一段代码逻辑。 上述三段代码逻辑上可以看作三个“线程”。 while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。</p>
<p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“<strong>用户级线程</strong>”就是“<strong>从用户视角看能看到的线程</strong>”</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的实现方式——内核级线程（Kernel-Level Thread, KLT”）</u></strong><br>
又称“<strong>内核支持的线程</strong>“</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p>由操作系统支持的线程，<strong>内核级线程才是处理机分配的单位</strong></p>
<p>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块）， 通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看能看到的线程</strong>”</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>
缺点：一个用户进程会占用多个内核级线程，内核级线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ol>
<hr>
<ul>
<li><strong><u>多线程模型</u></strong><br>
在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关 系，可以划分为几种多线程模型</li>
</ul>
<p><strong>重点重点重点</strong>： 操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</p>
<p><strong>一对一</strong>模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p><strong>多对一</strong>模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-06.png" alt=""></p>
<p>多对多模型：n 用户及线程映射到 m 个内核级 线程（n &gt;= m）。每个用户进程对应 m 个内核 级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-11.png" alt=""></p>
<p>可以这么理解：<br>
用户级线程是“代码逻辑”的载体<br>
内核级线程是“运行机会”的载体<br>
【<strong>内核级线程才是处理机分配的单位</strong>。例如：多核 CPU环境下，上图这个进程最多能被分配两个核。】</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU执行<br>
【内核级线程中可以运行任意一个有映射关系的用户级线程代码，如上图，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞】</p>
<hr>
<h2 id="2-1-7-线程的状态与转换">2.1.7 线程的状态与转换</h2>
<ul>
<li><strong><u>线程的状态与转换</u></strong></li>
</ul>
<p>下面与进程完全一致</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<hr>
<ul>
<li><strong><u>线程的组织与控制</u></strong></li>
</ul>
<p>类似于进程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-40-03.png" alt=""></p>
<p>组织：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-41-19.png" alt=""></p>
<hr>
<h2 id="2-2-1-调度的概念、层次">2.2.1 调度的概念、层次</h2>
<ul>
<li><strong><u>调度的概念</u></strong></li>
</ul>
<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——高级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-49-48.png" alt=""></p>
<p>作业：一个具体的任务<br>
用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>内存空间有限，有时无法将用户提交的作业全部放入内存</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。<br>
【简化理解：好几个程序需要启动，到底先启动哪个】</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——低级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-50-23.png" alt=""></p>
<p><strong>低级调度（进程调度/处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——中级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-53-15.png" alt=""></p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p>
<p><strong>中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。<br>
一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p>
<hr>
<ul>
<li><strong><u>补充知识：进程的挂起态与七状态模型</u></strong></li>
</ul>
<p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p>
<p>五状态模型→七状态模型：【看学校怎么考】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。<br>
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<hr>
<ul>
<li><strong><u>三层调度的联系、对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>要做什么</th>
<th style="text-align:center">调度发生在…</th>
<th style="text-align:center">发生频率</th>
<th style="text-align:center">对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高级调度<br />（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td style="text-align:center">外存→内存<br />（面向作业）</td>
<td style="text-align:center">最低</td>
<td style="text-align:center">无→创建态→就绪态</td>
</tr>
<tr>
<td style="text-align:center">中级调度<br />（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td style="text-align:center">外存→内存<br />（面向进程）</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">挂起态→就绪态 <br />（阻塞挂起→阻塞态）</td>
</tr>
<tr>
<td style="text-align:center">低级调度<br />（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td style="text-align:center">内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">就绪态→运行态</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-2-2-进程调度的时机、切换与过程调度方式">2.2.2 进程调度的时机、切换与过程调度方式</h2>
<ul>
<li><strong><u>进程调度的时机</u></strong></li>
</ul>
<p><strong>进程调度</strong>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p><strong>需要进行</strong>进程调度与切换的情况：</p>
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如 等待I/O）</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p><strong>不能进行</strong>进程调度与切换的情况：</p>
<ol>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中。<br>
【但是进程在普通临界区中是可以进行调度和切换的】</li>
<li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<p>【考题：】<br>
【对】进程在操作系统内核程序临界区中不能进行调度与切换<br>
【错】（2012年联考真题）进程处于临界区时不能进行处理机调度<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
首先要知道：<br>
临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>
临界区：访问临界资源的那段代码。<br>
<strong>内核程序临界区</strong>一般是用来<strong>访问某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成)</p>
<p>【eg:】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-24-53.png" alt=""></p>
<p>如果还没退出临界区 (还没解锁 )就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度<br>
内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-25-07.png" alt=""></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲；<br>
普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<hr>
<ul>
<li><strong><u>进程调度的方式</u></strong></li>
</ul>
<p>有的系统中，只允许进程主动放弃处理机<br>
有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br>
【实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统】</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>
【可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统】</li>
</ul>
<hr>
<ul>
<li><strong><u>进程的切换与过程</u></strong></li>
</ul>
<p>“狭义的进程调度”与“进程切换”的区别：<br>
<strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程， 也可能是另一个进程，后一种情况就需要进程切换）<br>
<strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<hr>
<h2 id="2-2-3-调度器和闲逛程序">2.2.3 调度器和闲逛程序</h2>
<ul>
<li><strong><u>调度器/调度程序（scheduler）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<p>上图中，2和3由调度程序引起，调度程序决定:</p>
<p>让谁运行?——调度算法<br>
运行多长时间?——时间片大小</p>
<p>调度时机——什么事件会触发“调度程序” ?</p>
<ul>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li>运行<strong>进程阻塞</strong></li>
<li><strong>l/O中断</strong>发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个<strong>时钟中断</strong>或k个时钟中断会触发调度程序工作</li>
</ul>
<p>不支持内核级线程的操作系统，调度程序的处理对象是进程<br>
支持内核级线程的操作系统，调度程序的处理对象是内核线程</p>
<hr>
<ul>
<li><strong><u>闲逛进程</u></strong></li>
</ul>
<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程(idle)</p>
<p>闲逛进程的<strong>特性</strong>:</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<hr>
<h2 id="2-2-4-调度算法的评价指标">2.2.4 调度算法的评价指标</h2>
<blockquote>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>等待时间</mtext><mo>=</mo><mtext>周转时间</mtext><mo>−</mo><mtext>运行时间</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>平均等待时间</mtext><mo>=</mo><mfrac><mtext>各作业等待时间之和</mtext><mtext>作业数</mtext></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
&amp;CPU利用率 = \frac{忙碌的时间}{总时间}\nonumber\\\nonumber\\

&amp;系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}\nonumber\\\nonumber\\

&amp;（作业）周转时间=作业完成时间-作业提交时间\nonumber\\\nonumber\\

&amp;平均周转时间 = \frac{各作业周转时间之和}{作业数}\nonumber\\\nonumber\\

&amp;带权周转时间 = \frac{作业周转时间}{作业实际运行时间}\nonumber\\\nonumber\\

&amp;平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}\nonumber\\\nonumber\\

&amp;等待时间=周转时间-运行时间\nonumber\\\nonumber\\

&amp;平均等待时间=\frac{各作业等待时间之和}{作业数}\nonumber
\end{align}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:27.578em;vertical-align:-13.539em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.039em;"><span style="top:-16.039em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-14.213em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-12.1927em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-10.3667em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-8.8667em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-7.3667em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-5.3463em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-3.5203em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:0.326em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:2.3463em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:4.1723em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:5.6723em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:7.1723em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span><span style="top:9.1927em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:13.539em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.039em;"><span style="top:-16.039em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">忙碌的时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-12.1927em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共花了多少时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共完成了多少作业</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-8.8667em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span><span style="top:-5.3463em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业周转时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业实际运行时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业周转时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:2.3463em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业带权周转时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:5.6723em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord cjk_fallback">周转时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">运行时间</span></span></span><span style="top:9.1927em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord"></span><span class="mord cjk_fallback">平均等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业等待时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:13.539em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<ul>
<li><strong><u>CPU利用率</u></strong></li>
</ul>
<p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong></p>
<p><strong>CPU利用率</strong>：指CPU “忙碌”的时间占总时间的比例。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【有的题目还会要求计 算某种设备的利用率】</p>
<p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒， 再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中， CPU利用率、打印机利用率分别是多少？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>打印机利用率</mtext><mo>=</mo><mfrac><mn>5</mn><mn>15</mn></mfrac><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">打印机利用率=\frac{5}{15}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">打印机利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span><br>
【通常会考察多道程序并发 执行的情况，可以用“甘特图”来辅助计算】</p>
<hr>
<ul>
<li><u><strong>系统吞吐量</strong></u></li>
</ul>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<br>
<strong>系统吞吐量</strong>：单位时间内完成作业的数量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<br>
10/100 = 0.1 道/秒</p>
<hr>
<ul>
<li><strong><u>周转时间</u></strong></li>
</ul>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br>
<strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。<br>
它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>
【对于用户来说，更关心自己的单个作业的周转时间】</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值】</p>
<p>【思考】有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<br>
eg：等待1分钟，执行10分钟；等待10分钟，运行1分钟。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<hr>
<ul>
<li><strong><u>等待时间</u></strong></li>
</ul>
<p>计算机的用户希望自己的作业尽可能少的等待处理机<br>
<strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业在后备队列等待被服务（调度）<br>
作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候</p>
<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>
对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p>
<hr>
<ul>
<li><strong><u>响应时间</u></strong></li>
</ul>
<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>
<hr>
<h2 id="2-2-5-调度算法1：先来先服务-最短作业优先-最高响应比优先">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</h2>
<blockquote>
<p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于 作业调度 还是 进程调度？</li>
<li>抢占式？非抢占式？</li>
<li>优点和缺点</li>
<li>是否会导致<strong>饥饿</strong>【某进程/作业长期得不到服务】</li>
</ol>
</blockquote>
<ul>
<li><strong><u>先来先服务（FCFS, First Come First Serve）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li>
<li><strong>算法规则</strong><br>
按照作业/进程到达的先后顺序进行服务</li>
<li><strong>用于作业/进程调度</strong><br>
用于作业调度时，考虑的是哪个作业先到达后备队列；<br>
用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
<li><strong>是否可抢占？</strong><br>
非抢占式的算法</li>
<li><strong>优缺点</strong><br>
优点：公平、算法实现简单<br>
缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶，前面某个人要买100杯…）</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>先来先服务调度算法：按照到达的先后顺序调度，事实上就 是等待时间越久的越优先得到服务。 因此，调度顺序为：P1 → P2 → P3 → P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-52-11.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间     P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7</p>
<p>平均周转时间 = (7+9+8+11)/4 = 8.75</p>
<p>平均带权周转时间 = (1+2.25+8+2.75)/4 = 3.5</p>
<p>平均等待时间 = (0+5+7+7)/4 = 4.75</p>
<hr>
<ul>
<li><strong><u>短作业优先（SJF, Shortest Job First）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li><strong>算法规则</strong><br>
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li>
<li><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</li>
<li><strong>是否可抢占？</strong><br>
SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本</strong>——<strong>最短剩余时间优先算法</strong>（<strong>SRTN</strong>, Shortest Remaining Time Next）</li>
<li><strong>优缺点</strong><br>
优点：“最短的”平均等待时间、平均周转时间<br>
缺点：不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的， 并不一定真实，不一定能做到真正的短作业优先</li>
<li>是否会导致<strong>饥饿</strong><br>
会。如果源源不断地有短作业/进程到来，可能使长作业/进 程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不到服务，则称为“<strong>饿死</strong>”</li>
</ol>
<p>【<strong>例题1</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>非抢占式</strong>的<strong>短作业优先</strong>调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周 转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业/进程。 因此，<strong>调度顺序</strong>为：P1 → P3 → P2 → P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<p>【对比FCFS算法的结果的平均周转时间8.75、平均带权周转时间3.5、平均等待时间4.75，显然SPF算法的 平均等待/周转/带权周转时间都要更低】</p>
<p>【<strong>例题2</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>抢占式</strong>的<strong>短作业优先</strong>调度算法， 计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时 间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>最短剩余时间优先</strong>算法：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个<strong>进程完成时也需要调度</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-10-34.png" alt=""></p>
<p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_n(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表 示当前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进程剩余时间为 m。各个时刻的情况如下：<br>
0时刻（P1到达） ： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(7)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">7</span><span class="mclose">)</span></span></span></span></span><br>
2时刻（P2到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
4时刻（P3到达）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">3</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、P_2(2)、\mathbf{P_3(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span></span></span></span></span><br>
5时刻（P3完成且P4刚好到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">2</mn><mo stretchy="false">)</mo></mrow><mtext>、</mtext><msub><mi>P</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(2)}、P_4(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">2</span><span class="mclose">)</span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span><br>
7时刻（P2完成）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">4</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_4(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
11时刻（P4完成） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(5)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">5</span><span class="mclose">)</span></span></span></span></span></p>
<p>周转时间 = 完成时间 - 到达时间    P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6</p>
<p>带权周转时间 = 周转时间/运行时间    P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5</p>
<p>等待时间 = 周转时间 – 运行时间    P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2</p>
<p>平均周转时间 = (16+5+1+6)/4 = 7</p>
<p>平均带权周转时间 = (2.28+1.25+1+1.5)/4 = 1.50</p>
<p>平均等待时间 = (9+1+0+2)/4 = 3</p>
<p>【对比非抢占式的短作业优先算法的平均周转时间8、平均带权周转时间2.56、平均等待时间4，显 然抢占式的这几个指标又要更低】</p>
<ul>
<li><strong>注意</strong>几个小细节：</li>
</ul>
<ol>
<li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</li>
<li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”
<ul>
<li>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</li>
<li>应该加上一个条件“在<strong>所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”；</li>
<li>或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</li>
<li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算 法）的平均等待时间、平均周转时间最少”</li>
</ul>
</li>
<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS）， SJF依然可以获得较少的平均等待时间、平均周转时间</li>
<li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li>
</ol>
<hr>
<ul>
<li><strong><u>对FCFS和SJF两种算法的思考…</u></strong></li>
</ul>
<p>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>
<p>SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p>
<p>能不能设计一个算法，即考虑到各个作业 的等待时间，也能兼顾运行时间呢？<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高响应比优先算法</strong></p>
<hr>
<ul>
<li><strong><u>高响应比优先（HRRN, Highest Response Ratio Next）</u></strong></li>
</ul>
<ol>
<li>
<p><strong>算法思想</strong><br>
要综合考虑作业/进程的等待时间和要求服务的时间</p>
</li>
<li>
<p><strong>算法规则</strong><br>
在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间 + 要求服务时间}{要求服务时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度</p>
</li>
<li>
<p><strong>是否可抢占？</strong><br>
<strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
</li>
<li>
<p><strong>优缺点</strong><br>
综合考虑了等待时间和运行时间（要求服务时间）<br>
等待时间相同时，要求服务时间短的优先（SJF 的优点）<br>
要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br>
对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
</li>
<li>
<p>是否会导致<strong>饥饿</strong><br>
不会</p>
</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算 各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>高响应比优先</strong>算法：<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进 行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的</strong>进程上处理机。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>0时刻：只有 P1到达就绪队列，<strong>P1</strong>上处理机<br>
7时刻（P1主动放弃CPU）： 就绪队列中有 P2 (响应比=(5+4)/4=2.25)、 <strong>P3</strong>((3+1)/1=4)、 P4((2+4)/4=1.5)，<br>
8时刻（P3完成）： <strong>P2</strong>(2.5)、 P4(1.75)<br>
12时刻（P2完成）：就绪队列中只剩下 <strong>P4</strong></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">考虑到等待时间&amp;运行时间？</th>
<th style="text-align:center">导致饥饿？</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FCFS</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">公平；实现简单</td>
<td style="text-align:center">对短作业不利</td>
<td style="text-align:center">等待时间√ <br />运行时间×</td>
<td style="text-align:center">不会</td>
</tr>
<tr>
<td style="text-align:center">SJF/SPF</td>
<td style="text-align:center">默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN）</td>
<td style="text-align:center">“最短的”平均等待/周转时间；</td>
<td style="text-align:center">对长作业不利，可能导致饥饿；难以做到真正的短作业优先</td>
<td style="text-align:center">等待时间× <br />运行时间√</td>
<td style="text-align:center">会</td>
</tr>
<tr>
<td style="text-align:center">HRRN</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">上述两种算法的权衡 折中，综合考虑的等 待时间和运行时间</td>
<td style="text-align:center"></td>
<td style="text-align:center">等待时间√ <br />运行时间√</td>
<td style="text-align:center">不会</td>
</tr>
</tbody>
</table>
<p>注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于<strong>交互式系统</strong>的调度算法将在下个小节介绍…</p>
<p><strong>提示：一定要动手做课后习题</strong>！这些算法特性容易考小题，算法的使用常结合调度算法的评价指标在大题中考察。</p>
<hr>
<h2 id="2-2-6-调度算法2：时间片轮转-优先级调度-多级反馈队列">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</h2>
<ul>
<li><strong><u>时间片轮转（RR, Round-Robin）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li><strong>算法规则</strong><br>
按照各进程到达<strong>就绪队列</strong>的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度（只有作业放入内存建立了相应的进程后， 才能被分配处理机时间片）</li>
<li><strong>是否可抢占？</strong><br>
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</li>
<li><strong>优缺点</strong><br>
优点：公平；响应快，适用于<strong>分时操作系统</strong>；<br>
缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
<li>补充<br>
时间片太大或太小分别有什么影响？【下面例题中介绍】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>时间片轮转</strong>调度算法，分析时间片大小分别是2、5时的进程运行情况。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-02-10.png" alt=""></p>
<p>时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>
<p>时间片大小为 2 （注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p>
<p>0时刻（<strong>P1(5)</strong> ）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片<br>
2时刻（<strong>P2(4)</strong>  → P1(3)）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。 此时P2排在队头，因此让P2上处理机。（<strong>注意</strong>： 2时刻，P1<strong>下处理机</strong>，同一时刻新进程P2到达，如果在 题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>）<br>
4时刻（<strong>P1(3)</strong>  → P3(1) → P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾<br>
5时刻（<strong>P3(1)</strong>  → P2(2) → P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此 暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）<br>
6时刻（<strong>P3(1)</strong> → P2(2) → P4(6) → P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度<br>
7时刻（<strong>P2(2)</strong> → P4(6) → P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>
9时刻（<strong>P4(6)</strong> → P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机<br>
11时刻（<strong>P1(1)</strong> → P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机<br>
12时刻（<strong>P4(4)</strong> ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机<br>
14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>
16时刻：所有进程运行结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-10-53.png" alt=""></p>
<p>时间片大小为 5</p>
<p>0时刻（<strong>P1(5)</strong> ）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2(4)</strong> ）：P2到达，但P1时间片尚未结束，因此暂不调度<br>
4时刻（<strong>P2(4)</strong> → P3(1)）：P3到达，但P1时间片尚未结束，因此暂不调度<br>
5时刻（<strong>P2(4)</strong> → P3(1) → P4(6) ）：P4到达，同时，P1运行结束。发生调度，P2上处理机。<br>
9时刻（<strong>P3(1)</strong> → P4(6) ）：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
10时刻（<strong>P4(6)</strong> ）：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
15时刻（ ）：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。<br>
16时刻（ ）：P4运行完，主动放弃处理机。所有进程运行完。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>若按照先来先服务调度算法…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且会<strong>增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。<br>
【比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应 可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调 试命令，可能需要等待9秒才能被系统响应】</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理%进程切换，从而导致实际用于进程执行的时间比例减小。可见<strong>时间片也不能太小</strong>。<br>
【一般来说，设计时间片时要让切换进程的开销占比不超过1%】</p>
<hr>
<ul>
<li><strong><u>优先级调度算法</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
<li><strong>算法规则</strong><br>
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li><strong>用于作业/进程调度</strong><br>
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
<li><strong>是否可抢占？</strong><br>
抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>
<li><strong>优缺点</strong><br>
优点：用优先级区分紧急程度、重要程度，适用于<strong>实时操作系统</strong>。可灵活地调整对各种作业/进程的偏好程度。<br>
缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>是否会导致<strong>饥饿</strong><br>
会</li>
<li>补充：<br>
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置<br>
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。<br>
<strong>静态优先级</strong>：创建进程时确定，之后一直不变。<br>
<strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ol>
<p>【<strong>思考</strong>】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
如何合理地设置各类进程的优先级？<br>
通常：<br>
系统进程优先级 <strong>高于</strong> 用户进程<br>
前台进程优先级 <strong>高于</strong> 后台进程<br>
操作系统更<strong>偏好 I/O型进程（或称 I/O繁忙型进程）</strong><br>
注：与I/O型进程相对的是<strong>计算型进程（或称 CPU繁忙型进程)</strong><br>
【I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话， 则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p>
<p>如果采用的是动态优先级，什么时候应该调整？<br>
可以从追求公平、提升资源利用率等角度考虑<br>
如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级<br>
如果某进程占用处理机运行了很长时间，则可适当降低其优先级<br>
如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p>
<p>【<strong>例题1</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>非抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
7时刻（P2、<strong>P3</strong>、P4）：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。<br>
8时刻（ <strong>P2</strong>、P4 ）：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机<br>
12时刻（ <strong>P4</strong> ）：P2完成，就绪队列只剩P4，P4上处理机。<br>
16时刻（ ）：P4完成，所有进程都结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-23-54.png" alt=""></p>
<p>【<strong>例题2</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机</strong>时发生调度。另 外，当<strong>就绪队列发生改变时</strong>也需要检查是会发生抢占。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2</strong>）：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。<br>
4时刻（P1、<strong>P3</strong>）：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。<br>
5时刻（P1、<strong>P2</strong>、P4）：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列， 因此选择P2上处理机<br>
7时刻（P1、<strong>P4</strong>）：P2完成，就绪队列只剩P1、P4，P4上处理机。<br>
11时刻（<strong>P1</strong> ）：P4完成，P1上处理机<br>
16时刻（）：P1完成，所有进程均完成</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-26-59.png" alt=""></p>
<hr>
<ul>
<li><strong><u>思考</u></strong></li>
</ul>
<p>FCFS算法的优点是公平</p>
<p>SJF 算法的优点是能尽快处理完短作业， 平均等待/周转时间等参数很优秀</p>
<p>时间片轮转调度算法可以让各个进程得到及时的响应</p>
<p>优先级调度算法可以灵活地调整各种进程被服务的机会</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？</p>
<p><strong>多级反馈队列调度算法</strong></p>
<hr>
<ul>
<li><u><strong>多级反馈队列调度算法</strong></u></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
对其他调度算法的折中权衡</li>
<li><strong>算法规则</strong>
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
</ol>
</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度</li>
<li><strong>是否可抢占？</strong><br>
<strong>抢占式</strong>的算法。在 k 级队列的进程运行过程中，若更上级的队列 （1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的 队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列 队尾。</li>
<li><strong>优缺点</strong><br>
对各类型进程相对公平（FCFS的优点）；<br>
每个新到达的进程都可以 很快就得到响应（RR的优点）；<br>
短进程只用较少的时间就可完成 （SPF的优点）；<br>
不必实现估计进程的运行时间（避免用户作假）；<br>
可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密 集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级）</li>
<li>是否会导致<strong>饥饿</strong><br>
会【一直来短进程的话，有可能一直在高优先级队列处理，被降级的会饥饿】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>多级反馈队列调度算法</strong>，分析进程运行的过程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-47-19.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-55-40.png" alt=""></p>
<p>P1(1) —&gt; P2(1) —&gt; P1(2) —&gt; P2(1)—&gt; P3(1)—&gt; P2(2) —&gt; P1(4) —&gt; P1(1)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-05_22-22-51.gif" alt=""></p>
<p>设置多级就绪队列，各级队列<strong>优先级</strong>从<strong>高到低</strong>，<strong>时间片</strong>从<strong>小到大新进程</strong>到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程<strong>还未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>已经在最下级</strong>的队列，则<strong>重新放回最下级</strong>队列队尾<br>
只有第 <strong>k 级队列为空</strong>时，才会<strong>为 k+1 级</strong>队头的进程<strong>分配时间片</strong><br>
<strong>被抢占处理机</strong>的进程<strong>重新放回原队列</strong>队尾</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">导致饥饿？</th>
<th style="text-align:center">补充</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">时间片轮转</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">公平，适用于分时系统</td>
<td style="text-align:center">频繁切换有开销，不区分优先级</td>
<td style="text-align:center">不会</td>
<td style="text-align:center">时间片太大或太小有何 影响？</td>
</tr>
<tr>
<td style="text-align:center">优先级调度</td>
<td style="text-align:center">有抢占式的，也有非抢占式的。注意做题时的区</td>
<td style="text-align:center">区分优先级， 适用于实时系统</td>
<td style="text-align:center">可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center">动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？</td>
</tr>
<tr>
<td style="text-align:center">多级反馈队列</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">平衡优秀 666</td>
<td style="text-align:center">一般不说它有缺点，不过可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括 分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于<strong>交互式系统</strong>。（比如UNIX使用的就是多级反馈 队列调度算法）</p>
<p><strong>提示：一定要动手做课后习题</strong></p>
<hr>
<h2 id="2-2-5-调度算法3：多级队列">2.2.5 调度算法3：多级队列</h2>
<ul>
<li><strong><u>多级队列调度算法</u></strong></li>
</ul>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_08-38-34.png" alt=""></p>
<p>队列之间可采取固定优先级，或时间片划分<br>
固定优先级: 高优先级空时低优先级进程才能被调度<br>
时间片划分:如三个队列分配时间50%、40%、10%</p>
<p>各队列可采用不同的调度策略，如：<br>
系统进程队列采用 优先级调度<br>
交互式队列采用 RR<br>
批处理队列采用 FCFS</p>
<hr>
<h2 id="2-3-1-进程同步-进程互斥">2.3.1 进程同步 进程互斥</h2>
<ul>
<li><strong><u>什么是进程同步</u></strong></li>
</ul>
<p>知识点回顾：进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<p>【<strong>例1</strong>】老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p>
<p>但是这个时候：<br>
女一号只想做老渣的初恋<br>
女二号只想交一个有恋爱经验的渣男</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>那么，老渣在并发执行这两个约会进程的时候，<br>
就必须保证“一号的指令2” 一定要在“二号的指令1”之前执行。</p>
<p>操作系统要提供“<strong>进程同步</strong>机制”来实现上述需求。</p>
<p>【<strong>例2</strong>】进程通信——管道通信</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_22-46-57.png" alt=""></p>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据→读数据</strong>”的顺序来执行的。 如何解决这种异步问题，就是 “<strong>进程同步</strong>”所讨论的内容。</p>
<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<hr>
<ul>
<li><strong><u>什么是进程互斥</u></strong></li>
</ul>
<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
<p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。</p>
<ul>
<li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry section;	<span class="comment">// 进入区</span></span><br><span class="line">    critical section;	<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;	<span class="comment">// 退出区</span></span><br><span class="line">    remainder section;	<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">区</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入区</td>
<td style="text-align:left">负责检查是否可进入临界区，若可进入，则应<br />设置<strong>正在访问临界资源的标志</strong>（可理解为“上锁”），<br />以阻止其他进程同时进入临界区</td>
</tr>
<tr>
<td style="text-align:center">临界区</td>
<td style="text-align:left"><strong>访问临界资源</strong>的那段代码</td>
</tr>
<tr>
<td style="text-align:center">退出区</td>
<td style="text-align:left">负责解除<strong>正在访问临界资源的标志</strong>（可理解为“解锁”）</td>
</tr>
<tr>
<td style="text-align:center">剩余区</td>
<td style="text-align:left">做其他处理</td>
</tr>
</tbody>
</table>
<p>注意：<br>
<strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。<br>
<strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。<br>
临界区也可称为“临界段”。</p>
<ul>
<li>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下<strong>原则</strong>：</li>
</ul>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<hr>
<h2 id="2-3-2-进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2>
<blockquote>
<p>学习提示：</p>
<ol>
<li>理解各个算法的思想、原理</li>
<li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li>
<li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li>
</ol>
</blockquote>
<ul>
<li><strong><u>如果没有注意进程互斥？</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程A、进程B在系统中并发地运行</span></span><br><span class="line">进程A： </span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程B：</span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调度A上处理机运行<br>
当A在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度B让它上处理机运行<br>
进程B也在使用打印机</p>
<p>结局：A、B 的打印内容混在一起了【错误的，不希望看到的】</p>
<p>如何实现进程互斥？</p>
<hr>
<ul>
<li><strong><u>单标志法</u></strong></li>
</ul>
<p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前 允许进入 临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);	<span class="comment">// 1 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;		<span class="comment">// 3 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 4 剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);	<span class="comment">// 5 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;		<span class="comment">// 7 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 8 剩余区</span></span><br></pre></td></tr></table></figure>
<p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。<br>
若 P1 先上处理机运行，则会一直卡在5。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。<br>
代码1不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在5。<br>
只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</p>
<p>因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>只能按 P0 → P1 → P0 → P1 →……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。<br>
因此，<strong>单标志法</strong>存在的<strong>主要问题</strong>是：<strong>违背“空闲让进”原则</strong>。</p>
<hr>
<ul>
<li><u><strong>双标志先检查法</strong></u></li>
</ul>
<p>算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如 “flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 1 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 2 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 5 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6 3 7….的顺序执行，P0 和 P1 将会同时访问临界区。 因此，<strong>双标志先检查法</strong>的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。<br>
原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<hr>
<ul>
<li><strong><u>双标志后检查法</u></strong></li>
</ul>
<p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查” 的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 2 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 5 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 6 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6….的顺序执行，P0 和 P1 将都无法进入临界区<br>
因此，双标志后检查法虽然<strong>解决了“忙则等待”的问题</strong>，但是<strong>又违背了“空闲让进”和“有限等待” 原则</strong>，会因各进程都长期无法访问临界资源而<strong>产生 “饥饿”</strong> 现象。<br>
两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<hr>
<ul>
<li><strong><u>Peterson 算法</u></strong></li>
</ul>
<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;			<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">// 2 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);	<span class="comment">// 3 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;		<span class="comment">// 4 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;		<span class="comment">// 5 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;			<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">// 7 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);	<span class="comment">// 8 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;		<span class="comment">// 9 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;		<span class="comment">// 10 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>动手推导： 按不同的顺序穿插 执行会发生什么？<br>
1 2 3  6 7 8…<br>
1 6 2 3…<br>
1 3 6 7 8…<br>
1 6 2 7 8…</p>
<p>Peterson 算法用软件方法解决了进 程互斥问题，<strong>遵循了 空闲让进、忙则等待、有限等待 三个原则</strong>，但是 依然<strong>未遵循让权等待</strong>的原则。</p>
<p>Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<hr>
<h2 id="2-3-3-进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2>
<ul>
<li><strong><u>中断屏蔽方法</u></strong></li>
</ul>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断； <span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断； <span class="comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>优点：简单、高效<br>
缺点：不适用于多处理机【多个处理机同时访问临界区的情况，因为关中断只能关这个处理机】；<br>
只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令</u></strong></li>
</ul>
<p>简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令<br>
TSL 指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true 表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">bool</span> old;		</span><br><span class="line">    old = *lock; 	<span class="comment">// old用来存放Lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; 	<span class="comment">// 无论之前是否已加锁，都将Lock设为true</span></span><br><span class="line">    <span class="keyword">return</span> old;		<span class="comment">// 返回Lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用 TSL 指今实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// “检查”并“上锁”</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;	<span class="comment">// “解锁”</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作<strong>用硬件的方式变成了一气呵成的原子操作</strong>。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br>
缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>Swap指令</u></strong></li>
</ul>
<p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。<br>
Swap 指令是<strong>用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap 指令的作用是交换两个变量的值</span></span><br><span class="line">Swap (<span class="type">bool</span> *a，<span class="type">bool</span> *b) &#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// Lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">    Swap (&amp;lock，&amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p><strong>逻辑上来看 Swap 和 TSL 并无太大区别</strong>，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令和Swap指令的逻辑</u></strong></li>
</ul>
<ol>
<li>old记录是否已被上锁;</li>
<li>再将lock设为 true;</li>
<li>检查临界区是否已被上锁(若已上锁，则循环重复前几步)</li>
</ol>
<p>总之就是为了：<strong>检查并上锁</strong></p>
<hr>
<h2 id="2-3-4-互斥锁">2.3.4 互斥锁</h2>
<ul>
<li><strong><u>进程互斥：锁</u></strong></li>
</ul>
<p>解决临界区最简单的工具就是<strong>互斥锁 (mutex lock)</strong> 。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 <code>acquire()</code> 获得锁，而函数 <code>release()</code> 释放锁。</p>
<p>每个互斥锁有一个布尔变量 <code>available</code>，表示锁是否可用。如果锁是可用的，调用 acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻寒，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);	<span class="comment">// 忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>;	<span class="comment">// 获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>;	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire()或release()的执行必须是<strong>原子</strong>操作，因此互斥锁通常<strong>采用硬件</strong>机制来实现。</p>
<p>互斥锁的主要缺点是<strong>忙等待</strong>【违反了“<strong>让权等待</strong>”】，当有一个进程在临界区中，任何其他进程在进入临界区时必约连续循环调用 acquire()。当多个进程共享同一 CPU 时，就浪费了 CPU 周期。因此，互斥锁通用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong> ，如TSL指令、swap指令、单标志法</p>
<p>【<strong>特性</strong>】:</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<hr>
<h2 id="2-3-5-信号量机制">2.3.5 信号量机制</h2>
<ul>
<li><strong><u>复习回顾</u></strong></li>
</ul>
<p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题?</p>
<p>进程互斥的四种软件实现方式 (单标志法、双标志先检查、双标志后检查、Peterson算法)</p>
<p>进程互斥的三种硬件实现方式 (中断屏蔽方法、TS/TSL指令、Swap/XCHG指令)</p>
<ol>
<li>在双标志先检查法中，<strong>进入区的“检查”、“上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题:</li>
<li>所有的解决方案<strong>都无法实现“让权等待“</strong></li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法–<strong>信号量机制</strong></p>
<hr>
<ul>
<li><strong><u>信号量机制</u></strong></li>
</ul>
<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p><strong>信号量</strong>其实就是一个变量 (<strong>可以是一个整数，也可以是更复杂的记录型变量</strong>)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如: 系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p><strong>一对原语</strong>: <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p>
<p>wait、signal 原语常<strong>简称为 P、V操作</strong> (来自荷兰语 proberen 和 verhogen)。因此，做题的时候<strong>常</strong>把wait(S)、signal(S) 两个操作<strong>分别写为 <code>P(S)</code>、<code>V(S)</code></strong></p>
<hr>
<ul>
<li><strong><u>信号量机制——整型信号量</u></strong></li>
</ul>
<p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。<br>
【与普通整数变量的区别： 对信号量的操作只有三种， 即 初始化、P操作、V操作】</p>
<p>Eg ：某计算机系统中有一台打印机…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整型信号量s，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --“检查”和“上锁”一气呵成，避免了并发、异步导致的问题--</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;	<span class="comment">// wait 原语，相当于“进入区”</span></span><br><span class="line">    <span class="comment">// --存在的问题：不满足“让权等待”原则，会发生“忙等”--</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);	<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S=S<span class="number">-1</span>;		<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> s)</span> &#123;	<span class="comment">// signal 原语，相当于“退出区&quot;</span></span><br><span class="line">    S=S+<span class="number">1</span>;		<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">进程P0:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程P1:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程Pn:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>
<p><strong><u>信号量机制——记录型信号量</u></strong></p>
<p><strong>大题、小题超高频出题点</strong></p>
</li>
</ul>
<p>整型信号量的缺陷是存在“<strong>忙等</strong>”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表 示的信号量。<br>
为了解决上面&quot;<strong>让权等待</strong>&quot;的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;		<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>	<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过 wait 原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【如果剩余资源数不够，使用block原语使进程从</span></span><br><span class="line"><span class="comment">// 运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过 signal 原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【释放资源后，若还有别的进程在等待这种资源，则使用</span></span><br><span class="line"><span class="comment">// wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态】</span></span><br></pre></td></tr></table></figure>
<p>Eg：某计算机系统中有2台打印机…，<br>
则可在初始化信号量 S 时将 <code>S.value</code> 的值设为 2，队列 S.L 设置为空</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_9-44-38.gif" alt=""></p>
<p>在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S)， 这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong> 。</p>
<p><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p>
<p>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 <code>S.value--</code>，表示资源数减1，当 <code>S.value &lt; 0</code> 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>（当前运行的进程从<strong>运行态→阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 <code>S.L</code> 中。可见，该机制<strong>遵循了“让权等待”原则&quot;</strong> ， 不会出现“忙等”现象。</p>
<p>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 <code>S.value++</code>，表示资源数加1， 若加1后仍是 <code>S.value &lt;= 0</code>，表示依然有进程在等待该类 资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态→就绪态</strong>）。</p>
<p>注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量。</p>
<hr>
<h2 id="2-3-6-用信号量机制实现：进程互斥、同步、前驱关系">2.3.6 用信号量机制实现：进程互斥、同步、前驱关系</h2>
<blockquote>
<p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p>
<p>信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<p>P( S ) —— 申请一个资源S，如果<strong>资源不够就阻塞等待</strong><br>
V( S ) —— 释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong></p>
</blockquote>
<ul>
<li><strong><u>信号量机制实现进程互斥</u></strong></li>
</ul>
<ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>
<li>设置<strong>互斥信号量</strong> mutex，<strong>初值为 1</strong> 【互斥访问临界资源】<br>
【理解：信号量 mutex 表示 “进入临界区的名额”】</li>
<li>在进入区 P(mutex)——<strong>申请资源</strong></li>
<li>在退出区 V(mutex)——<strong>释放资源</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;		<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>	<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">// 这是上一小节信号量的定义，但是如果题目 没有特别说明 ，用下面方式定义即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【要会自己定义记录型信号量，但如果题目中没特别说明，可以把信号量的声明简写成这种形式】</span></span><br><span class="line">semphore muutex = <span class="number">1</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	. . .</span><br><span class="line">	P(mutex);	<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">	临界区代码段...</span><br><span class="line">	V(mutex);	<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	. . .</span><br><span class="line">	P(mutex);	</span><br><span class="line">	临界区代码段...</span><br><span class="line">	V(mutex);	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-07-06.png" alt=""></p>
<p><strong>P、V操作必须成对出现</strong>。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</p>
<hr>
<ul>
<li><strong><u>信号量机制实现进程同步</u></strong></li>
</ul>
<p>进程同步：要让各并发进程按要求有序地推进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p>
<p>若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。</p>
<p>用信号量实现进程同步：</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li>
<li>设置<strong>同步信号量</strong> S, <strong>初始为 0</strong></li>
<li><strong>在“前操作”之后执行 V(S)</strong></li>
<li><strong>在“后操作”之前执行 P(S)</strong></li>
</ol>
<p>【<strong>技巧口诀：前V后P</strong>】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号量机制实现进程同步 */</span></span><br><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化同步信号量，初值为0</span></span><br><span class="line"><span class="comment">// 【理解：信号量S代表“某种资源”，刚开始是没有这种资源的。</span></span><br><span class="line"><span class="comment">// P2需要使用这种资源，而又只能由P1产生这种资源】</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);	<span class="comment">// 释放资源</span></span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    P(S);	<span class="comment">// 保证了 代码4 一定是在 代码2 之后执行</span></span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若先执行到 V(S) 操作，则 <code>S++</code> 后 <code>S=1</code>。之后当执行到 P(S) 操作 时，由于 <code>S=1</code>，表示有可用资源，会执行 <code>S--</code>，S 的值变回 0， P2 进程不会执行 block 原语，而是继续往下执行代码4。</p>
<p>若先执行到 P(S) 操作，由于 <code>S=0</code>，<code>S--</code> 后 <code>S=-1</code>，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。 之后当执行完代码2，继而执行 V(S) 操作， <code>S++</code>，使 S 变回 0， 由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续 执行 代码4 了</p>
<hr>
<ul>
<li><strong><u>信号量机制实现前驱关系</u></strong></li>
</ul>
<p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求 按如下前驱图所示的顺序来执行：</p>
<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作） 因此，</p>
<ol>
<li>要<strong>为每一对前驱关系各设置一个同步信号量</strong></li>
<li><strong>在“前操作”之后对相应的同步信号量执行 V 操作</strong></li>
<li><strong>在“后操作”之前对相应的同步信号量执行 P 操作</strong></li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-22-13.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	...</span><br><span class="line">	s1;</span><br><span class="line">	V(a);</span><br><span class="line">	V(b);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(a);</span><br><span class="line">	s2;</span><br><span class="line">	V(c);</span><br><span class="line">	V(d);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(b);</span><br><span class="line">	s3;</span><br><span class="line">	V(g);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(c);</span><br><span class="line">	s4;</span><br><span class="line">	V(e);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(d);</span><br><span class="line">	s5;</span><br><span class="line">	V(f);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P6() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(e);</span><br><span class="line">	P(f);</span><br><span class="line">	P(g);</span><br><span class="line">	s6;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点和考点</u></strong></li>
</ul>
<p>除了互斥、同步问题外， 还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行 V 操作即可</p>
<p>互斥问题，信 号量初值为1<br>
同步问题，信 号量初值为0</p>
<p>前驱关系问题， 本质上就是多级同步问题</p>
<hr>
<h2 id="2-3-7-生产者消费者问题">2.3.7 生产者消费者问题</h2>
<ul>
<li>
<p><strong><u>问题描述</u></strong></p>
</li>
<li>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者 进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>
</li>
<li>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
</li>
<li>
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 【缓冲区没满→生产者生产】</p>
</li>
<li>
<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 【缓冲区没空→消费者消费】</p>
</li>
<li>
<p>缓冲区是临界资源，各进程必须互斥地访问。【互斥关系】</p>
</li>
<li>
<p>缓冲区满时，生产者必须等待。</p>
</li>
<li>
<p>缓冲区空时，消费者必须等待。</p>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_21-54-04.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<p>PV操作题目分析步骤：</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>
<li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;	<span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;	<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		生产一个产品;</span><br><span class="line">		P(empty);	<span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">		<span class="comment">// --实现互斥是在同一进程中进行一对PV操作--</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		把产品放入缓冲区;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);	<span class="comment">// 增加一个产品</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V--</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(full);	<span class="comment">// 消耗一个产品（非空缓冲区）</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		从缓冲区取出一个产品;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);	<span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">		使用产品;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【分析双方执行后，增加了什么，申请了什么资源<br>
生产者增加了产品 V(full），消费者增加了缓冲区空白 V(empty）<br>
生产者申请了空白 P(empty)，消费者申请了产品 P(full)】</p>
<hr>
<ul>
<li><strong><u>思考：能否改变相邻P、V操作的顺序？</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		生产一个产品;	</span><br><span class="line">		P(mutex);	<span class="comment">// ①</span></span><br><span class="line">		P(empty);	<span class="comment">// ②</span></span><br><span class="line">		把产品放入缓冲区;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;	</span><br><span class="line">		P(mutex);	<span class="comment">// ③</span></span><br><span class="line">		P(full);	<span class="comment">// ④</span></span><br><span class="line">		从缓冲区取出一个产品;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);	</span><br><span class="line">		使用产品;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时缓冲区内已经放满产品，则 <code>empty=0</code>，<code>full=n</code>。<br>
则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。<br>
由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。<br>
这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“<strong>死锁</strong>”。</p>
<p>同样的，若缓冲区中没有产品，即<code>full=0</code>，<code>empty=n</code>。按③④① 的顺序执行就会发生死锁。</p>
<p>因此，<strong><u>实现互斥的P操作一定要在实现同步的P操作之后</u></strong>。<br>
V操作不会导致进程阻塞，因此**<u>两个V操作顺序可以交换</u>**。</p>
<p>【思考】能否将“生产一个产品;”和“使用产品;”放到PV操作之间呢？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>可以；但是不这么做，这样会使上锁和解锁之间的时间变长，实际应该让这个时间尽可能短。</p>
<hr>
<ul>
<li><strong><u>知识点和考点</u></strong></li>
</ul>
<p>生产者消费者问题是一个互斥、同步的综合问题。<br>
对于初学者来说最难的是发现题目中隐含的两对同步关系。<br>
有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p>
<hr>
<h2 id="2-3-8-多生产者-多消费者">2.3.8 多生产者-多消费者</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_23-13-01.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>
【互斥：临界区前后加P、V；同步：前V后P】</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>互斥关系：mutex = 1<br>
对缓冲区（盘子）的访问要互斥地进行</p>
<p>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果<br>
【“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果】</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-21-38.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;	<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;	<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;	<span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个苹果;</span><br><span class="line">		P(plate);</span><br><span class="line">		P(mutex);</span><br><span class="line">		把苹果放入盘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个橘子;</span><br><span class="line">		P(plate);</span><br><span class="line">		P(mutex);</span><br><span class="line">		把橘子放入盘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(orange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(apple);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从盘中取出苹果;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉苹果;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(orange);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从盘中取出橘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉橘子;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：<strong>可不可以不用互斥信号量</strong>？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore apple = <span class="number">0</span>;	<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;	<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;	<span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个苹果;</span><br><span class="line">		P(plate);</span><br><span class="line">		把苹果放入盘子;</span><br><span class="line">		V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个橘子;</span><br><span class="line">		P(plate);</span><br><span class="line">		把橘子放入盘子;</span><br><span class="line">		V(orange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(apple);</span><br><span class="line">		从盘中取出苹果;</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉苹果;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(orange);</span><br><span class="line">		从盘中取出橘子;</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉橘子;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程即使上处理机运行也会被阻塞。如果刚开始是父亲进程先上处理机运行，则： 父亲 P(plate)，可以访问盘子→母亲 P(plate)，阻塞等待盘子→父亲放入苹果 V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）→女儿 P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒→母亲进程访问盘子（其他进程暂时都无法进入临界区）→……</p>
<p><strong>结论</strong>：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。</p>
<p><strong>原因</strong>在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻， 最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p><strong>如果盘子容量为2的话</strong>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate = <span class="number">2</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure>
<p>父亲 P(plate)，可以访问盘子→母亲 P(plate)，可以访问盘子→父亲在往盘子里放苹果，同时母亲也可以往盘子里 放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现 互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p>
<p>建议：在考试中如果来不及仔细分析，最好是可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。 <strong>但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</strong></p>
<p>PV 操作题目的<strong>解题思路</strong>：</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>
【互斥：临界区前后加P、V；同步：前V后P】</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。 在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生 的事看做是两种“事件”的前后关系。<br>
比如，如果<strong>从单个进程行为的角度来考虑</strong>的话，我们会有以下结论：<br>
<strong>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</strong><br>
<strong>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</strong><br>
这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-40-36.png" alt=""></p>
<p>正确的分析方法应该从“事件”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<br>
盘子变空事件→放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件” 既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-44-39.png" alt=""></p>
<hr>
<h2 id="2-3-9-吸烟者问题">2.3.9 吸烟者问题</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、 第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它</strong>，并<strong>给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-49-18.png" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>组合一：纸+胶水<br>
组合二：烟草+胶水<br>
组合三：烟草+纸</p>
<p>互斥关系：桌子可以抽象为容量为1的缓冲区，要互斥访问</p>
<p>同步关系（从事件的角度来分析）：<br>
桌上有组合一 → 第一个抽烟者取走东西<br>
桌上有组合二 → 第二个抽烟者取走东西<br>
桌上有组合三 → 第三个抽烟者取走东西<br>
发出完成信号 → 供应者将下一个组合放到桌上</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-54-13.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;	<span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;	<span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;	<span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;	<span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;		<span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure>
<p>【思考】是否需要设置 一个专门的互斥信号量？<br>
缓冲区大小为1，同一时 刻，四个同步信号量中至多有一个的值为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">provider() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			将组合一放桌上;</span><br><span class="line">			V(offer1);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">			将组合二放桌上;</span><br><span class="line">			V(offer2);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">			将组合三放桌上;</span><br><span class="line">			V(offer3);</span><br><span class="line">		&#125;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">		P(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">		从桌上拿走组合一；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer2);</span><br><span class="line">		从桌上拿走组合二；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer3);</span><br><span class="line">		从桌上拿走组合三；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。<br>
值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注 意体会我们是如何用一个整型变量 i 实现这个“轮流”过程的。</p>
<p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = rand() % <span class="number">3</span>;	<span class="comment">// 随机产生0/1/2</span></span><br></pre></td></tr></table></figure>
<p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的 “事件”发生之后的位置。</p>
<hr>
<h2 id="2-3-10-读者-写者问题">2.3.10 读者-写者问题</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>有读者和写者两组并发进程，共享<strong>一个文件</strong>【不要被下面的图误导了，本问题只有一个已存在的文件】，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<strong>因此要求</strong>：<br>
① 允许多个读者可以同时对文件执行读操作；<br>
② 只允许一个写者往文件中写信息；<br>
③ 任一写者在完成写操作之前不允许其他读者或写者工作；<br>
④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_00-15-28.png" alt=""></p>
<ul>
<li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。 因此多个读者可同时访问共享数据</li>
<li>两个写进程同时共享数据，可能导致数据错误覆盖的问题</li>
<li>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题</li>
</ul>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>两类进程：写进程、读进程<br>
互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;	<span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// “加锁”由第一个读进程负责</span></span><br><span class="line">			P(rw);	<span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++;	<span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		读文件…</span><br><span class="line">		count--;	<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// “解锁”由最后一个读进程负责</span></span><br><span class="line">			V(rw);	<span class="comment">// 读完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【思考】：若两个读进程并发执行，则 count=0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况。 如何解决：出现上述问题的<strong>原因在于对 count 变量的检查和赋值无法一气呵成</strong>，因此可以设置另一个互斥信号量来保证各读进 程对count 的访问是互斥的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;		<span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;		<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(rw);	<span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw);	<span class="comment">// 写完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex);	<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// 由第一个读进程负责</span></span><br><span class="line">			P(rw);	<span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++;	<span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		读文件…</span><br><span class="line">		P(mutex);	<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		count--;	<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">			V(rw);	<span class="comment">// 读完了“解锁”</span></span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>潜在的问题</strong>：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。 因此，这种算法中，读进程是优先的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;		<span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;		<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line">semaphore w = <span class="number">1</span>;	<span class="comment">// 用于实现“写优先”【其实不是写优先，是“读写公平法”】</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);	<span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw);	<span class="comment">// 写完了“解锁”</span></span><br><span class="line">		V(W);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(mutex);	<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// 由第一个读进程负责</span></span><br><span class="line">			P(rw);	<span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++;	<span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		V(W);</span><br><span class="line">		读文件…</span><br><span class="line">		P(mutex);	<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		count--;	<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>)	<span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">			V(rw);	<span class="comment">// 读完了“解锁”</span></span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析以下并发执行 P(w) 的情况：<br>
（1）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>
（2）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2<br>
（3）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<br>
（4）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>
（5）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2</p>
<p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并<strong>不是真正的“写优先”</strong> ，而是相对公平的先来先服务原则。 有的书上把这种算法称为“<strong>读写公平法</strong>”。</p>
<p>【其实是通过w实现了一个<strong>等待w的队列</strong>】<br>
对上面各情况来说，当第一个事件占用了“w资源”，等待队列如下：<br>
（1）[w] → [读者2]<br>
（2）[w] → [写者2]<br>
（3）[w] → [读者1]<br>
（4）[w] → [写者1] → [读者2]<br>
（5）[w] → [读者1] → [写者2]<br>
所以其实是先来先服务原则，不会导致写操作饿死，但也不是“写优先”，而是”读写公平法“</p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>读者-写者问题为我们解决复杂的互斥问题ᨀ供了一个参考思路。</p>
<p>其<strong>核心思想</strong>在于设置了一个<strong>计数器 count</strong> 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p>
<p>另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量</strong>。</p>
<p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p>
<hr>
<h2 id="2-3-11-哲学家进餐问题">2.3.11 哲学家进餐问题</h2>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_09-27-55.png" alt=""></p>
<ol>
<li>关系分析。系统中有5个哲学家进程，5位哲学 家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li>
<li>信号量设置。定义互斥信号量数组 <code>chopstick[5]=&#123;1,1,1,1,1&#125;</code> 用于实现对5个筷子的互 斥访问。并对哲学家按<code>0~4</code>编号，哲学家 <code>i</code> 左边 的筷子编号为 <code>i</code>，右边的筷子编号为 <code>(i+1)%5</code>。</li>
</ol>
<ul>
<li><strong>每个哲学家吃饭前依次拿起左、 右两支筷子</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123;	<span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(chopstick[i]);	<span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右</span></span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]);	<span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果5个哲学家并发地拿起了自己左手边的筷子…<br>
每位哲学家循环等待右边 的人放下筷子（阻塞）。 发生“死锁”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p>
<ul>
<li><strong>如何防止死锁的发生呢</strong>？</li>
</ul>
<p>① 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore able2eat = <span class="number">4</span>;	<span class="comment">// 最多有4个人能吃饭</span></span><br><span class="line">Pi() &#123;	<span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		p(able2eat);		<span class="comment">// 申请吃饭</span></span><br><span class="line">		P(chopstick[i]);	<span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右</span></span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]);	<span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 放右</span></span><br><span class="line">		v(able2eat);		<span class="comment">// 吃完了，别人可以吃</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就 避免占有一支后再等待另一只的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;	<span class="comment">// 奇数号哲学家</span></span><br><span class="line">			P(chopstick[i]);	<span class="comment">// 拿左</span></span><br><span class="line">			P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右	</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;				<span class="comment">// 偶数号哲学家</span></span><br><span class="line">			P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右</span></span><br><span class="line">			P(chopstick[i]);	<span class="comment">// 拿左</span></span><br><span class="line">		&#125;</span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]);	<span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。【下面的实现其实并不是这样】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123;	<span class="comment">// i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(chopstick[i]);	<span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]);	<span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码③分析下面的情况：<br>
【哲学家0拿起来左边的筷子，然后进程切换到哲学家2】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-58-44.gif" alt=""></p>
<p>【哲学家0吃饭，这个时候哲学家1想吃饭，然后哲学家2想吃饭】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-02-32.gif" alt=""></p>
<p>【哲学家0吃饭，这个时候哲学家4想吃饭】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-04-15.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>哲学家进餐问题的关键在于解决进程死锁。<br>
这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p>
<p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。<br>
可以参考哲学家就餐问题解决死锁的三种思路。</p>
<hr>
<h2 id="2-3-12-管程">2.3.12 管程</h2>
<ul>
<li><strong><u>为什么要引入管程</u></strong></li>
</ul>
<p>信号量机制存在的问题：编写程序困难、易出错</p>
<p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p>
<p>1973年，Brinch Hansen 首次在程序设计语言 (Pascal) 中引入了“管程”成分——一种高级同步机制</p>
<hr>
<ul>
<li><strong><u>管程的定义和基本特征</u></strong></li>
</ul>
<p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程需要一个名字。</li>
</ol>
<p>跨考Tips: “过程”其实就是“函数”</p>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></li>
</ol>
<hr>
<ul>
<li><strong><u>拓展1：用管程解决生产者消费者问题</u></strong></li>
</ul>
<p>以下当做伪代码来理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下当做伪代码来理解</span></span><br><span class="line">monitor ProcedureConsumer   <span class="comment">// 定义一个管程</span></span><br><span class="line">    管程内容...</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line">monitor ProcedureConsumer</span><br><span class="line">	condition full, empty;  	<span class="comment">// 条件变量用来实现同步</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;  		<span class="comment">// 缓冲区中的产品</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">insert</span> <span class="params">(Item item)</span> &#123;   	<span class="comment">// 把产品放入缓冲区</span></span><br><span class="line">		<span class="keyword">if</span> (count == N)		<span class="comment">// 是否满</span></span><br><span class="line">			wait(empty);	<span class="comment">// 相当于P操作</span></span><br><span class="line">		count++;</span><br><span class="line">		insert_item(item);	<span class="comment">// 放入缓冲区</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">1</span>)		<span class="comment">// 我是第一个，空-&gt;非空，那么我会唤醒等待队列的进程</span></span><br><span class="line">			signal(full);	<span class="comment">// 相当于V操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	Item <span class="title function_">remove</span><span class="params">()</span> &#123; 		<span class="comment">// 从缓冲区取出一个产品</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>)		<span class="comment">// 是否空</span></span><br><span class="line">			wait(full);	<span class="comment">// 相当于P操作</span></span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span> (count == N - <span class="number">1</span>) 	<span class="comment">// 我是最后一个，满-&gt;不满，那么我会唤醒等待队列的进程</span></span><br><span class="line">			signal(empty);  <span class="comment">// 相当于V操作</span></span><br><span class="line">		<span class="keyword">return</span> remove_item();   <span class="comment">// 取出一个产品</span></span><br><span class="line">	&#125;</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		item = 生产一个产品;</span><br><span class="line">		ProcedureConsumer.insert(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		item = ProcedureConsumer.remove();</span><br><span class="line">		消费产品item;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由编译器负责实现 各进程互斥地进入管程中的过程</p>
<p>每次仅允许一个进程在管程内执行某个内部过程。<br>
例1：两个生产者进程并发执行，依次调用了 insert 过程…<br>
例2：两个消费者进程先执行，生产者进程后执行…</p>
<p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者 问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li>
<li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li>
<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong> ，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一 个时间段内最多只会有一个进程在访问缓冲区。<strong>注意：这种互斥特性是由编译器负责实现的， 程序员不用关心</strong>）</li>
<li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒</strong>操作以解决同步问题。可以让一个进程或线程在条件变量上等待（<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong> ）；可以通过唤醒操作将 等待在条件变量上的进程或线程唤醒。</li>
</ol>
<p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;）， 之后其他程序员就可以使用这个管程提供的特定“入口”【“封装”思想】很方便地使用实现进程同步/互斥了。</p>
<hr>
<ul>
<li><strong><u>拓展2：Java 中类似于管程的机制</u></strong></li>
</ul>
<p>Java 中，如果用关键字 <code>synchronized</code> 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 每次只能有一个线程进入insert 函数，如果多个线程同时调用 insert 函数，则后来者需要排队等待</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> viod <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：不熟悉 Java 的同学看不懂也没关系，不会考，仅作为思维拓展。 熟悉 Java 的同学在时间充裕的情况下可以动手尝试用 synchronized 实现生产者消费者问题的“管程”</p>
<hr>
<h2 id="2-4-1-死锁的概念">2.4.1 死锁的概念</h2>
<ul>
<li><strong><u>什么是死锁</u></strong></li>
</ul>
<p>每位哲学家都在等待自己右边的人放下筷 子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p>
<p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推 进的现象，就是“死锁”。 发生死锁后若无外力干涉， 这些进程都将无法向前推进。</p>
<hr>
<ul>
<li><strong><u>死锁、饥饿、死循环的区别</u></strong></li>
</ul>
<p><strong>死锁</strong>：<strong>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</strong>。</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。</p>
<p><strong>共同点</strong>：都是进程无法顺利向前推进的现象 （故意设计的死循环除 外）</p>
<table>
<thead>
<tr>
<th style="text-align:center">现象</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁</td>
<td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td>
</tr>
<tr>
<td style="text-align:center">饥饿</td>
<td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)</td>
</tr>
<tr>
<td style="text-align:center">死循环</td>
<td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者（程序员）的问题</strong>。</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><strong><u>死锁产生的必要条件</u></strong></li>
</ul>
<p>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ol>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待 这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ol>
<p><strong>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）【选择题】</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<hr>
<ul>
<li><strong><u>什么时候会发生死锁</u></strong></li>
</ul>
<ol>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1， 两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资 源）</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<hr>
<ul>
<li><strong><u>死锁的处理策略</u></strong></li>
</ul>
<ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<hr>
<h2 id="2-4-2-死锁的处理策略——预防死锁">2.4.2 死锁的处理策略——预防死锁</h2>
<ul>
<li><strong><u>破坏互斥条件</u></strong></li>
</ul>
<p><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>SPOOLing技术</strong>。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>
<p>【进程1还没用完打印机之前，进程2申请使用打印机会阻塞】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-24.png" alt=""></p>
<p>【使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理 了，不需要再阻塞等待】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-29.png" alt=""></p>
<p>该策略的<strong>缺点</strong>：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p>
<hr>
<ul>
<li><strong><u>破坏不剥夺条件</u></strong></li>
</ul>
<p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>破坏不剥夺条件：<br>
方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的<strong>优先级</strong>（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<p>该策略的<strong>缺点</strong>：</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程<strong>饥饿</strong>。</li>
</ol>
<hr>
<ul>
<li><strong><u>破坏请求和保持条件</u></strong></li>
</ul>
<p><strong>请求和保持条件</strong>：进程已经<strong>保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</p>
<p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源 了。</p>
<p>该策略实现起来简单，但也有明显的<strong>缺点</strong>：<br>
有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造 成严重的资源浪费，<strong>资源利用率极低</strong>。</p>
<p>另外，该策略也有可能<strong>导致某些进程饥饿</strong>。eg:<br>
【如下图：假设A类进程结束后，又来了A类进程，这样C类进程一直的怒道资源1，发生了饥饿】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-39-42.png" alt=""></p>
<hr>
<ul>
<li><strong><u>破坏循环等待条件</u></strong></li>
</ul>
<p><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>， 同类资源（即编号相同的资源）一次申请完。</p>
<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p>eg：假设系统中共有10个资源，编号为 1, 2, …… 10</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-45-16.png" alt=""></p>
<p>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。 因此，不可能出现所有进程都阻塞的死锁现象<br>
【<strong>我的疑问</strong>，假设现在有P1,P2,P3,P4,P5，他们需要任意三个资源才能运行，这个时候他们几乎同时进行申请资源，第一轮P1[1]，p2[2]，p3[3]，p4[4]，p5[5]，第二轮P1[1,6]，p2[2,7]，p3[3,8]，p4[4,9]，p5[5,10]，这不是死锁了吗？】<br>
【上面的问题，首先资源不同的编号的资源不相同，错啦】<br>
【证明：反证法，假设资源编完号了（10个资源，10个进程），有以下死锁情况：(资源&lt;a，b，…，j&gt;，已经按&lt;1, 2, …,10&gt;有序编号了)<br>
P1需要a资源，但是a资源被P2占有了；<br>
P2需要b资源，但是b资源被P3占有了；<br>
…<br>
p10需要j资源，但是j资源被P1占有了。<br>
那么这里对于P1进程，拥有了j(10)，资源，但是却还申请a(1)资源，矛盾<br>
大概是这个意思。】</p>
<p>该策略的缺点： 1. 不方便增加新的设备，因为可能需要重新分配所有的编号； 2. 进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源浪费； 3. 必须按规定次序申请资源，用户编程麻烦。</p>
<hr>
<h2 id="2-4-3-死锁的处理策略——避免死锁">2.4.3 死锁的处理策略——避免死锁</h2>
<ul>
<li><strong><u>什么是安全序列</u></strong></li>
</ul>
<p>你是一位成功的银行家，手里掌握着100个亿的资金…<br>
有三个企业想找你贷款，分别是 企业B、企业A、企业T，为描述方便，简称BAT。<br>
B 表示：“大哥，我最多会跟你借70亿…”<br>
A 表示：“大哥，我最多会跟你借40亿…”<br>
T 表示：“大哥，我最多会跟你借50亿…”<br>
<strong>然而…江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了</strong></p>
<p>刚开始，BAT三个企业分别从你这儿借了 20、10、30 亿 …</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-33-04.png" alt=""></p>
<p>手里还有：40亿<br>
此时… B 还想借 30 亿，你敢借吗？ 假如答应了B的请求……</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p>
<p>手里还有：10亿<br>
只剩下10亿，如果BAT都提出再借20亿的请求，那么任何一个企业的需求都得不到满足…<br>
【借30亿是不安全的】</p>
<p>手里还有：40亿<br>
此时… A 还想借 20 亿，你敢借吗？假如答应了A的请求……</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-38-30.png" alt=""></p>
<p>手里还有：20亿<br>
可以先把20亿全部借给T，等T把钱全部还回来了，手里就会有20+30=50亿，再把这些钱全借给B，B还钱后总共有 50+20=70亿，最后再借给A【之后按T → B → A的顺序借钱是OK的】</p>
<p>或者，先借给A 10亿，等A还钱了手里就 有 20+30 = 50 亿，再给 T 20亿，等T还钱 了就有 50+30 = 80 亿，最后再给 B 借…【按A → T → B的顺序借钱也是OK的】</p>
<hr>
<ul>
<li><strong><u>安全序列、不安全状态、死锁的联系</u></strong></li>
</ul>
<p>给B借30亿是不安全的…之后手里只剩10亿，如果BAT都提出再借20亿的请求，那么任何一个企 业的需求都得不到满足…</p>
<p>给A借 20 亿是安全的，因为存在 T → B → A 这样的<strong>安全序列</strong>。</p>
<p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>
如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>【如下解释】，不过我们在分配资源之前总是要考虑到最坏的情况。<br>
【系统也有可能重新回到安全状态】：手里还有10亿，比如A先归还了10亿，那么就有安全序列 B → A → T</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p>
<p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）<br>
因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想。</p>
<hr>
<ul>
<li><strong><u>银行家算法</u></strong></li>
</ul>
<p>银行家算法是荷兰学者 Dijkstra【还提出了信号量机制】 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能 满足所有客户需要的情况。后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p>
<p><strong>核心思想</strong>：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p>思考：BAT 的例子中，只有一种类型的资源——钱，但是在计算机系统中会有多种多样的资源，应该怎么把算法拓展为多种资源的情况呢？</p>
<p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0~P4，3 种资源 R0~R2，初始数量为 (<strong>10, 5, 7</strong>)，则某一时刻的情况可表示如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-52-53.png" alt=""></p>
<p>【查看上表的情况是否安全】：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-14-26.gif" alt=""></p>
<p>依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求<br>
可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)<br>
依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求<br>
可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)<br>
依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求……<br>
。。。<br>
以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列（P1,P3,P0,02,P4)<br>
该算法称为<strong>安全性算法</strong>。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。 实际做题时可以更快速的得到安全序列。</p>
<p><strong>实际做题（手算）时</strong>可用更快速的方法找到一个安全序列： 经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 可把 P1、P3 先加入安全序列。 (2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3) 剩下的 P0、P2、P4 都可被满足。同理，这些进程都可以加入安全序列。</p>
<p>于是，5个进程全部加入安全序列，说明此时系统<strong>处于安全状态</strong>，暂<strong>不可能发生死锁</strong>。</p>
<p>【不安全序列的例子】资源总数 (10, 5, 7) ，剩余可用资源  (3,3,2)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-20-55.png" alt=""></p>
<p>无法找到任何一个安全序列，说明此时系统<strong>处于不安全状态</strong>，<strong>有可能发生死锁</strong>。<br>
经对比发现， (3,3,2)可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 可把 P1、P3 先加入安全序列。<br>
(2, 0, 0) +(2, 1, 1) +(3,3, 2) =(7, 4, 3)<br>
剩下的 P0 需要(8,4,3)，P2需要(6,5,0)，P4 需要(4,3,4)<br>
任何一个进程都不能被完全满足。</p>
<p>【<strong>代码实现</strong>】</p>
<p>假设<strong>系统中有 n 个进程，m 种资源</strong><br>
每个进程在运行前先声明对各种资源的最大需求数， 则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的<strong>最大需求数</strong>。不妨称为最大需求 <strong>矩阵 Max</strong>，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源 Rj。同理，系统可以用一个 n*m 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。Max – Allocation = <strong>Need 矩阵</strong>，表示各进程最多还需要多少各类资源。 另外，还要用一个<strong>长度为m的一维数组 Available</strong> 表示当前系统中还有多少可用资源。 某进程Pi向系统申请资源，可用一个长度为m的一维数组 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">R</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">s</mi><msub><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">i</mi></msub></mrow><annotation encoding="application/x-tex">\mathsf{Request_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathsf">Reques</span><span class="mord"><span class="mord mathsf">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3256em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></strong> 表示本次申请的各种资源量。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-33-25.png" alt=""></p>
<p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：<br>
① 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">R</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">s</mi><msub><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">i</mi></msub></mrow><annotation encoding="application/x-tex">\mathsf{Request_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathsf">Reques</span><span class="mord"><span class="mord mathsf">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3256em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>[j] ≤ Need[i, j] (0≤j≤m)便转向②；否则认为出错。<br>
② 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">R</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">q</mi><mi mathvariant="sans-serif">u</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">s</mi><msub><mi mathvariant="sans-serif">t</mi><mi mathvariant="sans-serif">i</mi></msub></mrow><annotation encoding="application/x-tex">\mathsf{Request_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathsf">Reques</span><span class="mord"><span class="mord mathsf">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3256em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>[j] ≤ Available[j] (0≤j≤m)，便转向③ ；否则表示尚无足够资源，Pi必须等待。<br>
③ 系统试探着把资源分配给进程Pi【代码如下】，并修改相应的数据（<strong>并非真的分配，修改数值只是为了做预判</strong>）<br>
④ 操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统<strong>是否处于安全状态</strong>。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配资源</span></span><br><span class="line">Available = Available - Request_i;</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Request_i[j];</span><br><span class="line">Need[i, j] = Need[i, j] – Request_i[j]</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>数据结构：<br>
长度为 m 的一维数组 Available 表示还有多少可用资源<br>
n*m 矩阵 Max 表示各进程对资源的最大需求数<br>
n*m 矩阵 Allocation 表示已经给各进程分配了多少资源<br>
Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>
用长度为 m 的一位数组 Request 表示进程此次申请的各种资源</p>
<p>银行家算法步骤：<br>
① 检查此次申请是否超过了之前声明的最大需求数<br>
② 检查此时系统剩余的可用资源是否还能满足这次请求<br>
③ 试探着分配，更改各数据结构<br>
④ 用安全性算法检查此次分配是否会导致系统进入不安全状态</p>
<p>安全性算法步骤：<br>
检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，<br>
并把该进程持有的资源全部回收。<br>
不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
<hr>
<h2 id="2-4-4-死锁的处理策略——检测和解除">2.4.4 死锁的处理策略——检测和解除</h2>
<blockquote>
<p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很<strong>可能发生死锁</strong>。在这种情况下，系统应当提供两个算法：<br>
① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。<br>
② 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p>
</blockquote>
<ul>
<li><strong><u>死锁的检测</u></strong></li>
</ul>
<p>为了能对系统是否已发生了死锁进行检测，必须：<br>
① 用<strong>某种数据结构</strong>来保存资源的请求和分配信息；<br>
② 提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</p>
<p><strong>数据结构：资源分配图</strong></p>
<ul>
<li><strong>两种结点</strong>
<ul>
<li>进程结点<br>
对应一个进程</li>
<li>资源结点<br>
对应一类资源</li>
</ul>
</li>
<li><strong>两种边</strong>
<ul>
<li>进程结点→资源结点<br>
表示进程想申请几个资源 (每条边代表一个)</li>
<li>资源结点→进程结点<br>
表示已经为进程分配了几个资源 (每条边代表一个)</li>
</ul>
</li>
</ul>
<p>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那 么这个进程暂时是不会阻塞的，可以顺利地执行下去。 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-54-52.gif" alt=""></p>
<p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-57-00.gif" alt=""></p>
<p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong><br>
<strong>最终还连着边的那些进程就是处于死锁状态的进程</strong>。</p>
<p><strong>检测死锁的算法</strong>：<br>
1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中， P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p>
<p>2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能<strong>消去途中所有的边</strong>，则称该图是<strong>可完全简化的</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p>
<p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化的</strong>，那么此时系统<strong>死锁</strong></p>
<hr>
<ul>
<li><strong><u>死锁的解除</u></strong></li>
</ul>
<p>一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p>
<p>解除死锁的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
<p>如何决定“对谁动手”</p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<hr>
<h1>第三章 内存管理</h1>
<h2 id="3-1-1-内存的基础知识">3.1.1 内存的基础知识</h2>
<ul>
<li><strong><u>什么是内存？有何作用？</u></strong></li>
</ul>
<p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的速度矛盾</p>
<p>思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p>
<p>方案：给内存的存储单元编地址</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_16-10-10.png" alt=""></p>
<p>内存地址从0 开始，<strong>每个地址对应一个存储单元</strong></p>
<p>内存中也有一个一个的“小房间”，每个小房间就是一 个“<strong>存储单元</strong>”</p>
<p>如果计算机“<strong>按字节编址</strong>”， 则<strong>每个存储单元大小</strong>为 <strong>1字节</strong>，即 1B，即 8个二进制位</p>
<p>如果<strong>字长为16位</strong>的计算机 “<strong>按字编址</strong>”，则<strong>每个存储单元大小</strong>为 <strong>1个字</strong>；每个字的大小为 16 个二进制位</p>
<hr>
<ul>
<li><strong><u>补充知识：几个常用的数量单位</u></strong></li>
</ul>
<p>一台手机/电脑 有 4GB 内存，是什么意思？<br>
是指该内存中可以存放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span></span></span></span>个字节。如果是按字节编址的 话，也就是有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30} = 2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>个“小房间”</p>
<p>补充知识：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1</mn><mi>K</mi><mtext>（千）</mtext></mrow><annotation encoding="application/x-tex">2^{10} = 1K （千）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord cjk_fallback">（千）</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mtext>（兆，百万）</mtext></mrow><annotation encoding="application/x-tex">2^{20} = 1M （兆，百万）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">（兆，百万）</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><mn>1</mn><mi>G</mi><mtext>（十亿，千兆）</mtext></mrow><annotation encoding="application/x-tex">2^{30} = 1G （十亿，千兆）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord cjk_fallback">（十亿，千兆）</span></span></span></span></p>
<p>注：有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：指令的工作原理</u></strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH/?p=42&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">3.1_1_内存的基础知识_哔哩哔哩_bilibili</a></p>
<p>07:57-18:31</p>
<p>程序经过编译、链接 后生成的指令中指明的是逻辑地址（相对地址），即：相对于 进程的起始地址而言 的地址</p>
<p>指令使用的是逻辑地址（相对地址），那么<strong>如何装入内存</strong>无法确定。</p>
<p>接下来解决的就是<strong>如何把逻辑地址转化为最终的物理地址</strong></p>
<hr>
<ul>
<li><strong><u>装入的三种方式——绝对装入</u></strong></li>
</ul>
<p><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。</p>
<p>Eg：如果知道装入模块要从地址为100 的地方开始存放…</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-12.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-53.png" alt=""></p>
<p>绝对装入<strong>只适用于单道程序环境</strong>【此时还没有产生操作系统】。</p>
<p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p>
<p>【灵活性很低，换个电脑就无法执行了】</p>
<hr>
<ul>
<li><strong><u>装入的三种方式——可重定位装入</u></strong></li>
</ul>
<p><strong>静态重定位</strong>：又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-53-04.png" alt=""></p>
<p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</p>
<p>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p>
<p>用于早期的<strong>多道批处理操作系统</strong></p>
<hr>
<ul>
<li><strong><u>装入的三种方式——动态运行时装入</u></strong></li>
</ul>
<p><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-57-03.png" alt=""></p>
<p>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。</p>
<p>并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
<p>用于<strong>现代操作系统</strong></p>
<hr>
<ul>
<li><strong><u>从写程序到程序运行</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-59-27.png" alt=""></p>
<p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<strong>翻译为机器语言</strong>）</p>
<p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p>
<p><strong>装入（装载）</strong> ：<strong>由装入程序将装入模块装入内存运行</strong></p>
<hr>
<ul>
<li><strong><u>链接的三种方式</u></strong></li>
</ul>
<p><strong>静态链接</strong>：在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）， 之后不再拆开。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-03-22.png" alt=""></p>
<p><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接的链接方式。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-13.png" alt=""></p>
<p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-39.png" alt=""></p>
<hr>
<h2 id="3-1-2-内存管理的概念">3.1.2 内存管理的概念</h2>
<ul>
<li><strong><u>内存空间的分配与回收</u></strong></li>
</ul>
<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-08-54.png" alt=""></p>
<p>很多位置都可以放， 那应该放在哪里？<br>
操作系统要怎么记录哪些内存区域已经被分配出去了， 哪些又还空闲？<br>
当进程运行结束之后，如何将进程占用的内存空间回收？</p>
<ol>
<li>操作系统负责<strong>内存空间的分配与回收</strong></li>
</ol>
<hr>
<ul>
<li><strong><u>内存空间的扩展</u></strong></li>
</ul>
<p>游戏 GTA 的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 4GB，但为什么这个游戏可以顺利运行呢？——虚拟技术（操作系统的虚拟性）</p>
<ol start="2">
<li>操作系统需要提供某种技术<strong>从逻辑上对内存空间进行扩充</strong></li>
</ol>
<hr>
<ul>
<li><strong><u>地址转换</u></strong></li>
</ul>
<p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p>
<ol start="3">
<li>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></li>
</ol>
<p><strong>三种装入方式</strong>：</p>
<ul>
<li>绝对装入【单道程序阶段，此时还没产生操作系统】<br>
编译时产生绝对地址</li>
<li>可重定位装入【用于早期的多道批处理操作系统】<br>
装入时将逻辑地址转化为物理地址</li>
<li>动态运行时装入【现代操作系统】<br>
运行时将逻辑地址转化为物理地址，需设计重定位寄存器</li>
</ul>
<hr>
<ul>
<li><strong><u>内存保护</u></strong></li>
</ul>
<ol start="4">
<li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-19-44.png" alt=""></p>
<p>内存保护可采取两种方法：<br>
方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-21-03.png" alt=""></p>
<p>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定 位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-22-21.png" alt=""></p>
<hr>
<h2 id="3-1-3-覆盖与交换">3.1.3 覆盖与交换</h2>
<blockquote>
<p>内存空间的扩充</p>
<ul>
<li>覆盖技术</li>
<li>交换技术</li>
<li>虚拟存储技术</li>
</ul>
</blockquote>
<ul>
<li><strong><u>覆盖技术</u></strong></li>
</ul>
<p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。</p>
<p>后来人们引入了<strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong></p>
<p>覆盖技术的思想：将<strong>程序分为多个段</strong>（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p>
<p>内存中分为<strong>一个“固定区”</strong> 和<strong>若干个“覆盖区”</strong> 。 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>
<p>不常用的段放在“<strong>覆盖区</strong>”，<strong>需要用到时调入内存， 用不到时调出内存</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-17-36.png" alt=""></p>
<p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一 个覆盖区</p>
<p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。<br>
<strong>缺点：对用户不透明</strong>，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。</p>
<hr>
<ul>
<li><strong><u>交换技术</u></strong></li>
</ul>
<p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-20-50.png" alt=""></p>
<p><strong>中级调度（内存调度）</strong> ，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>暂时换出外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<ol>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？</li>
</ol>
<p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节 后即可理解）。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-33-45.png" alt=""></p>
<ol start="2">
<li>什么时候应该交换？</li>
</ol>
<p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</p>
<ol start="3">
<li>应该换出哪些进程？</li>
</ol>
<p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… （<strong>注意：PCB 会常驻内存</strong>，不会被换出外存）</p>
<hr>
<h2 id="3-1-4-连续分配管理方式">3.1.4 连续分配管理方式</h2>
<blockquote>
<p><strong>连续分配</strong>：指为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</p>
</blockquote>
<ul>
<li><strong><u>单一连续分配</u></strong></li>
</ul>
<p>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-08-53.png" alt=""></p>
<p>系统区通常位于内存的低地址部分，用于存放操作系统<br>
相关数据；用户区用于存放用户进程相关数据。</p>
<p>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区 空间。</p>
<p>优点：实现简单；<strong>无外部碎片</strong>【后面说】；可以采用覆盖技术扩充<br>
内存；不一定需要采取内存保护（eg：早期的 PC 操作 系统 MS-DOS）。</p>
<p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>【分配给某进程的内存区域中，如果有些部分没有用 上，就是“内部碎片”】；存储器利用率极低。</p>
<hr>
<ul>
<li><strong><u>固定分区分配</u></strong>
<ul>
<li>分区大小相等</li>
<li>分区大小不相等</li>
</ul>
</li>
</ul>
<p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰， 于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-17-32.png" alt=""></p>
<p>分区大小相等：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序）</p>
<p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）</p>
<p>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-19-44.png" alt=""></p>
<p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表， 从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”。</p>
<p>优点：实现简单，<strong>无外部碎片</strong>。</p>
<p>缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. <strong>会产生内部碎片</strong>，内存利用率低</p>
<hr>
<ul>
<li><strong><u>动态分区分配</u></strong></li>
</ul>
<p><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时， <strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>系统要用什么样的数据结构记录内存的使用情况？</li>
</ol>
<p>两种数据结构：</p>
<ul>
<li><strong>空闲分区表</strong><br>
每个空闲分区对应 一个表项。表项中包含分区号、 分区大小、分区起始地址等信息</li>
<li><strong>空闲分区链</strong><br>
每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-37-50.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p>
<ol start="2">
<li>当很多个空闲分区都能满足需求时， 应该选择哪个分区进行分配？</li>
</ol>
<p>上图中有三个分区，现有进程5 (4MB)，应该用最大的分区进行分配？还是用最小的分区进行分配？又或是用地址最低的部分进行分配？</p>
<p>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p>
<p>下个小节会介绍四种<strong>动态分区分配算法</strong>…</p>
<ol start="3">
<li>如何进行分区的分配与回收操作？</li>
</ol>
<p><strong>分配</strong>情况1：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-41-39.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-41-51.png" alt=""></p>
<p><strong>分配</strong>情况2：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-44-10.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-44-16.png" alt=""></p>
<p><strong>回收</strong>情况1：回收区的后（前）面有一个相邻的空闲分区<br>
两个相邻的空闲分区合并为一个</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-47-32.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-47-35.png" alt=""></p>
<p><strong>回收</strong>情况2：回收区的前、后各有一个相邻的空闲分区<br>
三个相邻的空闲分区合并为一个</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-52-23.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-52-27.png" alt=""></p>
<p><strong>回收</strong>情况3：回收区的前、后都没有相邻的空闲分区</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-54-07.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-54-20.png" alt=""></p>
<p>新增一个表项<br>
注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</p>
<p>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。</p>
<p><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。</p>
<p><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-32-27.png" alt=""></p>
<p>如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。</p>
<p>可以通过<strong>紧凑（拼凑，Compaction）</strong> 技术来解决外部碎片。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-08_9-34-40.gif" alt=""></p>
<p>思考动态分区分配应使用哪种装方式？“紧凑”之后需要做什么处理？<br>
【动态运行时装入；需要修改重定位寄存器的起始地址】</p>
<hr>
<h2 id="3-1-5-动态分区分配算法">3.1.5 动态分区分配算法</h2>
<blockquote>
<p><strong>动态分区分配算法</strong>：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<ul>
<li><strong>首次适应算法</strong>（First Fit）</li>
<li><strong>最佳适应算法</strong>（Best Fit）</li>
<li><strong>最坏适应算法</strong>（Worst Fit）</li>
<li><strong>临近适应算法</strong>（Next Fit）</li>
</ul>
</blockquote>
<ul>
<li><u><strong>首次适应算法（First Fit）</strong></u></li>
</ul>
<p><strong>算法思想</strong>：每次都<strong>从低地址开始</strong>查找，找到第一个能满足大小的空闲分区。</p>
<p><strong>如何实现：空闲分区以 <u>地址</u> 递增 的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-37-50.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p>
<hr>
<ul>
<li><strong><u>最佳适应算法（Best Fit）</u></strong></li>
</ul>
<p><strong>算法思想</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区， 即，优先使用更小的空闲区。</p>
<p><strong>如何实现</strong>：空闲分区<strong>按 <u>容量</u> 递增 次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-04-13.png" alt=""></p>
<p><strong>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</strong></p>
<hr>
<ul>
<li><strong><u>最坏适应算法（Worst Fit）</u></strong></li>
</ul>
<p>又称 <strong>最大适应算法（Largest Fit）</strong></p>
<p><strong>算法思想</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p><strong>如何实现</strong>：空闲分区<strong>按 <u>容量</u> 递减 次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_09-38-13.png" alt=""></p>
<p><strong>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的 空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></p>
<hr>
<ul>
<li><strong><u>邻近适应算法（Next Fit）</u></strong></li>
</ul>
<p><strong>算法思想</strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p><strong>如何实现</strong>：空闲分区<strong>以 <u>地址</u> 递增 的顺序排列</strong>（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-14-07.png" alt=""></p>
<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区 都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
<p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">首次适应</td>
<td><strong>从头到尾找适合的分区</strong></td>
<td>空闲分区以地址递增次序排列</td>
<td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">最佳适应</td>
<td><strong>优先使用更小的分区，以保留更多大分区</strong></td>
<td>空闲分区以容量 递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片；<strong>算法开销大</strong>， 回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td style="text-align:center">最坏适应</td>
<td><strong>优先使用更大的分区，以防止产生太小的不可用的碎片</strong></td>
<td>空闲分区以容量 递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程；<strong>算法开销大</strong> （原因同上）</td>
</tr>
<tr>
<td style="text-align:center">邻近适应</td>
<td><strong>由首次适应演变而来，每次从上次查找结束位置开始查找</strong></td>
<td>空闲分区以地址 递增次序排列 （可排列成循环 链表）</td>
<td>不用每次都从低地址的小分区开始检索。 <strong>算法开销小</strong>（原因同首次适应算法）</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="3-1-6-基本分页存储管理的基本概念">3.1.6 基本分页存储管理的基本概念</h2>
<blockquote>
<p><strong>连续分配</strong>：为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</p>
<p><strong>非连续分配</strong>：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</p>
</blockquote>
<ul>
<li><strong><u>什么是分页存储</u></strong></li>
</ul>
<p>将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个“<strong>页框</strong>”（<strong>页框</strong>=<strong>页帧</strong>=<strong>内存块</strong>=<strong>物理块</strong>=<strong>物理页面</strong>）。每个页框有一个编号，即“<strong>页框号</strong>”（<strong>页框号</strong>=<strong>页帧号</strong>=<strong>内存块号</strong>=<strong>物理块号</strong>=<strong>物理页号</strong>），页框号<strong>从0开始</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-49-26.png" alt=""></p>
<p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个部分， 每个部分称为一个“<strong>页</strong>”或“<strong>页面</strong>” 。每个页面也有一个编号， 即“<strong>页号</strong>”，页号也是<strong>从0开始</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-51-48.png" alt=""></p>
<p>Tips：初学易混——页、页面 vs 页框、页帧、物理页</p>
<p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p>
<p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p>
<p>（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费）</p>
<hr>
<ul>
<li><strong><u>重要的数据结构——页表</u></strong></li>
</ul>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。 注：页表通常存在PCB（进程控制块）中<br>
【答题推荐使用<s>内存块号</s>页框号】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-56-52.png" alt=""></p>
<ol>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个<strong>页表项</strong></li>
<li>每个<strong>页表项</strong>由“页号”和“块号”组成</li>
<li>页表记录进程<strong>页面</strong>和实际存放的<strong>内存块</strong>之间的<strong>映射关系</strong></li>
<li>每个页表项的长度是相同的</li>
</ol>
<hr>
<ul>
<li><strong><u>问题一：每个页表项占多少字节？</u></strong></li>
</ul>
<p>每个页表项多大？占几个字节？<br>
如何通过页表实现逻辑地址到物理地址的转换？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节？</p>
<p>内存块大小=页面大小=4KB= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B<br>
→4GB 的内存总共会被分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} / 2^{12} = 2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个内存块<br>
→内存块号的范围应该是 0 ~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1<br>
→内存块号至少要用 20 bit 来表示<br>
→至少要用3B来表示块号（3*8=24bit）【注意：页表记录的只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J*内存块大小】<br>
→由于<strong>页号</strong>是<strong>隐含</strong>的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B【0~n页】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-08-08.png" alt=""></p>
<p>页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）<br>
假设页表中的各页表项从内存地址为 X 的地方开始连续存放…<br>
如何找到页号为 i 的页表项？<br>
i 号页表项的存放地址 = X + 3*i 因此，页表中的<strong>页号</strong>可以是<strong>隐含</strong>的，即<strong>页号不占用存储空间</strong></p>
<hr>
<ul>
<li><strong><u>问题二：如何实现地址的转换</u></strong></li>
</ul>
<p>进程在内存中连续存放时，操作系统是如何实现逻辑地址到物理地址的转换的？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-12-38.png" alt=""></p>
<p>将进程地址空间<strong>分页</strong>之后，操作系统该如何实现逻辑地址到物理地址的转换？</p>
<p>特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p>
<p>如果要访问逻辑地址 A，则<br>
① 确定逻辑地址A 对应的“<strong>页号</strong>”   ？<br>
②找到P号页面在内存中的起始地址（需要查页表） 【前面介绍了】<br>
③确定逻辑地址A 的“<strong>页内偏移量</strong>”    ？</p>
<p>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W</p>
<hr>
<ul>
<li><strong><u>子问题：如何确定一个逻辑地址对应的页号、页内偏移量？</u></strong></li>
</ul>
<p>Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应的页号、页内偏移量是多少？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-39-39.png" alt=""></p>
<p>如何计算：<br>
<strong>页号</strong> = 逻辑地址 / 页面长度 （取除法的<strong>整数</strong>部分）<br>
<strong>页内偏移量</strong> = 逻辑地址 % 页面长度（取除法的<strong>余数</strong>部分）</p>
<p>页号 = 110 / 50 = 2<br>
页内偏移量 = 110 % 50 = 10</p>
<p><strong>逻辑地址</strong> 可以拆分为（<strong>页号</strong>，<strong>页内偏移量</strong>）</p>
<p>通过页号查询页表，可知页面在内存中的起始地址<br>
页面在内存中的起始地址+页内偏移量 = 实际的物理地址</p>
<p>在计算机内部，地址是用二进制表示的， 如果<strong>页面大小</strong>刚好是 <strong>2 的整数幂</strong>，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>假设某计算机用32 个二进制位表示逻辑地址，页面大小为 4KB	= 212B = 4096B</p>
<p>0号页的逻辑地址范围应该是 0~4095，用二进制表示应该是：<br>
00000000000000000000<u>000000000000</u> ~<br>
00000000000000000000<u>111111111111</u></p>
<p>1号页的逻辑地址范围应该是 4096~8191，用二进制表示应该是：<br>
00000000000000000001<u>000000000000</u> ~<br>
00000000000000000001<u>111111111111</u></p>
<p>2号页的逻辑地址范围应该是 8192~12287，用二进制表示应该是：<br>
00000000000000000010<u>000000000000</u> ~<br>
00000000000000000010<u>111111111111</u></p>
<p>Eg：逻辑地址 2，用二进制表示应该是 00000000000000000000<u>000000000010</u><br>
页号 = 2/4096 = 0 = 00000000000000000000，<br>
页内偏移量 = 2%4096 = 2 = <u>000000000010</u></p>
<p>Eg：逻辑地址 4097，用二进制表示应该是 00000000000000000001<u>000000000001</u><br>
页号 = 4097/4096 = 1 = 00000000000000000001，<br>
页内偏移量 = 4097%4096 = 1 = <u>000000000001</u></p>
<p><strong>结论</strong>：如果每个页面大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址， 则<strong>末尾 K 位</strong>即为<strong>页内偏移量</strong>，<strong>其余</strong>部分就是<strong>页号</strong>，计算机硬件就 可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。</p>
<p>假设物理地址也用32个二进制位表示，则由于内存块的大小=页面大小，因此：<br>
0号内存块的起始物理地址是 00000000000000000000<u>000000000000</u><br>
1号内存块的起始物理地址是 00000000000000000001<u>000000000000</u><br>
2号内存块的起始物理地址是 00000000000000000010<u>000000000000</u><br>
3号内存块的起始物理地址是 00000000000000000011<u>000000000000</u></p>
<p>根据页号可以查询页表，而页表中记录的只是内存块号，而不是内存块的起始地址！<br>
<strong>J 号内存块的起始地址 = J * 内存块大小</strong></p>
<p>假设通过查询页表得知1号页面存放的内存块号是9（1001），则 9号内存块的起始地址 = 9*4096（4KB） = 00000000000000001001000000000000<br>
则逻辑地址4097对应的物理地址 = 页面在内存中存放的起始地址 + 页内偏移量 =（00000000000000001001<u>000000000001</u>）</p>
<p><strong>结论</strong>：如果页面大小刚好是2的整数幂，则只需把页表中记录的<strong>物理块号拼接上页内偏移量</strong>就能得到对应的<strong>物理地址</strong></p>
<hr>
<ul>
<li><strong><u>逻辑地址结构</u></strong></li>
</ul>
<p>分页存储管理的逻辑地址结构如下所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-55-48.png" alt=""></p>
<p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0~11位 为“<strong>页内偏移量</strong>”，或称“<strong>页内地址</strong>”；12~31 位为“<strong>页号</strong>”。</p>
<p><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>个内存单元</strong><br>
<strong>如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">2^M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span></span> 个页面</strong></p>
<p>【<strong>重要重要重要</strong>！！！】 <strong>页面大小↔页内偏移量位数 → 逻辑地址结构</strong></p>
<p>Tips：有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算：<br>
页号 = 逻辑地址 / 页面长度 （取除法的整数部分）<br>
页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</p>
<hr>
<h2 id="3-1-7-基本地址变换机构">3.1.7 基本地址变换机构</h2>
<blockquote>
<p>结合上一小节理解基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理和流程</p>
</blockquote>
<ul>
<li><strong><u>基本地址变换机构</u></strong></li>
</ul>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong> ，存放<strong>页表在内存中的起始地址F和页表长度M</strong>。 进程未执行时，页表的始址 和 页表长度 <strong>放在进程控制块（PCB）</strong> 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意：页面大小是2的整数幂<br>
设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-25-06.png" alt=""></p>
<p>①计算页号 P 和页内偏移量W（ 如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</p>
<p>②比较页号P 和页表长度M，若 P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开 始的，而页表长度至少是1，因此 <strong>P=M 时也会越界</strong>）</p>
<p>③页表中页号P对应的<strong>页表项地址 = 页表起始地址F + 页号P * 页表项长度</strong>，取出该页表项内容b， 即为内存块号。（注意区分<strong>页表项长度</strong>、<strong>页表长度</strong>、<strong>页面大小</strong>的区别。<strong>页表长度</strong>指的是这个页表中总共有几个页表项，即总共有几个页；<strong>页表项长度</strong>指的是每个页表项占多大的存储空间； <strong>页面大小</strong>指的是一个页面占多大的存储空间）</p>
<p>④计算 E = b * L + W，用得到的物理地址E 去访存。（如果内存块号、页面偏移量是用二进制表 示的，那么把二者拼接起来就是最终的物理地址了）</p>
<p>⑤访问目标内存单元</p>
<p><strong>例</strong>：若页面大小L 为 1K 字节，页号2对应的内存块号 b = 8，将逻辑地址 A=2500 转换为物理地址E。</p>
<p>等价描述：某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占10(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mi>B</mi><mo>=</mo><mn>1</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{10}B=1KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>)位</strong>，页号2对应的内存块号 b = 8， 将逻辑地址 A=2500 转换为物理地址E。</p>
<p>①计算页号、页内偏移量<br>
页号P = A/L = 2500/1024 = 2；<br>
页内偏移量 W = A%L = 2500%1024 = 452</p>
<p>②根据题中条件可知，页号2没有越界，其存放的内存块号 b = 8</p>
<p>③物理地址 E = b * L + W = 8 * 1024 + 425 = 8644</p>
<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong>。<strong>即，只要给出一个逻辑地址</strong>，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
<p>【<strong>一共两次访问内存的操作</strong>】</p>
<ol>
<li>查询页表</li>
<li>访问目标内存单元</li>
</ol>
<hr>
<ul>
<li><strong><u>对页表项大小的进一步探讨</u></strong></li>
</ul>
<p><strong>每个页表项的长度是相同的，页号是“隐含”的</strong></p>
<p>Eg：假设某系统物理内存大小为 4GB，页面大小为 4KB的内存总共会被分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} / 2^{12} = 2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个内存块，因此内存块号的范围应该是 0 ~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1，因此至少要 20 个二进制位才能表示这么多的内存块号，因此至少要 3个字节才够 （每个字节 8 个二进制位，3个字节共 24 个二进制位）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-43-56.png" alt=""></p>
<p>各页表项会按顺序连续地存放在内存中，如果该页表在内存中存放的起始地址为 X ，则 M 号页对应的页表项是存放在内存地址为 X + 3*M</p>
<p>一个页面为 4KB，则每个页框可以存放 4096/3 = 1365 个 页表项，但是这个页框会剩余 4096 % 3 = 1 B 页内碎片 因此，1365 号页表项存放的地址为 X + 3*1365 <strong>+ 1</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-45-17.png" alt=""></p>
<p>如果每个页表项占 4字节，则每个页框刚好可存放 1024 个页表项<br>
1024 号页表项虽然是存放在下一个页框中的，但是它 的地址依然可以用 X + 4*1024 得出</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_13-36-12.png" alt=""></p>
<p>【进程页表通常是<strong>装在连续的内存块中</strong>的】</p>
<p><strong>结论</strong>：理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询， 常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。</p>
<hr>
<h2 id="3-1-8-具有快表的地址变换机构">3.1.8 具有快表的地址变换机构</h2>
<blockquote>
<p>快表：是基本地址变换机构的改进版本</p>
</blockquote>
<ul>
<li><strong><u>什么是快表（TLB）</u></strong></li>
</ul>
<p><strong>快表</strong>，又称<strong>联想寄存器</strong>（<strong>TLB</strong>，translation lookaside buffer），是一种<strong>访问速度比内存快很多的高速缓存</strong>（<strong>TLB不是内存</strong>！），用来<strong>存放最近访问的页表项的副本</strong>，可以加速地址变换的速度。 与此对应，内存中的页表常称为<strong>慢表</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-57-38.png" alt=""></p>
<p>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p>
<hr>
<ul>
<li><strong><u>思考：能否把整个页表都放在TLB中？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p><strong>贵！</strong></p>
<hr>
<ul>
<li><strong><u>引入快表后，地址的变换过程</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_16-48-08.png" alt=""></p>
<p>① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此， 若<strong>快表命中</strong>，则访问某个逻辑地址仅需<strong>一次访存</strong>【快表不是内存】即可。</p>
<p>③ 如果没有找到匹配的页号，则需要<strong>访问内存中的页表</strong>，找到对应页表项，得到页面存放的内存块 号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此， 若<strong>快表未命中</strong>，则访问某个逻辑地址需要<strong>两次访存</strong>（<strong>注意：在找到页表项后，应同时将其存入快表</strong>， 以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p>
<p><strong>例</strong>：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？<br>
(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us<br>
有的系统支持<strong>快表和慢表同时查找</strong>，如果是这样，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 = 110.9 us<br>
若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us<br>
显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<p>【快表和慢表同时查找】：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_16-59-23.png" alt=""></p>
<hr>
<ul>
<li><strong><u>局部性原理</u></strong></li>
</ul>
<p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再 次被访问。（因为程序中存在大量的循环）</p>
<p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p>
<p>上小节介绍的<strong>基本地址变换机构</strong>中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，<strong>可能连续很多次查到的都是同一个页表项</strong></p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>地址变换过程</th>
<th>访问一个逻辑地 址的访存次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本地址变换机构</td>
<td>①：算页号、页内偏移量 <br />②：检查页号合法性 <br />③：查页表，找到页面存放的内存块号 <br />④：根据内存块号与页内偏移量得到物理地址 <br />⑤：访问目标内存单元</td>
<td><strong>两次访存</strong></td>
</tr>
<tr>
<td>具有快表的地址变换机构</td>
<td>①：算页号、页内偏移量 <br />②：检查页号合法性 <br />③：查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤； 若未命中则进行④ <br />④：查页表，找到页面存放的内存块号，并且将页表项复制到快表中 <br />⑤：根据内存块号与页内偏移量得到物理地址 <br />⑥：访问目标内存单元</td>
<td>快表<strong>命中</strong>，只需 <strong>一次</strong>访存 快表<br /><strong>未命中</strong>，需要<strong>两次</strong>访存</td>
</tr>
</tbody>
</table>
<p>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p>
<hr>
<h2 id="3-1-9-两级页表">3.1.9 两级页表</h2>
<ul>
<li><strong><u>单级页表存在的问题</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-56-52.png" alt=""></p>
<p>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B。</p>
<p>4KB = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，因此页内地址要用12位表示，剩余 20 位表示页号。<br>
因此，该系统中用户进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 页。相应的，一个进程的页表中，最多会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> = 1M = 1,048,576 个页表项，所以一个页表最大需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> * 4B = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> B，共需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span>/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页框存储该页表。<br>
根据页号查询页表的方法：K 号页对应的页表项存放位置 = 页表始址 + K * 4 要在<strong>所有的页表项都连续存放</strong>的基础上才能用这种方法找到页表项</p>
<p><strong>第一个问题</strong>：需要专门给进程分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> = 1024 个连续的页框来存放它的页表【与自身离散存储的优点相违背】</p>
<p><strong>第二个问题</strong>：根据局部性原理可知，很多时候，<strong>进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存</strong>。</p>
<hr>
<ul>
<li><strong><u>如何解决单级页表的问题？</u></strong></li>
</ul>
<p><strong>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</strong></p>
<p>思考:我们是如何解决进程在内存中必须连续存储的问题的?</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置<br>
同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</p>
<p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组 (比如上个例子中，页面大小4KB，<br>
每个页表项 4B，每个页面可存放 1K 个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中)</p>
<p>另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>（408常用），或称<strong>外层页表</strong>，或称<strong>顶层页表</strong></p>
<p>看本小节下面内容 《<strong>两级页表的原理、地址结构</strong>》</p>
<p><strong>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</strong></p>
<p>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>
<p>【实现】可以在页表增加标志位，如下图：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-20-54.png" alt=""></p>
<p>若想访问的页面不在内存中，则产生缺页中断（内中断/异常）， 然后将目标页面从外存调入内存</p>
<hr>
<ul>
<li><strong><u>两级页表的原理、地址结构</u></strong></li>
</ul>
<p>32位逻辑地址空间，页表项大小为4B，页面大小为 4KB，则页内地址占12位</p>
<p>单级页表结构的逻辑地址结构：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_11-55-48.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-02-11.png" alt=""></p>
<p>进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 个页面， 用 20 位二进制刚好可以 表示 0~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> -1 个页号。 每个页面可存放 4KB/4B = 1K = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> = 1024 个页表项</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-07-42.png" alt=""></p>
<p>套娃，<strong>两级页表</strong>结构如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-11-59.png" alt=""></p>
<p><strong>例</strong>：将逻辑地址 (0000000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-16-09.png" alt=""></p>
<p>如上图：</p>
<p>① 按照地址结构将逻辑地址拆分成三部分</p>
<p>② 从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p>
<p>③ 根据二级页号查二级页表，找到最终想访问的内存块号</p>
<p>④ 结合页内偏移量得到物理地址</p>
<p>最终要访问的内存块号为4 该内存块的起始地址为 4*4096 = 16384 页内偏移量为 4095<br>
最终的物理地址为 16384 + 4095= 20479</p>
<hr>
<ul>
<li><strong><u>需要注意的几个细节</u></strong></li>
</ul>
<ol>
<li>若分为两级页表后，页表依然很长，则可以采用更多级页表，<strong>各级页表的大小不能超过一个页面</strong></li>
</ol>
<p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p>
<p>页面大小 = 4KB =<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，按字节编址，因此页内偏移量为12位<br>
页号 = 40 - 12 = 28 位<br>
【<strong>问题</strong>：这里取顶，应该是取到整个字节，还是更要取到2的整数倍，比如23位的话，是取到3B呢，还是4B呢？看看考研什么要求吧】<br>
页面大小 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>B，页表项大小 = 4B ，则每个页面可存放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> / 4 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项<br>
因此各级页表最多包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项，需要 10 位二进制位才能映射到 210 个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_23-26-00.png" alt=""></p>
<p>如果只分为两级页表，则一级页号占 18 位， 也就是说页目录表中最多可能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">2^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span>个页表项， 显然，一个页面是放不下这么多页表项的。</p>
<ol start="2">
<li>两级页表的<strong>访存次数</strong>分析（假设没有快表机构）<br>
第一次访存：访问内存中的页目录表<br>
第二次访存：访问内存中的二级页表<br>
第三次访存：访问目标内存单元<br>
<strong>规律</strong>：N级页表访问一个逻辑地址需要N+1次访存</li>
</ol>
<hr>
<h2 id="3-1-10-基本分段存储管理方式">3.1.10 基本分段存储管理方式</h2>
<blockquote>
<p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同</p>
</blockquote>
<p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名（在低级语言 中，程序员使用段名来编程），<strong>每段从0开始编址</strong></p>
<p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-01-28.png" alt=""></p>
<p>由于是按逻辑功能模块划分，用户<strong>编程更方便，程序的可读性更高</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1, [D] | &lt;A&gt;; // 将分段D中A单元内的值读入寄存器1 </span><br><span class="line">STORE 1, [X] | &lt;B&gt;; // 将寄存器1的内容存入X 分段的B单元中</span><br></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-21-28.png" alt=""></p>
<p><strong>段号的位数决定了每个进程最多可以分几个段</strong><br>
<strong>段内地址位数决定了每个段的 最大长度 是多少</strong></p>
<p>在上述例子中，若系统是按字节寻址的，则<br>
段号占16位，因此在该系统中，每个进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64K 个段<br>
段内地址占 16位，因此每个段的最大长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64KB。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-23-44.png" alt=""></p>
<p>写程序时使用的 段名 [D]、[X] 会被编译程序翻译成对应段号<br>
&lt;A&gt;单元、&lt;B&gt;单元会被编译程序翻译成段内地址</p>
<hr>
<ul>
<li><strong><u>段表</u></strong></li>
</ul>
<p>问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“<strong>段表</strong>”。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-26-31.png" alt=""></p>
<ol>
<li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置</strong>（又称 “<strong>基址</strong>”）和段的长度。</li>
<li><strong>各个段表项的长度是相同的</strong>。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位 即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16(段长)+32(基址长度) = 48位，即6B。由于段表项长度相同，因此<strong>段号可以是隐含的，不占存储空间</strong>。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6</li>
</ol>
<hr>
<ul>
<li><strong><u>地址变换</u></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1, [D] | &lt;A&gt;; // 将分段D中A单元内的值读入寄存器1 </span><br></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-33-16.png" alt=""></p>
<p>经过编译程序编译后，形成等价的机器指令： “取出段号为2，段内地址为 1024 的内存单元中的内容，放到寄存 器1中”</p>
<p>CPU执行指令时需要将逻辑地址变换为物理地址:<br>
机器指令中的逻辑地址用二进制表示： 0000000000000010<u>0000000100000000</u></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_13-44-53.png" alt=""></p>
<hr>
<ul>
<li><strong><u>分段、分页管理的对比</u></strong></li>
</ul>
<p><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。</p>
<p><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</p>
<p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p>
<p><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-39-52.png" alt=""></p>
<p><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名【我的理解是：相当于汇编语言，你自己设置了数据段，分页只知道地址就行了，分段就自己分的段 + 偏移地址】，也要给出段内地址。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-39-56.png" alt=""></p>
<p><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong>。<br>
不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的【比如，有一个代码段只是简单的输出 “Hello World！”】。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）<br>
【分析：】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-50-48.png" alt=""></p>
<p>分段可以如下实现：设置标志位</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_14-52-06.png" alt=""></p>
<p>访问一个逻辑地址需要几次访存？<br>
<strong>分页</strong>（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共<strong>两次</strong>访存<br>
<strong>分段</strong>：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共<strong>两次</strong>访存<br>
与分页系统类似，分段系统中<strong>也可以引入快表机构</strong>，将近期访问过的段表项放到快表中，这样可以 <strong>少一次访问</strong>，加快地址变换速度。</p>
<hr>
<h2 id="3-1-11-段页式管理方式">3.1.11 段页式管理方式</h2>
<ul>
<li><strong><u>分页、分段的优缺点分析</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分页管理</td>
<td>内存空间利用率高，<strong>不会产生外部碎片</strong>，只会有少量的页内碎片</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便按照逻辑模块实现信息的共享和保护</td>
<td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td>
</tr>
</tbody>
</table>
<p>分段管理中产生的外部碎片也 可以用“<strong>紧凑</strong>”【上面介绍了，Ctrl + F吧！】来解决，只是需要付出较大的时间代价</p>
<hr>
<ul>
<li><strong><u>分段+分页=段页式管理</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-02-08.png" alt=""></p>
<p>将进程按逻辑模块分段，再将各段分页（如每个页面4KB）<br>
再将内存空间分为大小相同的内存块/页框/页帧/物理块<br>
进程前将各页面分别装入各内存块中</p>
<hr>
<ul>
<li><strong><u>段页式管理的逻辑地址结构</u></strong></li>
</ul>
<p><strong>分段</strong>系统的逻辑地址结构由段号和段内地址（段内偏移量）组成。如：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-04-36.png" alt=""></p>
<p><strong>段页式</strong>系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。如：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-05-24.png" alt=""></p>
<p><strong>段号的位数决定了每个进程最多可以分几个段</strong><br>
<strong>页号位数决定了每个段最大有多少页</strong><br>
<strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p>
<p>在上述例子中，若系统是按字节寻址的，则<br>
段号占16位，因此在该系统中，每个进程最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> = 64K 个段<br>
页号占4位，因此每个段最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> = 16页<br>
页内偏移量占12位，因此每个页面\每个内存块大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> = 4096 = 4KB</p>
<p>“分段”对用户是可见的，程 序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统 会根据段内地址自动划分页号和页内偏移量。 因此<strong>段页式</strong>管理的<strong>地址结构是二维的</strong>。</p>
<hr>
<ul>
<li><strong><u>段表、页表</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-14-33.png" alt=""></p>
<p>每个段对应一个段表项，每个段表项由段号、<strong>页表长度</strong>、<strong>页表存放块号（页表起始 地址）</strong> 组成。每个<strong>段表项长度相等，段号是隐含的</strong>。</p>
<p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-25-59.png" alt=""></p>
<p>访问一个逻辑地址所需访存次数:</p>
<p>第一次:查段表、第二次:查页表、第三次:访问目标单元</p>
<p>可引入快表机构，以<strong>段号</strong>和<strong>页号</strong>为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存</p>
<hr>
<h2 id="3-2-1-虚拟内存的基本概念">3.2.1 虚拟内存的基本概念</h2>
<blockquote>
<p>在传统存储管理方式的基础上引入了<strong>交换技术、覆盖技术</strong>，使得内存利用率有所提 升，并且能从逻辑上扩充内存容量。</p>
</blockquote>
<ul>
<li><strong><u>传统存储管理方式的特征、缺点</u></strong></li>
</ul>
<p>很多暂时用不到的数据也会长期占用内存， 导致内存利用率不高</p>
<p><strong>传统存储管理</strong></p>
<ul>
<li><strong>连续分配</strong>
<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
</ul>
</li>
<li><strong>非连续分配</strong>
<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>基本段页式存储管理</li>
</ul>
</li>
</ul>
<p><strong>一次性</strong>：<strong>作业必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题：<br>
① 作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong>；<br>
② 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。<br>
【可用虚拟存储技术解决问题】</p>
<p><strong>驻留性</strong>：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p>
<hr>
<ul>
<li><strong><u>局部性原理</u></strong></li>
</ul>
<p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p>
<p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p>
<hr>
<ul>
<li><strong><u>虚拟内存的定义和特征</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_12-57-38.png" alt=""></p>
<p><strong>高速缓存技术</strong>：使用频繁的数据放到更高速的存储器中</p>
<p>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>， 就可以让程序开始执行。</p>
<p>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。</p>
<p>若内存空间不够，由<strong>操作系统</strong>负责将内存中<strong>暂时用不到的信息换出到外存</strong>。 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p>
<p>【操作系统虚拟性的一个体现，实 际的物理内存大小没有变，只是在逻辑上进行了扩充。】</p>
<p><strong>易混知识点</strong>：<br>
虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU寻址范围）确定的<br>
虚拟内存的<strong>实际容量</strong> = min(内存和外存容量之和，CPU寻址范围)<br>
如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 则虚拟内存的<strong>最大容量</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> B = 4GB<br>
虚拟内存的<strong>实际容量</strong> = min(4GB, 512MB+2GB) = 2GB+512MB</p>
<p>虚拟内存有一下三个主要特征：</p>
<ol>
<li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
<li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
</ol>
<hr>
<ul>
<li><strong><u>如何实现虚拟内存技术</u></strong></li>
</ul>
<p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上。</p>
<p><strong>传统非连续分配存储管理</strong></p>
<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>基本段页式存储管理</li>
</ul>
<p><strong>虚拟内存的实现</strong></p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<p>主要区别： 在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。 【操作系统要提供<strong>请求调页</strong>（或<strong>请求调段</strong>）功能】</p>
<p>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong>。【操作系统要提供<strong>页面置换</strong>（或<strong>段置换</strong>）的功能】</p>
<hr>
<h2 id="3-2-2-请求分页管理方式">3.2.2 请求分页管理方式</h2>
<ul>
<li><strong><u>页表机制</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-57-28.png" alt=""></p>
<p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p>
<p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p>
<p><strong>请求分页存储管理的页表</strong>：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_15-59-44.png" alt=""></p>
<p>请求页表项增加了四个字段:</p>
<ol>
<li><strong>状态位</strong>：是否已调入内存</li>
<li><strong>访问字段</strong>：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</li>
<li><strong>修改位</strong>：页面调入内存后是否被修改过</li>
<li><strong>外存地址</strong>：页面在外存中的存放位 置</li>
</ol>
<hr>
<ul>
<li><strong><u>缺页中断机构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-07-46.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-09-25.png" alt=""></p>
<p>假设此时要访问逻辑地址 =（页号，页内偏移量）=（0, 1024）</p>
<ul>
<li>
<p>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong>。</p>
</li>
<li>
<p>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</p>
</li>
<li>
<p>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</p>
</li>
<li>
<p>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p>
</li>
</ul>
<p><strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此<strong>属于内中断</strong></p>
<p><strong>一条指令</strong>在执行期间，<strong>可能产生多次缺页中断</strong>。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）</p>
<hr>
<ul>
<li><strong><u>地址变换机构</u></strong></li>
</ul>
<p><strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的主要区别：</p>
<ul>
<li>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。 【操作系统要提供<strong>请求调页</strong>（或<strong>请求调段</strong>）功能】</li>
<li>若内存空间不够，由操作系统负责<strong>将内存中暂时用不到的信息换出到外存</strong>。【操作系统要提供<strong>页面置换</strong>（或<strong>段置换</strong>）的功能】</li>
</ul>
<p>新增步骤1：请求调页（查到页表项时进行判断）</p>
<p>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）</p>
<p>新增步骤3：需要修改请求页表中新增的表项</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-18-45.png" alt=""></p>
<p>快表中有的页面一定是在内存中的。若某个页面被换出外存， 则<strong>快表中的相应表项也要删除</strong>， 否则可能访问错误的页面。</p>
<p>书上：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_16-31-41.png" alt=""></p>
<p>补充细节：<br>
① 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p>
<p>② 和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p>
<p>③ 需要用某种“页面置换算法” 来决定一个换出页面（下节内容）</p>
<p>④ 换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。</p>
<p>⑤ 页面调入内存后，需要修改慢表，同时也需要将表项复制到快 表中。【在具有快表机构的请求分页系统中，访问一个逻辑地址 时，若发生缺页，则地址变换步骤是： 查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表，当然慢表也有)——查快表(命中)——访问目标内存单元】</p>
<hr>
<h2 id="3-2-3-页面置换算法">3.2.3 页面置换算法</h2>
<blockquote>
<p>页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该<strong>追求更少的缺页率</strong></p>
</blockquote>
<ul>
<li><strong><u>最佳置换算法（OPT）</u></strong></li>
</ul>
<p>最佳置换算法（OPT，Optimal）：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p>
<p>例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：<br>
7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-09_16-49-53.gif" alt=""></p>
<p>整个过程缺页中断发生了9次，页面置换发生了6次。<br>
注意：缺页时未必发生页面置换。若还有可用的空闲内存块， 就不用进行页面置换。<br>
<strong>缺页率</strong> = 9/20 = 45%</p>
<p>最佳置换算法可以保证<strong>最低的缺页率</strong>，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p>
<hr>
<ul>
<li><strong><u>先进先出置换算法（FIFO）</u></strong></li>
</ul>
<p>先进先出置换算法（FIFO）：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong></p>
<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。<br>
队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p>例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：<br>
3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-04-37.png" alt=""></p>
<p>分配三个内存块时，缺页次 数：9次</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-05-56.png" alt=""></p>
<p>分配四个内存块时， 缺页次数：10次</p>
<p><strong>Belady 异常</strong>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p><strong>只有 FIFO 算法会产生 Belady 异常</strong>。另外，FIFO算法虽然<strong>实现简单</strong>，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong></p>
<hr>
<ul>
<li><strong><u>最近最久未使用置换算法（LRU）</u></strong></li>
</ul>
<p>最近最久未使用置换算法（LRU，least recently used）：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p>
<p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间t</strong>。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-11-19.png" alt=""></p>
<p>例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br>
1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-13-35.png" alt=""></p>
<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</strong>。</p>
<p>该算法的实现需要专门的硬件支持，虽然算法<strong>性能好</strong>， 但是<strong>实现困难，开销大</strong></p>
<hr>
<ul>
<li><strong><u>时钟置换算法（CLOCK）</u></strong></li>
</ul>
<p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；<br>
最近最久未使用 置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_17-19-13.png" alt=""></p>
<ul>
<li><strong>简单的CLOCK 算法实现方法</strong>：</li>
</ul>
<p>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</p>
<p>例：假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串：<br>
1, 3, 4, 2, 5, 6, 3, 4, 7</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/GIF_2023-05-09_17-28-10.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>改进型的时钟置换算法</u></strong></li>
</ul>
<p><strong>简单的时钟置换算法</strong>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免I/O操作。这就是改进型的时钟置换算法的思想。 <strong>修改位=0</strong>，表示页面没有被修改过；<strong>修改位=1</strong>，表示页面被修改过。</p>
<p>为方便讨论，用（<strong>访问位</strong>，<strong>修改位</strong>）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过， 且被修改过。</p>
<p>算法规则：将所有可能被置换的页面排成一个循环队列</p>
<ol>
<li><strong>第一轮</strong>：从当前位置开始扫描到第一个（0,	0）的帧用于替换。本轮扫描不修改任何标志位<br>
【第一优先级：最近没访问， 且没修改的页面】</li>
<li><strong>第二轮</strong>：若第一轮扫描失败，则重新扫描，查找第一个（0,	1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>
【第二优先级：最近没访问， 但修改过的页面】</li>
<li><strong>第三轮</strong>：若第二轮扫描失败，则重新扫描，查找第一个（0,	0）的帧用于替换。本轮扫描不修改任何标志位<br>
【第三优先级：最近访问过， 但没修改的页面】</li>
<li><strong>第四轮</strong>：若第三轮扫描失败，则重新扫描，查找第一个（0,	1）的帧用于替换。<br>
【第四优先级：最近访问过， 且修改过的页面】</li>
</ol>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面<strong>最多会进行四轮扫描</strong></p>
<p>例子：【自己推】下图都是（起始状态，最终状态）</p>
<p>需要1轮扫描</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-33-50.png" alt=""></p>
<p>需要2轮扫描</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-36-01.png" alt=""></p>
<p>需要3轮扫描</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-38-16.png" alt=""></p>
<p>需要4轮扫描</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_18-38-43.png" alt=""></p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>算法规则</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OPT</td>
<td>优先淘汰最长时间内不会被访问的页面</td>
<td>缺页率最小，性能最好；但无法实现</td>
</tr>
<tr>
<td style="text-align:center">FIFO</td>
<td>优先淘汰最先进入内存的页面</td>
<td>实现简单；但性能很差，可能出现Belady异常</td>
</tr>
<tr>
<td style="text-align:center">LRU</td>
<td>优先淘汰最近最久没访问的页面</td>
<td>性能很好；但需要硬件支持，算法开销大</td>
</tr>
<tr>
<td style="text-align:center">CLOCK（NRU）</td>
<td>循环扫描各页面 <br />第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。</td>
<td>实现简单，算法开销小；但未考虑页面是否被修改过</td>
</tr>
<tr>
<td style="text-align:center">改进型CLOCK（改 进型NRU）</td>
<td>若用（访问位, 修改位）的形式表述，则<br />第一轮：淘汰（0, 0） <br />第二轮：淘汰（0, 1），并将扫描过的页面访问位都<strong>置为0</strong> <br />第三轮：淘汰（0, 0） <br />第四轮：淘汰（0, 1）</td>
<td>算法开销较小，性能也不错</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="3-2-4-页面分配策略">3.2.4 页面分配策略</h2>
<ul>
<li><strong><u>页面分配、置换策略</u></strong></li>
</ul>
<p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的物理块的集合。<br>
在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p>
<p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少； 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。<br>
【考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页】</p>
<p><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</p>
<p><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</p>
<p><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</p>
<p><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p>
<p>全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">局部置换</th>
<th style="text-align:center">全局置换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>固定分配</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><strong>可变分配</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p><strong>固定分配局部置换</strong>：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的<strong>缺点</strong>是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p>
<p><strong>可变分配全局置换</strong>：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，<strong>只要某进程发生缺页， 都将获得新的物理块</strong>，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个<strong>被选中的进程拥有的物理块会减少，缺页率会增加</strong>。<br>
【系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设置为“锁定”）】</p>
<p><strong>可变分配局部置换</strong>：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p>
<p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块<br>
可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来动态地增加或减少进程的物理块</p>
<hr>
<ul>
<li><strong><u>何时调入页面</u></strong></li>
</ul>
<p><strong>预调页策略</strong>：根据局部性原理【主要指空间局部性】，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略<strong>主要用于进程的首次调入</strong>【运行前调入】， 由程序员指出应该先调入哪些部分。</p>
<p><strong>请求调页策略</strong>：进程在<strong>运行期间发现缺页时才将所缺页面调入内存</strong>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</p>
<hr>
<ul>
<li><strong><u>从何处调入页面</u></strong></li>
</ul>
<p>1、系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-44-14.png" alt=""></p>
<p>2、系统缺少足够的对换区空间：凡是不会被修改 的数据都直接从文件区调入，由于这些页面不 会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时 再从对换区调入。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-47-33.png" alt=""></p>
<p>3、UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_19-51-13.png" alt=""></p>
<hr>
<ul>
<li><strong><u>抖动（颠簸）现象</u></strong></li>
</ul>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>。产生抖动的<strong>主要原因</strong>是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p>
<p>为进程分配的物理块太少，会使进 程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p>
<p>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“<strong>工作集</strong>”的概念</p>
<hr>
<ul>
<li><strong><u>工作集</u></strong></li>
</ul>
<p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的内存块的集合。<br>
<strong>工作集</strong>：指在某段时间间隔里，进程实际访问页面的集合。</p>
<p>操作系统会根据“窗口尺寸”来算出工作集。例：<br>
某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-00-10.png" alt=""></p>
<p><strong>工作集大小</strong>可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。</p>
<p>一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong></p>
<p>拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p>
<hr>
<h2 id="3-2-5-内存映射文件">3.2.5 内存映射文件</h2>
<ul>
<li><strong><u>传统的文件访问方式</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-14-43.png" alt=""></p>
<p>open 系统调用——打开文件<br>
seek 系统调用――将读写指针移到某个位置<br>
read 系统调用――从读写指针所指位置读入若干数据（从磁盘读入内存)<br>
write 系统调用――将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-14-36.png" alt=""></p>
<hr>
<ul>
<li><strong><u>内存映射文件（Memory-Mapped Files）</u></strong></li>
</ul>
<p>open系统调用――打开文件<br>
mmap系统调用一一将文件映射到进程的虚拟地址空间</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-16-18.png" alt=""></p>
<ul>
<li>以访问内存的方式访问文件数据</li>
<li>文件数据的读入、写出由操作系统自动完成</li>
<li>进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</li>
</ul>
<p>多个进程可以映射同一个文件，实现<strong>共享</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_20-18-05.png" alt=""></p>
<p>在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马“看到”</p>
<hr>
<ul>
<li><strong><u>知识回顾</u></strong></li>
</ul>
<p>内存映射文件：</p>
<ul>
<li><strong>特性</strong>
<ul>
<li>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间</li>
<li>以访问内存的方式读写文件</li>
<li>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</li>
<li>多个进程可以映射同一个文件，方便共享</li>
</ul>
</li>
<li><strong>优点</strong>
<ul>
<li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li>
<li>文件数据的读入/写出完全由操作系统负责，I/O效率可以由操作系统负责优化【eg:预读入、缓写出等】</li>
</ul>
</li>
</ul>
<hr>
<h1>第四章 文件管理</h1>
<h2 id="4-1-1-初识文件管理">4.1.1 初识文件管理</h2>
<ul>
<li><strong><u>前情回顾</u></strong></li>
</ul>
<p><strong>操作系统的功能和目标——作为系统资源的管理者</strong></p>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li><strong>文件管理</strong></li>
<li>设备管理</li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
<p><strong>文件的定义：文件——就是一组有意义的信息/数据集合</strong></p>
<p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p>
<p><strong>文件内部</strong>的数据应该怎样组织起来？</p>
<p><strong>文件之间</strong>又应该又应该怎么组织起来？</p>
<p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？<br>
从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p>
<hr>
<ul>
<li>
<p><strong><u>文件的属性</u></strong></p>
</li>
<li>
<p><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</p>
</li>
<li>
<p><strong>标识符</strong>：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分各个文件的一种内部名称。</p>
</li>
<li>
<p><strong>类型</strong>：指明文件的类型</p>
</li>
<li>
<p><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p>
</li>
<li>
<p><strong>大小</strong>：指明文件大小</p>
</li>
<li>
<p><strong>创建时间</strong>、<strong>上次修改时间</strong>、<strong>文件所有者信息</strong>……</p>
</li>
<li>
<p><strong>保护信息</strong>：对文件进行保护的访问控制信息</p>
</li>
</ul>
<hr>
<ul>
<li><strong><u>文件内部的数据应该怎样组织起来？</u></strong></li>
</ul>
<p><strong>无结构文件</strong>（如文本文件）——由一些二进制或字符流组成，又称“<strong>流式文件</strong>”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-06.png" alt=""></p>
<p><strong>有结构文件</strong>（如数据库表）——由一组相似的记录组成，又称“<strong>记录式文件</strong>”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-15.png" alt=""></p>
<p>记录是一组相关数据项的集合<br>
数据项是文件系统中最基本的数据单位</p>
<p>总结：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-48-12.png" alt=""></p>
<p>有结构文件中，各个记录间应该如何组织的问题——应该顺序存放？ 还是用索引表来表示记录间的顺序？——这是“文件的逻辑结构” 重点要探讨的问题</p>
<hr>
<ul>
<li><strong><u>文件之间应该怎样组织起来？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-49-41.png" alt=""></p>
<p>所谓的“<strong>目录</strong>” 其实就是我们熟悉的“<strong>文件夹</strong>”</p>
<p>用户可以自己创建一层一 层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了</p>
<p>目录其实也是一种特殊的有结构文件（由记录组成），如何实现文件目录是之后会重点探讨的问题</p>
<hr>
<ul>
<li><strong><u>操作系统应该向上提供哪些功能？</u></strong></li>
</ul>
<p>可以“<strong>创建文件</strong>”， （点击新建后，图形 化交互进程在背后调 用了“<strong>create 系统调用</strong>”）</p>
<p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统 提供的“读文件”功能，即 <strong>read 系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p>
<p>可以“<strong>写文件</strong>”，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后， “记事本”应用程序通过操作系统提供 的“写文件”功能，即 <strong>write 系统调用</strong>， 将文件数据从内存写回外存）</p>
<p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“删除文件”功能，即 <strong>delete 系统调用</strong>， 将文件数据从外存中删除）</p>
<p><strong>向上提供的几个最基本的功能</strong>：</p>
<ul>
<li><strong>创建文件（ create 系统调用）</strong></li>
<li><strong>读文件（ read 系统调用）</strong></li>
<li><strong>写文件（ write 系统调用）</strong></li>
<li><strong>删除文件（ delete系统调用）</strong></li>
<li><strong>打开文件（ open系统调用）</strong><br>
读/写文件之前，需要“打开文件”</li>
<li><strong>关闭文件（ close系统调用）</strong><br>
读/写文件结束之后， 需要“关闭文件”</li>
</ul>
<p>可用几个基本操作完成更复杂的操作，比如：“复制文件”： 先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</p>
<p>操作系统在背后做的处理会在以后进行探讨</p>
<hr>
<ul>
<li><strong><u>从上往下看，文件应如何存放在外存？</u></strong></li>
</ul>
<p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1B）。每个存储单元对应一个物理地址</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-01-25.png" alt=""></p>
<p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。外存中的数据读入内存时同样以块为单位</p>
<p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如本例中，一块包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小</p>
<ul>
<li>文件数据放在连续的几个磁盘块中:</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-05-00.png" alt=""></p>
<ul>
<li>文件数据放在离散的几个磁盘块中。 此时，应该如何记录各个磁盘块之间的先后顺序呢？<br>
操作系统又应该怎么管理空闲磁盘块？</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-07-09.png" alt=""></p>
<p>操作系统又应该怎么管理空闲磁盘块？</p>
<hr>
<ul>
<li><strong><u>其他需要由操作系统实现的文件管理功能</u></strong></li>
</ul>
<p><strong>文件共享</strong>：使多个用户可以共享使用一个文件</p>
<p><strong>文件保护</strong>：如何保证不同的用户对文件有不同的操作权限</p>
<p>之后会结合 Windows操作系统的实际应用进行探讨</p>
<hr>
<h2 id="4-1-2-文件的逻辑结构">4.1.2 文件的逻辑结构</h2>
<blockquote>
<ul>
<li>无结构文件</li>
<li>有结构文件
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
</ul>
</li>
</ul>
<p>所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p>
<p>类似于数据结构的“逻辑结构”和“物理结构”。<br>
如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a, b, c, d, e ……<br>
“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问。<br>
可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关）</p>
</blockquote>
<ul>
<li><strong><u>无结构文件</u></strong></li>
</ul>
<p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。如： Windows 操作系统中的 .txt 文件。</p>
<p>文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。</p>
<hr>
<ul>
<li><strong><u>有结构文件</u></strong></li>
</ul>
<p><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录又若干个数据项组成。如： 数据库表文件。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID【数据库的Primary Key】）</p>
<p>这是一张数据库表，记录了各个学生的信息:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_21-45-15.png" alt=""></p>
<p>每个学生对应一条记录，每条记录由若干个数据项组成<br>
在本例中， “学号”即可 作为各个记录的关键字</p>
<p>根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种</p>
<p><strong>定长记录</strong>：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-42-13.png" alt=""></p>
<p>这个有结构文件由定长记录组成，每条记录的长度都相同（共 128 B）。各数据项都处在记录中相同的位置，具有相同的顺序和长度 （前32B一定是学号，之后32B一定是姓名……）</p>
<p><strong>可变长记录</strong>：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-44-28.png" alt=""></p>
<p>这个有结构文件由可变长记录组成，由于各个学生的特长存在很大区别，因此“特长” 这个数据项的长度不确定，这就导致了各条记录的长度也不确定。当然，没有特长的学生甚至可以去掉“特长”数据项。</p>
<hr>
<ul>
<li><strong><u>有结构文件的逻辑结构</u></strong></li>
</ul>
<p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p>
<ul>
<li>有结构文件
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong><u>顺序文件</u></strong></li>
</ul>
<p><strong>顺序文件</strong>：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。</p>
<p><strong>顺序存储</strong>——逻辑上相邻的记录物理上也相邻（类似于顺序表）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-48-29.png" alt=""></p>
<p><strong>链式存储</strong>——逻辑上相邻的记录物理上不一定相邻 （类似于链表）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_22-48-40.png" alt=""></p>
<p>顺序文件：</p>
<ul>
<li><strong>串结构</strong><br>
记录之间的顺序与关键字无关<br>
【通常按照记录存入的时间决定记录的顺序】</li>
<li><strong>顺序结构</strong><br>
记录之间的顺序按关键字顺序排列</li>
</ul>
<p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p>
<p>思考1：能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）</p>
<p>思考2：能否快速找到某个关键字对应的记录存放的位置？</p>
<p><strong>顺序文件</strong>：</p>
<ul>
<li>链式存储<br>
无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</li>
<li>顺序存储
<ul>
<li>可变长记录<br>
无法实现随机存取。每次只能从第一个记录开始依次往后查找</li>
<li>定长记录
<ul>
<li>可实现随机存取。记录长度为L，则第 i个记录存放的相对位置是 i*L</li>
<li>若采用串结构，无法快速找到某关键字对应的记录</li>
<li>若采用顺序结构，可以快速找到某关键字对应的记录(如折半查找【二分查找】)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-00-46.png" alt=""></p>
<p>结论：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索 （即根据关键字快速找到对应记录）</p>
<p>注：一般来说，考试题目中所说的“顺序文件”指的是<strong>物理上顺序存储的顺序文件</strong>【所以不用考虑链式存储】。之后的讲解中提到的顺序文件也默认如此。</p>
<p>可见，顺序文件的<strong>缺点</strong>是<strong>增加/删除一个记录比较困难</strong>（如果是串结构则相对简单）</p>
<hr>
<ul>
<li><strong><u>索引文件</u></strong></li>
</ul>
<p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1 个记录， 但是很多应用场景中又必须使用可变长记录。如何解决这个问题？</p>
<p>建立一张索引表【连续存储】以加快文件检索速度。每条记录对应一个索引项。<br>
文件中的这些记录在物理上可以离散地存放。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-04-37.png" alt=""></p>
<p><strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第 i 个记录对应的索引项。</p>
<p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p>
<p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong>。</p>
<p>另外，<strong>可以用不同的数据项建立多个索引表</strong>。如： 学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。 （Eg：SQL 就支持根据某个数据项建立索引的功能）</p>
<hr>
<ul>
<li><strong><u>索引顺序文件</u></strong></li>
</ul>
<p>思考索引文件的<strong>缺点</strong>：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p>
<p><strong>索引顺序文件</strong>是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-41-38.png" alt=""></p>
<p>在本例中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件， 分组内的记录不需要按关键字排序</p>
<p>索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p>
<hr>
<ul>
<li><strong><u>索引顺序文件（检索效率分析）</u></strong></li>
</ul>
<p>用这种策略确实可以让索引 表“瘦身”，但是是否会出 现不定长记录的顺序文件检索速度慢的问题呢？</p>
<p>若一个<strong>顺序文件</strong>有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记 录、顺序结构的顺序文件），平均须查找 5000 个记录。 若采用<strong>索引顺序文件</strong>结构，可把 10000 个记录分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>10000</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{10000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1328em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9072em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">10000</span></span></span><span style="top:-2.8672em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1328em;"><span></span></span></span></span></span></span></span></span> = 100 组，每组 100 个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，<strong>平均查找次数减少为 50+50 = 100 次</strong>。</p>
<p>同理，若文件共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录平均需要查找 500+500 = 1000 次。这个<strong>查找次数依然很多</strong>，如何解决呢？</p>
<hr>
<ul>
<li><strong><u>多级索引顺序文件</u></strong></li>
</ul>
<p>为了进一步提高检索效率，可以为顺序文件建立<strong>多级索引表</strong>。例如，对于一个含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长 记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表 项。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-47-26.png" alt=""></p>
<p>此时，检索一个记 录平均需要查找 50+50+50 = 150 次</p>
<p><strong>Tips</strong>:  要为 N 个记录的文件建立 K 级索引，则最优的分组是每组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">N^{1/(K+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>个记录。</p>
<p>检索一个记录的平均查找次数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msup><mi>N</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mn>2</mn></mfrac><mo>×</mo><mo stretchy="false">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{N^{1/(K+1)}}{2}\times (K+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4157em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1/</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>如：本例中，建立2级索引，则最优分组为每组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn><msup><mn>0</mn><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">100000^{1/3} = 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord">10000</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span> 个记录， 平均查找次数是 (100/2) *  3 = 150 次</p>
<hr>
<h2 id="4-1-3-文件目录">4.1.3 文件目录</h2>
<blockquote>
<p><strong>文件目录</strong>：就是我们很熟悉 的 Windows 操作系统的“文件夹”</p>
<p>这种目录结构对 于用户来说有什么<strong>好处</strong>？</p>
<ul>
<li>文件之间的组织结构清晰，易于查找</li>
<li>编程时也可以很方便的用文件路径找到一个文件。如： FILE *fp; fp=fopen(“F:\data\myfile.dat”); 用户可以轻松实现“按名存取”</li>
</ul>
<p>从操作系统的角度来看，这些目录结构应该是如何实现的？</p>
</blockquote>
<ul>
<li><strong><u>文件控制块FCB</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-56-23.png" alt=""></p>
<p>当我们双击“照片”后，操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-09_23-59-17.png" alt=""></p>
<p><strong>FCB</strong> 的有序集合称为“文件目录”，一个FCB就是一个文件<strong>目录项</strong>。 FCB 中包含了文件的<strong>基本信息</strong>（<strong>文件名</strong>、<strong>物理地址</strong>、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。 <strong>最重要</strong>，<strong>最基本</strong>的还是<strong>文件名</strong>、<strong>文件存放的物理地址</strong>。<br>
【FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”】</p>
<p><strong>需要对目录进行哪些操作</strong>？</p>
<ol>
<li><strong>搜索</strong>：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li>
<li><strong>创建文件</strong>：创建一个新文件时，需要在其所属的目录中增加一个目录项</li>
<li><strong>删除文件</strong>：当删除一个文件时，需要在目录中删除相应的目录项</li>
<li><strong>显示目录</strong>：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li>
<li><strong>修改目录</strong>：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li>
</ol>
<hr>
<ul>
<li><strong><u>目录结构——单级目录结构</u></strong></li>
</ul>
<p>早期操作系统并不支持多级目录，整个系统中<strong>只建立一张目录表</strong>，每个文件占一个目录项。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-05-22.png" alt=""></p>
<p>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong>。</p>
<p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p>
<p>显然，单级目录结构不适用于多用户操作系统【容易重复】。</p>
<hr>
<ul>
<li><strong><u>目录结构——两级目录结构</u></strong></li>
</ul>
<p>早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD，Master File Directory）和<strong>用户文件目录</strong>（UFD，User Flie Directory）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-09-07.png" alt=""></p>
<p>主文件目录记录用户名及相应用户文件目录的存放位置<br>
用户文件目录由该用户的文件FCB组成</p>
<p><strong>允许不同用户的文件重名</strong>。文件名虽然相 同，但是对应的其实是不同的文件</p>
<p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类</p>
<hr>
<ul>
<li><strong><u>目录结构——多级目录结构</u></strong><br>
又称<strong>树形目录结构</strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-11-37.png" alt=""></p>
<p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从<strong>根目录出发</strong>的路径称为<strong>绝对路径</strong>。例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg”</p>
<p>系统根据绝对路径一层一层地找到下一级目录。刚开始<strong>从外存读入根目录的目录表</strong>；找到“照片”目录的 存放位置后，<strong>从外存读入对应的目录表</strong>；再找到“2015-08”目录的存放位置，再<strong>从外存读入对应目录表</strong>； 最后才找到文件“自拍.jpg”的存放位置。整个过程<strong>需要3次读磁盘I/O操作</strong>。</p>
<p>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）， 显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“<strong>当前目录</strong>”。<br>
例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用<strong>从当前目录出发</strong>的“<strong>相对路径</strong>” 。<br>
在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为： “./2015-08/自拍.jpg”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。</p>
<p>可见，引入“<strong>当前目录</strong>”和“<strong>相对路径</strong>”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</p>
<p><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构<strong>不便于实现文件的共享</strong>。为此，提出了“<strong>无环图目录结构</strong>”。</p>
<hr>
<ul>
<li><strong><u>目录结构——无环图目录结构</u></strong></li>
</ul>
<p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使 整个目录成为一个<strong>有向无环图</strong>。 可以更方便地实现多个用户间的文件共享。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-20-14.png" alt=""></p>
<p><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p>
<p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。<br>
<strong>只有共享计数器减为0时，才删除结点</strong>。</p>
<p>注意：共享文件不同于复制文件。在<strong>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</strong>。</p>
<hr>
<ul>
<li><strong><u>索引结点（FCB的改进）</u></strong></li>
</ul>
<p>其实在查找各级目录的过程中只需要用到“文件名”这个信 息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-24-21.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_00-25-05.png" alt=""></p>
<p><strong>思考有何好处</strong>？ 假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放 16个FCB。若一个文件目录中共有640个目录项，则共需要占用 640/16 = 40 个盘块。因此按照某文件名检索该目录，平均需要查询320 个目录项，<strong>平均需要启动磁盘20次（每次磁盘I/O读入一块</strong>）。</p>
<p>若<strong>使用索引结点机制</strong>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录<strong>平均只需要读入 320/64 = 5 个磁盘块</strong>。显然，这<strong>将大大提升文件检索速度</strong>。</p>
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p>
<p>存<strong>放在外存中</strong>的索引结点称为“<strong>磁盘索引结点</strong>”，当索引结点<strong>放入内存后</strong>称为“<strong>内存索引结点</strong>”。 相比之下<strong>内存索引结点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p>
<hr>
<h2 id="4-1-4-文件的物理结构（上）">4.1.4 文件的物理结构（上）</h2>
<blockquote>
<p>要探讨的问题:</p>
<p>“文件的物理结构/文件分配方式” 即：文件数据应该怎样存放在外存中？</p>
<p>“文件存储空间管理”</p>
</blockquote>
<ul>
<li><strong><u>文件块、磁盘块</u></strong></li>
</ul>
<p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-28-44.png" alt=""></p>
<p>内存与磁盘之间的数据交换（即读/写操作、磁盘I/O）都是以“块”为单位进行的。即每次读入一块，或每次写出一块</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-29-56.png" alt=""></p>
<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面<br>
同样的，在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的文件“块”</strong> 。 于是文件的逻辑地址也可以表示为（<strong>逻辑块号</strong>，<strong>块内地址</strong>）的形式。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-33-08.png" alt=""></p>
<p>操作系统为文件分配存储空间都是以块为单位的<br>
用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</p>
<hr>
<ul>
<li><strong><u>文件分配方式——连续分配</u></strong></li>
</ul>
<p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-38-19.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？<br>
（逻辑块号，块内地址）→ （物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p>
<p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）…<br>
<strong>物理块号 = 起始块号 + 逻辑块号</strong><br>
当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）</p>
<p>【可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问</strong>）】</p>
<p>如下图，读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-47-07.png" alt=""></p>
<p><strong>结论</strong>：<strong>连续分配的文件在顺序读/写时速度最快</strong></p>
<p><strong>eg</strong>: 如下图：若此时文件A要拓展，需要再增加一个磁盘块（总共 需要连续的4个磁盘块）。 由于采用连续结构，因此文件A占用的磁盘块必须是连续的。 因此只能将文件A全部“迁移”到绿色区域。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-41-52.png" alt=""></p>
<p><strong>结论</strong>：物理上采用<strong>连续配的文件不方便拓展</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-43-37.png" alt=""></p>
<p><strong>结论</strong>：物理上采用<strong>连续分配</strong>， <strong>存储空间利用率低</strong>，<strong>会产生难以利用的磁盘碎片</strong><br>
可以用<strong>紧凑</strong>【之前介绍了】来处理碎片，但是需要耗费很大的时间代价。</p>
<hr>
<ul>
<li><strong><u>连续分配（总结）</u></strong></li>
</ul>
<p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p>
<p><strong>优点</strong>：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p>
<p><strong>缺点</strong>：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p>
<hr>
<ul>
<li><strong><u>文件分配方式——链接分配</u></strong></li>
</ul>
<p><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</p>
<hr>
<ul>
<li><strong><u>链接分配——隐式链接</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-52-12.png" alt=""></p>
<p>除了文件的最后一个磁盘块之外，每 个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-51-24.png" alt=""></p>
<p>目录中记录了文件存放的起始块号和结束块号。当然， 也可以增加一个字段来表示文件的长度</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>如何实现文件的逻辑块号到物理块号的转变？</p>
<ul>
<li>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</li>
<li>从目录项中找到起始块号（即逻辑上的0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</li>
<li>因此，读入i号逻辑块，总共需要 i+1 【0<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>i】次磁盘 I/O。</li>
</ul>
<p><strong>结论</strong>：采用<strong>链式分配（隐式链接）</strong> 方式的文件，<strong>只支持顺序访问，不支持随机访问</strong>，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>是否方便拓展文件？</p>
<p>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_11-56-32.png" alt=""></p>
<p><strong>结论</strong>：采用隐式链接的<strong>链接分配方式</strong>，<strong>很方便文件拓展</strong>。 另外，所有的空闲磁盘块都可以被利用，<strong>不会有碎片问题， 外存利用率高</strong>。</p>
<p><strong>隐式链接</strong>——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。<br>
<strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高。<br>
<strong>缺点</strong>：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<hr>
<ul>
<li><strong><u>链接分配——显式链接</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_12-00-40.png" alt=""></p>
<p>把用于链接文件各物理块的指针显式地存放在一张表中。即<strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）</p>
<p>目录中只需记录文件的起始块号</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_12-01-24.png" alt=""></p>
<p>假设某个新创建的文件“aaa”依次存放在磁盘块 2 →5 →0 →1<br>
假设某个新创建的文件“bbb”依次存放在磁盘块 4 →23 →3<br>
【结果如上图】</p>
<p><strong>注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻内存</strong>。 FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“<strong>物理块号</strong>”字段<strong>可以是隐含的</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>如何实现文件的逻辑块号到物理块号的转变？</p>
<p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</p>
<p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT， 往后找到 i 号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</p>
<p><strong>结论</strong>：采用<strong>链式分配（显式链接）</strong> 方式的文件，支持顺序访问，也支持<strong>随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1 号逻辑块</strong>），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p>
<p>显然，显式链接也<strong>不会产生外部碎片</strong>，<strong>也可以很方便地对文件进行拓展</strong>。</p>
<hr>
<ul>
<li><strong><u>链接分配（总结）</u></strong></li>
</ul>
<p><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</p>
<p><strong>隐式链接</strong>——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。<br>
<strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高。<br>
<strong>缺点</strong>：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<p>【考试题目中遇到未指明隐式/显式的“链接分配”，<strong>默认</strong>指的是<strong>隐式链接</strong>的链接分配】</p>
<p><strong>显式链接</strong>——把用于链接文件各物理块的指针显式地存放在一张表中，即 <strong>文件分配表</strong>（<strong>FAT</strong>，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并<strong>常驻内存</strong>。<br>
<strong>优点</strong>：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。<br>
<strong>缺点</strong>：文件分配表的需要占用一定的存储空间。</p>
<hr>
<h2 id="4-1-4-文件的物理结构（下）">4.1.4 文件的物理结构（下）</h2>
<blockquote>
<p>即：文件数据应该怎样存放在外存中？</p>
</blockquote>
<ul>
<li><strong><u>文件分配方式——索引分配</u></strong></li>
</ul>
<p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-10-16.png" alt=""></p>
<p>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2→5→13→9 。 7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。</p>
<p>注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p>
<p>可以用固定的长度表示物理块号（如： 假设磁盘总容量为1TB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span></span></span></span>B，磁盘块大小为1KB，则共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span></span></span></span>个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-13-31.png" alt=""></p>
<br>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>如何实现文件的逻辑块号到物理块号的转变？</p>
<p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…</p>
<p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只 i 号逻辑块在外存中的存放位置。</p>
<p>可见，<strong>索引分配方式可以支持随机访问</strong>。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是<strong>索引表需要占用一定的存储空间</strong></p>
<br>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-08_10-58-50.png" alt=""></p>
<p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256 个索引项。<br>
如果一个文件的大小超过了256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？<br>
①链接方案; ②多层索引; ③混合索引.</p>
<ol>
<li><strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</li>
</ol>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256 个索引项。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-20-20.png" alt=""></p>
<p>若一个文件大小为 256*256KB = 65,536 KB = 64MB</p>
<p>该文件共有 256*256 个块，也就对应 256*256个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来。</p>
<p>若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用 指针链接起来的，因此必须先顺序地读入前 255 个索引块。</p>
<p>这显然是很低效的。如何解决呢？</p>
<ol start="2">
<li><strong>多层索引</strong></li>
</ol>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-30-04.png" alt=""></p>
<p>若某文件采用<strong>两层索引</strong>，则该<strong>文件的最大长度</strong>可以到 256*256*1KB = 65,536 KB = 64MB【常考计算】</p>
<p>可根据逻辑块号算出应该查找索引表中的哪个表项。 如：要访问 1026 号逻辑块，则<br>
1026/256 = 4，1026%256 = 2<br>
因此可以先将一级索引表调入内存，查询 4 号表项， 将其对应的二级索引表调入内存，再查询二级索引表 的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。 <strong>访问目标数据块，需要3次磁盘I/O</strong>。</p>
<p>若采用三层索引，则文件的最大长度为 256*256*256*1KB = 16GB 类似的，访问目标数据块，需要4次磁盘I/O</p>
<p>【<strong>规律</strong>】采用K层索引结构，<strong>且顶级索引表未调入内存</strong>，则访问一个数据块只需要K+1次读磁盘操作</p>
<ol start="3">
<li><strong>混合索引</strong></li>
</ol>
<p><strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-10_23-36-23.png" alt=""></p>
<p>这种结构的索引支持的最大文件长度为8 + 256 + 256 * 256 = 65800KB</p>
<p>若顶级索引表<strong>还没读入内存</strong><br>
访问0-7号逻辑块：两次读磁盘<br>
访问8-263：三次读磁盘<br>
访问264~65799：四次读磁盘</p>
<p>对于小文件，只需较少的读磁盘次数就可以访问目标数据块（一般计算机中小文件更多）</p>
<hr>
<ul>
<li><strong><u>索引分配（总结）</u></strong></li>
</ul>
<p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系） 。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p>
<p>若文件太大，索引表项太多，可以采取以下三种方法解决：<br>
① <strong>链接方案</strong>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<strong>缺点</strong>：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘I/O次数过多，查找效率低下。</p>
<p>② <strong>多层索引</strong>：建立多层索引（<strong>原理类似于多级页表</strong>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且<strong>顶级索引表未调入内存</strong>，则访问 一个数据块只需要 K + 1 次读磁盘操作。<strong>缺点</strong>：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p>
<p>③ <strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），又包含<strong>一级间接索引</strong>（指向单层索引表）、还包含<strong>两级间接索引</strong>（指向两层索引表） 。 <strong>优点</strong>：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p>
<p><strong><u>超级超级超级重要考点</u></strong>：<br>
①要会根据多层索引、混合索引的结构计算出文件的最大长度（<strong>Key</strong>：<strong>各级索引表最大不能超过一个块</strong>）；<br>
②要能自己分析访问某个数据块所需要的读磁盘次数（<strong>Key</strong>：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要<strong>注意题目条件——顶级索引块是否已调入内存</strong>）</p>
<hr>
<ul>
<li><strong><u>知识点回顾与重要考点</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>How?</th>
<th>目录项内容</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>顺序</strong>分配</td>
<td>为文件分配的必须是连续的磁盘块</td>
<td>起始块号、文件长度</td>
<td>顺序存取速度快，支持随机访问</td>
<td>会产生碎片，不利于文件拓展</td>
</tr>
<tr>
<td><strong>链接</strong>分配<br /><strong>隐式</strong>链接</td>
<td>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针</td>
<td>起始块号、结束块号</td>
<td>可解决碎片问题，外存利用率高，文件拓展实现方便</td>
<td>支持随机访问，易于实现文件的拓展</td>
</tr>
<tr>
<td><strong>链接</strong>分配<br /><strong>显式</strong>链接</td>
<td>建立一张文件分配表(FAT)，显式记录盘块的先后关系（开机后FAT常驻内存）</td>
<td>起始块号</td>
<td>除了拥有隐式链接的优点之外，还可通过查询内存中的FAT实现随机访问</td>
<td>FAT需要占用一定的存储空间</td>
</tr>
<tr>
<td><strong>索引</strong>分配</td>
<td>为文件数据块建立索引表。若文件太大，可采用链接方案、多层索引、混合索引</td>
<td>链接方案记录的是第一个索引块的块号，多层/混合索引记录的是顶级索引块的块号</td>
<td>支持随机访问，易于实现文件的拓展</td>
<td>索引表需占用一定的存储空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块时可能需要很多次读磁盘操作。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4-1-5-逻辑结构Vs物理结构">4.1.5 逻辑结构Vs物理结构</h2>
<p>我觉得有基础不用看了，挺简单的，明确两个点就好了：</p>
<ul>
<li><strong>逻辑结构是用户看的</strong>，用户可以自己设计怎么存储，但是真正怎么分配内存的时候还是得看操作系统</li>
<li><strong>物理结构是给操作系统看的</strong></li>
</ul>
<p>还有一个懵逼点是要明确顺序文件是什么，简单来说，<strong>顺序文件</strong>就是有结构的，<strong>文件内容有一定顺序</strong>的文件</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?p=63&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">4.1_5_逻辑结构VS物理结构_哔哩哔哩_bilibili</a></p>
<hr>
<h2 id="4-1-6-文件存储空间管理">4.1.6 文件存储空间管理</h2>
<blockquote>
<p>学习时要注意从三个方面进行理解：</p>
<ol>
<li>用什么方式记录，组织空闲快？</li>
<li>如何分配磁盘块</li>
<li>如何回收磁盘块</li>
</ol>
</blockquote>
<ul>
<li><strong><u>存储空间的划分与初始化</u></strong></li>
</ul>
<p>eg: 安装 Windows 操作系统的时候，一个必经步骤是–为磁盘分区 (C:盘、D:、E: 盘等)<br>
【存储空间的划分: 将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)】</p>
<p>存储空间的初始化:将各个文件卷划分为目录区、文件区</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-06-57.png" alt=""></p>
<p>目录区主要存放文件目录信息、用于磁盘存储空间管理的信息<br>
文件区用于存放文件数据</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-08-37.png" alt=""></p>
<hr>
<ul>
<li><strong><u>存储空间管理——空闲表法</u></strong></li>
</ul>
<p>适合”连续分配方式“</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-11-58.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-12-08.png" alt=""></p>
<p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样可采用<strong>首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p>
<p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——<br>
① 回收区的前后都没有相邻空闲区；<br>
② 回收区的前后都是空闲区；<br>
③ 回收区前面是空闲区；<br>
④ 回收区后面是空闲区。<br>
<strong>总之，回收时需要注意表项的合并问题。</strong></p>
<hr>
<ul>
<li><strong><u>空闲链表法</u></strong>
<ul>
<li><strong>空闲盘块链</strong><br>
以盘块为单位组成一条空闲链</li>
<li><strong>空闲盘区链</strong><br>
以盘区为单位组成一条空闲链</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-23-16.png" alt=""></p>
<ul>
<li><strong>空闲盘块链</strong></li>
</ul>
<p>操作系统保存着<strong>链头</strong>、<strong>链尾指针</strong><br>
<strong>如何分配</strong>：若某文件申请 K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。<br>
<strong>如何回收</strong>：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p>
<p>【适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作】</p>
<ul>
<li><strong>空闲盘区链</strong></li>
</ul>
<p>操作系统保存着<strong>链头</strong>、<strong>链尾指针</strong><br>
<strong>如何分配</strong>：若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据<br>
<strong>如何回收</strong>：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>
<p>【离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高】</p>
<hr>
<ul>
<li><strong><u>存储空管理——位示图法</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-27-29.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-27-43.png" alt=""></p>
<p><strong>位示图</strong>：每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中个字的字长是16位，字中的每一位对应一个盘块。因此<strong>可以用 (字号，位号) 对应一个盘块号。当然有的题目中也描述为(行号，列号</strong>)</p>
<p><strong><u>重要重要重要</u></strong>：要能自已推出盘块号与(字号位号)相转换的公式。<strong>注意题目条件:盘块号、字号、位号</strong>到底是从0开始还是从1开始</p>
<p>如本例中盘块号、字号、位号从0开始，若n表示字长，则…<br>
(字号,位号)=(i,j) 的二进制位对应的 盘块号 b = ni +j<br>
b号盘块对应的字号i= b/n，位号j= b%n</p>
<p><strong>如何分配</strong>：若文件需要K个块，① 顺序扫描位示图，找到K个相邻或不相邻的“0”，② 根据字号、位号算出对应的盘块号，将相应盘块分配给文件，③ 将相应位设置为“1”<br>
<strong>如何回收</strong>: ① 根据回收的盘块号计算出对应的字号、位号; ② 将相应进制位设为“0”</p>
<hr>
<ul>
<li><strong><u>存储空间管理——成组链接法</u></strong><br>
【不方便用文字描述也很难作为考题】</li>
</ul>
<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理。</p>
<p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为“<strong>超级块</strong>”，当系统启动时需要将<strong>超级块读入内存</strong>。并且要保证内存与外存中的“超级块”<strong>数据一致</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-49-02.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_13-52-38.png" alt=""></p>
<p>注意：成组链接法的每个分组是有上限的，本例中是100</p>
<p>什么是一组，直观地理解就是图中一列就是一组</p>
<p><strong>如何分配</strong>?<br>
Eg：需要1个空闲块<br>
① 检查第一个分组的块数是否足够。1&lt;100，因此是足够的。<br>
② 分配第一个分组中的1个空闲块【最后一个，上图中的201】，<br>
③ 并修改相应数据【超级块：100→99】</p>
<p>Eg：需要100个空闲块<br>
检查第一个分组的块数是否足够。100=100，是足够的。<br>
分配第一个分组中的100个空闲块。但是<strong>由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</strong>【相当于300号成了新的超级块】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-07-45.png" alt=""></p>
<p><strong>如何回收</strong>?<br>
Eg: 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块<br>
<strong>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-13-51.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-20-49.png" alt=""></p>
<hr>
<h2 id="4-1-7-文件的基本操作">4.1.7 文件的基本操作</h2>
<blockquote>
<p><strong>向上提供的几个最基本的功能</strong>：</p>
<ul>
<li><strong>创建文件（ create 系统调用）</strong></li>
<li><strong>读文件（ read 系统调用）</strong></li>
<li><strong>写文件（ write 系统调用）</strong></li>
<li><strong>删除文件（ delete系统调用）</strong></li>
<li><strong>打开文件（ open系统调用）</strong><br>
读/写文件之前，需要“打开文件”</li>
<li><strong>关闭文件（ close系统调用）</strong><br>
读/写文件结束之后， 需要“关闭文件”</li>
</ul>
</blockquote>
<ul>
<li><strong><u>创建文件</u></strong></li>
</ul>
<p>可以“<strong>创建文件</strong>”， （点击新建后，图形化交互进程在背后调用了“<strong>create 系统调用</strong>”）</p>
<p>进行 Create 系统调用时，需要提供的几个主要参数：</p>
<ol>
<li>所需的外存空间大小（如：一个盘块，即1KB）</li>
<li>文件存放路径（“D:/Demo”）</li>
<li>文件名（这个地方默认为“新建文本文档.txt”）</li>
</ol>
<p>操作系统在处理 Create 系统调用时，主要做了两件事：</p>
<ol>
<li><strong>在外存中找到文件所需的空间</strong>（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
<hr>
<ul>
<li><strong><u>删除文件</u></strong></li>
</ul>
<p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“删除文件”功能，即 <strong>delete 系统调用</strong>，将文件数据从外存中删除）</p>
<p>进行 Delete 系统调用时，需要提供的几个主要参数：</p>
<ol>
<li>文件存放路径（“D:/Demo”）</li>
<li>文件名（“test.txt”）</li>
</ol>
<p>操作系统在处理 Delete 系统调用时，主要做了几件事：</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。 （回收磁盘块时，根据空闲表法、空闲链表法、 位图法等管理策略的不同，需要做不同的处理）</li>
<li>从目录表中<strong>删除文件对应的目录项</strong>。</li>
</ol>
<hr>
<ul>
<li><strong><u>打开文件</u></strong></li>
</ul>
<p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用 “打开文件”，需要提供的几个主要参数：</p>
<ol>
<li>文件存放路径（“D:/Demo”）</li>
<li>文件名（“test.txt”）</li>
<li>要对文件的操作类型（如：r 只读； rw 读写等）</li>
</ol>
<p>操作系统在处理 open 系统调用时，主要做了几件事：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-56-27.png" alt=""></p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限。</li>
<li><strong>将目录项复制到内存中的“打开文件表”中</strong>。并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong></li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_14-58-55.png" alt=""></p>
<p><strong>读/写指针</strong>：记录了该进程对文件的读/写操作进行到的位置<br>
<strong>访问权限</strong>：如果打开文件时声明的是 “只读”，则该进程不能对文件进行写操作<br>
<strong>打开计数器</strong>：记录此时有多少个进程打开了此文件</p>
<p>系统的打开文件表可以方便实现某些文件管理的功能。例如：在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本” 进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。</p>
<hr>
<ul>
<li><strong><u>关闭文件</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-04-02.png" alt=""></p>
<p>进程使用完文件后，要“关闭文件” 操作系统在处理 Close 系统调用时，主要做了几件事：</p>
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count 减1，若 count = 0，则删除对应表项。</li>
</ol>
<hr>
<ul>
<li><strong><u>读文件</u></strong></li>
</ul>
<p>可以“读文件”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“<strong>读文件</strong>”功能，即 <strong>read 系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p>
<p>读/写文件之前，需要“打开文件”：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-06-20.png" alt=""></p>
<p>进程使用 read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的<strong>索引号</strong>【看”打开文件“的图】即可），还需要指明要读入多少数据（如：读入1KB）、指明读入 的数据要放在内存中的什么位置。 操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p>
<hr>
<ul>
<li><strong><u>写文件</u></strong></li>
</ul>
<p>可以“写文件”，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>写文件</strong>”功能，即 <strong>write 系统调用</strong>， 将文件数据从内存写回外存）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-06-20.png" alt=""></p>
<p>进程使用 write 系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的<strong>索引号</strong>即可），还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的 外存。</p>
<hr>
<ul>
<li><strong><u>知识点与重要考点</u></strong></li>
</ul>
<p>打开文件时并不会把文件数据直接读内存。“索引号”也称“<strong>文件描述符</strong>”<br>
【只是把文件目录项复制到内存中（知识点回顾：一个FCB就是一个文件目录项）】</p>
<p>“读/写文件”用“文件描述符”即可指明文件， 不再需要用到“文件名”</p>
<p>读/写文件的时候才把文件从外存读入内存/从内存写回外存</p>
<hr>
<h2 id="4-1-8-文件共享">4.1.8 文件共享</h2>
<blockquote>
<p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</p>
<p><strong>注意</strong>：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。<br>
如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p>
</blockquote>
<ul>
<li><strong><u>基于索引结点的共享方式（硬链接）</u></strong></li>
</ul>
<p>知识回顾：索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-15-10.png" alt=""></p>
<p>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p>
<p>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。 若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的 count值减 1。</p>
<p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p>
<p>当 count = 0 时系统负 责删除文件。</p>
<hr>
<ul>
<li><strong><u>基于符号链的共享方式（软链接）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_15-20-22.png" alt=""></p>
<p>【Link 类型的文件，记录了文件1的存放路径 “C:/User1/aaa”。 类似于 Windows 操作系统的“<strong>快捷方式</strong>”】</p>
<p>当 User3 访问“ccc”时，操作系统判断文件“ccc”属于 Link 类型文件，于是会根据其中记录的路径层层查找目录，最终找到 User1 的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p>
<p>Link 类型的文件名可以不同</p>
<p>例如QQ快捷方式：双击快捷方式图标打开时，操作系统判断这个文件是Link类型的 “快捷方式”文件，于是会根据其中记录的“路径 信息”检索目录，最终找到“QQScLauncher.exe”</p>
<p>但是如果QQScLauncher.exe已经删除，不存在了，QQ快捷方式打开时会提示错误。</p>
<p>由于用软链接的方式访问共享文件时要查询多级目录，因此用软链接访问会有<strong>多次磁盘I/O</strong></p>
<hr>
<h2 id="4-1-10-文件保护">4.1.10 文件保护</h2>
<ul>
<li><strong><u>口令保护</u></strong></li>
</ul>
<p>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。</p>
<p>【口令一般存放在文件对应的 FCB 或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比， 如果正确，则允许该用户访问文件】</p>
<p><strong>优点</strong>：保存口令的空间开销不多，验证口令的时间开销也很小。</p>
<p><strong>缺点</strong>：正确的“口令”存放在系统内部【被入侵】，不够安全。</p>
<hr>
<ul>
<li><strong><u>加密保护</u></strong></li>
</ul>
<p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p>
<p><strong>Eg</strong>：一个最简单的加密算法——异或加密<br>
假设用于加密/解密的“密码”为“01001”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-22-13.png" alt=""></p>
<p><strong>优点</strong>：保密性强，不需要在系统中存储“密码”</p>
<p><strong>缺点</strong>：编码/译码，或者说加密/解密要花费一定时间。</p>
<hr>
<ul>
<li><strong><u>访问控制</u></strong></li>
</ul>
<p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制列表</strong>（Access-Control List, <strong>ACL</strong>），该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-24-46.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-24-51.png" alt=""></p>
<p>有的计算机可能会有很多个用户， 因此访问控制列表可能会很大，可以用<strong>精简的访问列表</strong>解决这个问题</p>
<p><strong>精简的访问列表</strong>：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。 如：分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组。<br>
当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。【系统需要管理分 组的信息】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-26-47.png" alt=""></p>
<p>若想要让某个用户能够读取文件，只需要把该用户放入 “文件主的伙伴” 这个分组即可</p>
<p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p>
<hr>
<ul>
<li><strong><u>Windows 的访问控制</u></strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?p=67&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">4.1_9_文件保护_哔哩哔哩_bilibili </a> 08:38~11:55</p>
<hr>
<h2 id="4-3-1-文件系统的层次结构">4.3.1 文件系统的层次结构</h2>
<blockquote>
<p>说明：<strong>408大纲不要求考察本节内容</strong></p>
<p>本视频中介绍的“文件系统层次结构”，主要参考了<strong>国内教材</strong>；23版王道书介绍的“文件系统层次结构”，主要参考了<strong>国外教材</strong>。因此，二者看起来会有一些差异</p>
<p>不同的学者对文件系统的层次结构划分方法不同，本视频与王道书介绍的两种分层方法都是正确的，大家简要了解即可，<strong>不用追求“标准答案</strong>“</p>
</blockquote>
<ul>
<li><strong><u>文件系统的层次结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-36-02.png" alt=""></p>
<p><strong>用户接口</strong>：文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求（Read、Write、Open、 Close 等系统调用）</p>
<p><strong>文件目录系统</strong>：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如：管理活跃的文件目录表、管理打开文件表等。</p>
<p><strong>存取控制模块</strong>：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能。</p>
<p><strong>逻辑文件系统与文件信息缓冲区</strong>：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址</p>
<p><strong>物理文件系统</strong>：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址</p>
<p><strong>辅助分配模块</strong>：负责文件存储空间的管理，即负责分配和回收存储空间</p>
<p><strong>设备管理模块</strong>：直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘</p>
<p>调度、启动设备、释放设备等</p>
<br>
<p>【用一个例子来辅助记忆文件系统的层次结构】<br>
假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p>
<ol>
<li>用户需要通过操作系统提供的接口发出上述请求<br>
——<strong>用户接口</strong></li>
<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项<br>
——<strong>文件目录系统</strong></li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限<br>
——<strong>存取控制模块（存取控制验证层）</strong></li>
<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址<br>
——<strong>逻辑文件系统与文件信息缓冲区</strong></li>
<li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址<br>
——<strong>物理文件系统</strong></li>
<li>要删除这条记录，必定要对磁盘设备发出请求<br>
——<strong>设备管理程序模块</strong></li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收<br>
——<strong>辅助分配模块</strong></li>
</ol>
<hr>
<h2 id="4-3-2-文件系统的全局结构（布局）">4.3.2 文件系统的全局结构（布局）</h2>
<ul>
<li><strong><u>原始磁盘</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-49-08.png" alt=""></p>
<hr>
<ul>
<li><strong><u>物理格式化后</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-48-14.png" alt="·"></p>
<p>物理格式化，即低级格式化–划分扇区，检测坏扇区，并用备用扇区替换坏扇区</p>
<p>【坏扇区的存在对于操作系统来说也是透明的；当操作系统要访问一个坏扇区时，（磁盘驱动器格式化后，知道这是个坏的）磁盘驱动器会用备用扇区来替代扇区】</p>
<hr>
<ul>
<li><strong><u>逻辑格式化后</u></strong><br>
又叫 <strong>高级格式化</strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_16-55-43.png" alt=""></p>
<p><strong>逻辑格式化</strong>后，磁盘分区 (分卷 Volume)完成各分区的文件系统初始化</p>
<p>注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据<br>
注：“主引导记录MBR、引导块”的作用，可结合第一章“操作系统引导”小节来学习</p>
<p>【说明：i节点——索引节点】</p>
<hr>
<ul>
<li><strong><u>文件系统在内存中的结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-02-26.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-03-23.png" alt=""></p>
<p>注：近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</p>
<p>案例：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-07-11.png" alt=""></p>
<hr>
<h2 id="4-3-3-虚拟文件系统">4.3.3 虚拟文件系统</h2>
<ul>
<li><strong><u>普通文件系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-22-37.png" alt=""></p>
<p>有好几个不同的接口，对程序员不友好</p>
<hr>
<ul>
<li><strong><u>虚拟文件系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-25-02.png" alt=""></p>
<p>虚拟文件系统的特点:</p>
<ol>
<li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li>
<li>VFS要求下层的文件系统必须实现某些规定的函数功能，如:open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-28-32.png" alt=""></p>
<p>存在的问题：不同的文件系统，表示文件数据结构各不相同打开文件后，其在内存中的表示就不同</p>
<p>解决：打开文件就在主存中创建<code>vnode</code>结点</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-30-05.png" alt=""></p>
<ol start="3">
<li>每打开一个文件，VFS就在主存（内存）中新建一个 <code>vnode</code>，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。</li>
</ol>
<p>注意: <code>vnode</code> 只存在于主存中，而 <code>inode</code>（i结点（索引结点）） 既会被调入主存，也会在外存中存储</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-35-15.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-35-20.png" alt=""></p>
<p>打开文件后，创建<code>vnode</code>，并将文件信息复制到<code>vnode</code>中，<code>vnode</code>的功能指针指向具体文件系统的函数功能。</p>
<hr>
<ul>
<li><strong><u>文件系统挂载（mounting）</u></strong></li>
</ul>
<p>文件系统挂载(mounting)，即文件系统安装/装载——如何将文件系统挂载到操作系统中?</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-25-02.png" alt=""></p>
<p>文件系统挂载要做的事:</p>
<ol>
<li>在VFS中注册新挂载的文件系统<strong>内存中的挂载表</strong> (mount table) 包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li>
<li>新挂载的文件系统，要向VFS提供一个<strong>函数地址列表</strong></li>
<li>将新文件系统加到<strong>挂载点</strong> (<strong>mount point</strong>)，也就是将新文件系统挂载在某个父目录下</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_17-40-34.png" alt=""></p>
<hr>
<h1>第五章 输入/输出（I/O）管理</h1>
<h2 id="5-1-1-I-O设备的概念和分类">5.1.1 I/O设备的概念和分类</h2>
<blockquote>
<p>前情回顾</p>
<p><strong>操作系统的功能和目标——作为系统资源的管理者</strong></p>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li><strong>设备管理</strong></li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong><u>什么是I/O设备</u></strong></li>
</ul>
<p>“I/O” 就是 “输入/输出”（Input/Output）</p>
<p>I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p>鼠标、键盘——典型的输入型设备：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-03.png" alt=""></p>
<p>显示器——输出型设备：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-14.png" alt=""></p>
<p>移动硬盘——即可输入、又可输出的设备：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_18-40-23.png" alt=""></p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<br>
Write操作：向外部设备写出数据<br>
Read操作：从外部设备读入数据</p>
<hr>
<ul>
<li><strong><u>I/O设备的分类——按使用特性</u></strong>
<ul>
<li><strong>人机交互类外部设备</strong>：数据传输速度慢<br>
鼠标、键盘、打印机等——用于人机交互</li>
<li><strong>存储设备</strong>：数据传输速度快<br>
移动硬盘、光盘等——用于数据存储</li>
<li><strong>网络通信设备</strong>：数据传输速度介于上述二者之间<br>
调制解调器等——用于网络通信</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong><u>I/O设备的分类——按传输速率分类</u></strong>
<ul>
<li><strong>低速设备</strong><br>
鼠标、键盘等——传输速率为每秒几个到几百字节</li>
<li><strong>中速设备</strong><br>
如激光打印机等——传输速率为每秒数千至上万个字节</li>
<li><strong>高速设备</strong><br>
如磁盘等—— 传输速率为每秒数千字节至千兆字节的设备</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong><u>I/O设备的分类——按信息交换的单位分类</u></strong>
<ul>
<li><strong>块设备</strong>：传输速率较高，可寻址，即对它可随机地读/写任一块<br>
如磁盘等——数 据传输的基本单位是“块”</li>
<li><strong>字符设备</strong>：传输速率较慢，不可寻址，在输入/输出时常采用<strong>中断驱动方式</strong>【一种I/O控制方式】<br>
鼠标、键盘 等——数据传输的基本单位 是字符。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-1-2-I-O控制器">5.1.2 I/O控制器</h2>
<blockquote>
<p>I/O设备由机械部件和电子部件组成</p>
</blockquote>
<ul>
<li><strong><u>I/O设备的机械部件</u></strong></li>
</ul>
<p>I/O设备的<strong>机械部件</strong>主要用来执行具体I/O操作。<br>
如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</p>
<p>I/O设备的<strong>电子部件</strong>通常是一块插入主板扩充槽的印刷电路板。</p>
<hr>
<ul>
<li><strong><u>I/O设备的电子部件（I/O控制器）</u></strong></li>
</ul>
<p>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“<strong>中介</strong>”，用于实现CPU对设备的控制。</p>
<p>这个电子部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。</p>
<p><strong>I/O控制器的功能</strong>：</p>
<ol>
<li><strong>接受和识别CPU发出的命令</strong><br>
如CPU发来的 read/write 命令，I/O 控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li>
<li><strong>向CPU报告设备状态</strong><br>
I/O控制器中会有相应的<strong>状态寄存器</strong>，用于记录I/O设备的当前状态。如：1表示空闲，0表示忙碌</li>
<li><strong>数据交换</strong><br>
I/O控制器中会设置相应的<strong>数据寄存器</strong>。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</li>
<li><strong>地址识别</strong><br>
类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器。</li>
</ol>
<hr>
<ul>
<li><strong><u>I/O控制器的组成</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-06-23.png" alt=""></p>
<p>值得注意的小细节：<br>
① 一个I/O控制器可能会对应多个设备；<br>
② 数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I/O</strong>；另一些计算机则采用I/O专用地址，即<strong>寄存器独立编址</strong>。</p>
<hr>
<ul>
<li><strong><u>内存映像I/O v.s. 寄存器独立编址</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-18-07.png" alt=""></p>
<hr>
<h2 id="5-1-3-I-O控制方式">5.1.3 I/O控制方式</h2>
<blockquote>
<p><strong>I/O控制方式</strong>，即：用什么样的方式来控制 I/O设备的数据读/写</p>
<p>需要注意的问题：</p>
<ol>
<li>完成一次读/写操作的流程；</li>
<li>CPU干预的频率；</li>
<li>数据传送的单位；</li>
<li>数据的流向；</li>
<li>主要缺点和主要优点。</li>
</ol>
</blockquote>
<ul>
<li><strong><u>程序直接控制方式</u></strong></li>
</ul>
<p><strong>key word：轮询</strong><br>
完成一次读/写操作的流程（以<strong>读操作</strong>为例）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-27-08.png" alt=""></p>
<ol>
<li>完成一次读/写操作的流程（见下图，<strong>Key word：轮询</strong>，<strong>王道书上I/O模块这里写的是I/O控制器</strong>）</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_19-35-04.png" alt=""></p>
<p>【问题】：将CPU寄存器中的内容写到内存中？请看以下例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;	<span class="comment">// a存放在内存中</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);	<span class="comment">// 输入的数据最终要放到内存中（a变量存放在内存中）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);	<span class="comment">// 同理，输出的数据也存放在内存中，需要从内存取出</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>CPU干预的频率<br>
很频繁，I/O操作开始之前、完成之后需要CPU介入，并且<strong>在等待I/O完成的过程中CPU需要不断地轮询检查</strong>。</p>
</li>
<li>
<p>数据传送的单位<br>
每次读/写<strong>一个字</strong></p>
</li>
<li>
<p>数据的流向<br>
读操作（数据输入）：I/O设备→CPU【指的是CPU 的寄存器】→内存<br>
写操作（数据输出）：内存→CPU→I/O设备<br>
每个字的读/写都需要CPU的帮助</p>
</li>
<li>
<p>主要缺点和主要优点<br>
优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）<br>
<strong>缺点</strong>：<strong>CPU和I/O设备只能串行工作，CPU需要一直轮询检查， 长期处于“忙等”状态</strong> ，CPU利用率低。</p>
</li>
</ol>
<hr>
<ul>
<li><strong><u>中断驱动方式</u></strong></li>
</ul>
<p>引入<strong>中断机制</strong>。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将<strong>等待I/O的进程阻塞</strong>，先切换到别的进程执行。当I/O 完成后，控制器会向CPU发出一个中断信号，CPU<strong>检测到中断信号后</strong>，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，<strong>CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行</strong>。</p>
<p>下图中 <strong>王道书上I/O模块这里写的是I/O控制器</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-11-55.png" alt=""></p>
<p>注意：<br>
① CPU会在每个指令周期的末尾检查中断；<br>
② 中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。</p>
<ol>
<li>完成一次读/写操作的流程（见右图，<strong>Key word：中断</strong>）</li>
<li>CPU干预的频率<br>
每次I/O操作开始之前、完成之后需要CPU介入。<br>
<strong>等待I/O完成的过程中CPU可以切换到别的进程执行</strong>。</li>
<li>数据传送的单位<br>
每次读/写<strong>一个字</strong></li>
<li>数据的流向<br>
读操作（数据输入）：I/O设备→CPU【指的是CPU 的寄存器】→内存<br>
写操作（数据输出）：内存→CPU→I/O设备</li>
<li>主要缺点和主要优点<br>
优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。<strong>CPU和I/O设备可并行工作</strong>，CPU利用率得到明显提升。<br>
<strong>缺点</strong>：每个字在I/O设备与内存之间的传输，都需要经过CPU。而<strong>频繁的中断处理会消耗较多的CPU时间</strong>。</li>
</ol>
<hr>
<ul>
<li><strong><u>DMA方式</u></strong></li>
</ul>
<p>与“中断驱动方式”相比，<strong>DMA方式</strong>（ Direct Memory Access，<strong>直接存储器存取</strong>。主要用于块设备的I/O控制）有这样几个改进：<br>
① <strong>数据的传送单位是“块”</strong> 。不再是一个字、一个字的传送；<br>
② 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。<br>
③ 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>
<p>下图中 <strong>王道书上I/O模块这里写的是I/O控制器，DMA模块写的是DMA控制器</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-17-16.png" alt=""></p>
<p>【CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）】<br>
【控制器会根据CPU提出的要求完成数据的读/写工作，整块数据的传输完成后，才向CPU发出中断信号】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-19-02.png" alt=""></p>
<p><strong>DR</strong> （Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。<br>
<strong>MAR</strong> （Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么 位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。<br>
<strong>DC</strong> （Data Counter，数据计数器）：表示剩余要读/写的字节数。<br>
<strong>CR</strong>（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。</p>
<p>【由图，DMA和内存之间可以直接进行读写，不再经过CPU】<br>
【DMA其实也是<strong>一个字</strong>一个字读的，先读到DR里面，再写入内存】</p>
<ol>
<li>完成一次读/写操作的流程）</li>
<li>CPU干预的频率<br>
仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li>
<li>数据传送的单位<br>
每次读/写<strong>一个或多个块</strong>（注意：每次读写的只能是连续的多个块， 且这些块读入内存后在内存中也必须是连续的） 【离散的块也是需要CPU多次干预的】</li>
<li>数据的流向（<strong>不再需要经过CPU</strong>）<br>
读操作（数据输入）：I/O设备→内存<br>
写操作（数据输出）：内存→I/O设备</li>
<li>主要缺点和主要优点<br>
优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。<br>
<strong>缺点</strong>：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。<br>
如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</li>
</ol>
<hr>
<ul>
<li><strong><u>通道控制方式</u></strong></li>
</ul>
<p><strong>通道</strong>：一种<strong>硬件</strong>，可以理解为是 “<strong>弱鸡版的CPU</strong>”。通道可以识别并执行一系列<strong>通道指令</strong><br>
【与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-31-06.png" alt=""></p>
<ol>
<li>完成一次读/写操作的流程（见下图）</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-32-05.png" alt=""></p>
<ol start="2">
<li>CPU干预的频率<br>
极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</li>
<li>数据传送的单位<br>
每次读/写<strong>一组数据块</strong></li>
<li>数据的流向（<strong>在通道的控制下进行</strong>）<br>
读操作（数据输入）：I/O设备→内存<br>
写操作（数据输出）：内存→I/O设备</li>
<li>主要缺点和主要优点<br>
缺点：实现复杂，需要专门的通道硬件支持<br>
<strong>优点：CPU、通道、I/O设备可并行工作，资源利用率很高</strong>。</li>
</ol>
<hr>
<ul>
<li><u><strong>知识点回顾与重要考点</strong></u></li>
</ul>
<p>难点理解：<br>
通道=弱鸡版CPU<br>
通道程序=任务清单</p>
<table>
<thead>
<tr>
<th></th>
<th>完成一次读/写的过程</th>
<th>CPU干预频率</th>
<th>每次I/O的数据传输单位</th>
<th>数据流向</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序直接控制方式</td>
<td>CPU发出I/O命令后需要不断轮询</td>
<td>极高</td>
<td>字</td>
<td>I/O设备→CPU→内存 <br/>内存→CPU→I/O设备</td>
</tr>
<tr>
<td>中断驱动方式</td>
<td>CPU发出I/O命令后可以做其他事，本次I/O完成后设备控制器发出中断信号</td>
<td>高</td>
<td>字</td>
<td>I/O设备→CPU→内存 <br/>内存→CPU→I/O设备</td>
</tr>
<tr>
<td>DMA方式</td>
<td>CPU发出I/O命令后可以做其他事，本次I/O完成后DMA控制器发出中断信号</td>
<td>中</td>
<td>块</td>
<td>I/O设备→内存 <br />内存→I/O设备</td>
</tr>
<tr>
<td>通道控制方式</td>
<td>CPU发出I/O命令后可以做其他事。通道会执行通道程序以完成I/O，完成后通道向CPU发出中断信号</td>
<td>低</td>
<td>一组块</td>
<td>I/O设备→内存 <br/>内存→I/O设备</td>
</tr>
</tbody>
</table>
<p><strong>优缺点</strong>：每一个阶段的优点都是解决了上一阶段的最大缺点。 总体来说，整个发展过程就是要尽量减少CPU对I/O过程的干预，把CPU从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。</p>
<hr>
<h2 id="5-1-4-I-O软件层次结构">5.1.4 I/O软件层次结构</h2>
<blockquote>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-48-28.png" alt=""></p>
<p>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）</p>
</blockquote>
<ul>
<li><strong><u>用户层软件</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-51-42.png" alt=""></p>
<p>【有的题目中也会称设备独立性软件为系统调用处理层】</p>
<p>Windows 操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用（Windows API）</p>
<hr>
<ul>
<li><strong><u>设备独立性软件</u></strong></li>
</ul>
<p><strong>设备独立性软件</strong>，又称<strong>设备无关性软件</strong>。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<p>主要实现的功能：<br>
① 向上层提供统一的调用接口（如 read/write 系统调用）；</p>
<p>② 设备的保护；<br>
原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</p>
<p>③ 差错处理<br>
设备独立性软件需要对一些设备的错误进行处理【差错类型太多了，基本没法考】</p>
<p>④ 设备的分配与回收</p>
<p>⑤ 数据缓冲区管理<br>
可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
<p>⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序<br>
用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名（eg：去学校打印店打印时，需要选择打印机1/打印机2/打印机3 ，其实这些都是<strong>逻辑设备名</strong>）</p>
<p><strong>设备独立性软件</strong>需要通过“<strong>逻辑设备表（LUT，Logical Unit Table</strong>）”来确定逻辑设备对应的<strong>物理设备</strong>，并找到该设备对应的<strong>设备驱动程序</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-01-03.png" alt=""></p>
<p>操作系统系统可以采用两种方式管理<strong>逻辑设备表（LUT</strong>）：<br>
<strong>第一种方式</strong>，<strong>整个系统只设置一张LUT</strong>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。<br>
<strong>第二种方式</strong>，<strong>为每个用户设置一张LUT</strong>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p>
<hr>
<ul>
<li><strong><u>思考：为何不同的设备需要不同的设备驱动程序？</u></strong></li>
</ul>
<p>各式各样的设备，外形不同，其内部的电子部件（I/O控制器）也有可能不同</p>
<p>eg：<br>
佳能打印机的厂家规定状态寄存器为 0 代表空闲，1代表忙碌。有两个数据寄存器<br>
惠普打印机的厂家规定状态寄存器为 1代表空闲，0代表忙碌。有一个数据寄存器</p>
<p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p>
<hr>
<ul>
<li><strong><u>设备驱动程序</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-06-19.png" alt=""></p>
<p>注：驱动程序一般会以一个独立进程的方式存在。如下图</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-01-03.png" alt=""></p>
<hr>
<ul>
<li><strong><u>中断处理程序</u></strong></li>
</ul>
<p>当I/O任务完成时，I/O控制器会发送一个<strong>中断信号</strong>，系统会<strong>根据中断信号类型</strong>找到相应的<strong>中断处理程序</strong>并执行。中断处理程序的处理流程如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-13-38.png" alt=""></p>
<hr>
<ul>
<li><strong><u>知识点回顾与重要考点</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>用户层软件</strong></td>
<td>实现与用户交互的接口，向上提供方便易用的库函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>设备独立性软件</strong></td>
<td>① 向上层提供统一的调用接口（如 read/write 系统调用）； <br />② 设备的保护；<br />③ 差错处理；<br />④ 设备的分配与回收；<br />⑤ 数据缓冲区管理；<br />⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序…</td>
</tr>
<tr>
<td style="text-align:center"><strong>设备驱动程序</strong></td>
<td>设置设备寄存器、检查设备状态</td>
</tr>
<tr>
<td style="text-align:center"><strong>中断处理程序</strong></td>
<td>进行中断处理</td>
</tr>
<tr>
<td style="text-align:center"><strong>硬件</strong></td>
<td>执行I/O操作，有机械部件、电子部件组成（参考“I/O控制器”小节的视频）</td>
</tr>
</tbody>
</table>
<p>理解并记住I/O软件<strong>各个层次之间的顺序</strong>，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可：<strong>直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</strong>）</p>
<hr>
<h2 id="5-1-5-输入-输出应用程序接口和设备驱动程序接口">5.1.5 输入/输出应用程序接口和设备驱动程序接口</h2>
<ul>
<li><strong><u>输入/输出应用程序接口</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-21-42.png" alt=""></p>
<p>显然，用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的I/O</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-27-53.png" alt=""></p>
<ul>
<li>
<p><strong>字符设备接口</strong>：<br>
get/put 系统调向字符设备读/写一个字符；<br>
基本特征：传送速率低，<strong>不可寻址</strong>，并且在输入输出时通常采用中断驱动方式。</p>
</li>
<li>
<p><strong>块设备接口</strong>：<br>
read/write 系统调用：向块设备的<strong>读写指针位置</strong>读/写多个字符；<br>
seek系统调用：<strong>修改读写指针位置</strong>；<br>
基本特征：传送速率高，可寻址。</p>
</li>
<li>
<p><strong>网络设备接口</strong>，又称“<strong>网络套接字(socket)接口</strong>：<br>
<code>socket = (主机IP地址，端口号)</code><br>
socket 系统调用：<strong>创建一个网络套接字</strong>，需指明网络协议 (TCP? UDP?)<br>
bind：将套接字绑定到某个本地“<strong>端口</strong>“<br>
connect：将套接字连接到远程地址<br>
read/write：从套接字读/写数据</p>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-42-10.png" alt=""></p>
<hr>
<ul>
<li><strong><u>阻塞/非阻塞 I/O</u></strong></li>
</ul>
<p>阻塞I/O：应用程序发出I/O系统调用，<strong>进程需转为阻塞态等待</strong>。<br>
eg：字符设备接口——从键盘读一个字符 get【scanf()】</p>
<p>非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，<strong>进程无需阻寒等待</strong>。<br>
eg：块设备接口——往磁盘写数据 write</p>
<hr>
<ul>
<li><strong><u>设备驱动程序接口</u></strong></li>
</ul>
<p>若各公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-49-19.png" alt=""></p>
<hr>
<ul>
<li><strong><u>统一标准的设备驱动程序接口</u></strong></li>
</ul>
<p>操作系统规定好设备驱动程序的接口标准，各厂商必须按要求开发设备驱动程序</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-49-24.png" alt=""></p>
<p>不同的操作系统，对设备驱动程序接口的标准各不相同</p>
<p>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用。eg:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_22-52-00.png" alt=""></p>
<hr>
<h2 id="5-2-1-I-O核心子系统">5.2.1 I/O核心子系统</h2>
<blockquote>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_21-48-28.png" alt=""></p>
<p>因此I/O核心子系统要实现的功能其实就是中间三层要实现的功能 （参考上节）</p>
<p>考研中，我们需要重点理解和掌握的功能是：I/O调度、设备保护、假脱机技术 （SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存）这些功能要在哪个层次实现？</p>
</blockquote>
<ul>
<li><strong><u>这些功能要在哪个层次实现？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-31-28.png" alt=""></p>
<p>注：假脱机技术（SPOOLing 技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。但是<strong>408大纲又将假脱机技术归为“I/O核心子系统” 的功能，因此考试时还是以大纲为准</strong>。</p>
<hr>
<ul>
<li><strong><u>I/O调度</u></strong></li>
</ul>
<p><strong>I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求。</strong></p>
<p>如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、 C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。</p>
<p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序。</p>
<hr>
<ul>
<li><strong><u>设备保护</u></strong></li>
</ul>
<p>操作系统需要实现<strong>文件保护功能</strong>，不同的用户对各个文件有不同的访问权限（如：只读、读和 写等）。</p>
<p>在UNIX系统中，<strong>设备被看做是一种特殊的文件</strong>，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。（参考“文件保护”小节）</p>
<hr>
<h2 id="5-2-2-假脱机技术">5.2.2 假脱机技术</h2>
<ul>
<li><strong><u>什么是脱机技术</u></strong></li>
</ul>
<p>手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-38-38.png" alt=""></p>
<p>批处理阶段引入了<strong>脱机输入/输出技术</strong>（用磁带完成）：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-41-08.png" alt=""></p>
<p>在外围控制机的控制下， 慢速输入设备的数据先被输入到更快速的磁带上。 之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾</p>
<p>Tips：为什么称为“脱机”——脱离主机的控制进行的输入/输出操作。</p>
<p>引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备1正在忙碌，也可以提前将数据输出到磁带。</p>
<hr>
<ul>
<li><strong><u>假脱机技术——输入井和输出井</u></strong></li>
</ul>
<p>“<strong>假脱机技术</strong>”，又称“<strong>SPOOLing 技术</strong>”是用软件的方式模拟脱机技术。 SPOOLing 系统的组成如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-43-19.png" alt=""></p>
<p>在磁盘上开辟出两个 存储区域——“<strong>输入井</strong>”和“<strong>输出井</strong>”</p>
<p>“输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据</p>
<p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</p>
<p>“输入进程”模拟脱机输入时的外围控制机</p>
<p>“输出进程”模拟脱机输出时的外围控制机</p>
<p>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</p>
<p>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</p>
<p>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上</p>
<hr>
<ul>
<li><strong><u>共享打印机原理分析</u></strong></li>
</ul>
<p>独占式设备——<strong>只允许各个进程串行使用的设备</strong>。一段时间内只能满足一个进程的请求。<br>
共享设备——<strong>允许多个进程“同时”使用的设备</strong>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p>
<p>打印机是种“独占式设备”，但是可以用 SPOOLing 技术改造成“共享设备”</p>
<p>独占式设备的例子：若进程1 正在使用打印机，则进程2 请求使用打印机时必然阻塞等待</p>
<p><strong>共享打印机原理分析如下</strong>：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-11_23-57-17.png" alt=""></p>
<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们， 而是由假脱机管理进程为每个进程做两件事：</p>
<p>（1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</p>
<p>（2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</p>
<p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数 据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p>
<p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p>SPOOLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，<strong>可将独占式设备改造成共享设备</strong>。</p>
<hr>
<h2 id="5-2-3-设备的分配与回收">5.2.3 设备的分配与回收</h2>
<ul>
<li><strong><u>设备分配时应考虑的因素</u></strong>
<ul>
<li><strong>设备的固有属性</strong></li>
<li><strong>设备的分配算法</strong></li>
<li><strong>设备分配中的安全性</strong></li>
</ul>
</li>
</ul>
<p><strong>设备的固有属性</strong>可分为三种：独占设备、共享设备、虚拟设备。<br>
<strong>独占设备</strong>——一个时段只能分配给一个进程（如打印机）<br>
<strong>共享设备</strong>——可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。<br>
<strong>虚拟设备</strong>——采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</p>
<p><strong>设备的分配算法</strong>：<br>
先来先服务<br>
优先级高者优先<br>
短任务优先<br>
……</p>
<p>从<strong>进程运行的安全性</strong>上考虑，设备分配有两种方式：</p>
<ul>
<li>
<p><strong>安全分配方式</strong>：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。</p>
<p>一个时段内每个进程只能使用一个设备<br>
优点：破坏了“请求和保持”条件，不会死锁<br>
缺点：对于一个进程来说，CPU和I/O设备只能串行工作</p>
</li>
<li>
<p><strong>不安全分配方式</strong>：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。（eg：考虑进程请求打印机打印输出的例子）</p>
<p>一个进程可以同时使用多个设备<br>
优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进<br>
缺点：有可能发生死锁（死锁避免、死锁的检测和解除）【银行家算法……】</p>
</li>
</ul>
<hr>
<ul>
<li><strong><u>静态分配和动态分配</u></strong></li>
</ul>
<p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源<br>
【破坏了“请求和保持”条件，不会发生死锁】</p>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<hr>
<ul>
<li><strong><u>设备分配管理中的数据结构</u></strong></li>
</ul>
<p>“设备、控制器、通道”之间的关系：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-10-28.png" alt=""></p>
<p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p>
<p><strong>设备控制表（DCT）</strong> ：系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-14-28.png" alt=""></p>
<p>注：“进程管理”章节中曾经提到过“系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中”</p>
<p><strong>控制器控制表（COCT）</strong> ：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-18-28.png" alt=""></p>
<p><strong>通道控制表（CHCT）</strong> ：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-19-07.png" alt=""></p>
<p><strong>系统设备表（SDT）</strong> ：记录了<strong>系统中全部设备</strong>的情况，每个设备对应一个表目。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-20-00.png" alt=""></p>
<hr>
<ul>
<li><strong><u>设备分配的步骤</u></strong></li>
</ul>
<p>① 根据进程请求的<strong>物理设备名</strong>查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-20-56.png" alt=""></p>
<p>② 根据SDT找到DCT，若<strong>设备</strong>忙碌则将进程PCB挂到<strong>设备等待队列</strong>中，不忙碌则将<strong>设备</strong>分配给进程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-21-37.png" alt=""></p>
<p>③ 根据DCT找到COCT，若<strong>控制器</strong>忙碌则将进程PCB挂到<strong>控制器等待队列</strong>中，不忙碌则将<strong>控制器</strong>分配给进程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-22-09.png" alt=""></p>
<p>④ 根据COCT找到CHCT，若<strong>通道</strong>忙碌则将进程PCB挂到<strong>通道等待队列</strong>中，不忙碌则将<strong>通道</strong>分配给进程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-26-41.png" alt=""></p>
<p><strong>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</strong></p>
<p>【一个通道控制多个控制器， 一个控制器控制多个设备】</p>
<hr>
<ul>
<li><strong><u>设备分配步骤的改进</u></strong></li>
</ul>
<p>之前的缺点：<br>
① 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程<br>
② 若换了一个物理设备，则程序无法运行<br>
③ 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p>
<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>
<p>改进过程：<br>
① 根据进程请求的<strong>逻辑设备名</strong>查找SDT（<strong>注：用户编程时提供的逻辑设备名其实就是“设备类型</strong>”）<br>
② 查找SDT，找到用户进程<strong>指定类型的、并且空闲</strong>的设备，将其分配给该进程。操作系统<strong>在逻辑设备表（LUT）中新增一个表项</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-35-10.png" alt=""></p>
<p>剩下的一样：<br>
③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。<br>
④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p>
<p><strong>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系</strong>。</p>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在 LUT中增加相应表项。</p>
<p><strong>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</strong>。</p>
<p>逻辑设备表的设置问题：<br>
整个系统只有一张LUT：各用户所用的<strong>逻辑设备名不允许重复</strong>，适用于单用户操作系统<br>
每个用户一张LUT：不同用户的<strong>逻辑设备名可重复</strong>，适用于多用户操作系统</p>
<hr>
<h2 id="5-2-4-缓冲区管理">5.2.4 缓冲区管理</h2>
<ul>
<li><strong><u>什么是缓冲区？有什么作用？</u></strong></li>
</ul>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<p>使用<strong>硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器【快表】，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“设备独立性软件”的缓冲区管理就是要组织管理 好这些缓冲区</p>
<p><strong>缓冲区的作用</strong>：</p>
<ul>
<li>缓和CPU和I/O设备之间速度不匹配的矛盾</li>
</ul>
<p>CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事<br>
慢速的I/O设备可以慢慢从缓冲区取走数据<br>
数据输入时类似</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_20-59-36.png" alt=""></p>
<ul>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
</ul>
<p>如果是字符型设备，则每输出完一个字符就要向CPU发送一次中断信号</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-00-16.png" alt=""></p>
<ul>
<li>解决数据粒度不匹配的问题</li>
</ul>
<p>如：输出进程每次可以生成一块数据，但I/O设备每次只能输出一个字符</p>
<ul>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
<hr>
<ul>
<li><strong><u>单缓冲</u></strong></li>
</ul>
<p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会在<strong>主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>
<p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</strong>。</p>
<p>【用户进程的内存空间中，会分出一片工作区来接受输入/输出数据（一般也默认工作区大小与缓冲区相同）】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-04-18.png" alt=""></p>
<p><strong>常考题型</strong>：计算每处理一块数据平均需要多久？<br>
<strong>技巧</strong>：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间。</p>
<p>在“单缓冲”题型中，可以假设初始状态为工作区满，缓冲区空。<br>
[分析1]：【如上图，T M C表示的都是时间】<br>
初始状态：工作区满，缓冲区空<br>
<strong>假设T&gt;C</strong>【因此CPU处理完数据后暂时不能将下一块数据传送到工作区，必须等待缓冲区中冲满数据】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-09-45.png" alt=""></p>
<p>所以处理一块数据的平均用时 = T+M</p>
<p>[分析2]：<br>
初始状态：工作区满，缓冲区空<br>
<strong>假设T&lt;C</strong>【因此缓冲区中冲满数据后暂时不能继续冲入下一块数据， 必须等待CPU处理结束后将数据从缓冲区传送到工作区】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-12-53.png" alt=""></p>
<p>所以处理一块数据的平均用时 = C+M</p>
<p><strong>结论：采用单缓冲策略，处理一块数据平均耗时 Max(C, T) + M</strong></p>
<hr>
<ul>
<li><strong><u>双缓冲</u></strong></li>
</ul>
<p>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-18-05.png" alt=""></p>
<p>双缓冲题目中，假设初始状态为：<strong>工作区空，其中一个缓冲区满，另一个缓冲区空</strong></p>
<p>[分析1]：<br>
<strong>假设T&gt;C+M</strong><br>
【状态分析（缓冲区1，缓冲区2）0：（满，空）T：（空，满）2T：（满，空）】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-22-51.png" alt=""></p>
<p>处理一块数据的平均用时 = T</p>
<p>[分析2]：<br>
<strong>假设T&lt;C+M</strong>【没办法周期的回到初始状态了，之前的方法不适用】<br>
假设2T&lt;2M+C，则I/O设备将缓冲区1冲满时，缓冲区2的数据尚未取空，因此I/O设备暂时不能冲入数据，结果如下图</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-26-19.png" alt=""></p>
<p>注：M(1) 表示“将缓冲区1中的数据传送到工作区”； M(2) 表示“将缓冲区2中的数据传送到工作区”</p>
<p>总之，T&lt;C+M 意味着<strong>设备输入数据块的速度要比处理机处理数据块的速度更快</strong>。每处理一个数据块平均耗时C+M</p>
<p><strong>结论：采用双缓冲策略，处理一个数据块的平均耗时为 Max(T, C+M)</strong></p>
<hr>
<ul>
<li><strong><u>使用单/双缓冲在通信时的区别</u></strong></li>
</ul>
<p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。</p>
<p>显然，若两个相互通信的机器只设置<strong>单缓冲区</strong>，在任一时刻只能实现数据的单向传输。如下图：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-32-51.png" alt=""></p>
<p>若两个相互通信的机器设置<strong>双缓冲区</strong>，则同一时刻可以实现双向的数据传输。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-34-30.png" alt=""></p>
<p><strong>注：管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</strong></p>
<hr>
<ul>
<li><strong><u>循环缓冲区</u></strong></li>
</ul>
<p>将多个<strong>大小相等</strong>的缓冲区链接成一个<strong>循环队列</strong>。</p>
<p>注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-36-51.png" alt=""></p>
<hr>
<ul>
<li><strong><u>缓冲池</u></strong></li>
</ul>
<p><strong>缓冲池</strong>由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-38-18.png" alt=""></p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-39-05.png" alt=""></p>
<p>原理分析：</p>
<p>① 输入进程请求输入数据</p>
<p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-46-00.png" alt=""></p>
<p>② 计算进程想要取得一块输入数据</p>
<p>从输入队列中取得一块冲满输入数据的缓冲区作 “提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-47-24.png" alt=""></p>
<p>③ 计算进程想要将准备好的数据冲入缓冲区</p>
<p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-48-34.png" alt=""></p>
<p>④ 输出进程请求输出数据</p>
<p>从输出队列中取得一块冲满输出数据的缓冲区作为 “提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_21-49-23.png" alt=""></p>
<hr>
<h2 id="5-3-1-磁盘结构">5.3.1 磁盘结构</h2>
<ul>
<li><strong><u>磁盘、磁道、扇区</u></strong></li>
</ul>
<p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-07-19.png" alt=""></p>
<p>如下图：<br>
磁盘的盘面被划分成一个个磁道这样的一个“圈”就是一个磁道<br>
一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同 (如1KB)<br>
最内侧磁道上的扇区面积最小，因此数据密度最大</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-14-35.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何在磁盘中读/写数据</u></strong></li>
</ul>
<p>需要把“磁头”移动到想要读/写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-16-19.png" alt=""></p>
<hr>
<ul>
<li><strong><u>盘面、柱面</u></strong></li>
</ul>
<p>一个盘片可能会有两个盘面【正反面】</p>
<p>每个盘面对应一个磁头</p>
<p>所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退“</p>
<p>所有盘面中相对位置相同的磁道组成柱面【下图的黄色磁道】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-21-30.png" alt=""></p>
<hr>
<ul>
<li><strong><u>磁盘的物理地址</u></strong></li>
</ul>
<p>可用 <strong>(柱面号，盘面号，扇区号)</strong> 来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成(柱面号，盘面号，扇区号)的地址形式</p>
<p>可根据该地址读取一个“块”</p>
<ol>
<li>根据“柱面号”移动磁臂，让磁头指向指定柱面;</li>
<li>激活指定盘面对应的磁头;</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>
</ol>
<hr>
<ul>
<li><strong><u>磁盘的分类</u></strong></li>
</ul>
<p>磁头可以移动的称为<strong>活动头磁盘</strong>。磁臂可以来回伸缩来带动磁头定位磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-24-08.png" alt=""></p>
<p>磁头不可移动的称为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头【下图中别的盘面中的磁头<strong>只是没画出来</strong>】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-25-52.png" alt=""></p>
<p>盘片可以更换的称为<strong>可换盘磁盘</strong><br>
盘片不可更换的称为<strong>固定盘磁盘</strong></p>
<hr>
<h2 id="5-3-2-磁盘的调度算法">5.3.2 磁盘的调度算法</h2>
<ul>
<li><strong><u>一次磁盘读/写需要的时间</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-42-43.png" alt=""></p>
<p><strong>寻找时间 (寻道时间)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">T_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 在读/写数据前，将磁头移动到指定磁道所花的时间。</p>
<ol>
<li><strong>启动磁头臂</strong>是需要时间的。假设耗时为s;</li>
<li><strong>移动磁头</strong>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越n条磁道。则:<br>
<strong>寻道时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">T_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= s + m*n</strong></li>
</ol>
<p><strong>延迟时间</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。: 通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r (单位:转/秒，或转/分)，则：<br>
<strong>平均所需的延迟时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = (1/2)*(1/r) = 1/2r</strong>【1/r 就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以 1/2】</p>
<p><strong>传输时间</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的之节数为 N。则:<br>
<strong>传输时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>= (1/r) * (b/N) = b/(rN)</strong><br>
【每个磁道要可存 N 字节的数据，因此 b 字节的数据需要 b/N 个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间 1/r】</p>
<p>总的平均存取时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + 1/2r + b/(rN)</p>
<p>延迟时间和传输时间与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此<strong>操作系统也无法优化延迟时间和传输时间</strong></p>
<p>但是操作系统的磁盘调度算法会直接影响<strong>寻道时间</strong></p>
<hr>
<ul>
<li><strong><u>先来先服务算法（FCFS）</u></strong></li>
</ul>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p>按照 FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_22-56-45.png" alt=""></p>
<p>磁头总共移动了45+3+19+21+72+70+10+112+146 = 498 个磁道</p>
<p>响应一个请求平均需要移动 498/9 = 55.3 个磁道(平均寻找长度)</p>
<p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去。</p>
<p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。【相当于随机访问了】</p>
<hr>
<ul>
<li><strong><u>最短寻找时间优先 （SSTF）</u></strong></li>
</ul>
<p>SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。 (其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-12_23-01-37.png" alt=""></p>
<p>磁头总共移动了 (100-18)+(184-18) = 248 个磁道</p>
<p>响应一个请求平均需要移动 248/9 = 27.5个磁道(平均寻找长度)</p>
<p>优点：性能较好，平均寻道时间短</p>
<p>缺点：可能产生“<strong>饥饿</strong>”现象<br>
Eg：本例中，如果在处理18号磁道的访问请求时又来了个38号磁道的访问请求，处理38号的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的 18号、38号磁道的访问请求到来的话，150、160、184 号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。<br>
【产生饥饿的原因在于：磁头在一个小区域内来回来去地移动】</p>
<hr>
<ul>
<li><strong><u>扫描算法（SCAN）</u></strong></li>
</ul>
<p>SSTF 算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。这就是扫描算法 (SCAN) 的<strong>思想</strong>。由于磁头移动的方式很像电梯，因此也叫<strong>电梯算法</strong>。</p>
<p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头<strong>正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-04-24.png" alt=""></p>
<p>磁头总共移动了(200-100) +(200-18) = 282 个磁道</p>
<p>响应一个请求平均需要移动 282/9 =31.3 个磁道(平均寻找长度)</p>
<p>优点：性能较好，平均寻道时间较短，<strong>不会产生饥饿现象</strong></p>
<p>缺点：<br>
① 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。<br>
② SCAN算法对于各个位置磁道的响应频率不平均（如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应 184 号磁道的请求了)</p>
<hr>
<ul>
<li><strong><u>LOOK 调度算法</u></strong></li>
</ul>
<p><strong>扫描算法（SCAN）</strong> 中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</p>
<p><strong>LOOK 调度算法</strong>就是为了解决这个问题，<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</strong>。 (边移动边观察，因此叫 LOOK)</p>
<p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头<strong>正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-12-47.png" alt=""></p>
<p>磁头总共移动了 (184-100)+(184-18)= 250个磁道</p>
<p>响应一个请求平均需要移动 250/9 = 27.5个磁道(平均寻找长度)</p>
<p>优点：比起 SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>
<hr>
<ul>
<li><strong><u>循环扫描算法（C-SCAN）</u></strong></li>
</ul>
<p>SCAN算法对于各个位置磁道的响应频率不平均，而 <strong>C-SAN 算法</strong>就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>。</p>
<p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且<strong>此时磁头正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-17-25.png" alt=""></p>
<p>磁头总共移动了(200-100)+(200-) +(90-0)= 390个磁道</p>
<p>响应一个请求平均需要移动 390/9 = 43.3 个磁道(平均寻找长度)</p>
<p>优点：比起SCAN 来，对于各个位置磁道的响应频率很平均。</p>
<hr>
<ul>
<li><strong><u>C-LOOK 调度算法</u></strong></li>
</ul>
<p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。<strong>C-LOOK 算法</strong>就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<p>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且<strong>此时磁头正在往磁道号增大的方向移动</strong>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_00-29-49.png" alt=""></p>
<p>磁头总共移动了 (184-100) +(184-18) +(90-18)= 322 个磁道</p>
<p>响应一个请求平均需要移动 322/9 =35.8个磁道(平均寻找长度)</p>
<p>优点：比起 C-SCAN 算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时问进一步缩短</p>
<hr>
<ul>
<li><strong><u>知识点回顾与重要考点</u></strong></li>
</ul>
<p>磁盘调度算法影响的指标：<strong>移动磁头的时间</strong></p>
<p><strong>若题目中无特别说明</strong>，则<br>
<strong>SCAN 就是 LOOK,</strong><br>
<strong>C-SCAN 就是C-LOOK</strong></p>
<hr>
<h2 id="5-3-3-减少磁盘延迟时间的方法">5.3.3 减少磁盘延迟时间的方法</h2>
<blockquote>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-04-15.png" alt=""></p>
<p>假设要连续读取橙色区域的 2、3、4扇区：磁头读取一块的内容(也就是一个扇区的内容)后，需要一小段时间处理，而盘片又在不停地旋转</p>
<p>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区，必须等盘片继续旋转，3号扇区<strong>再次</strong>划过磁头，才能完成扇区读入</p>
<p><strong>结论</strong>：<strong>磁头读入一个扇区数据后需要一小段时间处理</strong>，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间“</p>
</blockquote>
<ul>
<li><strong><u>减少延迟时间的方法：交替编号</u></strong></li>
</ul>
<p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-0-49.png" alt=""></p>
<hr>
<ul>
<li><strong><u>磁盘地址结构设计</u></strong></li>
</ul>
<p>思考：为什么磁盘的物理地址是(柱面号，盘面号，扇区号)，而不是 (盘面号，柱面号，扇区号)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-11-29.png" alt=""></p>
<p>假设某磁盘有8个柱面/磁道(假设最内侧柱面/磁道号为0)，4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p>
<ul>
<li>
<p><strong>若物理地址结构是(盘面号，柱面号，扇区号)</strong> ，且需要连续读取物理地址 (00,000,000) ~ (00,001,111)的扇区:</p>
<p>(00,000,000) ~ (00,000,111) 转两圈可读完</p>
<p>之后再读取物理地址相邻的区域，即(00,001,000) ~ (00,001,111)，<strong>需要启动磁头臂</strong>，<strong>将磁头移动到下一个磁道</strong></p>
</li>
<li>
<p><strong>若物理地址结构是(柱面号，盘面号，扇区号)</strong> ，且需要连续读取物理地址 (000,00,000) ~ (000,01,111)的扇区:</p>
<p>(000,00,000) ~ (000,00,111) 由盘面0的磁头读入数据</p>
<p>之后再读取物理地址相邻的区域，即(000,01,000) ~ (000,01,111)，<strong>由于柱面号/磁道号相同只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</strong></p>
</li>
</ul>
<p>所以：答：读取地址连续的磁盘块时，采用(柱面号,盘面号，扇区号) 的地址结构<strong>可以减少磁头移动消耗的时间</strong>【可能考选择题】</p>
<p>【可以这么好，柱面号是移动磁头，移动磁头花费大；而把柱面号放在最外面，那么柱面号变化的频率最小，自然也就减少了花费】</p>
<hr>
<ul>
<li><strong><u>减少延迟时间的方法：错位命名</u></strong></li>
</ul>
<p>注意，所有盘面都是一起连轴转的</p>
<p><strong>方案一</strong>：若相邻的盘面相对位置相同处扇区编号相同</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-24-31.png" alt=""></p>
<p>读取完磁盘块 (000, 00, 111) 之后，需要短暂的时间处理，而盘面又在不停地转动，因此当(000, 01, 000)第一次划过磁头下方时读取数据，只能再等该扇区再次划过磁头</p>
<p><strong>方案二</strong>：<strong>错位命名</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-33-08.png" alt=""></p>
<p>由于采用错位命名法，因此读取完磁盘块(000, 00,111) 之后，还有一段时间处理，当 (000, 01,000)第一次划过1号盘面的磁头下方时，就可以直接读取数据，减少了延迟时间</p>
<hr>
<h2 id="5-3-4-磁盘的管理">5.3.4 磁盘的管理</h2>
<ul>
<li><strong><u>磁盘初始化</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-12.png" alt=""></p>
<p><strong>Step 1</strong>：进行<strong>低级格式化(物理格式化)</strong> 【出厂之前】，将磁盘的各个磁道<strong>划分为扇区</strong>。一个扇区通常可分为 头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码(如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-23.png" alt=""></p>
<p><strong>Step 2</strong>：将磁盘分区，每个分区由若干柱面组成(即分为我们熟悉的 C盘、D盘、E盘)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-40-17.png" alt=""></p>
<p><strong>Step 3</strong>：进行<strong>逻辑格式化</strong>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如位示图、空闲分区表)</p>
<hr>
<ul>
<li><strong><u>引导块</u></strong></li>
</ul>
<p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<strong>初始化程序</strong> (<strong>自举程序</strong>) 完成的</p>
<p>初始化程序可以放在<strong>ROM</strong> (<strong>只读存储器</strong>) 中。ROM中的数据在出厂时就写入了，并且<strong>以后不能再修改</strong></p>
<p>注：ROM一般是出厂时就集成在主板上的</p>
<p>初始化程序程序(自举程序) 放在ROM中存在什么问题?<br>
万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p>
<p>解决：ROM中只存放很小的“自举装入程序”；<br>
完整的自举程序放在磁盘的<strong>启动块（即引导块/启动分区）上</strong>，启动块位于磁盘的固定位置；<br>
开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化。</p>
<p>拥有启动分区的磁盘称为<strong>启动磁盘或系统磁盘(C:盘)</strong></p>
<hr>
<ul>
<li><strong><u>坏块的管理</u></strong></li>
</ul>
<p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它</p>
<p>对于简单的磁盘，可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在 FAT 表上标明。 (在这种方式中，<strong>坏块对操作系统不透明</strong>)</p>
<p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br>
在磁盘出厂前进行低级格式化(物理格式化)时就将坏块链进行初始化。<br>
会保留一些“备用扇区“，用于替换坏块。这种方案称为<strong>扇区备用</strong>。且这种处理方式中，<strong>坏块对操作系统透明</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-13_14-50-59.png" alt=""></p>
<hr>
<h2 id="5-3-5-固态硬盘SSD">5.3.5 固态硬盘SSD</h2>
<blockquote>
<p>计组，操作系统考研大纲<strong>新考点</strong></p>
<p>操作系统：<br>
固态硬盘；读写性能特性，磨损均衡</p>
<p>计算机组成原理：固态硬盘(SSD)</p>
</blockquote>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-39-25.png" alt=""></p>
<hr>
<ul>
<li><strong><u>机械硬盘 vs 固态硬盘</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-40-55.png" alt=""></p>
<hr>
<ul>
<li><strong><u>固态硬盘的结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/computer_organization/Snipaste_2023-07-07_10-47-12.png" alt=""></p>
<p>每个闪存芯片由若干块组成，比如块大小:16KB~512KB</p>
<p>每个块再拆解为一个一个页，比如页大小，512B~4KB</p>
<p>系统读写以 页 为单位，磁盘中则是块（扇区），这里作区分</p>
<hr>
<ul>
<li><strong><u>理想情况下，固态硬盘的寿命</u></strong></li>
</ul>
<p>某固态硬盘采用磨损均衡技术，大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span></span></span></span></span></span></span></span></span>B=1TB，闪存块的擦写寿命只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>=1K次。某男子平均每天会对该固态硬盘写<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>37</mn></msup></mrow><annotation encoding="application/x-tex">2^{37}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">37</span></span></span></span></span></span></span></span></span></span></span></span>B=128GB数据。在最理想的情况下，这个固态硬盘可以用多久?</p>
<p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。</p>
<p>1TB/128GB =8<br>
因此，平均每8天，每个闪存块需要擦除一次。每个闪存块可以被擦除1K次，因此，经过8K天，约23年后，该固态硬盘被男子玩坏</p>
<p>所以没那么容易坏</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.netlify.app">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.netlify.app/posts/54954ebc.html">https://gxblogs.netlify.app/posts/54954ebc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.netlify.app" target="_blank">ggw和xpl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/118b0d8c.html"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">王道计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/posts/30eda4c1.html"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/fc4637c0.html" title="择校信息"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-09-20_07-53-44.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-20</div><div class="title">择校信息</div></div></a></div><div><a href="/posts/a50e5893.html" title="408做题笔记"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-08-31_08-29-31.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">408做题笔记</div></div></a></div><div><a href="/posts/cccb0b9b.html" title="820笔记"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/message/Snipaste_2023-09-24_22-51-23.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-24</div><div class="title">820笔记</div></div></a></div><div><a href="/posts/c883127.html" title="词根词缀"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/courses/en/Snipaste_2023-07-18_21-17-53.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-18</div><div class="title">词根词缀</div></div></a></div><div><a href="/posts/d7158ead.html" title="查缺补漏"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/message/Snipaste_2023-11-19_00-31-46.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-19</div><div class="title">查缺补漏</div></div></a></div><div><a href="/posts/e5638c49.html" title="政治笔记"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-09-19_14-26-47.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">政治笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1.1 操作系统的概念、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.1.2 操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 操作系统的发展与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3.1 操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">1.3.2 中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.3.3 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">1.4.1 操作系统的体系结构（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">1.4.2 操作系统的体系结构（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-text">1.5 操作系统的引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.1.2 进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.5 线程概念 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.6 线程的实现方式 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.7 线程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 调度的概念、层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机、切换与过程调度方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E9%97%B2%E9%80%9B%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.2.3 调度器和闲逛程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.4 调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%951%EF%BC%9A%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-text">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-6-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952%EF%BC%9A%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%953%EF%BC%9A%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">2.2.5 调度算法3：多级队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3.1 进程同步 进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-4-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">2.3.4 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.5 信号量机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-6-%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-text">2.3.6 用信号量机制实现：进程互斥、同步、前驱关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-7-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.7 生产者消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-8-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.3.8 多生产者-多消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-9-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.9 吸烟者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-10-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.10 读者-写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-11-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.11 哲学家进餐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-12-%E7%AE%A1%E7%A8%8B"><span class="toc-text">2.3.12 管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4.1 死锁的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.2 死锁的处理策略——预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.3 死锁的处理策略——避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-text">2.4.4 死锁的处理策略——检测和解除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3.1.1 内存的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.2 内存管理的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-3-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.1.3 覆盖与交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.4 连续分配管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-5-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5 动态分区分配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-6-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.6 基本分页存储管理的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-7-%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.7 基本地址变换机构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-8-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.8 具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-9-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">3.1.9 两级页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-10-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.10 基本分段存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-11-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.11 段页式管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.2.1 虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2.2 请求分页管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.3 页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-4-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">3.2.4 页面分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-5-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">3.2.5 内存映射文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-1-%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">4.1.1 初识文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">4.1.2 文件的逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">4.1.3 文件目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">4.1.4 文件的物理结构（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">4.1.4 文件的物理结构（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-5-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84Vs%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">4.1.5 逻辑结构Vs物理结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-6-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">4.1.6 文件存储空间管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-7-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">4.1.7 文件的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-8-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">4.1.8 文件共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-10-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-text">4.1.10 文件保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.1 文件系统的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%A8%E5%B1%80%E7%BB%93%E6%9E%84%EF%BC%88%E5%B8%83%E5%B1%80%EF%BC%89"><span class="toc-text">4.3.2 文件系统的全局结构（布局）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-3-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.3.3 虚拟文件系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第五章 输入&#x2F;输出（I&#x2F;O）管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">5.1.1 I&#x2F;O设备的概念和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-2-I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">5.1.2 I&#x2F;O控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-3-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">5.1.3 I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">5.1.4 I&#x2F;O软件层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-5-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.1.5 输入&#x2F;输出应用程序接口和设备驱动程序接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-1-I-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.2.1 I&#x2F;O核心子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-2-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-text">5.2.2 假脱机技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-3-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">5.2.3 设备的分配与回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-4-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">5.2.4 缓冲区管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-1-%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">5.3.1 磁盘结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-2-%E7%A3%81%E7%9B%98%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">5.3.2 磁盘的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-3-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.3.3 减少磁盘延迟时间的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-4-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">5.3.4 磁盘的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-5-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98SSD"><span class="toc-text">5.3.5 固态硬盘SSD</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>