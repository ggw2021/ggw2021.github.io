<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面经 | GXBLOGS</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的简历 CS-Notes 面试笔记 (cyc2018.xyz) 小林coding (xiaolincoding.com) 帅地玩编程-校招|面试|学习路线，你都可以在这里找到 (iamshuaidi.com) 大厂15万字C++开发面试手册出炉(C++和计算机基础全有) (qq.com) 编程十万问的个人空间 (bilibili.com) 程序员面试HR问题汇总及答案，好不容易过了一面二面，千">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://gxblogs.com/posts/65115/index.html">
<meta property="og:site_name" content="GXBLOGS">
<meta property="og:description" content="我的简历 CS-Notes 面试笔记 (cyc2018.xyz) 小林coding (xiaolincoding.com) 帅地玩编程-校招|面试|学习路线，你都可以在这里找到 (iamshuaidi.com) 大厂15万字C++开发面试手册出炉(C++和计算机基础全有) (qq.com) 编程十万问的个人空间 (bilibili.com) 程序员面试HR问题汇总及答案，好不容易过了一面二面，千">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-28_23-36-48.png">
<meta property="article:published_time" content="2024-03-28T15:39:23.113Z">
<meta property="article:modified_time" content="2024-09-22T13:50:44.959Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="求职">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-28_23-36-48.png"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.com/posts/65115/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: GXBLOGS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-22 21:50:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/highlight/Kimbiedark.css"><script src="/css/else/echarts.min.js"></script><script src="/css/else/wow.min.js"></script><script type="text/javascript" src="/css/else/echarts-gl.min.js"></script><script src="/css/else/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="/static/imgs/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-28_23-36-48.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GXBLOGS</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-28T15:39:23.113Z" title="发表于 2024-03-28 23:39:23">2024-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-22T13:50:44.959Z" title="更新于 2024-09-22 21:50:44">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">70.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>221分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/65115/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/65115/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p><a href="https://gxblogs.com/resume_ggw">我的简历</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/">CS-Notes 面试笔记 (cyc2018.xyz)</a><br>
<a target="_blank" rel="noopener" href="https://xiaolincoding.com/">小林coding (xiaolincoding.com)</a><br>
<a target="_blank" rel="noopener" href="https://www.iamshuaidi.com/">帅地玩编程-校招|面试|学习路线，你都可以在这里找到 (iamshuaidi.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4MjgwNjQ0OQ==&amp;mid=2247487041&amp;idx=1&amp;sn=1c49fe6e12b1e52f66462b8b942e1644&amp;chksm=fdb3f09fcac47989e399f52a975a6d2b18bd15e8cdfe720e3d878866f2d05c758318e2f6241f#rd">大厂15万字C++开发面试手册出炉(C++和计算机基础全有) (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/1886950756">编程十万问的个人空间 (bilibili.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RV4y1p7mz/?spm_id_from=333.337.search-card.all.click&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">程序员面试HR问题汇总及答案，好不容易过了一面二面，千万别栽在HR面_哔哩哔哩_bilibili</a></p>
</blockquote>
<p><br><br><br></p>
<h2 id="手撕">手撕</h2>
<ol>
<li><strong>宇量升</strong>：</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>就是leetcode的动态规划<strong>原题</strong>，刷的不多，压根就没往动态规划想，下面是现场做的暴力解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;./sample1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;样例文件不存在\n&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        nums[n]: 最大和 的连续子数组，至少包含一个数 n &lt; 10^5     int -10^4 ~ 10^4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        -2 1 -3 4 -1 2 1 -5 4</span><br><span class="hljs-comment">        output: 6 [4 -1 2 1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3</span><br><span class="hljs-comment">        output: 3 [3]</span><br><span class="hljs-comment">    */</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) nums.<span class="hljs-built_in">push_back</span>(n);<br>    <span class="hljs-comment">// 子数组[i, j]</span><br>    <span class="hljs-type">int</span> max = <span class="hljs-number">-0x7fffffff</span>;<br>    <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-type">int</span> left;<br>        <span class="hljs-type">int</span> right;<br>    &#125;ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 至少一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            tmp += nums[j];<br>            <span class="hljs-keyword">if</span> (max &lt; tmp) &#123;    <span class="hljs-comment">// 更新最大值</span><br>                max = tmp;<br>                ans.left = i;<br>                ans.right = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大数和为：%d\n&quot;</span>, max);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.left; i &lt;= ans.right; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, nums[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div></details>
<ol start="2">
<li><strong>招银网络</strong>：求子序列</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看题目 </summary><div class="toggle-content"><p>一个字符串a被称作另一个字符串b的子序列，说明从序列b通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列a。</p>
<p>字典序是基于字母顺序排列的单词按字母顺序排列的方法。比如ca是cmbchina的子序列，但是caa不是</p>
<p>假设小招有一个字符串，只包含英文的小写字母，小招想求出给定字符串的子序列，按照字典序最大的是哪一个？</p>
<p><strong>示例 1</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cmbchina<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">na<br></code></pre></td></tr></table></figure>
<p><strong>示例 2</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">aabcbccacbbcbaaba<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cccccbba<br></code></pre></td></tr></table></figure>
<p><strong>现场代码</strong></p>
<p>大的退栈，一直退</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">maxDictionaryorder</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                stk.<span class="hljs-built_in">push</span>(s[i]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">char</span> top = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">while</span> (s[i] &gt; top) &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                top = stk.<span class="hljs-built_in">top</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(s[i]); <br><br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>());<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseStr</span>(ans);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">string &amp; <span class="hljs-title">reverseStr</span><span class="hljs-params">(string &amp;str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-built_in">swap</span>(str[i], str[str.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>回来想的</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路；倒着输出，找一个非递增序</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function">string <span class="hljs-title">maxDictionaryorder</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-type">int</span> maxIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前找到的最大的字母的索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= s[maxIndex]) &#123;<br>                maxIndex = i;   <span class="hljs-comment">// 更新</span><br>                ans.<span class="hljs-built_in">push_back</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转回来</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</div></details>
<ol start="3">
<li><strong>快手一面</strong>：翻转中间部分链表</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II - 力扣（LeetCode）</a></p>
<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>
1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode *head0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);   <span class="hljs-comment">// 新建哨兵节点</span><br>        <span class="hljs-comment">// 找到left的前一个</span><br>        ListNode *p = head0;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++) &#123;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 头插法   [left right]</span><br>        ListNode *tmpFirst = p-&gt;next;  <br>        ListNode *tmp = p-&gt;next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left + <span class="hljs-number">1</span>; i++) &#123;<br>            ListNode *tmpNext = tmp-&gt;next;<br>            tmp-&gt;next = p-&gt;next;<br>            p-&gt;next = tmp;<br>            tmp = tmpNext;<br>        &#125; <br>        <span class="hljs-comment">// 剩下的放在第一个后面，如果没有这一步还可以置空</span><br>        tmpFirst-&gt;next = tmp;<br>        <span class="hljs-keyword">return</span> head0-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ol start="4">
<li><strong>快手二面</strong>：循环打印链表</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>希望可以顺时针螺旋打印一个矩阵，用 int[][] a 来表达这个矩阵。</p>
<p>eg：</p>
<p><code>a[0][0] ... a[0][n] ... a[m][n] ... a[m][0] ... a[1][0] ... a[1][n-1] ...</code></p>
<p>1 2 3</p>
<p>4 5 6</p>
<p>7 8 9</p>
<p>1 2 3 6 9 8 7 4 5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOver</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">3</span>], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">marked</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Dir</span> &#123; LEFT, RIGHT, UP, DOWN &#125;;<br>    <span class="hljs-comment">// 从左上角开始，初始向右</span><br>    Dir curDir = RIGHT;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>        <span class="hljs-keyword">switch</span> (curDir) &#123;<br>        <span class="hljs-keyword">case</span> RIGHT:<br>            <span class="hljs-comment">// 没越界 且 没走过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(x, y, m, n) &amp;&amp; marked[x][y] == <span class="hljs-literal">false</span>) &#123;<br>                marked[x][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[x][y]);<br>                y++;    <span class="hljs-comment">// 继续移动</span><br>            &#125;<br>            <span class="hljs-comment">// 需要回退，且转向</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                y--;<br>                curDir = DOWN;<br>                x++;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DOWN:<br>            <span class="hljs-comment">// 没越界 且 没走过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(x, y, m, n) &amp;&amp; marked[x][y] == <span class="hljs-literal">false</span>) &#123;<br>                marked[x][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[x][y]);<br>                x++;    <span class="hljs-comment">// 继续移动</span><br>            &#125;<br>            <span class="hljs-comment">// 需要回退，且转向</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                x--;<br>                curDir = LEFT;<br>                y--;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> LEFT:<br>            <span class="hljs-comment">// 没越界 且 没走过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(x, y, m, n) &amp;&amp; marked[x][y] == <span class="hljs-literal">false</span>) &#123;<br>                marked[x][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[x][y]);<br>                y--;    <span class="hljs-comment">// 继续移动</span><br>            &#125;<br>            <span class="hljs-comment">// 需要回退，且转向</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                y++;<br>                curDir = UP;<br>                x--;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> UP:<br>            <span class="hljs-comment">// 没越界 且 没走过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(x, y, m, n) &amp;&amp; marked[x][y] == <span class="hljs-literal">false</span>) &#123;<br>                marked[x][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[x][y]);<br>                x--;    <span class="hljs-comment">// 继续移动</span><br>            &#125;<br>            <span class="hljs-comment">// 需要回退，且转向</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                x++;<br>                curDir = RIGHT;<br>                y++;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;<br>        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,<br>        &#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>    &#125;;<br>    <span class="hljs-built_in">printArray</span>(a, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div></details>
<ol start="5">
<li><strong>shopee</strong>，32位加法</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>36进制由0-9，a-z，共36个字符表示。</p>
<p>要求按照加法规则计算出任意两个36进制正整数的和，如1b + 2x = 48 （解释：47+105=152）</p>
<p>要求：不允许使用先将36进制数字整体转为10进制，相加后再转回为36进制的做法</p>
<p>作答时间30min，完成时间25</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> map_[<span class="hljs-number">36</span>] = &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <br>                <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>,<br>                <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>,<br>                <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change2num</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string num1, num2, ans;<br>    cin &gt;&gt; num1 &gt;&gt; num2;<br>    <span class="hljs-keyword">if</span> (num1.<span class="hljs-built_in">size</span>() &lt; num2.<span class="hljs-built_in">size</span>()) &#123;    <span class="hljs-comment">// 保持num1更长</span><br>        <span class="hljs-built_in">swap</span>(num1, num2);<br>    &#125;<br><br>    <span class="hljs-built_in">reverse</span>(num1.<span class="hljs-built_in">begin</span>(), num1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(num2.<span class="hljs-built_in">begin</span>(), num2.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 是否进位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-built_in">change2num</span>(num1[i]) + <span class="hljs-built_in">change2num</span>(num2[i]);<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) &#123;<br>            curSum += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = curSum % <span class="hljs-number">36</span>;<br>        ans.<span class="hljs-built_in">push_back</span>(map_[left]);<br>        <span class="hljs-comment">// printf(&quot;i=%d, curSum=%d，insert=%c\n&quot;, i, curSum, map_[left]);</span><br>        <span class="hljs-keyword">if</span> (curSum &gt;= <span class="hljs-number">36</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = num2.<span class="hljs-built_in">size</span>(); i &lt; num1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-built_in">change2num</span>(num1[i]);<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) &#123;<br>            curSum += <span class="hljs-number">1</span>;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(map_[curSum % <span class="hljs-number">36</span>]);<br>        <span class="hljs-keyword">if</span> (curSum &gt;= <span class="hljs-number">36</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// cout &lt;&lt; reverse(ans.begin(), ans.end()) &lt;&lt; endl;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cout &lt;&lt; ans[i];<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; ans &lt;&lt; endl;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="C-面经">C++面经</h2>
<h3 id="C-基础知识">C++基础知识</h3>
<ol>
<li><strong>C和C++有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>C++是面向对象的语言，而C是面向过程的语言；</li>
<li>C++引入 new/delete 运算符，取代了C中的 malloc/free 库函数；</li>
<li>C++引入引用的概念，而C中没有；</li>
<li>C++引入类的概念，而C中没有；</li>
<li>C++引入函数重载的特性，而C中没有</li>
</ul>
</div></details>
<ol start="2">
<li><strong>a和&amp;a有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>假设数组<code>int a[10]; int (*p)[10] = &amp;a;</code>其中：</p>
<ul>
<li><code>a</code>是数组名，是数组首元素地址， <code>+1</code>表示地址值加上一个<code>int</code>类型的大小，如果<code>a</code>的值是<code>0x00000001</code>，加1操作后变为<code>0x00000005</code>。 <code>*(a + 1) = a[1]</code>。</li>
<li><code>&amp;a</code>是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加<code>1</code>时，系统会认为是数组首地址加上整个数组的偏移（<code>10</code>个<code>int</code>型变量），值为数组<code>a</code>尾元素后一个元素的地址。</li>
<li>若<code>(int *)p</code> ，此时输出 <code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照<code>int</code>类型大小来读取。</li>
</ul>
</div></details>
<ol start="3">
<li><strong>static关键字有什么作用？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；</li>
<li>修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；</li>
<li>修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；</li>
<li>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 <code>static</code> ；</li>
<li>修饰成员函数时，该函数不接受 this 指针，只能访问类的静态成员；不需要实例化对象即可访问。</li>
</ol>
</div></details>
<ol start="4">
<li><strong>#define和const有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>编译器处理方式不同： <code>#define</code> 宏是在预处理阶段展开，不能对宏定义进行调试，而 <code>const</code> 常量是在编译阶段使用；</li>
<li>类型和安全检查不同： <code>#define</code> 宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错<br>
误，而 <code>const</code> 常量有具体类型，在编译阶段会执行类型检查；</li>
<li>存储方式不同： <code>#define</code> 宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而 <code>const</code> 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。</li>
<li>定义域不同： <code>#define</code> 宏不受定义域限制，而 <code>const</code> 常量只在定义域内有效。</li>
</ol>
</div></details>
<ol start="5">
<li><strong>对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>应该使用 <code>inline</code> 内联函数，即编译器将 <code>inline</code> 内联函数内的代码替换到函数被调用的地方。</p>
<p>优点：<br>
在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；<br>
相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；</p>
<p>缺点：<br>
代码膨胀，产生更多的开销；<br>
如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；<br>
如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；<br>
内联声明只是建议，是否内联由编译器决定，所以实际并不可控</p>
<br>
<p>GPT：</p>
<p><code>inline</code> 关键字在 C++ 中用于建议编译器将某个函数的代码在每个调用点直接展开，而不是执行常规的函数调用。这意味着使用 <code>inline</code> 关键字的函数的代码将直接插入到每个调用该函数的位置，从而可能减少函数调用的开销。但是，最终是否内联，以及如何内联，取决于编译器的决策。</p>
<p><strong>使用场景</strong></p>
<p><code>inline</code> 关键字通常用于小型、频繁调用的函数。因为这些函数的执行时间可能非常短，常规的函数调用开销（保存寄存器、栈操作等）相对较大，内联可以减少这种开销。</p>
<p><strong>如何使用</strong></p>
<p>在函数声明或定义前加上 <code>inline</code> 关键字。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ol>
<li>
<p><strong>编译器的自由</strong>：尽管 <code>inline</code> 提供了一个明确的建议，但编译器并不总是遵循这个建议。编译器会根据自己的优化规则来决定是否内联一个函数。</p>
</li>
<li>
<p><strong>代码膨胀</strong>：过度使用 <code>inline</code> 可能会导致代码体积的膨胀，因为每个调用点都会插入函数的完整代码。这不仅增加了程序的大小，还可能影响缓存的利用率和程序的执行速度。</p>
</li>
<li>
<p><strong>适用于成员函数</strong>：在类定义中，成员函数默认是 <code>inline</code> 的，如果它们是在类定义内部直接定义的。</p>
</li>
<li>
<p><strong>链接器的角色</strong>：对于在程序多个地方使用的 <code>inline</code> 函数，需要在每个使用点提供函数的定义。这是因为 <code>inline</code> 函数的定义需要对链接器可见，以便在每个调用点展开。通常，这意味着将 <code>inline</code> 函数的定义放在头文件中。</p>
</li>
<li>
<p><strong>虚函数</strong>：虚函数也可以声明为 <code>inline</code>，但如果通过指针或引用调用虚函数，则不会内联，因为具体调用哪个函数版本在编译时是未知的。</p>
</li>
</ol>
<p>总之，<code>inline</code> 关键字是一种优化工具，它可以减少函数调用的开销，但应谨慎使用，避免导致代码膨胀和其他潜在问题。编译器的现代优化技术通常能够自动决定哪些函数应该内联，因此，在很多情况下，显式使用 <code>inline</code> 关键字可能不是必须的。</p>
</div></details>
<ol start="6">
<li><strong>什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>智能指针是一个<code>RAII</code>类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用 <code>delete</code> 删除指针所指向的内存空间。</p>
<p>智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。</p>
<p>分为 <code>auto_ptr</code> 、 <code>unique_ptr</code> 、 <code>shared_ptr</code> 和 <code>weak_ptr</code>四种，各自的<strong>特点</strong>：</p>
<ul>
<li>对于 <code>auto_ptr</code> ，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但 <code>auto_ptr</code><br>
在C++11中被摒弃，其主要问题在于：
<ul>
<li>对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；</li>
<li>不能指向数组，也不能作为STL容器的成员。</li>
</ul>
</li>
<li>对于 <code>unique_ptr</code> ，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；</li>
<li>对于 <code>shared_ptr</code> ，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；</li>
<li>对于 <code>weak_ptr</code> ，解决 <code>shared_ptr</code> 相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而 <code>weak_ptr</code> 是对象的一种弱引用，可以绑定到 <code>shared_ptr</code> ，但不会增加对象的引用计数。</li>
</ul>
</div></details>
<ol start="7">
<li><strong>shared_ptr是如何实现的？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>构造函数中计数初始化为1；</li>
<li>拷贝构造函数中计数值加1；</li>
<li>赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；</li>
<li>析构函数中引用计数减1；</li>
<li>在赋值运算符和析构函数中，如果减1后为0，则调用 <code>delete</code> 释放对象。</li>
</ol>
</div></details>
<ol start="8">
<li><strong>右值引用有什么作用？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>左值、右值是什么？</strong></p>
<p>在C++中，左值（Lvalue）和右值（Rvalue）是根据表达式结束后对象的身份是否还可以被识别来区分的。它们主要用来描述对象的存储期限、地址的可获取性以及表达式的赋值特性。</p>
<p><strong>左值（Lvalue）</strong></p>
<ul>
<li><strong>定义</strong>：左值是指表达式结束后仍然存在的对象或函数。换句话说，左值表达式的结果具有持久状态。</li>
<li><strong>特点</strong>：左值可以出现在赋值表达式的左侧，表示对象的身份可以被识别，其内容可以被修改（如果没有const限制）。</li>
<li><strong>示例</strong>：变量、解引用指针、数组的元素、具名的非临时对象、函数返回引用等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// x 是左值</span><br>x = <span class="hljs-number">20</span>;     <span class="hljs-comment">// 可以将20赋值给x，因为x是左值</span><br></code></pre></td></tr></table></figure>
<p><strong>右值（Rvalue）</strong></p>
<ul>
<li><strong>定义</strong>：右值是指表达式结束时就不再存在的临时对象，以及那些不与对象存储位置直接关联的值。</li>
<li><strong>特点</strong>：右值通常用于描述临时对象或者那些不需要持久化的值。右值可以出现在赋值表达式的右侧，但不能被赋值。</li>
<li><strong>分类</strong>：纯右值（Prvalue，Pure rvalues）和将亡值（Xvalue，eXpiring values）。纯右值是指临时的或未绑定到对象的值，将亡值是指即将被移动的对象。</li>
<li><strong>示例</strong>：字面量、表达式计算的结果、函数返回非引用值等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br><span class="hljs-built_in">getNumber</span>(); <span class="hljs-comment">// getNumber() 的返回值是右值</span><br></code></pre></td></tr></table></figure>
<p><strong>区分左值和右值的重要性</strong></p>
<ul>
<li><strong>资源管理</strong>：通过区分左值和右值，C++引入了移动语义（Move Semantics），允许资源的所有权在不同对象间转移，提高了程序的效率。</li>
<li><strong>函数重载</strong>：函数可以根据接收参数是左值还是右值进行重载，从而更有效地处理数据。</li>
<li><strong>完美转发</strong>：利用左值和右值的区分，可以通过<code>std::forward</code>在模板中实现参数的完美转发，既保持了参数的原始类型，又维护了其值类别（左值或右值）。</li>
</ul>
<p>理解左值和右值对于深入学习C++的现代特性（如右值引用、移动语义和完美转发）非常关键，有助于编写出更高效、更优雅的代码。</p>
<p><br><br><br></p>
<p><strong>什么是移动语义，什么是完美转发，什么是右值引用？</strong></p>
<p>移动语义、完美转发和右值引用是C++11中引入的三个重要概念，它们共同作用于提升C++程序的性能和灵活性，特别是在对象管理和函数调用过程中。</p>
<p><strong>移动语义（Move Semantics）</strong></p>
<p>移动语义允许一个资源（如动态内存）从一个对象转移到另一个对象，避免了不必要的复制，从而提高效率。在传统的复制操作中，对象的内容被复制到新对象，然后原对象保持不变。而在移动操作中，资源的所有权从原对象转移给新对象，原对象不再拥有该资源，这通常通过修改原对象的指针或引用来实现，使其指向一个空状态。</p>
<ul>
<li><strong>关键点</strong>：移动语义通过移动构造函数和移动赋值操作符实现，它们接受一个右值引用作为参数。</li>
</ul>
<p><strong>完美转发（Perfect Forwarding）</strong></p>
<p>完美转发指的是在函数模板中，能够接受任意实参（包括左值和右值），并将其无损地转发给另一个函数，保持原有的值类别（左值或右值）。这允许开发者编写接受任意实参的模板函数，并将这些实参以几乎零开销转发给其他函数。</p>
<ul>
<li><strong>实现方法</strong>：完美转发通常通过<code>std::forward</code>实现，<code>std::forward</code>是一个条件性转换，它仅当其参数为右值时才将参数转换为右值。</li>
</ul>
<p><strong>右值引用（Rvalue Reference）</strong></p>
<p>右值引用是引用临时对象（即将销毁的对象）的一种方式，通过类型后面加<code>&amp;&amp;</code>来表示。它是实现移动语义和完美转发的基础。</p>
<ul>
<li><strong>语法</strong>：<code>Type&amp;&amp; name</code>，其中<code>Type</code>是数据类型。</li>
<li><strong>特点</strong>：右值引用允许一个函数知道其参数是否可以被&quot;移动&quot;。在传统C++中，我们只能通过复制对象来传递它们，即使是临时对象也不例外。右值引用允许我们直接传递临时对象，避免复制的成本。</li>
</ul>
<p><strong>三者之间的关系</strong></p>
<ul>
<li><strong>右值引用</strong>为移动语义和完美转发提供了语法基础。它允许临时对象被标记并用于优化。</li>
<li><strong>移动语义</strong>使用右值引用作为参数，允许资源从一个对象&quot;移动&quot;到另一个对象，而不是复制。</li>
<li><strong>完美转发</strong>使用<code>std::forward</code>和右值引用来确保函数模板可以接受任何类型的参数（左值或右值）并将其正确转发给其他函数，保持其原始的值类别。</li>
</ul>
<p>这三个特性共同作用，使得C++程序在处理临时对象、资源管理以及函数调用时更加高效和灵活。</p>
<p><br><br><br></p>
<p><strong>例子</strong>：</p>
<p>让我们通过具体的例子来解释移动语义、完美转发和右值引用是如何工作的，以及它们如何改善C++程序的性能。</p>
<p><strong>移动语义示例</strong></p>
<p>假设我们有一个简单的<code>String</code>类，用于动态管理字符串数据。在不使用移动语义的情况下，复制一个<code>String</code>对象会涉及到分配新内存和复制数据，这是资源密集型的。引入移动语义后，我们可以避免这种不必要的复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* data;<br>    <span class="hljs-type">size_t</span> size;<br><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) &#123; <span class="hljs-comment">// 构造函数</span><br>        size = <span class="hljs-built_in">strlen</span>(str);<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(data, str, size + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">delete</span>[] data; &#125; <span class="hljs-comment">// 析构函数</span><br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">String</span>(String&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">size</span>(other.size) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>;<br>        other.size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(String&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<br>            data = other.data;<br>            size = other.size;<br>            other.data = <span class="hljs-literal">nullptr</span>;<br>            other.size = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，移动构造函数和移动赋值运算符允许一个<code>String</code>对象接管另一个临时对象的资源，而不是复制它们。当我们有一个临时<code>String</code>对象时，这些资源可以被移动而不是被复制。</p>
<p><strong>完美转发示例</strong></p>
<p>完美转发允许我们写一个模板函数，将其参数精确地转发给另一个函数，保持所有的左值、右值属性不变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">relay</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用std::forward&lt;T&gt;来保持arg的左值/右值属性</span><br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(arg));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Lvalue processed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Rvalue processed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>relay</code>函数使用模板和右值引用参数<code>T&amp;&amp;</code>接收任何类型的参数。然后它使用<code>std::forward</code>来完美转发这个参数给<code>process</code>函数，无论是左值还是右值。</p>
<p><strong>右值引用示例</strong></p>
<p>右值引用的一个直接用例就是上面提到的移动语义示例中的移动构造函数和移动赋值运算符的实现。右值引用允许函数知道它们可以安全地重用输入参数的资源：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">String <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><span class="hljs-function">String <span class="hljs-title">b</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">// 使用移动构造函数</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>std::move(a)</code>将<code>a</code>转换为右值引用，这使得<code>String</code>的移动构造函数可以接管<code>a</code>的内部资源而不是复制它们。<code>a</code>在移动操作之后处于有效但未定义的状态。</p>
<p>这些例子展示了如何使用移动语义、完美转发和右值引用来提高C++程序的效率，尤其是在涉及资源管理和函数参数传递时。</p>
</div></details>
<ol start="9">
<li><strong>悬挂指针与野指针有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>悬挂指针</strong>：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</p>
<p><strong>野指针</strong>：未初始化的指针被称为野指针。</p>
</div></details>
<ol start="10">
<li><strong>静态链接和动态链接有什么区别</strong>？</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>静态链接</strong> 是在编译链接时直接将需要的执行代码拷贝到调用处；<br>
优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；</p>
<p><strong>动态链接</strong> 是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；</p>
<ul>
<li>优点在于多个程序可以共享同一个动态库，节省资源；</li>
<li>缺点在于由于运行时加载，可能影响程序的前期执行性能。</li>
</ul>
</div></details>
<ol start="11">
<li><strong>变量的声明和定义有什么区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个<br>
地方定义。加入 <code>extern</code> 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</p>
<p>说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> A;<br>    <span class="hljs-comment">// 这是个声明而不是定义，声明A是⼀个已经定义了的外部变量</span><br>    <span class="hljs-comment">// 注意：声明外部变量时可以把变量类型去掉如： extern A;</span><br>    <span class="hljs-built_in">dosth</span>(); <span class="hljs-comment">// 执行函数</span><br>&#125;<br><span class="hljs-type">int</span> A; <span class="hljs-comment">// 是定义，定义了A为整型的外部变量</span><br></code></pre></td></tr></table></figure>
</div></details>
<ol start="12">
<li><strong>简述#ifdef、 #else、 #endif和#ifndef的作用</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>利用#ifdef、 #endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MATH</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>在子程序前加上标记，以便于追踪和调试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Indebugging......!&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。</p>
<p>「注意」：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），<br>
运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标<br>
程序的长度，减少运行时间。</p>
</div></details>
<ol start="13">
<li><strong>写出int 、 bool、 float 、指针变量与 “零值”比较的if 语句</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>注意一下float</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// int与零值比较</span><br><span class="hljs-keyword">if</span> ( n == <span class="hljs-number">0</span> )<br><span class="hljs-keyword">if</span> ( n != <span class="hljs-number">0</span> )<br>    <br><span class="hljs-comment">// bool与零值比较</span><br><span class="hljs-keyword">if</span> (flag) <span class="hljs-comment">// 表示flag为真</span><br><span class="hljs-keyword">if</span> (!flag) <span class="hljs-comment">// 表示flag为假</span><br>    <br><span class="hljs-comment">// float与零值比较</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> EPSINON = <span class="hljs-number">0.00001</span>;	<span class="hljs-comment">// = 1e-7也行</span><br><span class="hljs-keyword">if</span> ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON) <span class="hljs-comment">//其中EPSINON是允许的误差（即精度）。</span><br>    <br><span class="hljs-comment">// 指针变量与零值比较</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)   <br></code></pre></td></tr></table></figure>
</div></details>
<ol start="14">
<li><strong>结构体可以直接赋值吗</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小<br>
心。</p>
<p>「注意」 ：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放<br>
前一定要确保其他指针不再使用这段内存空间。</p>
</div></details>
<ol start="15">
<li><strong>sizeof 和strlen 的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li><code>sizeof</code>是一个操作符， <code>strlen</code>是库函数。</li>
<li><code>sizeof</code>的参数可以是数据的类型，也可以是变量，而<code>strlen</code>只能以结尾为<code>‘\0’</code>的字符串作参数。</li>
<li>编译器在<u>编译时就计算出了</u><code>sizeof</code>的结果，而<code>strlen</code>函数必须在运行时才能计算出来。并且<code>sizeof</code>计算的是数据类型占内存的大小，而<code>strlen</code>计算的是字符串串实际的长度。</li>
<li>数组做<code>sizeof</code>的参数不退化，传递给<code>strlen</code>就退化为指针了<br>
（说明，sizeof的参数如果退化为指针，那就会计算指针的大小了，所以其参数还是保持原有的类型）</li>
</ul>
</div></details>
<ol start="16">
<li><strong>C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>在 C 中 <code>static</code> 用来修饰局部静态变量和外部静态变量、函数。</p>
<p>而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。</p>
<p>「注意」 ：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行<u>通信</u>，传递信息，而 C++的<br>
静态成员则可以在多个对象实例间进行通信，传递信息。</p>
</div></details>
<ol start="17">
<li><strong>volatile有什么作用</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>状态寄存器一类的并行设备硬件寄存器。</li>
<li>一个中断服务子程序会访问到的非自动变量。</li>
<li>多线程间被几个任务共享的变量。</li>
</ul>
<p>「注意」 ：虽然<code>volatile</code>在嵌入式方面应用比较多，但是在PC软件的多线程中， volatile修饰的临界变量也是非常实用的。</p>
<br>
<p>GPT4：</p>
<p>要理解这段描述，首先需要搞清楚<code>volatile</code>关键字在C语言（及类似语言）中的作用，以及它为何在嵌入式系统和多线程编程中特别重要。</p>
<p><strong><code>volatile</code>关键字的基本作用</strong></p>
<p><code>volatile</code>是一个类型修饰符。它告诉编译器，修饰的变量可能会在程序的控制之外被改变。换句话说，这意味着编译器在优化代码时，不能假设这个变量的值在两次读取之间是不变的，即使在程序中没有明显的代码对它进行修改。因此，每次访问<code>volatile</code>修饰的变量时，都会直接从其内存位置读取，而不是使用可能存储在寄存器中的缓存值。</p>
<p><strong><code>volatile</code>的应用场景</strong></p>
<ol>
<li>
<p><strong>状态寄存器一类的并行设备硬件寄存器</strong>：</p>
<ul>
<li>这些寄存器的值可能由硬件事件（如接收到数据）而非软件控制的代码改变。因此，使用<code>volatile</code>修饰可以<u>防止编译器优化掉对这些寄存器的读操作</u>（下面有解释），确保软件能够获取到最新的硬件状态。</li>
</ul>
</li>
<li>
<p><strong>一个中断服务子程序会访问到的非自动变量</strong>：</p>
<ul>
<li>在中断服务例程（ISR）中，变量的值可能在ISR外被修改，或者在ISR中修改后需在主程序中使用。因此，这些变量应被声明为<code>volatile</code>，以确保正确读取它们的值。</li>
</ul>
</li>
<li>
<p><strong>多线程间被几个任务共享的变量</strong>：</p>
<ul>
<li>在多线程应用中，一个线程可能修改另一个线程可以访问的变量。虽然<code>volatile</code>可以确保变量的读/写操作不会被编译器优化掉，但它并不保证操作的原子性。这意味着在多线程环境下，仅仅使用<code>volatile</code>并不能完全解决并发访问的问题，可能还需要使用互斥锁或其他同步机制来保证数据一致性和完整性。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong></p>
<p>虽然<code>volatile</code>在嵌入式开发中经常被用于处理硬件寄存器访问的情况，但它在多线程程序中也是有用的，尤其是当你需要确保变量的更新能够即时反映到其他线程中时。然而，重要的是要理解<code>volatile</code>并不能替代锁或其他同步机制来处理线程之间的竞争条件。<code>volatile</code>确保了变量访问的可见性，但不保证原子性。在多数现代编程语言和环境中，处理多线程共享数据时，更推荐使用专门的并发控制或同步机制，比如锁（mutexes）、信号量（semaphores）或原子操作（atomic operations）。</p>
<br>
<p>编译器在将源代码转换成机器代码的过程中会进行优化，以提高程序的运行效率和减少占用的资源。这些优化可能包括重排指令、消除冗余的代码、以及减少不必要的内存访问等。当编译器认为某些变量的值在它们的使用过程中不会改变时，它可能决定不重复从内存中读取这些变量的值，而是使用之前读取的值或者将这些值缓存起来。</p>
<p>对于普通的变量，这种优化通常是安全且有效的，因为如果代码中没有显式地修改这些变量的值，那么它们的值确实是不变的。然而，对于某些特殊的变量，如硬件状态寄存器或由另一个线程控制的变量，这种假设就不成立了。这些变量的值可能会在外部事件的影响下随时改变，而这种改变对于当前执行的代码来说是不可预见的。</p>
<p>例如，考虑一个与硬件设备交互的情况，设备的状态通过读取特定的内存地址（寄存器）来检查。如果设备状态改变（比如说，数据可用于读取），则相应的寄存器值会变化。如果编译器优化掉了对这个寄存器的读操作，认为它之前读取过一次后就不会再改变，那么程序就可能错过设备状态的更新，继而导致逻辑错误或无法从设备读取数据。</p>
<p>因此，当我们使用<code>volatile</code>关键字声明这类特殊变量时，我们告诉编译器，这些变量的值可能会在程序控制之外改变，编译器不应该对这些变量进行优化，如缓存它们的值或者删除看似无用的读操作。这确保了每次访问<code>volatile</code>变量时都会直接从它们所在的内存地址读取，从而获取到最新的值。</p>
</div></details>
<ol start="18">
<li><strong>一个参数可以既是const⼜又是volatile吗</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>可以，用<code>const</code>和<code>volatile</code>同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。</p>
<p>注意：在此一定要注意<code>const</code>的意思， <code>const</code>只是不允许程序中的代码改变某一变量，其<strong>在编译期发挥作用</strong>，它并没<br>
有实际地禁止某段内存的读写特性。</p>
</div></details>
<ol start="19">
<li><strong>全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的?</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>全局变量是整个程序都可访问的量，谁都可以访问，生存期在整个程序从行到结束（在程序结束时所占内存释放）；</p>
<p>而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</p>
<p>操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载局部变量则分配在堆栈里面。</p>
</div></details>
<ol start="20">
<li><strong>简述strcpy、 sprintf 与memcpy 的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>操作对象不同， <code>strcpy</code> 的两个操作对象均为字符串串， <code>sprintf</code> 的操作源对象可以是多种数据类型， 目的操作对象是字符串， <code>memcpy</code> 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
<li>执行效率不同， <code>memcpy</code> 最⾼高， <code>strcpy</code> 次之， <code>sprintf</code> 的效率最低。</li>
<li>实现功能不同， <code>strcpy</code> 主要实现字符串串变量间的拷贝， <code>sprintf</code> 主要实现其他数据类型格式到字符串的转化，<code>memcpy</code> 主要是内存块间的拷贝。</li>
</ul>
<p>「注意」 ： <code>strcpy</code>、 <code>sprintf</code> 与 <code>memcpy</code> 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能</p>
</div></details>
<ol start="21">
<li><strong>请解析 ((void ()( ) )0)( ) 的含义</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>表达式用到了C语言中的类型转换和函数指针的概念，可能看起来有点复杂，但我们可以一步步解析来理解它们的含义。</p>
<ol>
<li><code>void (*0)( )</code></li>
</ol>
<p>这个表达式试图声明一个函数指针，但它是不正确的。在C语言中，函数指针的声明需要指定函数的返回类型，函数参数的类型（如果有的话），以及一个变量名作为指针的标识。例如，一个正确的函数指针声明可能看起来像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funcPtr)();<br></code></pre></td></tr></table></figure>
<p>这声明了<code>funcPtr</code>为一个函数指针，该函数的返回类型为<code>void</code>且不接受任何参数。因此，<code>void (*0)( )</code>是不合法的，因为<code>0</code>不能用作变量名。</p>
<ol start="2">
<li><code>(void (*)( ))0</code></li>
</ol>
<p>这个表达式是正确的。它将<code>0</code>（通常代表<code>NULL</code>指针）强制类型转换为一个返回值为<code>void</code>、参数为空的函数指针类型。这是一种将整数（在这种情况下是零值）显式转换为指定类型的函数指针的方法。</p>
<ol start="3">
<li><code>(void ()( ))0</code></li>
</ol>
<p>这个表达式有语法错误。看起来它试图声明一个函数类型，然后将<code>0</code>作为该类型的实例，但这样的语法是不正确的。如果目的是声明一个函数类型，正确的方式可能是使用<code>typedef</code>来定义一个函数指针类型，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*funcType)</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>然而，即使这样，也不能将<code>0</code>直接与函数类型一起使用来创建一个实例。</p>
<ol start="4">
<li><code>((void ()( ))0)( )</code></li>
</ol>
<p>由于第3点中的表达式是错误的，这个表达式同样是基于错误的前提。这个表达式的意图看起来是尝试调用一个起始地址为0的函数，但由于它的基础是不正确的语法，这个表达式也是错误的。</p>
<p>如果想要调用一个函数指针，首先需要正确地声明并初始化这个函数指针。例如，假设有一个函数指针指向地址为0的位置，并希望调用它，正确的做法应该类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funcPtr)() = (<span class="hljs-type">void</span> (*)())<span class="hljs-number">0</span>; <span class="hljs-comment">// 将0转换为函数指针类型</span><br>funcPtr(); <span class="hljs-comment">// 调用函数指针</span><br></code></pre></td></tr></table></figure>
<p>需要注意，尝试执行起始地址为0的函数是危险的，因为这通常代表着空指针，尝试调用这样的函数会导致未定义行为，可能导致程序崩溃。</p>
<p>总之，这些表达式中的一些是错误的或者基于不正确的语法，理解它们需要对C语言中的类型转换和函数指针有深入的了解。正确使用函数指针非常重要，特别是在涉及到底层编程或嵌入式系统编程时。</p>
</div></details>
<ol start="22">
<li><strong>C语言的指针 和  c++的引用有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>指针有自己的一块空间，而引用只是一个别名；</li>
<li>使用<code>sizeof</code>看一个指针的大小是4，而引用则是被引用对象的大小；</li>
<li>作为参数传递时，指针需要被解引用才可以对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>可以有<code>const</code>指针，但是没有<code>const</code>引用；</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li>
<li>指针可以有多级指针（**p），而引用止于一级；</li>
<li>指针和引用使用++运算符的意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>
</ul>
<br>
<p>解释：</p>
<p><code>const</code>引用</p>
<p>在C++中，确实没有所谓的“非<code>const</code>引用”，因为引用一经初始化后就不能改变它所绑定的对象。但是，可以有指向<code>const</code>类型的引用，我们通常称之为<code>const</code>引用。<code>const</code>引用的特点是不能通过它来修改它所引用的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = someInt;<br></code></pre></td></tr></table></figure>
<p>这里，<code>ref</code>是一个<code>const</code>引用，指向一个<code>int</code>类型的值。通过<code>ref</code>，你不能修改它所引用的<code>int</code>值。</p>
</div></details>
<ol start="23">
<li><strong>typedef和define有什么区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>用法不同： <code>typedef</code> 用来定义一种数据类型的别名，增强程序的可读性。 <code>define</code> 主要用来定义常量，以及书写复杂使用频繁的宏。</li>
<li>执行时间不同： <code>typedef</code> 是编译过程的一部分，有类型检查的功能。 <code>define</code> 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li>
<li>作用域不同： <code>typedef</code> 有作用域限定。 <code>define</code> 不受作用域约束，只要是在<code>define</code>声明后的引用都是正确的。</li>
<li>对指针的操作不同： <code>typedef</code> 和<code>define</code> 定义的指针时有很大的区别。</li>
</ul>
<p>「注意」 ： typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。</p>
</div></details>
<ol start="24">
<li><strong>指针常量与常量指针区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</p>
<p>「注意」 ：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</p>
</div></details>
<ol start="25">
<li><strong>简述队列和栈的异同</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。</p>
<p>「注意」 ：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存储区域。</p>
</div></details>
<ol start="26">
<li><strong>设置地址为0x67a9 的整型变量的值为0xaa66</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr;<br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x67a9</span>;<br>*ptr = <span class="hljs-number">0xaa66</span>;<br></code></pre></td></tr></table></figure>
<p>「注意」 ：这道题就是强制类型转换的典型例子，<strong>无论在什么平台地址长度和整型数据的长度是一样的</strong>， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。</p>
<br>
<p>实际上，地址长度（即指针的大小）与整型数据的长度（例如，<code>int</code>的大小）不一定在所有平台上都是一样的。这两者的大小取决于处理器的架构（尤其是其地址总线和数据总线的宽度），以及编译器的实现细节。</p>
<p><strong>地址长度（指针大小）</strong></p>
<ul>
<li><strong>地址长度</strong>或者说<strong>指针大小</strong>，取决于计算机的架构。在32位系统上，指针通常是32位（4字节）的，这意味着它们可以直接寻址高达<code>2^32</code>字节（即4GB）的内存空间。而在64位系统上，指针通常是64位（8字节）的，可以寻址<code>2^64</code>字节（即16EB，1EB等于1024PB，1PB等于1024TB）的内存。</li>
</ul>
<p><strong>整型数据长度</strong></p>
<ul>
<li><strong>整型数据长度</strong>，比如<code>int</code>类型的长度，虽然在很多系统中通常是32位（4字节），但这并不是一个固定的标准。在某些系统或编译器中，<code>int</code>可能被定义为16位（尤其是一些旧的或嵌入式系统），而在某些环境下，编译器可能允许<code>int</code>为64位。C++标准只规定了<code>int</code>的最小范围，即至少能表示-32767到32767之间的整数，但具体的大小由编译器决定。</li>
</ul>
<p><strong>比较</strong></p>
<p>因此，不能一概而论地说地址长度和整型数据的长度在所有平台上都是一样的。例如，在64位系统上，指针的大小通常是64位（8字节），而<code>int</code>的大小可能仍然是32位（4字节），尽管有的系统或编译器可能提供了64位的整型（如<code>long long</code>在很多系统上都是64位的）。这种差异对于编程时理解数据类型的内存布局非常重要。</p>
<p>为了编写可移植的代码，C和C++提供了特定的类型（如<code>size_t</code>和<code>ptrdiff_t</code>），它们的大小总是足够存储内存中任何对象的大小或任两个指针间的差值。此外，C++11及更高版本引入了<code>&lt;cstdint&gt;</code>头文件，提供了具有明确大小的整型，如<code>int32_t</code>、<code>int64_t</code>等，这些类型在需要确保整数大小和行为一致性时非常有用。</p>
<br>
<p>所以这句话只是个普遍情况。</p>
</div></details>
<ol start="27">
<li><strong>如何避免“野指针”</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。</li>
<li>指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。</li>
<li>指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。</li>
</ul>
</div></details>
<ol start="28">
<li><strong>C语言的结构体和C++的类有什么区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>C语言的结构体是不能有函数成员的，而C++的类可以有。</li>
<li>C语言的结构体中数据成员是没有<code>private</code>、 <code>public</code>和<code>protected</code>访问限定的。而C++的类的成员有这些访问限定。</li>
<li>C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。</li>
</ul>
<p>「注意」 ：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。</p>
</div></details>
<ol start="29">
<li><strong>句柄和指针的区别和联系是什么</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>句柄和指针其实是两个截然不同的概念。 Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的unsigned int。指针则标记某个物理内存地址，两者是不同的概念。</p>
</div></details>
<ol start="30">
<li><strong>说一说extern “C”</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><code>extern &quot;C&quot;</code>的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上<code>extern &quot;C&quot;</code>后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
<p>这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好<br>
的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern &quot;C&quot;就是其中的一个策略。</p>
<ul>
<li>C++代码调用C语言代码</li>
<li>在C++的头文件中使用</li>
<li>在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到</li>
</ul>
<br>
<p>你的解释非常准确！<code>extern &quot;C&quot;</code>是C++中一个重要的关键字，用于解决C++代码与C代码之间的互操作性问题。下面是对<code>extern &quot;C&quot;</code>使用的进一步解释和一些补充信息：</p>
<p><strong>名字修饰（Name Mangling）</strong></p>
<p>C++支持函数重载，意味着可以有多个同名函数，只要它们的参数列表不同。为了区分这些函数，C++编译器在编译过程中会对函数名进行修改，这一过程通常称为“名字修饰”（Name Mangling）或“名字变形”。修饰后的名字不仅包含原始的函数名，还包括了函数的参数类型信息等。这样，即使函数名相同，修饰后的名字也会不同，从而使得函数重载成为可能。</p>
<p><strong>C语言的编译方式</strong></p>
<p>与C++不同，C语言不支持函数重载，因此C编译器不会对函数名进行修饰。函数名在编译后的代码（比如目标文件或库文件）中保持不变。</p>
<p><strong><code>extern &quot;C&quot;</code>的作用</strong></p>
<p>当C++代码需要调用由C语言编写的函数时，如果直接调用，由于C++编译器会对函数名进行修饰，而C语言编译的库中的函数名是未经修饰的，因此会导致链接错误，无法找到对应的函数实现。</p>
<p>通过在C++代码中使用<code>extern &quot;C&quot;</code>声明C语言函数或包含C语言头文件，可以告诉C++编译器对这部分代码禁用名字修饰，确保函数名在C++和C编译后的代码中是一致的。这样就可以成功地在C++代码中调用C语言编写的函数。</p>
<p><strong>使用方式</strong></p>
<ul>
<li><strong>单个函数声明</strong>：可以直接在C++代码中使用<code>extern &quot;C&quot;</code>声明单个C语言函数。</li>
<li><strong>头文件包含</strong>：当有多个C语言函数需要在C++中使用时，可以将这些函数声明放在一个或多个头文件中，然后在C++代码中通过<code>extern &quot;C&quot;</code>块包含这些头文件。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;c_header.h&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>条件编译</strong>：为了使头文件既能在C环境下使用，也能在C++环境下正确工作，可以在头文件中使用条件编译：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// C函数声明</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>这种方式确保了头文件在C++编译器处理时使用<code>extern &quot;C&quot;</code>，而在C编译器处理时则不使用，从而保持了代码的兼容性。</p>
<p><strong>总结</strong></p>
<p><code>extern &quot;C&quot;</code>是C++中为了实现与C代码互操作而设计的一项功能，它通过禁用名字修饰来确保C++代码能够正确地链接并调用C语言编写的函数。这个机制对于使用现有的C语言库，以及在C和C++混合编程环境中协同工作非常重要。</p>
</div></details>
<ol start="31">
<li><strong>对c++中的smart pointer四个智能指针：shared_ptr, unique_ptr, weak_ptr, auto_ptr的理解</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>让我们再简要概括一下每种智能指针的特点和用途，以便更清晰地理解它们之间的差异和适用场景。</p>
<p>1、<code>auto_ptr</code>（已废弃）</p>
<ul>
<li><strong>特点</strong>：<code>auto_ptr</code>采用所有权模式，一个<code>auto_ptr</code>对象拥有对其指向的对象的独占所有权。当<code>auto_ptr</code>对象被销毁时，它指向的对象也会被自动删除。</li>
<li><strong>问题</strong>：<code>auto_ptr</code>存在所有权转移的问题，复制操作会导致所有权从一个<code>auto_ptr</code>转移到另一个，使得原来的<code>auto_ptr</code>变为空，容易引起悬挂指针问题。</li>
<li><strong>替代</strong>：C++11中已被<code>unique_ptr</code>替代。</li>
</ul>
<p>2、<code>unique_ptr</code></p>
<ul>
<li><strong>特点</strong>：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。相比<code>auto_ptr</code>，<code>unique_ptr</code>更安全，不允许通过复制构造器或赋值操作复制<code>unique_ptr</code>，但可以通过<code>std::move</code>转移所有权。</li>
<li><strong>用途</strong>：用于需要确保资源只被一个指针拥有的场景，如避免资源泄露。</li>
</ul>
<p>3、<code>shared_ptr</code></p>
<ul>
<li><strong>特点</strong>：实现共享式拥有概念，多个<code>shared_ptr</code>可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。使用引用计数机制来跟踪有多少个<code>shared_ptr</code>共享同一个资源。</li>
<li><strong>用途</strong>：用于资源可以被多个指针共享的场景，特别适合用于如树、图这样的数据结构中。</li>
</ul>
<p>4、<code>weak_ptr</code></p>
<ul>
<li><strong>特点</strong>：不控制对象生命周期的智能指针，指向<code>shared_ptr</code>管理的对象。设计目的是为了解决<code>shared_ptr</code>相互引用时可能产生的循环引用问题。</li>
<li><strong>用途</strong>：与<code>shared_ptr</code>配合使用，用于观察<code>shared_ptr</code>指向的资源，而不影响该资源的生命周期。可以通过<code>lock()</code>方法尝试从<code>weak_ptr</code>获得一个可用的<code>shared_ptr</code>。</li>
</ul>
<p>智能指针的引入大大简化了资源管理，特别是内存管理的复杂性，减少了内存泄露和其他资源泄露的风险。它们通过自动化的资源管理，使得C++资源管理更接近于具有垃圾回收机制的语言，同时保持了C++的性能优势和灵活性。使用智能指针需要了解它们的工作原理和适用场景，以免误用导致资源管理上的问题。</p>
</div></details>
<ol start="32">
<li><strong>C++的顶层const和底层const ？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>底层const是代表对象本身是一个常量（不可改变）；</p>
<p>顶层const是代表指针的值是一个常量, 而指针的值(即对象的地址)的内容可以改变（指向的不可改变）；</p>
<br>
<p>在C++中，<code>const</code>关键字用于定义常量，即定义后值不可更改的变量。理解顶层<code>const</code>和底层<code>const</code>的概念对于掌握C++的<code>const</code>语义特别重要，它们描述了<code>const</code>修饰符所作用的位置和含义。</p>
<p><strong>顶层<code>const</code></strong></p>
<p>顶层<code>const</code>表示指针本身是个常量。这种<code>const</code>的应用与指针所指向的对象无关，仅仅表示指针本身的值（即存储的地址）不可变。换句话说，你不能改变指针存储的地址，但可以修改指针指向的值（除非指向的对象也被声明为<code>const</code>）。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;x; <span class="hljs-comment">// 底层const，指向的int是一个常量</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;x; <span class="hljs-comment">// 顶层const，指针p本身是一个常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;x; <span class="hljs-comment">// 既是底层const也是顶层const</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，第二行中的<code>const</code>修饰符就是顶层<code>const</code>，表示指针<code>p</code>本身是一个常量。</p>
<p><strong>底层<code>const</code></strong></p>
<p>底层<code>const</code>表示指针指向的对象是个常量，即通过指针不能改变所指对象的值。这种<code>const</code>的应用与指针指向的内容有关。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;x;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>const</code>修饰的是<code>int</code>，表示<code>p</code>指向的<code>int</code>值是不可修改的，这就是底层<code>const</code>。</p>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>顶层<code>const</code>的应用</strong>：顶层<code>const</code>常用于定义不可变的变量。对于指针来说，它用于声明指针本身的值不可变。</li>
<li><strong>底层<code>const</code>的应用</strong>：底层<code>const</code>更多地用于指针和引用，表明指针指向的数据或引用的数据不可被修改。</li>
</ul>
<p>理解这两种<code>const</code>的区别有助于更准确地使用C++的<code>const</code>修饰符，尤其是在复杂的指针操作和函数参数传递中。顶层<code>const</code>和底层<code>const</code>还涉及到类型兼容性和<code>const</code>正确性的问题，这在设计接口和实现函数时非常重要。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h3 id="C-面向对象">C++面向对象</h3>
<ol>
<li><strong>面向对象的三大特征是哪些？各自有什么样的特点？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>封装</strong>：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。</p>
<p><strong>继承</strong>：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；</p>
<p><strong>多态</strong>：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。</p>
</div></details>
<ol start="2">
<li><strong>C++中类成员的访问权限</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>C++通过 <code>public</code>、 <code>protected</code>、 <code>private</code> 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 <code>public</code>、<code>protected</code> 还是 <code>private</code>，都是可以互相访问的，没有访问权限的限制。</p>
<p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 <code>public</code> 属性的成员，不能访问 <code>private</code>、 <code>protected</code> 属性的成员。</p>
</div></details>
<ol start="3">
<li><strong>多态的实现有哪几种？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>多态分为静态多态和动态多态。其中，静态多态是通过重载和模板技术实现的，在编译期间确定；动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。</p>
</div></details>
<ol start="4">
<li><strong>动态多态有什么作用？有哪些必要条件？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>动态多态的作用：</p>
<ul>
<li>隐藏实现细节，使代码模块化，提高代码的可复用性；</li>
<li>接口重用，使派生类的功能可以被基类的指针引用所调用，即向后兼容，提高代码的可扩充性和可维护性。</li>
</ul>
<p>动态多态的必要条件：</p>
<ul>
<li>需要有继承；</li>
<li>需要有虚函数覆盖；</li>
<li>需要有基类指针引用指向子类对象。</li>
</ul>
</div></details>
<ol start="5">
<li><strong>动态绑定是如何实现的？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针 <code>vptr</code> ，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。</p>
</div></details>
<ol start="6">
<li><strong>纯虚函数有什么作用？如何实现？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。</p>
<p>实现方式是在虚函数声明的结尾加上<code>= 0</code>即可。</p>
</div></details>
<ol start="7">
<li><strong>虚函数表是针对类的还是针对象的？同一个类的两个对象的虚函数表是怎么维护的？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针 <code>vptr</code> ，每个对象的 <code>vptr</code> 的存放地址都不同，但都指向同一虚函数表。</p>
</div></details>
<ol start="8">
<li><strong>为什么基类的构造函数不能定义为虚函数？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>虚函数的调用依赖于虚函数表，而指向虚函数表的指针 <code>vptr</code> 需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p>
</div></details>
<ol start="9">
<li><strong>为什么基类的析构函数需要定义为虚函数？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p>
</div></details>
<ol start="10">
<li><strong>构造函数和析构函数能抛出异常吗？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。</p>
<p>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时， C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。</p>
</div></details>
<ol start="11">
<li><strong>如何让一个类不能实例化？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为 <code>private</code> 。</p>
</div></details>
<ol start="12">
<li><strong>多继承存在什么问题？如何消除多继承中的二义性？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>
<p>增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；</p>
</li>
<li>
<p>在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；</p>
<p>消除同名二义性的方法：</p>
<ul>
<li>利用作用域运算符 <code>::</code> ，用于限定派生类使用的是哪个基类的成员；</li>
<li>在派生类中定义同名成员，覆盖基类中的相关成员；</li>
</ul>
</li>
<li>
<p>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不<br>
确定性，即路径二义性；</p>
<p>消除路径二义性的方法：</p>
<ul>
<li>消除同名二义性的两种方法都可以；</li>
<li>使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。</li>
</ul>
</li>
</ol>
</div></details>
<ol start="13">
<li><strong>如果类 A 是一个空类，那么 sizeof(A) 的值为多少？为什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><code>sizeof(A) </code>的值为1，因为编译器需要区分这个空类的不同<u>实例</u>，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。</p>
</div></details>
<ol start="14">
<li><strong>覆盖和重载之间有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别； 覆盖只发生在类的成员函数中；</li>
<li>重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。</li>
</ul>
<br>
<p>在C++中，子类中的函数如果与父类中的函数名相同，确实会隐藏父类中所有的同名函数，这被称为<strong>隐藏（Hiding）</strong>，而不是<strong>覆盖（Overriding）</strong>。覆盖是多态性的一种表现，而隐藏则是名字解析的结果。让我们来详细解释一下这两个概念：</p>
<p><strong>覆盖（Overriding）</strong></p>
<p>覆盖发生在派生类中重新定义基类中的虚函数的情况。为了发生覆盖，派生类中的函数必须与基类中的虚函数有相同的签名（函数名、参数列表相同，返回类型相同或协变），并且基类中的函数必须被声明为虚函数（<code>virtual</code>）。覆盖实现了多态性，即允许通过基类指针或引用调用派生类中的函数实现。</p>
<p><strong>隐藏（Hiding）</strong></p>
<p>隐藏则是一个更广泛的概念，发生在派生类中声明了一个与基类中同名的函数时，不论其参数列表是否相同。隐藏不仅仅发生在虚函数上，它适用于所有的类成员函数。当派生类中声明了一个同名函数时，基类中所有同名函数的其他重载版本都会被隐藏，不论其参数如何。</p>
<p><strong>为什么会隐藏同名函数</strong></p>
<p>这个行为的原因是C++的名字解析规则。当你在派生类对象上调用一个函数时，编译器首先查找派生类的成员。如果在派生类中找到了同名的成员函数，编译器就停止搜索，即使参数列表不匹配。基类中的同名函数就被隐藏了，除非显式地使用作用域解析操作符（<code>::</code>）来指定。</p>
<p><strong>如何避免隐藏</strong></p>
<p>如果你希望在派生类中使用与基类同名的函数，同时保留对基类同名函数的访问，可以在派生类中使用<code>using</code>声明来引入基类中的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::func; <span class="hljs-comment">// 引入Base中所有的func函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 不会隐藏Base中的func(int)，因为使用了using声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这样，<code>Derived</code>类中就同时有了<code>func(int)</code>和<code>func(double)</code>两个版本的函数，前者来自基类，后者是派生类自己定义的。</p>
<p>总的来说，虽然C++中的名字隐藏可能会造成一些混淆，了解和正确使用这一机制可以帮助你更好地控制类继承和多态行为。</p>
</div></details>
<ol start="15">
<li><strong>拷贝构造函数和赋值运算符重载之间有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>
<p>拷贝构造函数用于构造新的对象；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Student s;<br>Student s1 = s; <span class="hljs-comment">// 隐式调用拷⻉贝构造函数</span><br><span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(s)</span></span>; <span class="hljs-comment">// 显式调用拷⻉贝构造函数</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Student s;<br>Student s1;<br>s1 = s; <span class="hljs-comment">// 使用赋值运算符</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><u>一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数</u>。</p>
</li>
</ol>
<br>
<p>解释第二点：</p>
<p>赋值运算符重载确实用于控制一个对象如何将另一个对象的内容拷贝到自身。当源对象包含动态分配的内存或其他需要显式释放的资源时，正确重载赋值运算符就变得尤为重要。这里的关键在于确保目标对象能够安全地释放自己当前持有的资源，并正确地接管或复制源对象的资源。这个过程很像是目标对象的一次“重新生命周期”。</p>
<p>让我们具体分析一下赋值运算符的重载过程中发生的事情：</p>
<ol>
<li>
<p><strong>释放当前资源</strong>：如果目标对象之前已经拥有了资源（比如动态分配的内存），那么在拷贝新内容之前，这些资源需要被正确释放。这一步是为了防止内存泄漏，确保任何旧的资源都被适当地管理。</p>
</li>
<li>
<p><strong>拷贝/转移资源</strong>：接下来，源对象中的资源需要被拷贝或转移到目标对象。这可能涉及到简单的值拷贝，或者，对于指针等复杂资源，可能需要动态分配新的内存来存储拷贝的数据。特别是，如果资源是通过指针管理的，就需要深拷贝，以确保源对象和目标对象拥有各自独立的资源副本。</p>
</li>
<li>
<p><strong>返回引用</strong>：通常，重载的赋值运算符会返回目标对象的引用。这允许赋值表达式可以被链式使用。</p>
</li>
</ol>
<p>在某种意义上，这确实类似于目标对象经历了一次“生命周期的正常结束”后又开始了一个新的生命周期，因为它首先释放了自己的资源，然后接管了新的资源。</p>
<p>正确实现赋值运算符重载非常关键，特别是在处理资源管理的类中。错误的实现可能导致资源泄露、双重释放等问题。除此之外，还要考虑自赋值的情况，在赋值操作开始之前检查是否是自赋值是一个好习惯，这可以避免潜在的错误和资源浪费。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123; <span class="hljs-comment">// 防止自赋值</span><br>            <span class="hljs-comment">// 释放当前对象的资源</span><br>            <span class="hljs-keyword">delete</span> resource;<br>            <span class="hljs-comment">// 拷贝或重新分配资源</span><br>            resource = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ResourceType</span>(*other.resource);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    ResourceType* resource;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个简单的例子展示了如何安全地重载赋值运算符，包括释放当前资源、避免自赋值问题、以及如何拷贝资源。</p>
</div></details>
<ol start="16">
<li><strong>对虚函数和多态的理解</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</p>
<p>举个例子：一个父类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了<code>virtual</code>关键字的函数，在子类中重写时候不需要加<code>virtual</code>也是虚函数。</p>
<p>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</div></details>
<ol start="17">
<li><strong>请你来说一下C++中struct和class的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>默认继承权限不同， <code>class</code>继承默认是<code>private</code>继承，而<code>struct</code>默认是<code>public</code>继承</li>
<li><code>class</code>还可用于定义模板参数，像<code>typename</code>，但是关键字<code>struct</code>不能同于定义模板参数</li>
</ul>
<p>C++保留<code>struct</code>关键字，原因:</p>
<ul>
<li>保证与C语言的向下兼容性， C++必须提供一个<code>struct</code></li>
<li>C++中的<code>struct</code>定义必须百分百地保证与C语言中的<code>struct</code>的向下兼容性，把C++中的最基本的对象单元规定为<code>class</code>而不是<code>struct</code>，就是为了避免各种兼容性要求的限制</li>
<li>对<code>struct</code>定义的扩展使C语言的代码能够更容易的被移植到C++中</li>
</ul>
</div></details>
<ol start="18">
<li><strong>说说强制类型转换运算符</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>C++提供了四种强制类型转换运算符，以替代传统的C风格类型转换。这些运算符提供了更明确、更可控的类型转换机制：</p>
<ol>
<li>
<p><strong><code>static_cast</code></strong>：</p>
<ul>
<li><strong>用途</strong>：用于非多态类型的转换。可以用来在不同类型之间进行转换，如整型和浮点型之间，或者将<code>void*</code>转换为具体类型的指针等。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> f = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i); <span class="hljs-comment">// 将int转换为float</span><br><span class="hljs-type">void</span>* p = &amp;i;<br><span class="hljs-type">int</span>* ip = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p); <span class="hljs-comment">// 将void*转换为int* </span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong><code>dynamic_cast</code></strong>：</p>
<ul>
<li><strong>用途</strong>：主要用于处理多态类型，用于类层次结构中向下的类型转换（从基类指针/引用转换为派生类指针/引用），并在运行时检查转换的安全性。如果转换失败（例如，因为指向的对象不是目标类型或该类型的派生类型），指针类型的<code>dynamic_cast</code>会返回<code>nullptr</code>，引用类型的<code>dynamic_cast</code>会抛出<code>std::bad_cast</code>异常。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">dummy</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-type">int</span> a; &#125;;<br>Base* b = <span class="hljs-keyword">new</span> Derived;<br>Derived* d = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="hljs-comment">// 安全转换基类指针为派生类指针</span><br><span class="hljs-keyword">if</span> (d) &#123; <span class="hljs-comment">/* 成功转换 */</span> &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong><code>const_cast</code></strong>：</p>
<ul>
<li><strong>用途</strong>：用于修改类型的<code>const</code>或<code>volatile</code>属性。通常用于去除<code>const</code>属性。</li>
<li><strong>注意</strong>：使用<code>const_cast</code>去除<code>const</code>属性后修改所指向的数据，如果原对象本身是<code>const</code>，则行为未定义。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* modifiable = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;ci);<br><span class="hljs-comment">// *modifiable = 20; // 危险！如果ci是真的const，这是未定义行为</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong><code>reinterpret_cast</code></strong>：</p>
<ul>
<li><strong>用途</strong>：进行低级别的重新解释转换，几乎没有任何类型检查。可以将任何指针转换成任何其他指针类型，也可以将指针转换成足够大的整型，反之亦然。</li>
<li><strong>注意</strong>：<code>reinterpret_cast</code>是非常危险的，应该尽可能避免使用，除非你确切知道自己在做什么，并且了解与之相关的风险。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">char</span>* ch = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(p); <span class="hljs-comment">// 将int*转换为char*</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>这些强制类型转换运算符提供了更精细、更安全的转换控制，使代码意图更加明确，同时帮助避免不安全的转换。</p>
<br>
<p>为什么不使用C的强制转换？</p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</div></details>
<ol start="19">
<li><strong>简述类成员函数的重写、重载和隐藏的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>tips：重写 就是 覆盖</p>
<p>（1）重写和重载主要有以下几点不同。</p>
<ul>
<li>范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。</li>
<li>参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。</li>
<li>virtual的区别：重写的基类中被重写的函数必须要有<code>virtual</code>修饰，而重载函数和被重载函数可以被 <code>virtual</code>修饰，也可以没有。</li>
</ul>
<p>（2）隐藏和重写、重载有以下几点不同。</p>
<ul>
<li>与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。</li>
<li>参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的参数是否被 <code>virtual</code> 修饰，基类的函数都是被隐藏，而不是被重写。</li>
</ul>
<p>「注意」 ：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态绑定的多态，而重载是静态绑定的多态。</p>
</div></details> 
<ol start="20">
<li><strong>RTTI是什么？其原理是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>RTTI即运行时类型识别，其功能由两个运算符实现：</p>
<ul>
<li><code>typeid</code> 运算符，用于返回表达式的类型，可以通过基类的指针获取派生类的数据类型；</li>
<li><code>dynamic_cast</code> 运算符，具有类型检查的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
</div></details>
<ol start="21">
<li><strong>C++的空类有哪些成员函数</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>缺省构造函数。</li>
<li>缺省拷贝构造函数。</li>
<li>缺省析构函数。</li>
<li>赋值运算符。</li>
<li>取址运算符。</li>
<li>取址运算符 const 。</li>
</ul>
<p>「注意」 ：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。</p>
<br>
<p>有点争议啊：</p>
<ul>
<li>
<p><strong>取址运算符（Address-of Operator）</strong>：这通常指的是通过<code>&amp;</code>获取对象的地址。实际上，这并不是类特有的成员函数，而是C++内置的操作。对于类对象，可以直接使用<code>&amp;</code>操作符获取对象的地址，不需要类中定义特殊的成员函数。</p>
</li>
<li>
<p><strong>取址运算符 const（Address-of Operator for const objects）</strong>：这是对const对象使用取址运算符的情形，同样，并不需要类中定义特殊的成员函数来支持。</p>
</li>
</ul>
<p>对于第5点和第6点，实际上在标准C++中，并没有特指“取址运算符”作为类的默认成员函数。取址操作是通过C++语言内置的<code>&amp;</code>运算符完成的，适用于所有类型的对象，包括类的实例，而不需要由编译器为类特别生成。这可能是你所提到的书籍与标准C++文档描述不同的地方。</p>
</div></details>
<ol start="22">
<li><strong>C++中空结构体和空对象的大小</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>1个字节</p>
<p>空对象占用内存空间为:1<br>
C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置<br>
每个空对象也应该有一个独一无二的内存地址</p>
<p>C语言中的空结构体和C++中的空结构体在所占用的内存大小方面有所不同。在C语言中，空结构体的大小未明确规定，不同的编译器可能会有不同的处理方式；而在C++中，空结构体的大小为1字节。这是因为C++标准规定了每个对象必须有一个独一无二的地址，即使是空对象也不例外，因此空结构体至少占用1字节的空间，以确保它可以被唯一地标识。这个规定有助于C++支持面向对象的特性，如多态和继承。</p>
</div></details>
<ol start="23">
<li><strong>为什么析构函数一般写成虚函数</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p>
</div></details>
<ol start="24">
<li><strong>拷贝初始化和直接初始化，初始化和赋值的区别?</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li><code>ClassTest ct1(&quot;ab&quot;);</code> 这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数<code>ClassTest(constchar *pc);</code>，所以当复制构造函数变为私有时，它还是能直接执行的。</li>
<li><code>ClassTest ct2 = &quot;ab&quot;;</code> 这条语句为复制初始化，它首先调用构造函数 <code>ClassTest(const char* pc)</code> 函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。</li>
<li><code>ClassTest ct3 = ct1;</code>这条语句为复制初始化，因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。</li>
<li><code>ClassTest ct4(ct1) ;</code>这条语句为直接初始化，因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。</li>
</ul>
<p>要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。</p>
</div></details>
<ol start="25">
<li><strong>虚函数和虚函数表</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>虚函数和虚函数表是C++实现多态性的核心机制。让我们深入了解这两个概念。</p>
<p><strong>虚函数（Virtual Function）</strong></p>
<p>虚函数是在基类中使用<code>virtual</code>关键字声明的成员函数，它可以在派生类中被重写（Override）。虚函数允许派生类根据对象的实际类型来调用相应的函数，实现运行时多态。这意味着，如果有一个基类指针或引用指向一个派生类对象，那么通过这个指针或引用调用虚函数时，调用的将是派生类中的版本（如果派生类中有重写的话）。</p>
<p><strong>虚函数表（Virtual Table，简称vtable）</strong></p>
<p>虚函数表是一个实现细节，用于支持运行时的多态性。每个使用虚函数的类都有一个虚函数表。这个表是一个编译器在编译时期生成的静态数组，用于存储指向类的虚函数的指针。每个对象都包含一个指向其类的虚函数表的指针（称为vptr），通过这个指针可以找到对应的虚函数实现。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>虚函数表的创建</strong>：编译器为每一个包含虚函数的类生成一个虚函数表。这个表包含了指向类中每个虚函数实现的指针。如果派生类重写了基类中的虚函数，则派生类的虚函数表中会存储指向这些新实现的指针。</li>
<li><strong>对象的vptr</strong>：每个对象实例都会包含一个指针（vptr），指向其类的虚函数表。这个指针在对象被创建时自动设置。</li>
<li><strong>虚函数的调用</strong>：当调用一个对象的虚函数时，实际上是通过对象的vptr来访问虚函数表，然后通过虚函数表找到相应函数的地址，最后调用该函数。</li>
</ol>
<p><strong>示例</strong></p>
<p>考虑以下的类定义和函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::func() called&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived::func() called&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>obj-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 输出 &quot;Derived::func() called&quot;</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，尽管<code>obj</code>的静态类型是<code>Base*</code>，但由于<code>func</code>是虚函数，并且<code>obj</code>实际指向<code>Derived</code>对象，所以调用的是<code>Derived</code>中的<code>func</code>实现。</p>
<p><strong>优点与局限</strong></p>
<ul>
<li><strong>优点</strong>：虚函数和虚函数表提供了一种强大的机制，允许C++程序在运行时进行函数调用的决策，从而实现多态性和动态绑定。</li>
<li><strong>局限</strong>：虚函数的使用增加了一定的运行时开销，因为每次虚函数调用都需要通过虚函数表来解析函数地址。此外，每个对象因为包含vptr而稍微增加了内存占用。</li>
</ul>
<p>虚函数和虚函数表是C++中实现面向对象编程核心特性之一，理解它们的工作原理对于深入学习C++非常重要。</p>
</div></details>
<hr>
<br>
<br>
<br>
<h3 id="内存">内存</h3>
<ol>
<li><strong>new / delete 和 malloc / free 之间有什么关系？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> *q = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>new</code>与<code>delete</code>直接带具体类型的指针， <code>malloc</code>和<code>free</code>返回<code>void</code>类型的指针。</li>
<li><code>new</code>类型是安全的，而<code>malloc</code>不是。例如<code>int *p = new float[2];</code>就会报错；而<code>int p = malloc(2sizeof(int))</code>编译时编译器就无法指出错误来。</li>
<li><code>new</code>一般分为两步：<code>new</code>操作和构造。 <code>new</code>操作对应与<code>malloc</code>，但<code>new</code>操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而<code>malloc</code>不行。</li>
<li><code>new</code>调用构造函数， <code>malloc</code>不能； <code>delete</code>调用析构函数，而<code>free</code>不能。</li>
<li><code>malloc</code>/ <code>free</code>需要库文件<code>stdlib.h</code>的支持， <code>new/delete</code>则不需要！</li>
</ul>
<p>「注意」 ： <code>delete</code>和<code>free</code>被调用后，内存不会立即回收，指针也不会指向空， <code>delete</code>或<code>free</code>仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该将该指针指向<code>NULL</code>。</p>
</div></details>
<ol start="2">
<li><strong>delete与delete []有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>
<p>对于简单类型来说，使用 <code>new</code> 分配后，不管是数组还是非数组形式，两种方式都可以释放内存：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-type">int</span> *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">delete</span> [] b;<br><span class="hljs-type">int</span> *c = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">11</span>];<br><span class="hljs-keyword">delete</span> c;<br><span class="hljs-type">int</span> *d = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br><span class="hljs-keyword">delete</span> [] d;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>对于自定义类型来说，就需要对于单个对象使用 <code>delete</code> ，对于对象数组使用 <code>delete []</code> ，逐个调用数组中对象的析构函数，从而释放所有内存；</p>
</li>
<li>
<p>如果反过来使用，即对于单个对象使用 <code>delete []</code> ，对于对象数组使用 delete ，其行为是未定义的；</p>
</li>
<li>
<p>所以，最恰当的方式就是如果用了 <code>new</code> ，就用 <code>delete</code> ；如果用了 <code>new []</code> ，就用 <code>delete []</code> 。</p>
</li>
</ul>
</div></details>
<ol start="3">
<li><strong>内存块太小导致 malloc 和 new 返回空指针，该怎么处理？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>
<p>对于 <code>malloc</code> 来说，需要判断其是否返回空指针，如果是则马上用 <code>return</code> 语句终止该函数或者 <code>exit</code> 终止该程序；</p>
</li>
<li>
<p>对于 <code>new</code> 来说，默认抛出异常，所以可以使用 <code>try...catch...</code> 代码块的方式：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10000000</span>];<br>&#125; <span class="hljs-built_in">catch</span>(bad_alloc &amp;memExp) &#123;<br>    cerr &lt;&lt; memExp.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还可以使用 <code>set_new_handler</code> 函数的方式：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_more_memory</span><span class="hljs-params">()</span> </span>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;Unable to satisfy request for memory&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">abort</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">set_new_handler</span>(no_more_memory);<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10000000</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这种方式里，如果 <code>new</code> 不能满足内存分配请求， <code>no_more_memory</code> 会被反复调用，所以 <code>new_handler</code> 函数必须完成以下事情：</p>
<ul>
<li>让更多内存可被使用：可以在程序一开始执行就分配一大块内存，之后当 <code>new_handler</code> 第一次被调用，就将这些内存释放还给程序使用；</li>
<li>使用另一个 <code>new_handler</code> ；</li>
<li>卸除 <code>new_handler</code> ：返回空指针，这样 <code>new</code> 就会抛出异常；</li>
<li>直接抛出 <code>bad_alloc</code> 异常；</li>
<li>调用 <code>abort</code> 或 <code>exit</code> 。</li>
</ul>
</li>
</ul>
</div></details>
<ol start="4">
<li><strong>内存泄漏的场景有哪些？如何判断内存泄漏？如何定位内存泄漏？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>内存泄漏漏的场景：</p>
<ul>
<li>
<p><code>malloc</code> 和 <code>free</code> 未成对出现； <code>new/new []</code> 和 <code>delete/delete []</code> 未成对出现；</p>
</li>
<li>
<p>在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     ……</span><br><span class="hljs-comment">    */</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>在构造函数中动态分配内存，但未在析构函数中正确释放内存；</p>
</li>
<li>
<p>未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的；</p>
</li>
<li>
<p>没有将基类的析构函数定义为虚函数。</p>
</li>
</ul>
<p>判断和定位内存泄漏的方法：在Linux系统下，可以使用<code>valgrind</code>、 <code>mtrace</code>等内存泄漏检测工具。</p>
</div></details>
<ol start="5">
<li><strong>内存的分配方式有几种？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限；</li>
<li>从堆上分配：由 <code>new</code> 分配 <code>delete</code> 释放的内存块，也称为动态内存分配，程序员自行申请和释放内存，使用灵活；</li>
<li>从自由存储区分配：由 <code>malloc</code> 分配 <code>free</code> 释放的内存块，与堆类似；</li>
<li>从常量存储区分配：特殊的存储区，存放的是常量，不可修改；</li>
<li>从全局/静态存储区分配：编译期间分配内存，整个程序运行期间都存在，如全局变量、静态变量等。</li>
</ul>
</div></details>
<ol start="6">
<li><strong>堆和栈有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>分配和管理方式不同</strong>：</p>
<ul>
<li>堆是动态分配的，其空间的分配和释放都由程序员控制；</li>
<li>栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由 <code>alloca()</code> 函数进行分配，但是会由编译器释放；</li>
</ul>
<p><strong>产生碎片不同</strong>：</p>
<ul>
<li>对堆来说，频繁使用 <code>new/delete</code> 或者 <code>malloc/free</code> 会造成内存空间的不连续，产生大量碎片，使程序效率降低；</li>
<li>对栈来说，不存在碎片问题，因为栈具有先进后出的特性；</li>
</ul>
<p><strong>生长方向不同</strong>：</p>
<ul>
<li>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；</li>
<li>栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；</li>
</ul>
<p><strong>申请大小限制不同</strong>：</p>
<ul>
<li>栈顶和栈底是预设好的，大小固定；</li>
<li>堆是不连续的内存区域，其大小可以灵活调整</li>
</ul>
</div></details>
<ol start="7">
<li><strong>静态内存分配和动态内存分配有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；</li>
<li>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；</li>
<li>静态内存分配不需要指针或引用类型的支持；动态内存分配需要；</li>
<li>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；</li>
<li>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；</li>
<li>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。</li>
</ul>
</div></details>
<ol start="8">
<li><strong>如何构造一个类，使得只能在堆上或只能在栈上分配内存？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>只能在堆上分配内存：将析构函数声明为 <code>private</code> ；</p>
<p>只能在栈上生成对象：将 <code>new</code> 和 <code>delete</code> 重载为 <code>private</code> 。</p>
<br>
<p>你的概念基本正确，但有一些需要微调和补充的地方。下面是如何实现这两种限制的详细说明：</p>
<ol>
<li><strong>限制对象只能在堆上创建</strong></li>
</ol>
<p>要创建一个只能在堆上分配的类对象，可以将析构函数设为<code>private</code>。这样，用户就不能在栈上创建对象，因为栈上的对象在作用域结束时会自动调用析构函数，而私有析构函数在类外部是不可访问的。同时，你需要提供一个公有的静态成员函数来删除对象，因为用户无法直接调用<code>delete</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOnly</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> HeapOnly* <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapOnly</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">HeapOnly</span>() &#123;&#125;  <span class="hljs-comment">// 私有析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，用户可以通过调用<code>HeapOnly::create()</code>在堆上创建对象，并通过对象的<code>destroy()</code>方法来删除对象。</p>
<ol start="2">
<li><strong>限制对象只能在栈上创建</strong></li>
</ol>
<p>限制对象只能在栈上创建的关键是防止通过<code>new</code>操作符在堆上分配对象。为此，可以将<code>new</code>操作符重载为<code>private</code>。这样，用户就无法在类外使用<code>new</code>来创建对象实例。由于栈上的对象不需要显式地调用<code>delete</code>，因此没有必要将<code>delete</code>操作符设为<code>private</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOnly</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StackOnly</span>() &#123;&#125;  <span class="hljs-comment">// 公有构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 示例成员函数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用new操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> </span>= <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 为了完整性，也可以禁用delete操作</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，用户可以在栈上创建<code>StackOnly</code>类型的对象，但不能在堆上创建。</p>
<p><strong>注意</strong></p>
<ul>
<li>限制只在堆上创建对象时，需要额外注意析构函数的调用权。因为析构函数是<code>private</code>的，你需要确保有适当的方法来释放对象。</li>
<li>限制只在栈上创建对象可能会阻止某些高级用法，例如通过智能指针管理对象的生命周期。在实际应用中，需要根据具体需求仔细考虑这些限制的利弊。</li>
</ul>
<p>这两种方法各有其用途，可以根据特定场景选择适合的实现方式。</p>
<br>
<p><strong>为什么析构函数私有化就不能在栈区申请</strong>？</p>
<p>将析构函数设为<code>private</code>限制了在栈上创建对象的能力，原因在于对象的生命周期管理。在C++中，当一个对象在栈上创建时，它的生命周期由程序的作用域决定。一旦对象所在的作用域结束，编译器会自动插入对该对象析构函数的调用，以确保正确地清理资源。</p>
<p>如果析构函数被声明为<code>private</code>，那么在类的外部就无法访问它。这意味着在类外部的代码（包括由编译器自动生成的代码）不能调用这个析构函数。因此，如果试图在栈上创建这种类的对象，编译器将在编译时报错，因为它不能生成在作用域结束时调用私有析构函数的代码。</p>
<p>这是一种设计选择，用于确保对象的生命周期仅能通过类提供的公有接口来管理。在只能在堆上创建对象的设计中，通常会提供一个公有的静态成员函数来创建对象，并提供一个公有的成员函数来销毁对象，如下例所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOnly</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> HeapOnly* <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 允许在堆上创建对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapOnly</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 允许通过对象的公有方法销毁对象</span><br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">HeapOnly</span>() &#123;&#125; <span class="hljs-comment">// 析构函数私有化</span><br>    <span class="hljs-comment">// 类的其他成员</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>通过这种方式，可以控制对象的创建和销毁，确保对象只能通过<code>new</code>在堆上创建，并通过特定方法销毁，同时避免了在栈上创建对象的可能性。</p>
<p>总的来说，将析构函数设为<code>private</code>是一种强制对象只能在堆上分配的技术，它利用了C++对于作用域结束时自动调用析构函数的规则，通过限制析构函数的访问来阻止栈上对象的创建。这样做的目的通常是为了更精细地控制对象的生命周期，尤其是在涉及复杂资源管理的情况下。</p>
</div></details>
<ol start="9">
<li><strong>浅拷贝与深拷贝</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>如果你没有为你的类显式定义一个拷贝构造函数，C++编译器会为你自动生成一个默认的拷贝构造函数。这个自动生成的拷贝构造函数执行的是浅拷贝（shallow copy），意味着它会逐个复制对象的所有成员变量到新对象中，这个复制过程是按成员的位复制（bitwise copy）进行的。</p>
<p><strong>浅拷贝的含义和影响</strong>:</p>
<ul>
<li><strong>对于非指针类型的成员</strong>，浅拷贝简单地复制其值。这对于内置数据类型（如<code>int</code>、<code>float</code>等）和包含这些类型的复合数据类型通常是足够的。</li>
<li><strong>对于指针类型的成员</strong>，浅拷贝只复制指针的值，而不复制指针所指向的数据。因此，原始对象和拷贝对象的指针成员将指向同一个内存地址。这可能会导致问题，如：
<ul>
<li>当原始对象或拷贝对象被销毁时，它们的析构函数可能尝试释放同一个内存地址，造成双重释放问题（double-free）。</li>
<li>修改一个对象中的动态分配数据也会影响另一个对象，因为它们共享同一个数据。</li>
</ul>
</li>
</ul>
<p><strong>深拷贝</strong>:</p>
<p>为了解决浅拷贝可能导致的问题，特别是在类成员包含指向动态分配内存的指针时，可以显式定义自己的拷贝构造函数来实现深拷贝（deep copy）。深拷贝不仅复制指针的值，还复制指针所指向的数据到新的内存地址，这样原始对象和拷贝对象就有了各自独立的数据副本，互不干扰。</p>
<p><strong>示例</strong>:</p>
<p>下面是一个演示默认拷贝构造函数只执行浅拷贝的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    MyClass obj2 = obj1; <span class="hljs-comment">// 使用默认拷贝构造函数，浅拷贝</span><br>    <span class="hljs-comment">// 此时obj1.data和obj2.data指向同一块内存</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果<code>MyClass</code>需要深拷贝行为，你应该显式定义一个拷贝构造函数来正确复制<code>data</code>成员指向的内存。</p>
<p><strong>总结</strong>:</p>
<p>当类中没有显式定义拷贝构造函数时，C++编译器生成的默认拷贝构造函数执行浅拷贝。这在许多情况下是合理的，但如果类成员包含指针指向动态分配的内存，就需要考虑实现深拷贝以避免潜在的内存管理问题。</p>
</div></details>
<ol start="10">
<li><strong>字节对齐的原则是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>从偏移为0的位置开始存储；</li>
<li>如果没有定义 <code>#pragma pack(n)</code>
<ul>
<li><code>sizeof</code> 的最终结果必然是结构内部最大成员的整数倍，不够补齐；</li>
<li>结构内部各个成员的首地址必然是自身大小的整数倍；</li>
</ul>
</li>
<li>如果定义了 <code>#pragma pack(n)</code>
<ul>
<li><code>sizeof</code> 的最终结果必然是 <code>min[n,结构内部最大成员]</code> 的整数倍，不够补齐；</li>
<li>结构内部各个成员的首地址必然是 <code>min[n,自身大小]</code> 的整数倍。</li>
</ul>
</li>
</ul>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="计算机网络">计算机网络</h2>
<ol>
<li><strong>说一说三次握手</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次握手的时候，我想很多人会这样回答：</p>
<p>首先很多人会先讲下握手的过程：<br>
1、第一次握手：客户端给服务器发送一个 SYN 报文。<br>
2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。<br>
3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。<br>
4、服务器收到 ACK 报文之后，三次握手建立完成。<br>
作用是为了确认双方的接收与发送能力是否正常。</p>
<br>
<p>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：<br>
第一次握手：客户端发送网络包，服务端收到了。这样<u>服务端</u>就能得出结论：<u>客</u>户端的<u>发</u>送能力、<u>服</u>务端的<u>接</u>收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。这样<u>客户端</u>就能得出结论：<u>服</u>务端的<u>接</u>收、<u>发</u>送能力，<u>客</u>户端的<u>接</u>收、<u>发</u>送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
<p>第三次握手：客户端发包，服务端收到了。这样<u>服务端</u>就能得出结论：<u>客</u>户端的<u>接</u>收、<u>发</u>送能力正常，<u>服</u>务器自己的<u>发</u>送、<u>接</u>收能力也正常</p>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<br>
<p>这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更详细一点，因为三次握手的过程中，双方是由很多状态的改变的，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</p>
<p>刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后<br>
1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于SYN_SEND 状态。</p>
<p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初<br>
始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</p>
<p>4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_20-40-48.png" alt="img"></p>
<br>
<p><strong>三次握手的作用</strong><br>
三次握手的作用也是有好多的，多记住几个，保证不亏。例如：<br>
1、确认双方的接受能力、发送能力是否正常。<br>
2、指定自己的初始化序列号，为后面的可靠传送做准备。</p>
<br>
<p><strong>1、（ISN）是固定的吗</strong></p>
<p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<br>
<p><strong>2、什么是半连接队列</strong><br>
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把<br>
此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例例如间隔时间为 1s, 2s, 4s, 8s,</p>
</blockquote>
<br>
<p><strong>3、三次握手过程中可以携带数据吗</strong><br>
很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，<br>
并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<br>
<p><strong>TCP状态</strong>：</p>
<ol>
<li><strong>CLOSED</strong>
<ul>
<li>这是初始状态和最终状态，表示没有任何活动连接，也没有挂起的连接请求。</li>
</ul>
</li>
<li><strong>LISTEN</strong>
<ul>
<li>服务器处于此状态，等待来自客户端的连接请求。在此状态下，服务器准备接受传入的 SYN 请求。</li>
</ul>
</li>
<li><strong>SYN_SENT</strong>
<ul>
<li>客户端发送完 SYN 报文后进入此状态，等待服务器确认。这是第一次握手，客户端已经开始尝试建立连接。</li>
</ul>
</li>
<li><strong>SYN_RECEIVED</strong>
<ul>
<li>服务器收到客户端的 SYN 报文，并且发送自己的 SYN+ACK 报文后，进入此状态。这表示服务器已响应客户端的连接请求，等待客户端的最终确认。</li>
</ul>
</li>
<li><strong>ESTABLISHED</strong>
<ul>
<li>连接已成功建立。在此状态下，客户端和服务器已经完成三次握手，并且可以开始数据传输。客户端和服务器都可以处于此状态。</li>
</ul>
</li>
<li><strong>FIN_WAIT_1</strong>
<ul>
<li>当连接处于建立状态并且有一方（通常是客户端）决定关闭连接时，它发送 FIN 包并进入此状态，等待对方的 ACK。</li>
</ul>
</li>
<li><strong>FIN_WAIT_2</strong>
<ul>
<li>当一方接收到对方的 ACK 后，进入此状态，等待对方的 FIN 包。</li>
</ul>
</li>
<li><strong>TIME_WAIT</strong>
<ul>
<li>当一方接收到对方的 FIN 包并发送 ACK 后，它会进入此状态。这个状态通常持续一段时间（2MSL，即两倍的最大段生命周期），以确保对方收到 ACK。</li>
</ul>
</li>
<li><strong>CLOSE_WAIT</strong>
<ul>
<li>当服务器端接收到客户端的 FIN 包时，它进入此状态。服务器需要等待应用程序关闭连接。</li>
</ul>
</li>
<li><strong>LAST_ACK</strong>
<ul>
<li>当应用程序关闭连接并发送 FIN 包时，服务器进入此状态，等待客户端的最后一个 ACK。</li>
</ul>
</li>
<li><strong>CLOSING</strong>
<ul>
<li>在同时关闭的情况下使用，即当两边几乎同时发送 FIN 包时，双方都会等待对方的 ACK。</li>
</ul>
</li>
</ol>
<p><strong>TCP 报文的控制位</strong></p>
<ul>
<li><strong>确认位ACK</strong>：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li>
<li><strong>同步位SYN</strong>：SYN=1时，表明是一个连接请求/连接接受报文。</li>
<li><strong>终止位FIN</strong>：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li>
</ul>
</div></details>  
<ol start="2">
<li><strong>说一说四次挥手</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>四次挥手也一样，千万不要<br>
对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。<br>
然后结束，最好是说的详细一点，例如想下面这样：</p>
<br>
<p>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p>
<ol>
<li><strong>第一次挥手：FIN from Client</strong>
<ul>
<li>客户端发送一个 FIN 报文到服务端，请求关闭连接。这时客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
</ul>
</li>
<li><strong>第二次挥手：ACK from Server</strong>
<ul>
<li>服务端接收到这个 FIN 报文后，发送一个 ACK 报文作为回应，确认序号为收到的 FIN 序号加一。服务端此时进入 <strong>CLOSE_WAIT</strong> 状态，客户端收到 ACK 后进入 <strong>FIN_WAIT_2</strong> 状态。</li>
</ul>
</li>
<li><strong>第三次挥手：FIN from Server</strong>
<ul>
<li>服务端准备好关闭连接时，会发送一个 FIN 报文到客户端。此时服务端进入 <strong>LAST_ACK</strong> 状态。</li>
</ul>
</li>
<li><strong>第四次挥手：ACK from Client</strong>
<ul>
<li>客户端接收到服务端的 FIN 报文后，发送一个 ACK 报文作为回应，确认序号为收到的 FIN 序号加一。客户端此时进入 <strong>TIME_WAIT</strong> 状态。在这个状态下，客户端会等待足够的时间以确保服务端收到其 ACK 报文。</li>
</ul>
</li>
<li><strong>关闭连接</strong>
<ul>
<li>服务端在收到客户端的 ACK 报文后，进入 <strong>CLOSED</strong> 状态，完成连接的关闭。</li>
<li>客户端在 <strong>TIME_WAIT</strong> 状态经过一定时间（通常是最大报文段生命周期的两倍，即 2MSL）后，也转入 <strong>CLOSED</strong> 状态。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>CLOSE_WAIT</strong> 是服务端接收到 FIN 后等待关闭本地连接的状态。</li>
<li><strong>LAST_ACK</strong> 是服务端发送完 FIN 并等待最终 ACK 的状态。</li>
<li><strong>TIME_WAIT</strong> 是客户端收到服务端的 FIN 并发送 ACK 后，确保服务端接收到 ACK 的状态，防止最后一个 ACK 丢失导致服务端无法正常关闭。</li>
<li><strong>其他状态写在上一个问题中</strong> —— <strong>说一说三次握手</strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_20-41-21.png" alt="img"></p>
<br>
<p>这里特别需要注意的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK<br>
之后不直接关闭，而是要等一阵子才关闭。</p>
<p>这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，<br>
如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>
至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到<br>
FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态</p>
</div></details>  
<ol start="3">
<li><strong>说一说POST与GET有哪些区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>在HTTP协议中，<code>POST</code>和<code>GET</code>是两种最常用的方法（或称为“动作”），用于在客户端和服务器之间发送请求。这两种方法虽然在许多方面相似，但在使用方式和目的上有明显的差异。以下是<code>POST</code>和<code>GET</code>的一些主要区别：</p>
<p><strong>1. 数据提交方式</strong></p>
<ul>
<li><strong>GET</strong>：通过URL传递数据。数据附加在URL之后，并以查询字符串的形式出现，如<code>?key1=value1&amp;key2=value2</code>。这意味着GET请求的数据可以在浏览器的URL栏中看到。</li>
<li><strong>POST</strong>：将数据作为请求的主体发送，不在URL中显示。这使得POST比GET更安全，因为提交的数据不会保存在浏览器历史或服务器日志中。</li>
</ul>
<p><strong>2. 数据大小限制</strong></p>
<ul>
<li><strong>GET</strong>：由于数据在URL中传递，因此受URL长度限制（由浏览器和服务器定义），通常为2048字符。</li>
<li><strong>POST</strong>：理论上没有大小限制，因此可以传输大量数据。这使得POST适合于文件上传等操作。</li>
</ul>
<p><strong>3. 安全性</strong></p>
<ul>
<li><strong>GET</strong>：由于数据在URL中可见，因此不适合传输敏感数据，如密码或个人信息。</li>
<li><strong>POST</strong>：数据在请求体内，相对更加隐蔽，适合发送敏感或大量数据。</li>
</ul>
<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有： <strong>HEAD</strong>、 <strong>OPTIONS</strong>。<br>
不安全的方法除了 POST 之外还有 <strong>PUT</strong>、 <strong>DELETE</strong>。</p>
<p><strong>4. 缓存和历史</strong></p>
<ul>
<li><strong>GET</strong>：可以被缓存，可以被保存在浏览器历史中，可以被书签保存。</li>
<li><strong>POST</strong>：通常不被缓存，不会保存在浏览器历史中，不能被书签。</li>
</ul>
<p><strong>5. 幂等性</strong></p>
<ul>
<li><strong>GET</strong>：是幂等的，意味着多次执行相同的GET请求，资源的状态应该是相同的，不会因请求次数增加而改变。</li>
<li><strong>POST</strong>：不是幂等的，每次请求都可能改变服务器上的状态，如每次提交都可能在数据库中添加新的记录。</li>
</ul>
<p><strong>6. 用途</strong></p>
<ul>
<li><strong>GET</strong>：主要用于获取/查询资源信息，而不应当引起服务器上资源的状态变化。</li>
<li><strong>POST</strong>：用于向服务器提交数据，常用于表单提交、文件上传等，其操作可能会在服务器上创建新资源或更新现有资源。</li>
</ul>
<p><strong>7. 服务器端影响</strong></p>
<ul>
<li><strong>GET</strong>：请求应该只用于获取数据，不应改变服务器状态。</li>
<li><strong>POST</strong>：可以创建或更改服务器的状态，因此对安全性有更高的要求。</li>
</ul>
<p><strong>总结</strong></p>
<p>选择<code>GET</code>还是<code>POST</code>，主要取决于操作的性质：如果是获取数据，应使用GET；如果是修改服务器上的数据或提交敏感信息，应使用POST。正确的使用GET和POST可以帮助遵循HTTP协议的设计原则，提高应用程序的可维护性和效率。</p>
<p><br><br><br><br></p>
<p><strong>幂等性</strong>是一个在计算中常用的概念，特别是在网络协议和数据库操作中。在HTTP协议中，如果一个方法是幂等的，那么无论这个方法执行多少次，产生的效果和执行一次是相同的，至少在外部可观察的结果上是这样。</p>
<p><strong>HTTP方法的幂等性</strong></p>
<p>在HTTP中，以下方法被定义为幂等的：</p>
<ul>
<li><strong>GET</strong>：用于请求资源，不应该产生副作用，即不应该改变资源状态。无论你请求多少次，资源的展示应该是相同的。</li>
<li><strong>HEAD</strong>：与GET相似，但服务器在响应中只返回头部信息，不返回实体部分。它也不应改变任何状态，因此是幂等的。</li>
<li><strong>DELETE</strong>：用于删除资源。理论上，第一次调用删除资源后，资源不再存在，后续的DELETE请求将持续报告该资源已被删除（例如，通过404状态码），因此外部状态不改变。</li>
<li><strong>PUT</strong>：用于上传资源或在指定位置更新资源。多次上传相同的数据到同一位置的效果应该与一次上传相同，因此被视为幂等。</li>
</ul>
<p>相反，<strong>POST</strong>方法通常用于创建资源或触发服务器上的操作，它不是幂等的。例如，如果POST请求用于在数据库中创建一个新条目，那么每次执行相同的POST请求都会创建一个新的条目，这会改变服务器的状态。</p>
<p><strong>举例说明</strong></p>
<ol>
<li>
<p><strong>GET 示例</strong>：</p>
<ul>
<li>假设有一个URL，<code>http://example.com/info</code>，它返回一个用户信息的JSON对象。不管你访问这个URL多少次，只要信息没有被改变，返回的结果应该总是相同的。</li>
</ul>
</li>
<li>
<p><strong>POST 示例</strong>：</p>
<ul>
<li>假设有一个论坛，用户可以通过发送POST请求到 <code>http://example.com/new-post</code> 来发布新帖子。这个请求的体可能包含帖子的标题和内容。如果用户连续发送了两次完全相同的POST请求，系统通常会创建两个内容相同的独立帖子。</li>
</ul>
</li>
<li>
<p><strong>PUT 示例</strong>：</p>
<ul>
<li>假设有一个URL <code>http://example.com/update-profile</code>，用户可以通过PUT请求更新他们的个人信息。如果用户发送了多个包含相同信息（如姓名、地址等）的PUT请求，不论这个操作执行多少次，用户的最终状态都应该是一样的。</li>
</ul>
</li>
<li>
<p><strong>DELETE 示例</strong>：</p>
<ul>
<li>假设 <code>http://example.com/delete-item/123</code> 是一个用于删除ID为123的项的URL。第一次DELETE请求执行后，项123被删除。后续的DELETE请求可能会返回404错误，表明资源不存在，但不会改变服务器的状态。</li>
</ul>
</li>
</ol>
<p>通过这些例子，我们可以看到，幂等方法确保了无论操作执行多少次，资源的状态都保持一致，而非幂等方法则可能每次都改变服务器的状态。这种特性在设计API时非常重要，尤其是在分布式系统和可能面临网络问题的环境中，因为它们帮助开发者理解和预测请求可能带来的改变。</p>
</div></details>  
<ol start="4">
<li><strong>说一说TCP与UDP的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>TCP协议的主要特点</strong>：<br>
（1） TCP是面向连接的传输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手<br>
就是建立通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。<br>
（2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；<br>
（3） TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；<br>
（4） TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接<br>
受缓存；<br>
（5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。</p>
<p><strong>TCP的可靠性原理</strong><br>
可靠传输有如下两个特点:<br>
a.传输信道无差错,保证传输数据正确;<br>
b.不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;<br>
（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。<br>
（2）其次， TCP采用了连续ARQ协议（回退N， Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。<br>
（3）最后， TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p>
<br>
<p><strong>UDP协议特点</strong><br>
（1） UDP是无连接的传输层协议；<br>
（2） UDP使用尽最大努力交付，不保证可靠交付；<br>
（3） UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；<br>
（4） UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；<br>
（5） UDP支持一对一　一对多　多对多的交互通信；<br>
（6） UDP的首部开销小，只有８字节．</p>
<br>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-18_23-04-33.png" alt=""></p>
<p><strong>TCP和UDP的区别</strong><br>
（1）TCP是可靠传输，UDP是不可靠传输;<br>
（2）TCP面向连接，UDP无连接;<br>
（3）TCP传输数据有序，UDP不保证数据的有序性;<br>
（4）TCP不保存数据边界，UDP保留数据边界;<br>
（5）TCP传输速度相对UDP较慢;<br>
（6）TCP有流量控制和拥塞控制，UDP没有;<br>
（7）TCP是重量级协议，UDP是轻量级协议;<br>
（8）TCP首部较长20字节，UDP首部较短8字节;</p>
</div></details>  
<ol start="5">
<li><strong>说一说HTTP1.0， 1.1， 2.0 的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>HTTP（超文本传输协议）是Web的基础，随着时间的推移，该协议经历了几个重要的版本更新，每个版本都旨在改进性能、提高安全性和增加新功能。以下是HTTP 1.0、HTTP 1.1和HTTP 2.0之间的主要区别：</p>
<p><strong>HTTP 1.0</strong></p>
<ul>
<li><strong>1996年发布</strong>。</li>
<li><strong>无状态和无连接</strong>：每次请求都需要建立一个新的TCP连接，请求结束后连接就关闭。这导致每次HTTP请求都有显著的开销。</li>
<li><strong>简单和有限</strong>：HTTP 1.0支持基本的GET、POST和HEAD命令。</li>
<li><strong>无宿主名支持</strong>：HTTP 1.0不支持虚拟主机（多个域名在同一IP地址上），因为请求消息中没有宿主名。</li>
</ul>
<p><strong>HTTP 1.1</strong></p>
<ul>
<li><strong>1997年发布</strong>。</li>
<li><strong>持久连接</strong>：HTTP 1.1默认使用持久连接（也称为连接复用），允许多个请求和响应在单个连接上顺序完成，减少了建立和关闭连接的开销。</li>
<li><strong>管道化</strong>：允许客户端在收到上一个响应之前发送多个请求，以减少网络延迟。</li>
<li><strong>更多的缓存控制机制</strong>：引入了更复杂的缓存控制策略，如ETags，以及更多的缓存头字段。</li>
<li><strong>分块传输编码</strong>：允许服务器开始传输响应，而不必先发送内容的总长度。</li>
<li><strong>虚拟主机支持</strong>：通过请求头中的 <code>Host</code> 字段支持虚拟主机。</li>
<li><strong>错误通知的改进</strong>：增加了更多的状态代码，以提供更详细的错误类型信息。</li>
</ul>
<p><strong>HTTP 2.0</strong></p>
<ul>
<li><strong>2015年正式标准化</strong>。</li>
<li><strong>二进制协议</strong>：不再是纯文本协议，HTTP 2.0使用二进制格式，使得解析更快、更简洁，网络优化更有效。</li>
<li><strong>多路复用</strong>：在单一连接上可以并行交错地发送多个请求和响应，不需要按照顺序一一对应，极大地减少了延迟。</li>
<li><strong>服务器推送</strong>：服务器可以对一个客户端请求发送多个响应。服务器可以额外发送资源到客户端，而无需客户端明确地请求，从而提前加载可能需要的资源，提高性能。</li>
<li><strong>头部压缩</strong>：HTTP 2.0使用HPACK压缩格式压缩请求和响应的头部，减少了传输的数据量。</li>
</ul>
<p><strong>总结</strong></p>
<p>每个HTTP版本的推出都旨在解决前一版本的局限性，提高性能并满足新的网络需求。从HTTP 1.0的简单实现到HTTP 1.1的性能改进，再到HTTP 2.0的高效和现代化特性，每个版本都明显提升了Web通信的效率和速度。随着HTTP 3.0（基于QUIC协议）的出现，HTTP协议的发展预计将继续朝着更高效和更可靠的方向进步。</p>
</div></details>  
<ol start="6">
<li><strong>什么是SQL注入？举个例子？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>什么是SQL注入？</strong></p>
<p>SQL注入是一种安全漏洞，它允许攻击者通过在应用程序的输入中插入或“注入”恶意的SQL代码，来操纵后台数据库的执行。这通常发生在应用程序没有正确过滤或清理用户输入的情况下，使得攻击者能够执行未经授权的数据库命令，从而访问、修改、删除甚至在数据库中创建数据。</p>
<p>SQL注入可以对系统造成严重的安全威胁，包括数据泄露、数据损坏和完全的系统控制。</p>
<p><strong>示例</strong>：</p>
<p>假设有一个简单的网站，该网站允许用户通过输入用户名来查询其信息。后端的SQL查询可能类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;输入的用户名&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>如果应用程序没有适当过滤用户的输入，攻击者可以在输入中注入SQL片段。例如，如果攻击者输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">admin&#x27;; DROP TABLE users; --<br></code></pre></td></tr></table></figure>
<p>这将使得最终执行的SQL语句变为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span>; <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> users; <span class="hljs-comment">--&#x27;;</span><br></code></pre></td></tr></table></figure>
<p>这里发生的事情是：</p>
<ol>
<li><code>admin'</code>：将查询条件结束于管理员用户（如果存在）。</li>
<li><code>;</code>：SQL语句终止符，结束了原始的查询语句。</li>
<li><code>DROP TABLE users</code>：这是一个新的SQL语句，它会删除整个用户表。</li>
<li><code>--</code>：这是SQL中的注释标记，将使得剩余的部分被视为注释，从而忽略任何后续的SQL语句部分。</li>
</ol>
<br>
<p><strong>防御措施</strong></p>
<p>防止SQL注入的策略包括：</p>
<ul>
<li><strong>使用预处理语句（Prepared Statements）和参数化查询</strong>：这些技术确保发送到数据库的SQL命令对于预期的结构是静态的，输入值被数据库处理为数据，而不是SQL代码的一部分。</li>
<li><strong>有效的输入验证</strong>：确保应用程序验证所有输入数据，严格限制可能被解释为SQL代码的字符。</li>
<li><strong>使用最小权限原则</strong>：确保数据库连接使用的账户权限尽可能低，仅足够应用程序进行必要的操作。</li>
<li><strong>实时监控和警报</strong>：使用各种安全工具监控异常数据库活动，及时响应可能的安全事件。</li>
</ul>
<p>通过上述措施，可以显著降低SQL注入攻击的风险，保护应用程序和数据免受攻击者的侵害。</p>
</div></details>  
<ol start="7">
<li><strong>谈一谈 XSS 攻击，举个例子？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"></div></details>  
<ol start="8">
<li><strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>在很多现代网络应用中，尽管数据已经传送完毕，客户端和服务器可能仍需要保持连接以便未来的通信。维持这种“空闲”连接的方法有多种，主要取决于应用的具体需求和使用的协议。</p>
<br>
<p>在 HTTP 中响应体的 Connection 字段指定为 keep-alive</p>
<p><strong>作用和优势</strong></p>
<ol>
<li><strong>减少延迟</strong>：多次HTTP请求可以复用同一个TCP连接，避免了频繁进行TCP三次握手和四次挥手的延迟。</li>
<li><strong>节省资源</strong>：减少了因为频繁建立和关闭连接而消耗的计算和网络资源。</li>
<li><strong>提高性能</strong>：对于多个资源（如页面上的图片、样式表、脚本等）的请求，保持连接可以显著提高页面加载速度。</li>
</ol>
<p>在HTTP/1.0中，默认情况下，每个HTTP请求/响应对完成后，创建的TCP连接会立即关闭。这种方式称为“非持久连接”。为了在HTTP/1.0中保持连接，客户端需要在请求头中显式指定<code>Connection: keep-alive</code>。</p>
<p>相比之下，在HTTP/1.1中，默认的连接模式是持久连接（<code>keep-alive</code>），即除非明确指示关闭（<code>Connection: close</code>），否则连接将保持开放状态以供进一步的请求使用。这意味着在HTTP/1.1中，如果没有指定<code>Connection: close</code>，则不需要显式声明<code>Connection: keep-alive</code>，因为这已是<u>默认行为</u>。</p>
</div></details>  
<ol start="9">
<li>
<p><strong>GET请求中URL编码的意义</strong></p>
</li>
<li>
<p><strong>HTTP 哪些常用的状态码及使用场景？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>状态码分类</strong><br>
1xx：表示目前是协议的中间状态，还需要后续请求<br>
2xx：表示请求成功<br>
3xx：表示重定向状态，需要重新请求<br>
4xx：表示请求报文错误<br>
5xx：服务器端错误</p>
<p><strong>常用状态码</strong><br>
101 切换请求协议，从 HTTP 切换到 WebSocket<br>
200 请求成功，有响应体<br>
301 永久重定向：会缓存<br>
302 临时重定向：不会缓存<br>
304 协商缓存命中<br>
403 服务器禁止访问<br>
404 资源未找到<br>
400 请求错误<br>
500 服务器端错误<br>
503 服务器繁忙</p>
</div></details>  
<ol start="11">
<li>
<p><strong>HTTP 如何实现长连接？在什么时候会超时？</strong></p>
</li>
<li>
<p><strong>HTTP状态码301和302的区别，都有哪些用途？</strong></p>
</li>
<li>
<p><strong>IP地址有哪些分类？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li><strong>类A（Class A）</strong>
<ul>
<li>起始八位字节：0xxx xxxx</li>
<li>地址范围：0.0.0.0 至 127.255.255.255</li>
<li>默认子网掩码：255.0.0.0</li>
<li>用途：支持非常大的网络，适合大型组织。第一个八位字节是网络部分，剩下的三个八位字节是主机部分。</li>
</ul>
</li>
<li><strong>类B（Class B）</strong>
<ul>
<li>起始八位字节：10xx xxxx</li>
<li>地址范围：128.0.0.0 至 191.255.255.255</li>
<li>默认子网掩码：255.255.0.0</li>
<li>用途：适用于中等规模网络。前两个八位字节是网络部分，后两个是主机部分。</li>
</ul>
</li>
<li><strong>类C（Class C）</strong>
<ul>
<li>起始八位字节：110x xxxx</li>
<li>地址范围：192.0.0.0 至 223.255.255.255</li>
<li>默认子网掩码：255.255.255.0</li>
<li>用途：适合小型网络。前三个八位字节是网络部分，最后一个八位字节是主机部分。</li>
</ul>
</li>
<li><strong>类D（Class D）</strong>
<ul>
<li>起始八位字节：1110 xxxx</li>
<li>地址范围：224.0.0.0 至 239.255.255.255</li>
<li>用途：用于多播。在多播中，数据被发送到多个目的地。</li>
</ul>
</li>
<li><strong>类E（Class E）</strong>
<ul>
<li>起始八位字节：1111 xxxx</li>
<li>地址范围：240.0.0.0 至 255.255.255.255</li>
<li>用途：保留作为实验和未来使用，不用于公共网络。</li>
</ul>
</li>
</ol>
</div></details>  
<ol start="14">
<li><strong>简单说下每一层对应的网络协议有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>1. 物理层</strong></p>
<p>物理层是网络通信的最低层，负责原始比特流的传输，涉及的是<u>硬件设备、电气信号等物理设备标准</u>，而非特定的协议。这一层主要涉及的标准和技术包括：</p>
<ul>
<li><strong>以太网</strong>（Ethernet）：包括各种类型的电缆和信号</li>
<li><strong>光纤</strong>（Optical Fiber）</li>
<li><strong>串行传输标准</strong>，如RS-232</li>
<li><strong>物理接口和介质</strong>，如同轴电缆、双绞线、无线传输介质等</li>
</ul>
<br>
<p><strong>2. 数据链路层</strong></p>
<p>数据链路层负责在相邻的网络设备之间建立、维护和解除数据链路。主要的协议包括：</p>
<ul>
<li><strong>以太网</strong>（Ethernet）</li>
<li><strong>IEEE 802.11</strong>（无线局域网协议，即WiFi）</li>
<li><strong>PPP</strong>（点对点协议）</li>
<li><strong>ARP</strong>（地址解析协议），用于将网络层的地址（如IP地址）解析为数据链路层的地址（如MAC地址）</li>
<li><strong>流量控制</strong>：停止-等待协议、后退N帧协议（GBN）、选择重传协议（SR）</li>
<li><strong>ALOHA 协议</strong></li>
<li><strong>CSMA</strong>、<strong>CSMA/CD</strong>、<strong>CSMA/CA</strong></li>
</ul>
<br>
<p><strong>3. 网络层</strong></p>
<p>网络层负责在不同网络之间传输数据包，这包括数据包的路由选择和转发。主要的协议包括：</p>
<ul>
<li><strong>IP</strong>（互联网协议），包括IPv4和IPv6</li>
<li><strong>ICMP</strong>（互联网控制消息协议），用于传递控制消息</li>
<li><strong>IGMP</strong>（互联网组管理协议），用于IP多播组成员管理</li>
<li><strong>路由协议</strong>，如RIP, OSPF, BGP等</li>
<li><strong>ARP 协议</strong></li>
<li><strong>DHCP 协议</strong></li>
</ul>
<br>
<p><strong>4. 传输层</strong></p>
<p>传输层负责提供主机之间的数据传输服务，对接收到的信息进行错误检查和重发控制。主要协议包括：</p>
<ul>
<li><strong>TCP</strong>（传输控制协议），提供面向连接的、可靠的数据传输服务</li>
<li><strong>UDP</strong>（用户数据报协议），提供无连接的、尽最大努力交付的数据传输服务</li>
</ul>
<br>
<p><strong>5. 应用层</strong></p>
<p>应用层负责处理特定的应用程序细节。这一层的协议直接为用户的应用程序（如Web浏览器、电子邮件客户端等）提供服务。主要的协议包括：</p>
<ul>
<li><strong>HTTP</strong>（超文本传输协议），用于Web浏览</li>
<li><strong>HTTPS</strong>（HTTP安全），即安全的HTTP</li>
<li><strong>FTP</strong>（文件传输协议）</li>
<li><strong>SMTP</strong>（简单邮件传输协议）</li>
<li><strong>DNS</strong>（域名系统）</li>
<li><strong>Telnet</strong>（远程登录协议）</li>
<li><strong>SSH</strong>（安全外壳协议）</li>
</ul>
</div></details>  
<ol start="15">
<li><strong>ARP 协议的工作原理</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>ARP（地址解析协议，Address Resolution Protocol）是网络层与数据链路层之间的一个桥梁，用于在本地网络（如以太网）中将网络层的逻辑地址（如IPv4地址）解析为数据链路层的物理地址（如MAC地址）。ARP是局域网中进行主机或路由器间通信所必需的，因为虽然数据包是通过IP地址发送的，但最终是通过物理媒介传输，而物理媒介依赖于MAC地址来确保数据能够到达正确的设备。</p>
<p><strong>ARP的工作原理</strong>：</p>
<ol>
<li><strong>ARP请求</strong>：
<ul>
<li>当主机需要发送数据包到同一局域网的另一台主机时，它首先检查自己的ARP缓存表，这个表中包含了IP地址到MAC地址的映射。</li>
<li>如果没有找到相应的MAC地址（即表中没有目标IP地址的条目），它将广播一个ARP请求包到局域网上的所有主机。ARP请求包包含发送者的IP和MAC地址，以及接收者的IP地址，但接收者的MAC地址字段被留空。</li>
</ul>
</li>
<li><strong>ARP应答</strong>：
<ul>
<li>局域网中的所有设备都会接收到这个ARP请求，但只有IP地址匹配请求中的目标IP地址的设备会回应一个ARP应答。</li>
<li>这个应答包含了目标设备的IP地址和相对应的MAC地址，这个应答是直接发送给发起ARP请求的主机的，不是广播。</li>
</ul>
</li>
<li><strong>更新ARP缓存</strong>：
<ul>
<li>发起ARP请求的主机收到ARP应答后，会更新其ARP缓存表，将新的IP地址与MAC地址映射添加到表中。这样，未来向同一IP地址发送数据时，可以直接从缓存表中查找MAC地址，无需再次发起ARP请求。</li>
<li>ARP缓存中的条目通常不会永久存储，它们会在一段时间后过期，以适应网络配置可能的变化。</li>
</ul>
</li>
</ol>
<p><br><br><br></p>
<p>ARP（地址解析协议）仅用于将本地网络（局域网）中的IP地址解析为相应的MAC地址。当需要与非局域网内的设备通信时，确实需要通过网关（通常是路由器）来进行。以下是这一过程的简化说明，以及如何递归进行路由选择的细节：</p>
<p><strong>步骤简述</strong></p>
<ol>
<li>
<p><strong>局域网内的ARP查询</strong>：</p>
<ul>
<li>当设备需要发送数据到另一个不在同一局域网内的IP地址时，它会首先检查该IP地址是否属于已配置的路由表中的任何子网。</li>
<li>发现目标IP不在任何已知子网后，设备将使用ARP查询本地配置的默认网关的MAC地址。</li>
</ul>
</li>
<li>
<p><strong>向网关发送数据</strong>：</p>
<ul>
<li>设备将数据包发送到获取的网关MAC地址。虽然这个数据包的最终目标IP地址不在局域网内，但通过将其首先发送到网关，网关将负责进一步的路由处理。</li>
</ul>
</li>
<li>
<p><strong>网关的路由决策</strong>：</p>
<ul>
<li>网关（路由器）接收到数据包后，检查其路由表以确定下一跳的最佳路径。如果网关知道如何到达目标网络，它将根据路由表中的信息转发数据包。</li>
<li>如果网关不知道如何直接到达目标网络，它会将数据包发送到另一个上游路由器，该路由器进一步决定如何向目标进发。</li>
</ul>
</li>
<li>
<p><strong>递归路由选择</strong>：</p>
<ul>
<li>此过程可能涉及多个路由器，每个路由器都根据自己的路由表作出路由决策，直至数据包到达目标网络。</li>
<li>在到达目标网络后，最终的目标路由器使用ARP确定目标设备的MAC地址，并将数据包直接发送到目标设备。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong></p>
<ul>
<li><strong>ARP的限制</strong>：ARP只在本地网络（局域网）中有效，它不能跨越路由器或其他网络设备用于非直接连接的网络。</li>
<li><strong>网关的作用</strong>：网关作为局域网与外部网络之间的桥梁，处理出局域网范围的所有IP通信请求。</li>
<li><strong>数据包的封装和转发</strong>：尽管数据包在进入路由器时被封装在以太网帧中，但每经过一个路由点，新的数据链路层封装就会根据那个点的物理网络环境被重新生成。</li>
</ul>
<p>总之，从一个网络到另一个网络的数据传输是一个复杂的过程，涉及多层网络协议和多个网络设备。每个设备和协议层都为确保数据能够有效地从源头到达目的地发挥着关键作用。</p>
</div></details>  
<ol start="16">
<li><strong>TCP 的主要特点是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</li>
<li>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP 提供全双工通信。 TCP 允许通信双方的应用进程在任何时候都能发送数据。 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。 “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串串的无结构的字节流</li>
</ol>
</div></details>  
<ol start="17">
<li><strong>UDP 的主要特点是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>UDP 是无连接的；</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参<br>
数）；</li>
<li>UDP 是面向报文的；</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ol>
</div></details>  
<ol start="18">
<li><strong>TCP 和 UDP 分别对应的常见应用层协议有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>1. TCP 对应的应用层协议</strong></p>
<ul>
<li>
<p><strong>FTP</strong>：定义了文件传输协议，使用 <strong>21</strong> 端口。常说某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。<br>
FTP使用端口21（命令）和20（数据）</p>
</li>
<li>
<p><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 <strong>23</strong> 端口打开，对外提供服务。</p>
</li>
<li>
<p><strong>SMTP</strong>：定义了简单邮件传送协议，现在很多邮件服器都用的是这个协议，用于发送邮件。如常⻅见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 <strong>25</strong> 号端口。</p>
</li>
<li>
<p><strong>POP3</strong>：它是和 SMTP 对应， POP3 用于接收邮件。通常情况下， POP3 协议所用的是 <strong>110</strong> 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。</p>
</li>
<li>
<p><strong>HTTP</strong>：从 Web 服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP使用端口<strong>80</strong>；HTTPS使用端口<strong>443</strong></p>
</li>
</ul>
<br>
<p><strong>2. UDP 对应的应用层协议</strong></p>
<ul>
<li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为 IP 地址。 DNS 用的是 <strong>53</strong> 号端口。</li>
<li><strong>SNMP</strong>：简单网络管理协议，使用 <strong>161</strong> 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li><strong>TFTP</strong>(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 <strong>69</strong> 上使用 UDP 服务。</li>
</ul>
</div></details>  
<ol start="19">
<li><strong>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_20-41-21.png" alt="img"></p>
<p>1、为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。 B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后， A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样， B 就无法按照正常步骤进入 CLOSED 状态。</p>
<p>2、 防止已失效的连接请求报文段出现在本连接中。 A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL（因为TCP报文段的生存时间被假设为最多MSL），就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
<p><br><br></p>
<p><strong>MSL</strong>（Maximum Segment Lifetime）是TCP协议中定义的一个重要概念，它代表任何给定的TCP报文段在网络系统中被允许存在的最大时间。这个时间长度是用来确保TCP报文段在网络中不会无限期地存在，从而可能引起数据混乱或资源浪费。</p>
<ol>
<li><strong>报文段过期机制</strong>：
<ul>
<li>MSL是一种安全和正确性机制，用于限定数据包在网络中存在的时长。超过这段时间后，报文段应被认为是过时的，并应被丢弃，不再传输或处理。这样可以避免长时间滞留在网络设备中的“幽灵”数据包对新的或现有连接造成干扰。</li>
</ul>
</li>
<li><strong>防止数据混淆</strong>：
<ul>
<li>在某些网络条件下，如网络拥堵或路由器错误配置，报文段可能会异常延迟到达目的地。MSL确保这些延迟的报文段在一定时间后失效，减少了它们错误解释为其他连接的有效数据的机会。</li>
</ul>
</li>
<li><strong>连接的可靠关闭</strong>：
<ul>
<li>在TCP连接的终止阶段，保持一个2MSL的等待时间（即TIME-WAIT状态持续时间）确保了连接双方都可以接收到对方的最终ACK确认，同时确保所有在途中的报文段都会在新的连接建立之前从网络中消失。</li>
</ul>
</li>
</ol>
</div></details>  
<ol start="20">
<li><strong>保活计时器的作用？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>除时间等待计时器外， TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
</div></details>  
<ol start="21">
<li><strong>TCP 协议是如何保证可靠传输的？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。 TCP 将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间。 TCP 的接收端只允许一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。 TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ol>
</div></details>  
<ol start="22">
<li><strong>谈谈你对停止等待协议的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。</p>
</div></details>  
<ol start="23">
<li>
<p><strong>谈谈你对 ARQ 协议的理解？</strong></p>
</li>
<li>
<p><strong>谈谈你对滑动窗口的了解？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
</div></details>  
<ol start="25">
<li><strong>谈下你对流量控制的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
</div></details>  
<ol start="26">
<li><strong>谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。</p>
<p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制， TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。<u>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</u>。</p>
<p>TCP 的拥塞控制采用了四种算法，即：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略略（如：主动队列管理 AQM），以减少网络拥塞的发生。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_22-07-18.png" alt="img"></p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_22-07-29.png" alt="img"></p>
<ul>
<li>
<p><strong>慢开始</strong>：<br>
慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。 cwnd 初始值为 1，每经过一个传播轮次， cwnd 加倍。</p>
</li>
<li>
<p><strong>拥塞避免</strong>：<br>
拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p>
</li>
<li>
<p><strong>快重传与快恢复</strong>：<br>
在 TCP/IP 中，快速重传和快恢复（Fast Retransmit and Recovery， FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了， TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p>
<p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
</li>
</ul>
</div></details>  
<ol start="27">
<li>
<p><strong>什么是粘包？</strong></p>
</li>
<li>
<p><strong>TCP 黏包是怎么产生的？</strong></p>
</li>
<li>
<p><strong>怎么解决拆包和粘包？</strong></p>
</li>
<li>
<p><strong>forward 和 redirect 的区别？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>
</div></details>  
<ol start="31">
<li><strong>HTTP 方法有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>客户端发送的 请求报便 第一行为请求行，包含了方法字段。</p>
<ol>
<li><strong>GET</strong>：获取资源，当前网络中绝大部分使用的都是 GET；</li>
<li><strong>HEAD</strong>：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</li>
<li><strong>POST</strong>：传输实体主体</li>
<li><strong>PUT</strong>：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</li>
<li><strong>PATCH</strong>：对资源进行部分修改。 PUT 也可以用于修改资源，但是只能完全替代原始资源， PATCH 允许部分修改。</li>
<li><strong>OPTIONS</strong>：查询指定的 URL 支持的方法；</li>
<li><strong>CONNECT</strong>：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</li>
<li><strong>TRACE</strong>：追踪路路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</li>
</ol>
</div></details>  
<ol start="32">
<li><strong>在浏览器中输入 URL 地址到显示主页的过程？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>在浏览器中输入URL地址到显示主页的过程涉及多个步骤，包括网络、应用层协议、服务器处理和浏览器渲染等多个复杂环节。这里详细介绍这一过程：</p>
<p><strong>1. URL解析</strong></p>
<ul>
<li>当你在浏览器地址栏输入URL并按下回车，浏览器首先解析URL，确定它指向的是哪个服务器以及需要请求的资源。URL通常包括协议（如HTTP或HTTPS）、服务器地址（域名）和资源路径。</li>
</ul>
<p><strong>2. 域名解析（DNS查找）</strong></p>
<ul>
<li>如果URL包含的是域名（如 <code>www.example.com</code>），浏览器需要将该域名转换为服务器的IP地址。这一步通过查询域名系统（DNS）完成。浏览器首先检查本地缓存是否有这个域名的记录，如果没有，它会向配置的DNS服务器发送请求，解析出对应的IP地址。</li>
</ul>
<p><strong>3. 建立连接</strong></p>
<ul>
<li>获取到IP地址后，浏览器会发起到服务器的网络连接。对于HTTP协议，这意味着建立一个TCP连接；对于HTTPS，则还需要进行TLS握手过程，以确保连接的安全。</li>
</ul>
<p><strong>4. 发送HTTP请求</strong></p>
<ul>
<li>一旦TCP连接建立（和TLS握手完成，如果是HTTPS），浏览器就会通过这个连接发送一个HTTP请求。这个请求包括请求行（如 <code>GET /index.html HTTP/1.1</code>），请求头部和可能的请求体。</li>
</ul>
<p><strong>5. 服务器处理请求</strong></p>
<ul>
<li>服务器接收到HTTP请求后，会根据请求的资源路径处理请求。这可能包括在服务器上查找请求的文件，执行服务器端脚本，或者查询数据库等操作。</li>
</ul>
<p><strong>6. 发送HTTP响应</strong></p>
<ul>
<li>服务器处理完请求后，会向浏览器回送一个HTTP响应。响应通常包括一个状态码（如200表示成功），响应头部和响应体（即实际的资源内容，如HTML文档）。</li>
</ul>
<p><strong>7. 浏览器处理响应</strong></p>
<ul>
<li>浏览器接收到HTTP响应后，会开始解析响应体中的HTML文档。它会解析HTML结构，加载文档中引用的CSS样式文件、图像和JavaScript文件。</li>
</ul>
<p><strong>8. 页面渲染</strong></p>
<ul>
<li>HTML和CSS被解析后，浏览器会构建DOM树和CSSOM树，并将它们合并成渲染树。然后浏览器会进行布局（layout）过程，计算每个节点的准确位置和大小。最后，浏览器会绘制（paint）页面，将内容呈现在屏幕上。</li>
</ul>
<p><strong>9. 用户交互</strong></p>
<ul>
<li>一旦页面渲染完成，用户便可以与页面进行交互，如点击链接、填写表单等。JavaScript可以用来处理用户事件，提供动态的交互功能。</li>
</ul>
<p>这个过程涵盖了从用户输入URL到页面展现的全过程，涉及网络通信、服务器处理和浏览器渲染等多个层面，每一步都至关重要，共同确保了Web浏览的顺利进行。</p>
</div></details>  
<ol start="33">
<li><strong>DNS 的解析过程？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>DNS（域名系统）解析是互联网上将域名转换为对应IP地址的过程。这个过程涉及多个服务器和几个步骤，确保当你输入一个如 <code>www.example.com</code> 的网址时，你的计算机能够找到托管该网站的服务器的IP地址。下面详细介绍DNS解析的步骤：</p>
<p><strong>1. 浏览器缓存</strong></p>
<ul>
<li><strong>首先检查</strong>：当用户在浏览器中输入一个URL并开始加载网页时，浏览器首先检查自己的缓存中是否有这个域名的DNS记录，并检查这条记录是否仍然有效（未过期）。</li>
</ul>
<p><strong>2. 操作系统缓存</strong></p>
<ul>
<li><strong>系统级检查</strong>：如果浏览器缓存中没有找到DNS记录，接下来会检查操作系统的DNS缓存。操作系统也可能缓存了之前查询过的DNS解析结果。</li>
</ul>
<p><strong>3. 路由器缓存</strong></p>
<ul>
<li><strong>网络设备缓存</strong>：如果前两级缓存都没有找到，查询请求会被发送到本地网络中的路由器，很多路由器也会缓存DNS查询结果。</li>
</ul>
<p><strong>4. ISP DNS服务器</strong></p>
<ul>
<li><strong>ISP查询</strong>：如果以上都未能解析，则查询会发送到ISP（互联网服务提供商）的DNS服务器。ISP的DNS服务器通常会有较广泛的域名解析记录。</li>
</ul>
<p><strong>5. 根域名服务器</strong></p>
<ul>
<li><strong>根服务器查询</strong>：如果ISP的DNS服务器也无法解析该域名，它会查询根域名服务器。互联网有13组根域名服务器，它们是DNS层级的最顶端。根服务器不直接解析域名，而是指向负责该顶级域（<a target="_blank" rel="noopener" href="http://xn--bvs.com">如.com</a>、.net）的顶级域名（TLD）服务器。</li>
</ul>
<p><strong>6. 顶级域名服务器</strong></p>
<ul>
<li><strong>TLD服务器查询</strong>：TLD服务器管理在其域内的域名信息，并可以提供存储域名记录的权威DNS服务器的地址。例如，对于<code>www.example.com</code>，TLD服务器是<code>.com</code>域的DNS服务器。</li>
</ul>
<p><strong>7. 权威DNS服务器</strong></p>
<ul>
<li><strong>权威查询</strong>：最后，查询会发送到权威DNS服务器，这些服务器存储了特定域名的具体DNS记录（如A记录，即IP地址）。如果权威DNS服务器有缓存的记录，它将返回域名对应的IP地址。</li>
</ul>
<p><strong>8. 缓存结果</strong></p>
<ul>
<li><strong>记录缓存</strong>：得到IP地址后，此地址会被沿途的每个DNS服务器缓存（包括ISP的服务器、路由器以及本地系统），以便快速响应未来对同一域名的查询请求。每条DNS记录都有一个TTL（生存时间），决定了该记录在缓存中的存活时间。</li>
</ul>
<p><strong>9. 完成解析</strong></p>
<ul>
<li><strong>使用IP地址</strong>：一旦IP地址被确定并返回给原始请求者（如你的浏览器），浏览器就会使用这个IP地址来建立连接并获取网站内容。</li>
</ul>
<p>DNS解析过程是一个涉及多级网络结构和服务器的分布式查询过程，设计目的是为了确保域名能够被有效、可靠地解析成IP地址，从而使互联网上的资源可以被访问。</p>
<p><br><br></p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/cn/Snipaste_2023-02-02_23-23-57.png" alt="img"></p>
<ol>
<li>
<p>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p>
</li>
<li>
<p>本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器： “你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p>
</li>
</ol>
</div></details>  
<ol start="34">
<li><strong>谈谈你对域名缓存的了解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>域名缓存是一个关键的机制，它在多个层面上帮助优化和加速DNS（域名系统）查询过程。这种缓存策略不仅减少了对根服务器和权威DNS服务器的负担，也显著提升了用户访问网络资源的速度。下面我会详细解释域名缓存的作用、存储位置以及它如何工作。</p>
<p><strong>作用与优势</strong></p>
<ol>
<li>
<p><strong>减少DNS查询时间</strong>：</p>
<ul>
<li>通过存储先前查询的结果，DNS解析过程可以迅速完成，避免了多次通过网络进行远程查询的延迟。</li>
</ul>
</li>
<li>
<p><strong>减轻DNS服务器负载</strong>：</p>
<ul>
<li>缓存减少了对远端DNS服务器的请求次数，有助于分散网络流量，减轻中心DNS服务器的负担。</li>
</ul>
</li>
<li>
<p><strong>增强网络鲁棒性</strong>：</p>
<ul>
<li>在域名解析服务不可用或网络连接受限时，缓存可以使得本地系统仍然能够解析域名。</li>
</ul>
</li>
</ol>
<p><strong>缓存位置</strong></p>
<ol>
<li>
<p><strong>浏览器缓存</strong>：</p>
<ul>
<li>现代浏览器会在本地缓存DNS记录一段时间。这意味着如果你访问过某个网站，再次访问时，浏览器可能无需进行DNS查询就能解析其域名。</li>
</ul>
</li>
<li>
<p><strong>操作系统缓存</strong>：</p>
<ul>
<li>大部分操作系统（如Windows, macOS, Linux）也会在系统级别缓存DNS信息。这对所有使用该操作系统的应用程序都是透明的。</li>
</ul>
</li>
<li>
<p><strong>路由器缓存</strong>：</p>
<ul>
<li>许多家庭和企业路由器也会进行DNS缓存，作为网络中所有设备的共享资源。</li>
</ul>
</li>
<li>
<p><strong>ISP DNS缓存</strong>：</p>
<ul>
<li>你的互联网服务提供商（ISP）也可能在其DNS服务器上缓存DNS查询结果，从而为同一地区内的用户提供快速的DNS解析服务。</li>
</ul>
</li>
<li>
<p><strong>内容分发网络（CDN）DNS缓存</strong>：</p>
<ul>
<li>专业的CDN服务，如Cloudflare或Akamai，也会在全球多个位置缓存DNS查询结果，以提高其客户网站的访问速度。</li>
</ul>
</li>
</ol>
<p><strong>缓存管理</strong></p>
<p>每条DNS记录在缓存中存储的时间由其TTL（Time To Live）值决定。TTL是一个时间长度，指示该记录可以保持有效的最长时间。当缓存中的记录过期后，会在下一次DNS查询时重新从权威服务器获取新的记录。</p>
<p><strong>缓存相关的问题</strong></p>
<ol>
<li>
<p><strong>缓存过期</strong>：</p>
<ul>
<li>如果域名记录发生变更（例如IP地址改变），缓存中的旧记录在TTL过期前仍被使用，可能导致访问错误或延迟。</li>
</ul>
</li>
<li>
<p><strong>缓存污染</strong>：</p>
<ul>
<li>如果攻击者成功将错误的DNS信息注入到缓存中，可能导致用户被重定向到恶意站点。这种类型的攻击称为DNS缓存投毒。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>域名缓存是DNS架构中非常重要的一部分，有效地加速了域名解析过程，改善了用户体验，同时减轻了网络和服务器的负担。然而，管理缓存以保证数据的及时性和准确性也是网络管理员和系统架构师的重要任务。正确的缓存策略和安全措施对维持网络的健康和安全至关重要。</p>
</div></details>  
<ol start="35">
<li>
<p><strong>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</strong></p>
</li>
<li>
<p><strong>HTTPS 的工作过程</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>HTTPS（超文本传输协议安全）是一种保护在互联网上传输的数据安全的协议，它在HTTP的基础上通过SSL/TLS协议提供数据加密、数据完整性验证和身份验证的功能。HTTPS的工作过程涉及以下几个关键步骤：</p>
<p><strong>1. 客户端发起HTTPS请求</strong></p>
<ul>
<li>当你在浏览器中输入一个以<code>https://</code>开始的URL时，浏览器解析这个URL，提取服务器的主机名，并在默认的HTTPS端口443上向服务器发起连接。</li>
</ul>
<p><strong>2. TLS握手</strong> （先进行TCP三次握手，后TLS握手）</p>
<ul>
<li>
<p><strong>客户端Hello</strong>：浏览器发送一个&quot;ClientHello&quot;消息到服务器。这个消息包括浏览器支持的TLS版本，支持的加密算法（密码套件），以及一个客户端生成的随机数。</p>
</li>
<li>
<p><strong>服务器Hello</strong>：服务器回应一个&quot;ServerHello&quot;消息，包含服务器选择使用的TLS版本，选择的加密方法和一个服务器生成的随机数。</p>
</li>
<li>
<p><strong>服务器证书</strong>：服务器发送其数字证书给客户端。此证书包含了服务器的公钥，证书颁发机构（CA）的签名等信息。</p>
</li>
<li>
<p><strong>密钥交换</strong>：根据协商的加密方法，客户端和服务器协商生成一个&quot;会话密钥&quot;。客户端可能会发送一个&quot;PreMaster Secret&quot;的加密版本，这个只有持有私钥的服务器才能解密。</p>
</li>
<li>
<p><strong>客户端和服务器完成</strong>：双方发送各自的&quot;Finished&quot;消息，这个消息是对之前消息的加密验证，用来确认握手过程没有被篡改。</p>
</li>
</ul>
<p><strong>3. 加密的数据传输</strong></p>
<ul>
<li>完成握手后，客户端和服务器开始通过对称加密算法使用会话密钥来加密在通信过程中传输的数据。这保证了传输的数据的机密性和完整性。</li>
</ul>
<p><strong>4. 数据传输结束</strong></p>
<ul>
<li>通信结束后，客户端和服务器会发送消息通知对方关闭连接，然后进行连接的安全关闭。</li>
</ul>
<p><strong>5. 连接状态</strong></p>
<ul>
<li>在连接关闭之后，客户端和服务器可以选择重新使用相同的会话密钥再次快速建立连接，或者丢弃会话密钥并生成新的密钥来重新开始一个新的TLS握手过程。</li>
</ul>
<p><strong>安全特性</strong></p>
<ul>
<li><strong>加密</strong>：确保数据在传输过程中不被监听。</li>
<li><strong>身份验证</strong>：通过证书和CA保证服务器（以及可选的客户端）的身份，防止身份伪装。</li>
<li><strong>数据完整性</strong>：保证数据在传输过程中不被篡改。</li>
</ul>
<p>HTTPS增加了数据传输的安全性，是现代互联网中保护隐私和安全的关键技术。对于所有传输敏感数据的网站，例如电子商务、在线银行或任何需要登录的服务，HTTPS都是必须的。</p>
</div></details>  
<ol start="37">
<li><strong>HTTP 和 HTTPS 的区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li><strong>费用</strong>： HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li>
<li><strong>资源消耗</strong>： HTTP 是超文本传输协议，信息是明文传输， HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</li>
<li><strong>端口不同</strong>： HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li>
<li><strong>安全性</strong>： HTTP 的连接很简单，是无状态的； HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</li>
</ol>
<p><br><br></p>
<p><strong>SSL</strong>（Secure Sockets Layer）是一种安全协议，设计用于为互联网通信提供安全性和数据完整性。SSL协议能够保证网络传输中的数据在两个系统（通常是服务器和客户端，如网页浏览器和服务器之间）之间的传输过程中加密，并且安全地认证通信双方的身份。</p>
</div></details>  
<ol start="38">
<li><strong>HTTPS 的优缺点？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>优点</strong>：</p>
<ol>
<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</li>
<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</li>
<li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；</li>
<li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名， IPv4 资源不可能支撑这个消耗；</li>
<li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的， SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间⼈人攻击一样可行</li>
</ol>
</div></details>  
<ol start="39">
<li>
<p><strong>什么是数字签名？</strong></p>
</li>
<li>
<p><strong>什么是数字证书？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>
</div></details>  
<ol start="41">
<li><strong>Cookie 和 Session 有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>
</div></details>  
<ol start="42">
<li><strong>字节</strong>：网络四层协议是什么</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看内容 </summary><div class="toggle-content"><p><img src="/static/imgs/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt=""></p>
<p><strong>TCP/IP</strong>：</p>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt="img"></p>
<p><strong>GPT4</strong>：</p>
<p>网络的四层协议，通常指的是TCP/IP模型，它将计算机网络体系结构分为四层，分别是应用层、传输层、互联网层和网络接口层。下面我会详细介绍每一层的功能和一些常见的协议：</p>
<ol>
<li>
<p><strong>应用层</strong>：这是用户和网络之间的接口层，提供网络服务给最终用户的应用程序。应用层直接为用户的应用程序（如电子邮件、文件传输和终端仿真）提供服务。常见的应用层协议包括：</p>
<ul>
<li><strong>HTTP</strong>（超文本传输协议）：用于万维网上的信息传输。</li>
<li><strong>FTP</strong>（文件传输协议）：用于在网络上进行文件传输。</li>
<li><strong>SMTP</strong>（简单邮件传输协议）：用于发送邮件。</li>
<li><strong>DNS</strong>（域名系统）：用于将域名转换为IP地址。</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：负责在网络中的两个端点（主机间或网络中的两个应用程序间）进行可靠的数据传输。传输层协议包括：</p>
<ul>
<li><strong>TCP</strong>（传输控制协议）：提供一种可靠的、面向连接的通信服务。它保证数据包按序到达，未收到的包会重新发送。</li>
<li><strong>UDP</strong>（用户数据报协议）：提供一种无连接的通信服务。相对于TCP，UDP简单、高效，但不保证数据包的顺序或可靠性。</li>
</ul>
</li>
<li>
<p><strong>互联网层</strong>：也称为网络层，负责在多个网络之间传输数据包。这一层封装数据，并在发送端选择路径以将数据传输到接收端。常见的互联网层协议包括：</p>
<ul>
<li><strong>IP</strong>（互联网协议）：负责将数据包从源主机发送到目标主机。IP协议定义了数据包的结构和网络寻址方式。</li>
<li><strong>ICMP</strong>（互联网控制消息协议）：用于发送错误消息和网络通信的控制消息。</li>
</ul>
</li>
<li>
<p><strong>网络接口层</strong>：也被称为链路层或数据链路层，它是网络架构中最低的一层，负责在相邻的网络节点（如两台计算机）间传输数据帧。这一层涵盖了物理和数据链路两个层次，负责物理地址寻址、数据的封装成帧、流量控制和错误检测。常用的技术和协议包括：</p>
<ul>
<li><strong>以太网</strong>（Ethernet）：最常见的局域网技术。</li>
<li><strong>ARP</strong>（地址解析协议）：用于将网络层的IP地址解析为链路层的地址。</li>
</ul>
</li>
</ol>
<p>TCP/IP模型是互联网的基础，其设计简洁高效，支持多种网络架构，使得不同类型的网络可以互联互通。</p>
</div></details>
<ol start="2">
<li><strong>快手一面</strong>：http协议的工作方式</li>
<li><strong>快手二面</strong>：https的工作方式</li>
</ol>
<hr>
<br>
<p><strong>一些名词</strong>：</p>
<ul>
<li><strong>ISP</strong>：Internet Service Provider的缩写，即因特网服务提供商</li>
</ul>
<hr>
<p><br><br><br></p>
<h2 id="操作系统">操作系统</h2>
<ol>
<li><strong>简单说下你对并发和并行的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ol>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；</li>
</ol>
</div></details>
<ol start="2">
<li><strong>同步、异步、阻塞、非阻塞的概念</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p><strong>同步 vs 异步</strong></p>
<p>这两个概念主要涉及调用操作的时间处理方式：</p>
<ul>
<li><strong>同步</strong>：在同步操作中，调用者发起一个操作请求并且必须等待直到操作完成才能继续执行。这种方式简单但可能导致效率问题，因为调用者在等待期间不能执行其他任务。</li>
<li><strong>异步</strong>：在异步操作中，调用者发起请求后可以立即继续执行其他任务。异步操作通常涉及回调、事件、或者是使用Future/Promise等机制，这些机制允许在操作完成时通知调用者，或者允许调用者在稍后某个时刻获取结果。</li>
</ul>
<p><strong>阻塞 vs 非阻塞</strong></p>
<p>这两个概念与程序在等待操作完成时的行为有关：</p>
<ul>
<li><strong>阻塞</strong>：在阻塞模式下，调用者请求操作（如I/O操作）时，如果响应不立即可用，当前线程将挂起，直到有结果可用为止。这种方式在编程模型上简单直接，但缺点是当前线程的计算资源在等待期间不能被其他任务利用。</li>
<li><strong>非阻塞</strong>：非阻塞操作允许调用者请求操作而不会挂起当前线程；如果结果不立即可用，调用会立即返回一个状态，表示操作尚未完成。非阻塞调用通常需要轮询、事件订阅或回调来处理结果。</li>
</ul>
<p><br><br></p>
<p><strong>1. 同步阻塞</strong></p>
<p>这是最传统也是最直观的方式。在这种模式下，一个操作发起后，调用者必须等待操作完成才能继续执行后续代码。这种方式的编程模型简单，但可能导致应用性能问题，因为在等待操作完成期间，执行线程被挂起，无法执行其他任务。</p>
<ul>
<li><strong>用途</strong>：适用于客户端应用或者后台服务中对性能要求不高的场景，例如简单的脚本或命令行工具。</li>
</ul>
<p><strong>2. 同步非阻塞</strong></p>
<p>同步非阻塞操作较少见，因为它通常需要轮询或检查操作状态以确定何时可以继续执行，这可能会导致CPU资源的浪费。</p>
<ul>
<li><strong>用途</strong>：某些特定的系统级编程可能会用到，其中调用者主动检查操作的完成状态而不是被动等待。</li>
</ul>
<p><strong>3. 异步阻塞</strong></p>
<p>这种组合实际上是不常见的，因为异步设计的核心目的是避免阻塞。然而，在某些特殊情况下，如使用特定的同步机制（例如等待某个事件或锁）来完成异步操作，可能会出现阻塞。</p>
<ul>
<li><strong>用途</strong>：特定的多线程设计模式中，如使用条件变量或事件等待机制。</li>
</ul>
<p><strong>4. 异步非阻塞</strong></p>
<p>这是现代应用中特别是在高性能服务器和实时系统中最理想的模式。在这种模式下，操作被发起后，调用者无需等待操作完成，可以立即继续执行其他任务。操作完成后，通过回调、事件、Promises 或 Futures等机制得到通知。</p>
<ul>
<li><strong>用途</strong>：适用于需要高并发处理的服务器应用程序，如Web服务器、数据库系统、网络服务等。这种模式可以极大地提高应用的吞吐量和响应能力。</li>
</ul>
</div></details>
<ol start="3">
<li><strong>进程和线程的基本概念</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>进程：进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位。</p>
<p>线程：线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有<br>
时又被称为轻权进程或轻量级进程。</p>
</div></details>
<ol start="4">
<li><strong>进程与线程的区别</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ol>
<li>
<p>进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；</p>
</li>
<li>
<p>创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；</p>
</li>
<li>
<p>不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；</p>
</li>
<li>
<p>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；</p>
</li>
</ol>
</div></details>
<ol start="5">
<li><strong>为什么有了进程，还要有线程呢？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：</p>
<ol>
<li>进程在同一时间只能干一件事情；</li>
<li>进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执<br>
行。</li>
</ol>
<p>基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时，所付出的时间和空间开销，提高并发性能</p>
</div></details>
<ol start="6">
<li><strong>进程的状态转换</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/os/Snipaste_2023-05-04_21-37-42.png" alt="img"></p>
</div></details>
<ol start="7">
<li><strong>进程间的通信方式有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>进程间通信（IPC, InterProcess Communication）是指在不同进程之间传播或交换信息。 IPC 的方式通常有管道<br>
（包括无名管道和命名管道）、消息队列、信号量、共享存储、 Socket、 Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。</p>
<p><strong>管道</strong></p>
<ol>
<li>它是<strong>半双工</strong>（全双工直接用两个管道来实现）的，具有固定的读端和写端；</li>
<li>它只能用于父子进程或者兄弟进程之间的进程的通信；</li>
<li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、 write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li>
</ol>
<p><strong>命名管道</strong></p>
<ol>
<li>FIFO 可以在无关的进程之间交换数据，与无名管道不同；</li>
<li>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
</ol>
<p><strong>消息队列</strong></p>
<ol>
<li>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；</li>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；</li>
<li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</li>
</ol>
<p><strong>信号量</strong></p>
<ol>
<li>信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；</li>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</li>
<li>支持信号量组。</li>
</ol>
<p><strong>共享内存</strong></p>
<ol>
<li>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；</li>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
</ol>
</div></details>
<ol start="8">
<li><strong>进程的调度算法有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>调度算法是指：根据系统的资源分配策略所规定的资源分配算法。常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等。</p>
<ul>
<li>
<p>先来先服务调度算法</p>
<p>先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。</p>
</li>
<li>
<p>时间片轮转调度算法</p>
<p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片。</p>
</li>
<li>
<p><strong>短作业优先调度算法</strong></p>
<p>短作业优先调度算法是指对短作业优先调度的算法，从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。 短作业优先调度算法一个非抢占策略略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。</p>
</li>
<li>
<p><strong>最短剩余时间优先调度算法</strong></p>
<p>最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p>
</li>
<li>
<p><strong>高响应比优先调度算法</strong></p>
<p>高响应比优先调度算法主要用于作业调度，该算法是对先来先服务调度算法和短作业优先调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
</li>
<li>
<p><strong>优先级调度算法</strong><br>
优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p>
</li>
<li>
<p><strong>多级反馈队列调度算法</strong></p>
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
</ul>
</li>
<li>
<p><strong>多级队列调度算法</strong>（<strong>快手问过</strong>）</p>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/os/Snipaste_2023-05-06_08-38-34.png" alt="img"></p>
<p>队列之间可采取固定优先级，或时间片划分<br>
固定优先级: 高优先级空时低优先级进程才能被调度<br>
时间片划分: 如三个队列分配时间50%、40%、10%</p>
</li>
</ul>
</div></details>
<ol start="9">
<li><strong>什么是死锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>死锁，是指多个进程在运行过程中因<strong>争夺资源</strong>而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/courses/os/GIF_2023-05-07_9-33-42.gif" alt="img"></p>
<p>每位哲学家都在等待自己右边的人放下筷 子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p>
</div></details>
<ol start="10">
<li><strong>产生死锁的原因？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。</p>
<ul>
<li><strong>竞争资源</strong><br>
例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。系统中的资源可以分为两类：
<ol>
<li>可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺， CPU 和主存均属于可剥夺性资源；</li>
<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ol>
</li>
<li><strong>进程推进顺序不当</strong><br>
例如：进程 A 和 进程 B 互相等待对方的数据。</li>
</ul>
</div></details>
<ol start="11">
<li><strong>死锁产生的必要条件？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ol>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待 这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ol>
<p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p>
</div></details>
<ol start="12">
<li><strong>解决死锁的基本方法？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ul>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ul>
</div></details>
<ol start="13">
<li><strong>怎么预防死锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ol>
<li><strong>破坏互斥条件</strong></li>
</ol>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。</p>
<ol start="2">
<li><strong>破坏不剥夺条件</strong></li>
</ol>
<p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<ol start="3">
<li><strong>破坏请求和保持条件</strong></li>
</ol>
<p>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源 了。</p>
<ol start="4">
<li><strong>破坏循环等待条件</strong></li>
</ol>
<p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源， 同类资源（即编号相同的资源）一次申请完。</p>
</div></details>
<ol start="14">
<li><strong>怎么避免死锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>银行家算法步骤：<br>
① 检查此次申请是否超过了之前声明的最大需求数<br>
② 检查此时系统剩余的可用资源是否还能满足这次请求<br>
③ 试探着分配，更改各数据结构<br>
④ 用安全性算法检查此次分配是否会导致系统进入不安全状态</p>
<p>安全性算法步骤：<br>
检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，<br>
并把该进程持有的资源全部回收。<br>
不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
</div></details>
<ol start="15">
<li><strong>怎么解除死锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>检测死锁：<strong>资源分配图</strong>，如果如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p>
<p>解除死锁：</p>
<ol>
<li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
</div></details>
<ol start="16">
<li><strong>什么是缓冲区溢出？有什么危害？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>缓冲区溢出（Buffer Overflow）是一种常见的安全漏洞，主要出现在使用低级编程语言如C或C++时。在这些语言中，程序员需要手动管理内存，包括定义存储数据的缓冲区大小。如果程序在处理输入时没有恰当地检查这些输入的长度，就可能发生缓冲区溢出。以下是对缓冲区溢出和它导致的危害的详细解释：</p>
<p><strong>缓冲区的作用</strong></p>
<p>缓冲区在计算机程序中通常用于临时存储数据，比如从一个应用程序传输到另一个应用程序的数据。例如，网络数据在被处理之前可能首先被存放在缓冲区中。</p>
<p><strong>缓冲区溢出的原理</strong></p>
<ol>
<li><strong>定义缓冲区</strong>：程序定义一个固定大小的缓冲区来存储例如用户输入的数据。</li>
<li><strong>超出容量</strong>：如果输入的数据超过了缓冲区预设的大小，超出的部分将会继续写入相邻的内存地址。</li>
<li><strong>覆盖内存</strong>：这种超出部分的数据可以覆盖缓冲区附近的其他重要的内存数据，包括程序的控制信息。</li>
</ol>
<p><strong>导致的危害</strong></p>
<ol>
<li><strong>程序崩溃和拒绝服务</strong>：如果被覆盖的数据包括程序执行的关键控制数据（例如返回地址），这可能导致程序行为异常、崩溃或停止响应，从而导致服务不可用或拒绝服务攻击（DoS）。</li>
<li><strong>恶意代码执行</strong>：
<ul>
<li><strong>控制流篡改</strong>：攻击者可以故意使输入数据的溢出部分包含特定的值，用来覆盖程序内存中的执行流程控制数据（如返回地址），使程序跳转到攻击者控制的代码段。</li>
<li><strong>恶意代码载入</strong>：进一步地，攻击者可能将恶意代码嵌入输入数据中，通过控制程序执行流使程序执行这些恶意代码。</li>
</ul>
</li>
</ol>
<p><strong>防御措施</strong></p>
<ol>
<li><strong>输入验证</strong>：确保所有输入都经过验证，不超过预定的缓冲区大小。</li>
<li><strong>边界检查</strong>：程序中对所有缓冲区操作添加边界检查逻辑，防止数据写入超过缓冲区的部分。</li>
<li><strong>使用安全函数</strong>：在可能的情况下，使用如<code>strncpy()</code>代替<code>strcpy()</code>等安全函数，这些函数可以限制写入缓冲区的数据量。</li>
<li><strong>编译器保护</strong>：利用现代编译器提供的安全增强功能，如堆栈保护、地址空间布局随机化（ASLR）和非执行页（NX），来增加攻击的难度。</li>
<li><strong>代码审计和工具</strong>：对源代码进行安全审计，并使用静态和动态分析工具检测潜在的缓冲区溢出问题。</li>
</ol>
<p>理解缓冲区溢出的工作原理和它的危害，对于开发安全的应用程序是至关重要的。这不仅涉及编写安全的代码，还涉及设计整个系统的安全架构。</p>
</div></details>
<ol start="17">
<li><strong>分页与分段的区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ol>
</div></details>
<ol start="18">
<li><strong>物理地址、逻辑地址、虚拟内存的概念</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><ol>
<li><strong>物理地址</strong>：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存<br>
取，是内存单元真正的地址。</li>
<li><strong>逻辑地址</strong>：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻<br>
辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的<br>
地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址<br>
（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</li>
<li><strong>虚拟内存</strong>：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整<br>
的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在<br>
需要时进行数据交换。</li>
</ol>
</div></details>
<ol start="19">
<li><strong>页面置换算法有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会<br>
调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。</p>
<p>常用的页面置换算法如下：</p>
<ul>
<li><strong>先进先出置换算法</strong>（FIFO）<br>
先进先出，即淘汰最早调入的页面。</li>
<li><strong>最佳置换算法</strong>（OPT）<br>
选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</li>
<li><strong>最近最久未使用</strong>（LRU）算法<br>
即选择最近最久未使用的⻚页面予以淘汰</li>
<li><strong>时钟（Clock）置换算法</strong>（Clock）<br>
时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。</li>
</ul>
</div></details>
<ol start="20">
<li><strong>谈谈你对动态链接库和静态链接库的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>在软件开发中，动态链接库（Dynamic Link Libraries, DLLs）和静态链接库（Static Libraries）是两种常用的代码库实现方式，它们分别代表不同的编译和链接策略。了解它们的区别对于优化应用程序的性能、内存使用和分发策略至关重要。</p>
<p><strong>静态链接库（Static Libraries）</strong></p>
<p>静态链接库通常是以<code>.lib</code>（在Windows中）或<code>.a</code>（在Unix-like系统中）文件的形式存在。它们包含了可以直接集成到应用程序中的预编译代码。</p>
<ul>
<li><strong>链接方式</strong>：在编译阶段，静态库中的代码被完整地复制到最终的可执行文件中。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>简单性</strong>：因为所有需要的代码都包含在单个可执行文件中，所以部署和分发应用程序相对简单。</li>
<li><strong>独立性</strong>：应用程序不依赖于外部库文件，运行时不需要额外的库。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>文件大小</strong>：静态链接可以增加最终可执行文件的大小，因为每个程序都包含了它所需的整个库的副本。</li>
<li><strong>更新问题</strong>：如果库更新，整个应用程序需要重新编译和发布。</li>
</ul>
</li>
</ul>
<p><strong>动态链接库（Dynamic Link Libraries）</strong></p>
<p>动态链接库在Windows系统中通常以<code>.dll</code>文件形式存在，在Unix-like系统中则为<code>.so</code>（共享对象）文件。它们在运行时被加载到内存中，多个程序可以共享同一份物理内存中的库代码。</p>
<ul>
<li><strong>链接方式</strong>：动态库在程序运行时被加载，程序只包含需要链接和使用这些库的引用。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>内存效率</strong>：多个运行中的应用程序可以共享同一份动态库的单一物理副本，减少了内存占用。</li>
<li><strong>易于更新</strong>：更新库文件后，不需要重新编译使用该库的应用程序，可以简化维护和更新过程。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>依赖性</strong>：程序依赖于外部的.dll或.so文件，缺失或兼容性问题可能导致程序无法运行。</li>
<li><strong>启动时间</strong>：加载动态库可能会稍微延长程序的启动时间。</li>
<li><strong>版本冲突</strong>：可能会遇到“地狱依赖”问题，即不同的应用程序需要不同版本的同一动态库。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>选择静态链接库还是动态链接库，取决于具体的应用需求和分发策略。静态库适合那些需要简单部署、独立运行的小型应用程序。动态库则适合那些内存使用效率至关重要，或者需要频繁更新库文件而不重新部署整个应用程序的情况。在设计大型应用或系统时，合理地选择链接类型对于性能优化和资源管理非常关键。</p>
</div></details>
<ol start="21">
<li><strong>外中断和异常有什么区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p><strong>外中断</strong>是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而<strong>异常</strong>时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
</div></details>
<ol start="22">
<li><strong>一个程序从开始运行到结束的完整过程，你能说出来多少？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>四个过程：</p>
<p><strong>（1）预编译</strong></p>
<p>要处理源代码文件中的以“#”开头的预编译指令。处理规则见下<br>
1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、 “#endif”、 “#ifdef”、 “#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他“#include”。</p>
<p>4、删除所有的注释， “//”和“/**/”。</p>
<p>5、保留所有的#pragma编译器指令，编译器需要用到他们，如： #pragma once 是为了防止有硬件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p><strong>（2）编译</strong></p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一<br>
种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p><strong>（3）汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、 xxx.obj(Windows下)。</p>
<p><strong>（4）链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接： 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器<br>
从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2、动态链接： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一<br>
起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
</div></details>
<ol start="23">
<li><strong>介绍一下几种典型的锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>在操作系统中，锁是一种同步机制，用于控制多个进程或线程对共享资源（如数据结构、文件、设备等）的访问。锁的基本目的是确保在任何时刻，只有一个线程或进程可以访问临界区（即需要互斥访问的代码段）。这有助于防止数据竞争和保证数据一致性。</p>
<p><strong>锁的基本类型和作用：</strong></p>
<ol>
<li>
<p><strong>互斥锁（Mutexes）</strong></p>
<ul>
<li>互斥锁保证同一时间内只有一个线程可以访问某个特定的资源或代码块。它是最基本的锁类型，用于实现线程或进程的互斥（mutual exclusion）。</li>
<li>当一个线程获得互斥锁并进入临界区时，其他试图进入该临界区的线程将被阻塞，直到锁被释放。</li>
</ul>
</li>
<li>
<p><strong>读写锁（Read-Write Locks）</strong></p>
<ul>
<li>读写锁允许多个读操作同时进行，但在写操作执行时，它会阻止任何其他的读或写操作。这种锁适用于读多写少的情况，可以提高并发性。</li>
<li>读写锁可以提升性能，因为它允许多个线程同时读取数据，只在写入数据时才需要排他访问。</li>
</ul>
</li>
<li>
<p><strong>自旋锁（Spinlocks）</strong></p>
<ul>
<li>自旋锁是一种忙等锁，当线程尝试获得锁而锁已被占用时，线程会在一个循环中不断检查锁的状态。这种锁不会使线程进入睡眠状态，因此在等待锁的时间非常短的情况下是有效的。</li>
<li>自旋锁适用于锁持有时间极短的情况，因为它避免了线程从运行态到等待态的转换开销。</li>
</ul>
</li>
<li>
<p><strong>信号量（Semaphores）</strong></p>
<ul>
<li>信号量是一种更灵活的同步工具，可以看作是可用资源的计数器。信号量通常用于控制对一组相同资源的访问。</li>
<li>信号量主要用于实现资源的计数限制，它允许多个线程或进程根据可用资源数量并发访问资源。</li>
</ul>
</li>
</ol>
<p><strong>锁的应用</strong></p>
<p>锁在操作系统的许多领域都有应用，包括：</p>
<ul>
<li><strong>文件系统</strong>：防止多个进程同时写入同一文件。</li>
<li><strong>数据库管理</strong>：保证事务的原子性和一致性。</li>
<li><strong>网络通信</strong>：确保消息的有序处理。</li>
<li><strong>内存管理</strong>：保护对共享内存的访问。</li>
</ul>
<p><strong>锁的挑战</strong></p>
<p>尽管锁是并发控制的基本工具，但它们也引入了一些挑战，例如：</p>
<ul>
<li><strong>死锁</strong>：多个进程或线程互相等待对方持有的锁，导致所有进程都无法向前执行。</li>
<li><strong>活锁</strong>：进程或线程不断改变状态，尝试获取锁，但无一成功，导致系统性能下降。</li>
<li><strong>饥饿</strong>：一个或多个线程由于竞争条件长时间无法获得所需的锁。</li>
</ul>
<p>有效的锁策略需要仔细设计，以优化性能并避免死锁、活锁和饥饿等问题。选择正确的锁类型和策略对于建立高效、稳定和可靠的系统至关重要。</p>
</div></details>
<ol start="24">
<li><strong>什么是用户态和内核态</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>用户态和内核态是操作系统的两种运行状态。</p>
<ul>
<li><strong>内核态</strong> ：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之<br>
为内核态。</li>
<li><strong>用户态</strong> ：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独<br>
占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<p>那么为什么要有用户态和内核态呢？<br>
这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>
</div></details>
<ol start="25">
<li><strong>用户态和内核态是如何切换的？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -&gt; 内核态 -&gt; 用户态，而唯一能够做这些操作的只有系统调用 ，而能够执行系统调用的就只有操作系统 。</p>
<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction) 。</p>
<p>他们的工作流程如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-15_16-28-12.png" alt=""></p>
<ol>
<li>
<p>首先用户程序会调用 glibc 库， glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</p>
<p>glibc 库知道针对不同体系结构调用 系统调用 的正确方法，它会根据体系结构应用程序的二进制接口设置用户<br>
进程传递的参数，来准备系统调用。</p>
</li>
<li>
<p>然后， glibc 库调用 软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳<br>
转到地址 0x08 处。</p>
</li>
<li>
<p>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码， MMU 现在允许内核<br>
虚拟内存访问</p>
</li>
<li>
<p>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi() 。</p>
</li>
<li>
<p>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。</p>
</li>
<li>
<p>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</p>
</li>
</ol>
</div></details>
<ol start="26">
<li><strong>进程终止的方式</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>在操作系统中，进程终止是正常运行周期的一部分，或是由于异常情况而导致的结束。进程可以通过多种方式终止，这些方式可以归纳为以下几类：</p>
<p><strong>1. 正常退出</strong></p>
<ul>
<li><strong>自主终止</strong>：进程执行完毕程序中的所有指令后，通过执行退出系统调用（如C语言中的<code>exit()</code>函数）正常终止。在这种情况下，进程通常会返回一个状态码给其父进程，指示程序的结束状态。</li>
</ul>
<p><strong>2. 错误退出</strong></p>
<ul>
<li><strong>运行时错误</strong>：如果进程在执行过程中遇到无法恢复的错误（例如除零错误、访问违规等），它可能会导致进程异常终止。这种终止通常由操作系统强制执行，进程也可能返回一个错误码。</li>
</ul>
<p><strong>3. 异常终止</strong></p>
<ul>
<li><strong>信号/中断</strong>：进程可以由于接收到一个信号（如UNIX/Linux系统中的SIGKILL, SIGTERM等）而终止。信号可以由其他进程发出，用于指示一个进程应该终止。例如，操作系统命令行中的<code>kill</code>命令常用于发送终止信号给进程。</li>
</ul>
<p><strong>4. 被其他进程终止</strong></p>
<ul>
<li><strong>父进程请求</strong>：在某些系统中，一个父进程可以请求操作系统终止其一个或多个子进程。这可能是因为父进程正在关闭，且不希望其子进程继续运行。</li>
</ul>
<p><strong>5. 资源耗尽</strong></p>
<ul>
<li><strong>资源限制</strong>：操作系统可能因为系统资源耗尽（如内存不足）而终止一些进程。这是系统尝试释放资源，防止更多的系统级问题发生的一种方式。</li>
</ul>
<p><strong>6. 关机</strong></p>
<ul>
<li><strong>系统关闭</strong>：当操作系统关闭或重启时，所有进程都将被终止。操作系统通常会向运行中的进程发送终止信号，允许它们有序地关闭。</li>
</ul>
<p><strong>7. 死锁恢复</strong></p>
<ul>
<li><strong>死锁终止</strong>：在检测到死锁的情况下，操作系统可能会选择终止一个或多个进程来解锁死锁状态。这通常是最后的手段，当其他死锁恢复策略（如资源抢占）无效时采用。</li>
</ul>
<p><strong>8. 监控或安全</strong></p>
<ul>
<li><strong>安全策略执行</strong>：安全监控软件或操作系统可能因为检测到进程的异常行为（如疑似病毒活动或违反安全策略的行为）而终止进程。</li>
</ul>
<p>每种终止方式都有其特定的用途和背景，了解它们对于系统管理员、操作系统开发者以及应用程序开发者都非常重要，可以帮助他们设计更健壮、安全且可靠的软件系统。</p>
</div></details>
<ol start="27">
<li><strong>守护进程、僵尸进程和孤儿进程</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>在操作系统中，特别是在类 Unix 系统中，守护进程、僵尸进程和孤儿进程是三种特殊类型的进程，它们具有特定的行为和特征。这些进程的管理对于系统的健康运行至关重要。下面是对这些进程类型的详细解释：</p>
<p><strong>1. 守护进程（Daemon Process）</strong></p>
<p>守护进程是在后台运行的进程，它们不与任何终端设备关联，主要用于处理系统级任务，如日志记录、系统监控、调度等。守护进程通常在系统启动时启动，并持续运行直到系统关闭。</p>
<ul>
<li><strong>特征</strong>：守护进程没有控制终端，它们的父进程通常是 init 进程（进程号为1的进程），这使它们在用户退出系统时继续运行。</li>
<li><strong>目的</strong>：提供或支持一些后台服务，通常不直接与用户交互。</li>
</ul>
<br>
<p><strong>2. 僵尸进程（Zombie Process）</strong></p>
<p>僵尸进程是已经完成执行并退出的进程，但其在操作系统进程表中的一个记录仍然存在。这种情况发生在子进程已经结束，但其父进程尚未通过调用 <code>wait()</code> 系统调用来读取子进程的退出状态。</p>
<ul>
<li><strong>特征</strong>：僵尸进程不占用除进程表外的任何资源，它们不执行任何代码，但在进程表中占有一个位置，直到被父进程清理。</li>
<li><strong>问题</strong>：如果父进程永远不调用 <code>wait()</code>，僵尸进程将一直存在，可能导致进程表资源耗尽。</li>
</ul>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进<br>
程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵⼫尸状态）。</p>
<br>
<p><strong>3. 孤儿进程（Orphan Process）</strong></p>
<p>孤儿进程是指父进程结束或异常退出，而其子进程仍在运行的那些进程。这些子进程的父进程不再存在，因此它们被 init 进程（或其他特殊进程，如systemd）收养。</p>
<ul>
<li><strong>特征</strong>：孤儿进程由 init 进程接管，init 进程将定期调用 <code>wait()</code> 来清理任何已结束的孤儿子进程，确保不会留下僵尸进程。</li>
<li><strong>目的</strong>：避免在父进程终止后留下未管理的运行进程，保证系统的稳定和清洁。</li>
</ul>
<p><strong>系统的影响和管理</strong></p>
<ul>
<li><strong>守护进程</strong>是有益的，通常是系统设计的一部分，需要适当监控和维护。</li>
<li><strong>僵尸进程</strong>和<strong>孤儿进程</strong>可能是资源管理不当的标志。系统管理员需要确保这些进程被适当处理，避免资源浪费和潜在的系统不稳定。</li>
</ul>
<p>了解这些进程类型及其对系统的影响可以帮助开发者和系统管理员优化程序行为，预防潜在的问题，并维护操作系统的性能和稳定性。</p>
</div></details>
<ol start="28">
<li><strong>如何避免僵尸进程？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p><strong>1. 父进程调用 <code>wait()</code> 或 <code>waitpid()</code></strong></p>
<p>父进程可以通过调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来阻塞自身，直到一个或多个子进程结束。这样父进程可以获取子进程的终止状态，同时操作系统会清理掉子进程，防止它成为僵尸进程。</p>
<p><strong>2. 使用信号处理 <code>SIGCHLD</code></strong></p>
<p>当子进程结束时，父进程会收到 <code>SIGCHLD</code> 信号。父进程可以设定一个信号处理器来自动处理这个信号，通常处理器会调用 <code>wait()</code> 来清理终止的子进程，从而防止产生僵尸进程。</p>
<p><strong>3. 忽略 <code>SIGCHLD</code> 信号</strong></p>
<p>简单地忽略 <code>SIGCHLD</code> 信号也是一个选项。在某些系统中，如果 <code>SIGCHLD</code> 信号被设置为忽略，子进程结束时将不会变成僵尸进程；操作系统会自动回收它们。但这种方式可能不适合需要从子进程获取退出状态的应用。</p>
<p><strong>4. 双重 <code>fork()</code> 方法</strong></p>
<p>这种方法涉及父进程首先 <code>fork()</code> 一个子进程，该子进程随即 <code>fork()</code> 一个孙进程然后立即退出。这样一来，孙进程成为了孤儿进程，通常会被系统的 init 进程收养，init 进程将负责清理孙进程，防止其成为僵尸进程。这种方法尤其适用于守护进程的创建。</p>
<p><strong>5. 定期清理</strong></p>
<p>在一些长时间运行的父进程中，可以定期执行 <code>wait()</code> 调用（不必阻塞等待特定子进程终止），以清理所有已终止的子进程，这种方式有助于管理和回收任何潜在的僵尸进程。</p>
<p>这些策略每种都有其适用场景，选择哪一种取决于具体的应用需求和系统环境。通过有效管理子进程的生命周期，可以确保系统的健康运行和资源的高效使用。</p>
</div></details>
<ol start="29">
<li><strong>常见的内存分配内存错误</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p><strong>（1）内存分配未成功，却使用了它</strong>。</p>
<p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p>
<p><strong>（2）内存分配虽然成功，但是尚未初始化就引用它</strong>。</p>
<p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>
<p><strong>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</strong></p>
<p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
<p><strong>（4）忘记了释放内存，造成内存泄露。</strong></p>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</p>
<p><strong>（5）释放了内存却继续使用它。常见于以下有三种情况</strong>：</p>
<p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p>
</div></details>
<ol start="30">
<li><strong>内存交换中，被换出的进程保存在哪里？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式; 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p>
</div></details>
<ol start="31">
<li><strong>原子操作的是如何实现的</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>在操作系统中，原子操作是那些在执行完毕前不能被中断的操作。这种操作是系统编程中的一个基本概念，特别是在涉及并发编程时。原子操作的执行必须是连续的，无法在中途被其他任务或事件打断。这对于保证数据的一致性和防止竞争条件至关重要。操作系统通常通过以下几种方式实现原子操作：</p>
<p><strong>1. 硬件支持</strong></p>
<p>许多现代CPU提供了特殊的硬件指令，用来保证操作的原子性。这些指令可以直接在硬件级别上锁定总线或内存地址，执行所需的操作，然后释放锁定，整个过程对其他线程或进程不可见。</p>
<ul>
<li><strong>Test-and-Set</strong>: 一种常用的硬件指令，用于实现互斥锁。它检查一个值，改变它，并返回原始值，整个过程原子地执行。</li>
<li><strong>Compare-and-Swap (CAS)</strong>: 这种指令检查一个位置的值，如果符合预期，则更新为新的值，这三个步骤作为一个原子操作执行。</li>
</ul>
<p><strong>2. 中断禁用</strong></p>
<p>在单核处理器系统中，操作系统可以通过禁用中断来创建原子操作环境。当中断被禁用时，当前代码段无法被中断，因此可以安全地执行需要原子性的操作。</p>
<ul>
<li>这种方法在多核处理器系统中效果不佳，因为其他核心上的进程可以并发运行。</li>
</ul>
<p><strong>3. 互斥锁和自旋锁</strong></p>
<p>互斥锁（如Mutex）和自旋锁是操作系统层面提供的同步机制，它们在用户空间和内核空间中广泛使用，以保护临界区和共享资源。</p>
<ul>
<li><strong>互斥锁</strong>：提供了一种方法，让只有一个线程可以进入关键的代码段。</li>
<li><strong>自旋锁</strong>：与互斥锁类似，但是在等待锁的释放时，它会在那里忙等待而不是睡眠。</li>
</ul>
<p><strong>4. 事务内存</strong></p>
<p>事务内存是一种同步多线程程序的方法，允许代码片段以原子方式执行，这类似于数据库事务。它是通过一系列的内存操作，如果没有冲突，这些操作就会被提交，如果有冲突，操作会被回滚并重试。</p>
<ul>
<li>事务内存可以是硬件实现（如Intel的TSX指令集）或软件实现。</li>
</ul>
<p><strong>5. 序列点</strong></p>
<p>操作系统的调度器可以在特定的序列点（如系统调用、进程上下文切换等）确保操作的原子性。这是通过在这些点确保不会发生并发的方式来管理。</p>
<p>这些原子操作的实现方法各有优劣，并根据应用的特定需求和环境进行选择。在设计并发系统时，合理地选择和使用这些原子操作机制是确保数据一致性、系统稳定性和性能的关键。</p>
</div></details>
<ol start="32">
<li><strong>抖动你知道是什么吗？它也叫颠簸现象</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究为应该为每个进程分配多少个物理块， Denning 提出了进程“工作集” 的概念。</p>
<p>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="数据库">数据库</h2>
<ol>
<li><strong>请说下你对 MySQL 架构的了解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-12_11-01-19.png" alt=""></p>
<p>1). 连接层<br>
最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2). 服务层<br>
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3). 引擎层<br>
存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p>
<p>4). 存储层<br>
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
</div></details>
<ol start="2">
<li><strong>一条 SQL 语句在数据库框架中的执行流程？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>应用程序把查询 SQL 语句发送给服务器端执行；</li>
<li>查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；</li>
<li>查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；</li>
<li>MySQL 根据相应的执行计划完成整个查询；</li>
<li>将查询结果返回给客户端。</li>
</ol>
<p>详细过程可以看这篇博客https://blog.csdn.net/pcwl1206/article/details/86137408</p>
</div></details>
<ol start="3">
<li><strong>数据库的三范式是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>
<p>第一范式(1NF)：属性不可分割，即每个属性都是不可分割的原子项。(实体的属性即表中的列)</p>
</li>
<li>
<p>第二范式(2NF)：满足第一范式；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)</p>
</li>
<li>
<p>第三范式(3NF)：满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -&gt; B, B -&gt;C, A -&gt; C）</p>
</li>
</ol>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ddzzz_/article/details/119277573">https://blog.csdn.net/ddzzz_/article/details/119277573</a></p>
</div></details>
<ol start="4">
<li><strong>char 和 varchar 的区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>char(n) ： 固定长度类型，比如：订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>
优点：效率高；<br>
缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</li>
<li>varchar(n) ： 可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</li>
</ul>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
</div></details>
<ol start="5">
<li><strong>varchar(10) 和 varchar(20) 的区别？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>在 MySQL 中，<code>VARCHAR</code> 是一个可变长度的字符串数据类型，用于存储字符串。<code>VARCHAR</code> 数据类型后的数字表示该字段可以容纳的字符的最大长度。例如，<code>VARCHAR(10)</code> 表示字段可以存储最多 10 个字符的字符串，而 <code>VARCHAR(20)</code> 表示字段可以存储最多 20 个字符的字符串。</p>
<p>以下是 <code>VARCHAR(10)</code> 和 <code>VARCHAR(20)</code> 在几个方面的区别：</p>
<ol>
<li>
<p><strong>存储容量</strong>：</p>
<ul>
<li><code>VARCHAR(10)</code> 最多可以存储 10 个字符。</li>
<li><code>VARCHAR(20)</code> 最多可以存储 20 个字符。</li>
<li>如果存储的字符数量超过字段指定的长度，超出的部分会被截断。</li>
</ul>
</li>
<li>
<p><strong>存储空间使用</strong>：</p>
<ul>
<li><code>VARCHAR</code> 类型的实际存储需求取决于存储的具体内容。除了字符数据外，还需要额外的空间来存储字符串的长度信息。</li>
<li>对于 <code>VARCHAR(255)</code> 或更小的字段，每个字段的记录前使用 1 字节来存储长度信息。</li>
<li>如果超过 <code>255</code> 个字符，则使用 2 字节来存储长度信息。</li>
<li>因此，<code>VARCHAR(10)</code> 和 <code>VARCHAR(20)</code> 都会在每条记录前使用 1 字节来存储长度信息。</li>
</ul>
</li>
<li>
<p><strong>性能考虑</strong>：</p>
<ul>
<li>在大多数情况下，<code>VARCHAR(10)</code> 和 <code>VARCHAR(20)</code> 在性能上的差异非常小。但是，合理地选择 <code>VARCHAR</code> 的长度可以帮助减少数据存储的空间，尤其是在包含大量这种字段的大型表中。</li>
<li>在某些情况下，例如大量的排序操作和索引，更长的字段可能会略微降低性能，因为处理更多的数据需要更多的内存和可能的磁盘 I/O。【这是因为<code>VARCHAR(20)</code> 实际存放的也更长】</li>
</ul>
</li>
<li>
<p><strong>应用场景</strong>：</p>
<ul>
<li>选择 <code>VARCHAR(10)</code> 或 <code>VARCHAR(20)</code> 应基于实际需求。例如，如果你知道数据最长不会超过 10 个字符，那么使用 <code>VARCHAR(10)</code> 就足够了。如果可能会存储更长的数据，应选择 <code>VARCHAR(20)</code> 或更长。</li>
</ul>
</li>
</ol>
<p>综上，主要的区别在于能够存储的最大字符长度和相应的存储需求。在设计数据库时，合理估计字段长度可以提高存储效率和性能。</p>
</div></details>
<ol start="6">
<li><strong>谈谈你对索引的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知<br>
识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目<br>
录”。</p>
<p>同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
<p>建立索引的原则：</p>
<ol>
<li>在最频繁使用的、用以缩小查询范围的字段上建立索引；</li>
<li>在频繁使用的、需要排序的字段上建立索引。</li>
</ol>
<p>不适合建立索引的情况：</p>
<ol>
<li>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；</li>
<li>对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。</li>
</ol>
</div></details>
<ol start="7">
<li><strong>索引的底层使用的是什么数据结构？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>索引的数据结构和具体存储引擎的实现有关,，在MySQL中使用较多的索引有 Hash 索引、 B+树索引等。而我们经常使用的 InnoDB 存储引擎的默认索引实现为 B+ 树索引。</p>
</div></details>
<ol start="8">
<li><strong>谈谈你对B+树的理解</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>B+ 树是一种广泛使用的索引和数据结构，尤其在数据库和文件系统中非常常见。B+ 树是 B 树的一种变体，优化了对磁盘存储的访问，通过保持树的平衡性来提供高效的查询和维护性能。下面是 B+ 树的一些关键特征和工作原理：</p>
<p><strong>结构特征</strong></p>
<ol>
<li>
<p><strong>多路搜索树</strong>：</p>
<ul>
<li>B+ 树是一种多路平衡搜索树，每个节点可以有多个子节点，通常远多于二叉树的两个。</li>
</ul>
</li>
<li>
<p><strong>节点组成</strong>：</p>
<ul>
<li><strong>内部节点</strong>：只存储键（keys）和指向子节点的指针。内部节点不存储实际数据或记录，这与 B 树有所不同。</li>
<li><strong>叶子节点</strong>：包含所有数据记录的实际值及其键值。在 B+ 树中，所有的叶子节点通过指针相连，形成一个有序链表。</li>
</ul>
</li>
<li>
<p><strong>高度平衡</strong>：</p>
<ul>
<li>所有的叶子节点都在同一层上，确保了从根节点到任一叶子节点的路径长度相同，这使得所有搜索操作的时间复杂度均匀。</li>
</ul>
</li>
</ol>
<p><strong>操作</strong></p>
<ol>
<li>
<p><strong>搜索</strong>：</p>
<ul>
<li>搜索操作从根节点开始，通过比较节点内的键与目标键，选择适当的指针进入子节点，这一过程持续到达叶子节点。由于每个叶子节点都在同一层级，搜索效率很高。</li>
</ul>
</li>
<li>
<p><strong>插入</strong>：</p>
<ul>
<li>插入新的键值对时，首先搜索到适当的叶子节点，然后在该叶子节点中插入新的数据。如果叶子节点满了，就会分裂成两个节点，并将分裂产生的新键向上推到父节点中。这可能导致上层节点也分裂，甚至达到根节点。</li>
</ul>
</li>
<li>
<p><strong>删除</strong>：</p>
<ul>
<li>删除操作首先找到相应的键所在的叶子节点并移除。如果这导致节点下溢（即节点中的键值对数低于最小限度），则可能需要节点合并或重新分配。这种调整可能向上传播，直到满足 B+ 树的平衡要求。</li>
</ul>
</li>
</ol>
<p><strong>优势</strong></p>
<ol>
<li>
<p><strong>效率高</strong>：</p>
<ul>
<li>B+ 树的搜索、插入和删除操作都可以在对数时间内完成，这使其非常适合处理大量数据。</li>
</ul>
</li>
<li>
<p><strong>磁盘读写优化</strong>：</p>
<ul>
<li>由于数据只存在于叶子节点，并且叶子节点是连续的，B+ 树特别适合于磁盘存储，可以减少磁盘读写次数，并提高顺序访问的效率。</li>
</ul>
</li>
<li>
<p><strong>范围查询优化</strong>：</p>
<ul>
<li>由于叶子节点是通过指针连成链表的，B+ 树对执行范围查询（如查找某范围内的所有记录）非常有效。</li>
</ul>
</li>
</ol>
<p>总结来说，B+ 树通过其结构的优化为数据库和文件系统等应用提供了高效的索引机制，特别是在处理大规模数据集时，能够提供高效的查找、插入和删除操作。这种结构支持了高效的磁盘存储及访问，而且改进了大量数据的处理性能。</p>
</div></details>
<ol start="9">
<li><strong>为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>用 B+ 树不用 B 树考虑的是 IO 对性能的影响， B 树的每个节点都存储数据，而 B+ 树只有叶子节点才存储数据，所以查找相同数据量的情况下， B 树的高度更高， IO 更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</p>
</div></details>
<ol start="10">
<li><strong>谈谈你对 聚簇索引（聚集索引）的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且<strong>一张表只允许存在一个聚簇索引</strong>。</p>
<p>聚簇索引和非聚簇索引的区别：<br>
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<br>
<p><strong>非聚集索引的特性</strong>：</p>
<p>非聚集索引的叶子节点并不直接存储数据记录本身。相反，它们存储索引的键值和一个指向数据行的指针。这个指针的性质取决于表是否有聚集索引：</p>
<ol>
<li><strong>在有聚集索引的表中</strong>：非聚集索引的叶子节点通常存储指向聚集索引键的指针。由于聚集索引键直接与数据行的物理存储相关联，这意味着通过非聚集索引查找时需要进行“索引跳转”——首先在非聚集索引中查找，然后使用非聚集索引中的指针找到聚集索引键，最后通过聚集索引键定位到实际的数据行。</li>
<li><strong>在没有聚集索引的表中</strong>：表被称为堆表，非聚集索引的叶子节点会存储一个指向数据行的物理位置的指针，因为没有聚集索引来定义数据的物理顺序。</li>
</ol>
</div></details>
<ol start="11">
<li><strong>谈谈你对哈希索引的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查<br>
找和范围查找。InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。</p>
</div></details>
<ol start="12">
<li><strong>谈谈你对覆盖索引的认识？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。具有以下优点：</p>
<ol>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如： MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引（聚集索引）。</li>
</ol>
</div></details>
<ol start="13">
<li><strong>索引的分类？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>从数据结构角度</strong></p>
<ol>
<li>树索引 (O(log(n)))</li>
<li>Hash 索引</li>
</ol>
<p><strong>从物理存储角度</strong></p>
<ol>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index）</li>
</ol>
<p><strong>从逻辑角度</strong></p>
<ol>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ol>
</div></details>
<ol start="14">
<li><strong>谈谈你对最左前缀原则的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>MySQL 使用联合索引时，需要满足最左前缀原则。下面举例对其进行说明：</p>
<ol>
<li>一个 2 列的索引 (name, age)，对 (name)、 (name, age) 上建立了索引；</li>
<li>一个 3 列的索引 (name, age, sex)，对 (name)、 (name, age)、 (name, age, sex) 上建了索引。</li>
</ol>
<p>1、B+ 树的数据项是复合的数据结构，比如： (name, age, sex) 的时候， B+ 树是按照从左到右的顺序来建立搜索<br>
树的，比如：当(小明, 22, 男)这样的数据来检索的时候， B+ 树会优先比较 name 来确定下一步的所搜方向，如果<br>
name 相同再依次比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候， B+ 树<br>
就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索<br>
才能知道下一步去哪里查询。</p>
<p>2、 当 (小明, 男) 这样的数据来检索时， B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于小明的数据都找到，然后再匹配性别是男的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<br>
<p>关于最左前缀的补充：</p>
<ol>
<li>
<p>最左前缀匹配原则会一直向右匹配直到遇到范围查询（&gt;、 &lt;、 between、 like）就停止匹配，比如： a = 1<br>
and b = 2 and c &gt; 3 and d = 4 如果建立 (a, b, c, d) 顺序的索引， d 是用不到索引的。如果建立 (a, b, d, c) 的<br>
索引则都可以用到， a、 b、 d 的顺序可以任意调整。</p>
</li>
<li>
<p>= 和 in 可以乱序，比如： a = 1 and b = 2 and c = 3 建立 (a, b ,c) 索引可以任意顺序， MySQL 的优化器会优化</p>
</li>
</ol>
<br>
<p>假设现在有联合索引(idx_a, idx_b, idx_c)，查询条件是idx_a &gt; 0 and idx_b = 0 and idx_c = 0时只有idx_a生效，而查询条件是idx_a &gt;= 0 and idx_b = 0 and idx_c = 0，联合索引全部生效？</p>
<p>在解释这个问题时，需要理解联合索引工作机制以及SQL查询优化器如何使用这种索引。对于具有联合索引 <code>(idx_a, idx_b, idx_c)</code> 的表，索引项首先按 <code>idx_a</code> 排序，然后是 <code>idx_b</code>，最后是 <code>idx_c</code>。考虑到这一点，我们来分析以下两种情况：</p>
<p>情况 1: 查询条件是 <code>idx_a &gt; 0 AND idx_b = 0 AND idx_c = 0</code></p>
<p>在这种情况下，索引在寻找满足 <code>idx_a &gt; 0</code> 的记录时能够高效工作，因为 <code>idx_a</code> 是索引的第一个字段，数据库可以快速跳过所有 <code>idx_a &lt;= 0</code> 的记录。然而，一旦 <code>idx_a &gt; 0</code> 的条件被满足，接下来的条件 <code>idx_b = 0</code> 和 <code>idx_c = 0</code> 不能保证紧接在每个符合 <code>idx_a &gt; 0</code> 条件的记录之后。这是因为每个 <code>idx_a</code> 值可能与多个 <code>idx_b</code> 和 <code>idx_c</code> 的组合相关联。因此，尽管索引还是可以帮助快速定位到 <code>idx_a &gt; 0</code> 的第一个记录，但对于 <code>idx_b</code> 和 <code>idx_c</code> 的过滤则可能需要对每一个符合 <code>idx_a &gt; 0</code> 的记录进行检查。</p>
<p>情况 2: 查询条件是 <code>idx_a &gt;= 0 AND idx_b = 0 AND idx_c = 0</code></p>
<p>这种情况下，查询可以更高效地使用联合索引。当查询条件从 <code>idx_a &gt; 0</code> 改变为 <code>idx_a &gt;= 0</code> 时，可能看起来区别不大，但实际上这允许了从 <code>idx_a</code> 的最小值开始扫描索引。因为所有三个字段的具体值都被指定了（<code>idx_a &gt;= 0</code>, <code>idx_b = 0</code>, <code>idx_c = 0</code>），查询优化器可以更精确地使用索引来定位到第一个完全匹配所有三个条件的记录。从这一点开始，由于索引的顺序特性，数据库可以连续地访问所有匹配的记录，直到 <code>idx_a</code> 的值不满足条件为止。因此，在这种情况下，联合索引的所有部分都能被有效利用。</p>
<p>为什么第二种情况索引效率更高？</p>
<p>关键在于查询条件提供的信息量和范围限制。<code>&gt;=</code> 对应于一个从某一明确点开始到尽可能远的范围，而条件 <code>idx_b = 0 AND idx_c = 0</code> 则精确匹配索引的下一个和后一个层级，这允许数据库系统精确地利用索引路径来过滤数据。相反，当 <code>idx_a &gt; 0</code> 时，尽管可以确定起始点，但由于 <code>idx_a</code> 的值可能有多个有效载荷，<code>idx_b</code> 和 <code>idx_c</code> 的过滤需要在更多的 <code>idx_a</code> 值中进行，这降低了索引的过滤效率。</p>
<p>因此，联合索引的使用效率高低很大程度上取决于查询条件与索引顺序的匹配程度，以及这些条件如何限制数据扫描的范围。</p>
</div></details>
<ol start="15">
<li><strong>怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>使用 Explain 命令来查看语句的执行计划， MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会<br>
拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如： possilbe_key、 key、 key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p>
</div></details>
<ol start="16">
<li><strong>什么情况下索引会失效？即查询不走索引？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>下面列举几种不走索引的 SQL 语句：<br>
1、索引列参与表达式计算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;sname&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;stu&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-operator">+</span> <span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure>
<p>2、 函数运算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;sname&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;stu&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;date&#x27;</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">&lt;</span> <span class="hljs-number">1990</span>;<br></code></pre></td></tr></table></figure>
<p>3、 %词语%–模糊查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;manong&#x27;</span> <span class="hljs-keyword">WHERE</span> `uname` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;码农%&#x27;</span> <span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;manong&#x27;</span> <span class="hljs-keyword">WHERE</span> `uname` <span class="hljs-keyword">LIKE</span> &quot;%码农%&quot; <span class="hljs-comment">-- 不走索引</span><br><span class="hljs-comment">-- 不是因为单引号和双引号，而是因为%出现在了前面</span><br></code></pre></td></tr></table></figure>
<p>4、 字符串与数字比较不走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;a&#x27;</span> (<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-type">char</span>(<span class="hljs-number">10</span>));<br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-operator">=</span> &quot;1&quot; <span class="hljs-comment">-- 走索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 不走索引，同样也是使⽤了函数运算</span><br></code></pre></td></tr></table></figure>
<p>5、 查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索<br>
引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">or</span> loc<span class="hljs-operator">=</span><span class="hljs-string">&#x27;xx&#x27;</span> <span class="hljs-keyword">or</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">45</span>;<br></code></pre></td></tr></table></figure>
<p>6、正则表达式不使用索引。</p>
<p>7、 MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。</p>
</div></details>
<ol start="17">
<li><strong>查询性能的优化方法？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>减少请求的数据量</strong></p>
<ol>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存<br>
带来的查询性能提升将会是非常明显的。</li>
</ol>
<p><strong>减少服务器端扫描的行数</strong></p>
<ol>
<li>最有效的方式是使用索引来覆盖查询</li>
</ol>
</div></details>
<ol start="18">
<li><strong>InnoDB 和 MyISAM 的比较？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>事务： MyISAM不支持事务， InnoDB支持事务；</li>
<li>全文索引： MyISAM 支持全文索引， InnoDB 5.6 之前不支持全文索引；</li>
<li>关于 count()： MyISAM会直接存储总行数， InnoDB 则不会，需要按行扫描。意思就是对于 select count()<br>
from table; 如果数据量大， MyISAM 会瞬间返回，而 InnoDB 则会一行扫描；</li>
<li>外键： MyISAM 不支持外键， InnoDB 支持外键；</li>
<li>锁： MyISAM 只支持表锁， InnoDB 可以支持行锁。</li>
</ol>
</div></details>
<ol start="19">
<li><strong>谈谈你对水平切分和垂直切分的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>水平切分<br>
水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</li>
<li>垂直切分<br>
垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库</li>
</ul>
<br>
<p>垂直切分（Vertical Partitioning）</p>
<p>垂直切分是将一个数据库表按照列进行分割，将不同的列存储在不同的表或数据库中。这种方式通常用于减少单个表的复杂性，提高查询性能，并优化数据的存储。</p>
<p><strong>例子：</strong></p>
<p>假设有一个名为 <code>Users</code> 的表，包含如下列：<code>UserID</code>, <code>Username</code>, <code>Password</code>, <code>Email</code>, <code>LastLogin</code>, <code>ProfileDescription</code>。</p>
<p>在垂直切分的情况下，可以将 <code>Users</code> 表切分为两个表：</p>
<ul>
<li><code>UserAuth</code> 表，包含用户认证相关的信息：<code>UserID</code>, <code>Username</code>, <code>Password</code>, <code>Email</code>。</li>
<li><code>UserProfile</code> 表，包含用户的个人资料信息：<code>UserID</code>, <code>LastLogin</code>, <code>ProfileDescription</code>。</li>
</ul>
<p>这样，当只需要验证用户登录时，只需查询 <code>UserAuth</code> 表，而不需要加载用户的个人资料信息，这可以提高认证过程的效率。同样，当需要查看或更新用户的个人资料时，只需处理 <code>UserProfile</code> 表。</p>
<br>
<p>水平切分（Horizontal Partitioning）</p>
<p>水平切分是按行将数据分布到多个表或数据库中。每个分片包含表的全部列，但只包含部分行。这种方式用于处理大量数据，使得数据管理更加分散和易于扩展。</p>
<p><strong>例子：</strong></p>
<p>假设有一个名为 <code>Orders</code> 的表，存储电子商务网站的订单数据，表中有数百万条记录。可以根据订单的地理位置、时间或其他属性进行水平切分。</p>
<p>例如，根据地理位置，可以将 <code>Orders</code> 表分为三个分片：</p>
<ul>
<li><code>Orders_NorthAmerica</code></li>
<li><code>Orders_Europe</code></li>
<li><code>Orders_Asia</code></li>
</ul>
<p>每个表存储相应地区的订单数据。这样，查询特定地区的订单时，查询将被限制在较小的数据集上，从而提高查询效率和响应速度。</p>
</div></details>
<ol start="20">
<li>
<p><strong>主从复制中涉及到哪三个线程？</strong></p>
</li>
<li>
<p><strong>主从同步的延迟原因及解决办法？</strong></p>
</li>
<li>
<p><strong>谈谈你对数据库读写分离的理解？</strong></p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p><strong>读写分离能提高性能的原因在于</strong>：</p>
<ol>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ol>
</div></details>
<ol start="23">
<li><strong>请你描述下事务的特性？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>上述就是事务的四大特性，简称ACID。</p>
</div></details>
<ol start="24">
<li><strong>谈谈你对事务隔离级别的理解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>为了处理这些问题，SQL标准定义了四个隔离级别，每个级别都以牺牲一定的并发性能为代价，提供了不同程度的隔离保护：</p>
<ol>
<li><strong>读未提交 (Read Uncommitted)</strong>：最低的隔离级别，允许读取未提交的数据变更，可能会导致脏读、不可重复读和幻读。</li>
<li><strong>读已提交 (Read Committed)</strong>：保证读取的数据是已经被提交的。这可以避免脏读，但不可重复读和幻读仍然可能发生。</li>
<li><strong>可重复读 (Repeatable Read)</strong>：保证在同一个事务内的查询可以多次执行而返回相同的结果，即在事务开始后无法看到其他事务对数据所做的修改。这可以防止脏读和不可重复读，但幻读可能发生。</li>
<li><strong>串行化 (Serializable)</strong>：最高的隔离级别，通过强制事务串行执行，防止脏读、不可重复读和幻读。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th style="text-align:left">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read uncommitted</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">Read committed</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">Repeatable Read(默认)</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
</div></details>
<ol start="25">
<li><strong>解释下什么叫脏读、不可重复读和幻读？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p><strong>1).</strong> <strong>赃读</strong>：一个事务读到另外一个事务还没有提交的数据</p>
<p>比如B读取到了A未提交的数据。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-10_20-12-21.png" alt=""></p>
<p>脏读发生在一个事务读取了另一个事务未提交的数据。如果那个事务回滚，读取的数据将是无效的。</p>
<br>
<p><strong>2).</strong> <strong>不可重复读</strong>：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p>
<p>事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-10_20-14-11.png" alt=""></p>
<p>不可重复读发生在一个事务读取了某些数据，然后另一个事务修改或删除了这些数据。当第一个事务再次读取相同的数据时，得到的结果不同。</p>
<br>
<p><strong>3).</strong> <strong>幻读</strong>：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据<br>
已经存在，好像出现了 “幻影”。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-04-10_20-17-27.png" alt=""></p>
<p>幻读类似于不可重复读，但它是指当一个事务重新执行一个查询时，返回一组符合查询条件的行，但这组行中包含了因为其他事务插入的新行。</p>
</div></details>
<ol start="26">
<li><strong>MySQL 默认的隔离级别是什么？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>MySQL 默认采用的 <strong>REPEATABLE_READ</strong> 隔离级别。<br>
Oracle 默认采用的 <strong>READ_COMMITTED</strong> 隔离级别。</p>
</div></details>
<ol start="27">
<li><strong>谈谈你对MVCC 的了解？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>数据库并发场景：</p>
<ol>
<li>
<p><strong>读-读</strong>：不存在任何问题，也不需要并发控制；</p>
</li>
<li>
<p><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；</p>
</li>
<li>
<p><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题。</p>
</li>
</ol>
<p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，<u>读操作只读该事务开始前的数据库的快照</u>。</p>
<br>
<p>MVCC 可以为数据库解决以下问题：</p>
<ol>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，<u>但不能解决更新丢失问题</u>。</li>
</ol>
<p><br><br></p>
<p>多版本并发控制（MVCC，Multi-Version Concurrency Control）是一种广泛使用的数据库管理技术，特别是在关系数据库系统中，如 PostgreSQL 和 MySQL 的 InnoDB 存储引擎。MVCC 允许在不锁定数据库资源的情况下实现事务数据的一致性和隔离性，从而提高并发性能。这种技术的核心在于为每个正在数据库上执行的事务维护数据的不同版本。</p>
<p><strong>MVCC的工作原理</strong></p>
<ol>
<li>
<p><strong>数据版本</strong>：</p>
<ul>
<li>每当数据被修改时，MVCC 不会直接覆盖原有数据，而是创建一个新的数据版本。这样，不同的事务可以看到同一数据的不同版本，具体取决于事务的开始时间。</li>
</ul>
</li>
<li>
<p><strong>事务时间戳</strong>：</p>
<ul>
<li>每个事务都会获得一个唯一的时间戳。根据这个时间戳，系统可以确定一个事务应该看到哪个版本的数据。通常，一个事务只能看到在它开始之前已经提交的更改。</li>
</ul>
</li>
<li>
<p><strong>可见性规则</strong>：</p>
<ul>
<li>数据版本的可见性由事务的时间戳决定。如果一个数据版本是由时间戳较小（即较早）的事务创建的，那么所有时间戳较大（即稍后启动）的事务都可以看到这个版本，除非有更新的版本可用。</li>
</ul>
</li>
<li>
<p><strong>垃圾回收</strong>：</p>
<ul>
<li>由于数据的多个版本共存，旧版本的数据需要在不再被任何事务引用时清理，这个过程通常称为垃圾回收或清理。这有助于释放空间并维护性能。</li>
</ul>
</li>
</ol>
<p><strong>MVCC的优点</strong></p>
<ol>
<li>
<p><strong>高并发性</strong>：</p>
<ul>
<li>MVCC 允许多个读取事务与写入事务并行执行而无需相互阻塞，从而大大提高了并发性能。</li>
</ul>
</li>
<li>
<p><strong>读写分离</strong>：</p>
<ul>
<li>读事务不会阻塞写事务，反之亦然。这意味着读取操作可以在数据被其他事务更新的同时安全地执行，而不会遇到锁等待。</li>
</ul>
</li>
<li>
<p><strong>一致性视图</strong>：</p>
<ul>
<li>每个事务都有一个一致的数据视图，即使其他事务正在并发修改数据。这保证了数据的一致性和隔离性。</li>
</ul>
</li>
</ol>
<p><strong>MVCC的挑战</strong></p>
<ol>
<li>
<p><strong>性能开销</strong>：</p>
<ul>
<li>维护数据的多个版本需要额外的存储空间和管理开销。随着版本的增加，垃圾回收的复杂性和成本也会增加。</li>
</ul>
</li>
<li>
<p><strong>版本管理</strong>：</p>
<ul>
<li>管理大量的数据版本可能导致性能下降，尤其是在高更新频率的环境中。</li>
</ul>
</li>
<li>
<p><strong>事务冲突</strong>：</p>
<ul>
<li>尽管MVCC减少了锁的需要，但在高冲突环境中，如频繁更新同一记录，仍可能导致性能问题。</li>
</ul>
</li>
</ol>
<p>MVCC 是数据库管理中一种强大的技术，尤其适合需要高并发读取和写入操作的应用。通过优化其版本管理和垃圾回收策略，可以在保证事务隔离和一致性的同时，提高数据库的整体性能和效率。</p>
</div></details>
<ol start="28">
<li><strong>说一下 MySQL 的行锁和表锁？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>MyISAM 只支持表锁， InnoDB 支持表锁和行锁，默认为行锁。</p>
<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p>
<p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
</div></details>
<ol start="29">
<li><strong>InnoDB 存储引擎的锁的算法有哪些？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>Record lock：单个行记录上的锁；</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身；</li>
<li>Next-key lock： record+gap 锁定一个范围，包含记录本身。</li>
</ol>
</div></details>
<ol start="30">
<li><strong>MySQL 问题排查都有哪些手段？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>使用 show processlist 命令查看当前所有连接信息；</li>
<li>使用 Explain 命令查询 SQL 语句执行计划；</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ol>
<p><br><br></p>
<p><code>SHOW PROCESSLIST</code> 是 MySQL 和类似的 SQL 数据库系统中的一条 SQL 命令，用于显示关于当前连接到数据库服务器的所有进程（或线程）的信息。这个命令对数据库管理员非常有用，尤其是在诊断系统性能问题、监控查询或管理数据库连接时。</p>
<p><strong>作用和信息详解</strong></p>
<p>当你执行 <code>SHOW PROCESSLIST</code> 命令时，它会返回一个列表，其中包含当前活跃的每个进程的以下信息：</p>
<ol>
<li><strong>Id</strong>：每个进程的唯一标识符。</li>
<li><strong>User</strong>：启动进程的用户。</li>
<li><strong>Host</strong>：用户连接到服务器的主机名和端口号。</li>
<li><strong>db</strong>：当前进程正在使用的数据库。</li>
<li><strong>Command</strong>：该进程正在执行的命令类型，如 <code>Query</code>、<code>Sleep</code>、<code>Connect</code>、<code>Kill</code> 等。</li>
<li><strong>Time</strong>：当前命令已执行的秒数。</li>
<li><strong>State</strong>：显示进程的当前状态，这可能是 <code>Sending data</code>、<code>Sorting result</code>、<code>Locked</code> 等，说明了进程执行的具体阶段或等待的原因。</li>
<li><strong>Info</strong>：正在执行的 SQL 语句或进程的最近语句。长查询可能会被截断。</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>性能监控</strong>：管理员可以使用 <code>SHOW PROCESSLIST</code> 来查看哪些查询正在执行以及它们的执行时间，这有助于识别性能瓶颈。</li>
<li><strong>问题诊断</strong>：如果应用程序响应缓慢或数据库访问延迟，此命令可以帮助确定是否有长时间运行的查询或锁争用问题。</li>
<li><strong>连接管理</strong>：查看谁连接到了数据库，他们正在做什么，这对于管理数据库连接和安全非常重要。</li>
<li><strong>强制终止查询</strong>：通过得到需要被终止的查询的 <code>Id</code>，可以使用 <code>KILL [process id]</code> 命令来终止不需要的或长时间运行的查询。</li>
</ul>
<p><strong>使用示例</strong></p>
<p>简单执行 <code>SHOW PROCESSLIST;</code> 可以获得所有活跃进程的列表。如果你具有管理员权限，这将包括所有用户的进程；如果没有，则只显示你自己的进程。</p>
<p>对于更高级的用例，你可能希望将输出限制为那些可能影响系统性能的特定进程，比如运行时间超过一定阈值的进程。这可以通过一些 SQL 脚本来实现，结合使用 <code>SHOW PROCESSLIST</code> 和其他条件查询。</p>
<p><strong>权限</strong></p>
<ul>
<li>在 MySQL 中，执行 <code>SHOW PROCESSLIST</code> 不需要任何特殊权限就可以查看自己的进程信息；但查看其他用户的进程信息则需要 <code>PROCESS</code> 权限。</li>
</ul>
<p>总的来说，<code>SHOW PROCESSLIST</code> 是数据库管理和性能调优中的一个非常有用的工具，它提供了即时的系统活动视图，帮助管理员管理和优化数据库操作。</p>
</div></details>
<ol start="31">
<li><strong>MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？</strong></li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><ol>
<li>列出所有进程 show processlist，观察所有进程，多少没有状态变化的(干掉)；</li>
<li>查看超时日志或者错误日志 (一般会是查询以及大批量的插入会导致 CPU与 I/O 上涨，当然不排除网络状态突<br>
然断了，导致一个请求服务器只接受到一半。</li>
</ol>
<p><br><br></p>
<p>当 MySQL 数据库的 CPU 使用率飙升到 500% 或其他极高的水平时，这通常表明数据库正在处理大量的请求或执行一些资源密集型的操作。处理这种情况需要系统地分析问题原因并采取相应措施来优化性能和减轻负载。以下是一些基本步骤和策略，可以帮助你解决 MySQL 数据库的高 CPU 使用问题：</p>
<ol>
<li>确认问题</li>
</ol>
<p>首先确认高 CPU 使用率是由 MySQL 数据库引起的。可以使用如 <code>top</code>、<code>htop</code> 或系统特有的监控工具查看 CPU 使用详情。</p>
<ol start="2">
<li>查看当前运行的查询</li>
</ol>
<p>使用 <code>SHOW PROCESSLIST</code> 命令来查看当前所有运行的查询。这可以帮助你识别是否有长时间运行或锁表的查询。你也可以使用 <code>EXPLAIN</code> 命令对这些查询进行分析，了解它们的执行计划及是否有效利用索引。</p>
<ol start="3">
<li>分析慢查询日志</li>
</ol>
<p>检查 MySQL 的慢查询日志，找出执行时间长的查询。MySQL 可以配置来记录执行时间超过特定秒数的查询。这些信息对于诊断性能问题至关重要。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;long_query_time&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>优化查询和索引</li>
</ol>
<p>基于你从慢查询日志和 <code>EXPLAIN</code> 分析中获得的信息，优化查询语句和数据表的索引。确保所有的查询都高效地使用索引，尤其是涉及大量数据的查询。</p>
<ol start="5">
<li>调整配置设置</li>
</ol>
<p>查看并调整 MySQL 的配置设置，如 <code>innodb_buffer_pool_size</code>（InnoDB 缓冲池大小），确保它根据服务器的内存大小进行了优化。其他参数如 <code>query_cache_size</code>, <code>thread_cache_size</code>, <code>table_open_cache</code> 也可以根据具体情况进行调整。</p>
<ol start="6">
<li>服务器硬件和资源</li>
</ol>
<p>检查服务器的硬件资源，确保数据库服务器有足够的 RAM 和高效的 CPU。如果资源使用接近或超过限制，可能需要增加更多的资源或迁移到更强大的硬件。</p>
<ol start="7">
<li>分析和监控</li>
</ol>
<p>持续监控数据库的性能，使用诸如 Prometheus、Grafana 或其他专业的数据库监控工具来获得实时的性能分析数据。</p>
<ol start="8">
<li>考虑使用读写分离或负载均衡</li>
</ol>
<p>如果数据库访问量特别大，考虑实施读写分离，设置复制（replication）和读取副本（read replicas）来分散读取请求的压力。使用负载均衡可以平均分配请求到多个服务器。</p>
<ol start="9">
<li>寻求专业帮助</li>
</ol>
<p>如果问题复杂难以解决，可能需要寻求来自具有专业数据库管理经验的 IT 专家的帮助。</p>
<p>通过这些步骤，你可以诊断并缓解 MySQL 数据库的高 CPU 使用问题，提高数据库的性能和稳定性。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="数据结构与算法">数据结构与算法</h2>
<ol>
<li><strong>字节</strong>：给一百亿个整数，就是很大数量级个整数，怎么找到其中位数</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看内容 </summary><div class="toggle-content"><p>处理这么大量级的数据，特别是要找到一百亿个整数中的中位数，不能直接使用常规的排序方法，因为这会需要非常大的内存和处理时间。以下是一些高效处理大规模数据以找到中位数的方法：</p>
<ol>
<li><strong>使用外部排序</strong></li>
</ol>
<p>如果数据太大，无法一次性装入内存，可以使用外部排序算法。外部排序是一种设计用来处理超过内存限制的大量数据的排序算法。这个过程大致如下：</p>
<ul>
<li><strong>分割</strong>：将原始数据集分割成多个小块，每块小到足以装入内存。</li>
<li><strong>排序和存储</strong>：分别对每块数据进行排序，然后将排序后的数据块存储到硬盘上。</li>
<li><strong>合并</strong>：最后，使用多路归并排序算法合并这些排序后的数据块，直到合并成一个完整的排序后的数据集。</li>
</ul>
<p>这种方法的一个变种是只部分排序数据，以便更快地找到中位数。</p>
<ol start="2">
<li><strong>使用快速选择算法（QuickSelect）</strong></li>
</ol>
<p>快速选择算法是一种类似于快速排序的选择算法，用于在未排序的列表中找到第k小（或第k大）的元素。如果数据可以分布式存储，可以并行运行快速选择算法，以在合理的时间内找到中位数。</p>
<ol start="3">
<li><strong>使用堆（Heaps）</strong></li>
</ol>
<p>如果数据流是动态的或者可以分批处理，可以使用两个堆（一个最大堆和一个最小堆）来动态地维护中位数。最大堆存储当前较小的一半数，最小堆存储当前较大的一半数。这样，中位数可以容易地从两个堆的顶部计算得到。</p>
<ol start="4">
<li><strong>BFPRT算法（中位数的中位数算法）</strong></li>
</ol>
<p>BFPRT算法，也称为中位数的中位数算法，是快速选择算法的一个改进版，可以保证更好的最坏情况时间复杂度。这种算法适用于当数据量非常大时，可以提供比普通快速选择更稳定的性能。</p>
<ol start="5">
<li><strong>数据流算法</strong></li>
</ol>
<p>对于动态变化的数据流，可以使用特定的数据流算法来估算中位数，例如使用T-Digest或Q-Digest这类数据结构，虽然这不会给出精确结果，但可以在有限的内存中提供一个很好的近似。</p>
<p>总的来说，选择哪种方法取决于具体的应用场景，包括数据的大小、是否可以将数据载入内存、数据是否静态、以及对精度的需求等。对于一百亿这样的大数据量，通常需要采用一种或多种分布式处理和/或近似方法来有效地找到中位数。</p>
</div></details>
<ol start="2">
<li><strong>4399</strong>：有9999瓶水，1瓶毒药，老鼠可以随便喝，喝到毒药10分钟后毒发，要在10分钟后找到这瓶毒药，最少要用多少只老鼠？</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解释 </summary><div class="toggle-content"><p>为了解决这个问题，可以使用二进制表示法来最小化所需的老鼠数量。每瓶水都可以用二进制表示，从<code>00 0000 0000 0000</code>（0）到<code>10 0111 0000 1111</code>（9999）。这里的关键是每位二进制数代表一只老鼠是否应该喝那一批标记了1的水瓶。如果一瓶水的二进制表示在某一位上是1，那么对应的老鼠就需要喝这瓶水。如果在10分钟后，某只老鼠死了，就意味着它喝的水瓶中包含了毒药，那么所有这些老鼠的生死情况共同决定了哪一瓶是毒药。</p>
<p><strong>进行实验</strong>：</p>
<ul>
<li>每一只老鼠对应二进制编码中的一个位置。例如，第一只老鼠对应最低位，第二只对应第二位，依此类推。</li>
<li>如果某瓶水的编码在某位是1，则让对应这位的老鼠喝这瓶水。例如，如果某瓶水的编码是1001，那么第一和第四只老鼠需要喝这瓶水。</li>
<li>等待10分钟后，根据哪些老鼠死亡，记录下来。每个老鼠的生死状态对应一个二进制位，将这些二进制位组合起来就能确定哪瓶是毒药。</li>
</ul>
<p><strong>记录结果</strong>：</p>
<ul>
<li>每只老鼠对应一个特定的二进制位位置，从最低位（第一只老鼠）到最高位（第十四只老鼠）。</li>
<li>记录哪些老鼠在实验后死亡。死亡的老鼠对应的位置上标记为 <code>1</code>，未死的标记为 <code>0</code>。</li>
</ul>
<p>最后组合二进制数字，再转十进制就知道是哪一瓶了。</p>
<p>因此，要在10分钟内找出哪瓶水有毒，最少需要14只老鼠。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="职场">职场</h2>
<ol>
<li><strong>韶音科技</strong>：产品经理是什么</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解析 </summary><div class="toggle-content"><p>作为计算机专业的本科生，当被问到产品经理是什么时，你可以从以下几个角度来回答：</p>
<ol>
<li>
<p><strong>定义与角色定位</strong>：<br>
产品经理（Product Manager）是负责指导和管理一个产品从构想、开发到市场推广全过程的专业人士。他们充当团队与客户之间的桥梁，确保产品能够满足市场需求和用户期望。产品经理需要具备深入理解市场动态、用户需求、产品设计和技术开发的能力。</p>
</li>
<li>
<p><strong>核心职责</strong>：</p>
<ul>
<li><strong>市场研究</strong>：进行市场调研，了解行业趋势和竞争对手，定义目标用户群体。</li>
<li><strong>产品策略制定</strong>：基于市场研究，制定产品的愿景、战略和路线图。</li>
<li><strong>需求管理</strong>：收集和分析用户需求，定义产品功能和优先级。</li>
<li><strong>项目管理</strong>：与设计师、开发人员协作，确保产品按时发布。</li>
<li><strong>数据分析</strong>：通过数据分析来优化产品性能和用户体验。</li>
</ul>
</li>
<li>
<p><strong>技能要求</strong>：</p>
<ul>
<li><strong>交际能力</strong>：需要与团队成员、用户和其他利益相关者有效沟通。</li>
<li><strong>分析能力</strong>：能够处理和解读市场数据，做出基于数据的决策。</li>
<li><strong>项目管理</strong>：组织和协调资源，确保项目按计划进行。</li>
<li><strong>技术知识</strong>：虽然不一定需要深入的编程知识，但需要理解技术问题和限制，以便与开发团队有效沟通。</li>
</ul>
</li>
<li>
<p><strong>与计算机专业的关系</strong>：<br>
作为计算机专业的学生，你具备了理解复杂技术问题的能力，这是成为一名优秀产品经理的重要基础。你可以强调你的技术背景如何帮助你更好地与开发团队合作，以及如何利用这一优势来设计和推动实现高质量的产品解决方案。</p>
</li>
</ol>
<p>回答这个问题时，可以结合自己的经验和兴趣，说明为什么你对产品管理感兴趣，以及你如何利用自己的计算机科学知识和技能来成为一名成功的产品经理。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="公司">公司</h2>
<blockquote>
<p>C++方向</p>
</blockquote>
<h3 id="1-宇量升">1. 宇量升</h3>
<p><strong>一面</strong>：</p>
<p>直接手撕一道动态规划</p>
<hr>
<p><br><br><br></p>
<h3 id="2-招银网络">2. 招银网络</h3>
<p><strong>一面</strong>：</p>
<p>C++重写和重载</p>
<p>数据库索引</p>
<p>手写一道sql</p>
<p>java中间件</p>
<p>手撕一道算法题：子序列题</p>
<br>
<p><strong>二面</strong>：</p>
<p>简历有什么问什么</p>
<p>问转java能不能接受</p>
<hr>
<p><br><br><br></p>
<h3 id="3-快手">3. 快手</h3>
<p><strong>一面</strong>：</p>
<p>问计算机网络、操作系统哪个比较熟悉，挑一个讲，自己讲一下操作系统或者提问知识点</p>
<p>我选了讲解，内容太多，讲完进程被喊停了</p>
<p>手撕一道算法题：翻转链表中间部分</p>
<p>问了http协议</p>
<br>
<p><strong>二面</strong>：</p>
<p>问了一下项目，让自己挑一个讲讲，过程中提问</p>
<p>手撕一道算法题：螺旋打印矩阵</p>
<p>问了一下https</p>
<p>问了一下智能指针</p>
<hr>
<p><br><br><br></p>
<h3 id="4-4399">4. 4399</h3>
<p><strong>一面</strong>：</p>
<p>说很适合他们的岗位，给我讲解了一下游戏前端和互联网前端、客户端前端的区别</p>
<p>了解了一下我做的项目，个人情况</p>
<p>问了git的常用命令</p>
<p>问了一道智力题：<br>
有9999瓶水，1瓶毒药，老鼠可以随便喝，喝到毒药10分钟后毒发，要在10分钟后找到这瓶毒药，最少要用多少只老鼠？<br>
没答上来，但是我说到了剪枝，让我说一下剪枝也行。</p>
<hr>
<p><br><br><br></p>
<h3 id="5-巴伦如梭">5. 巴伦如梭</h3>
<p><strong>一面</strong>:</p>
<p>纯搞笑公司，一直问你项目，希望你的项目技术程度非常高，总之他要听到一个想要的答案，我想问问他知道这是校招吗</p>
<p>拿了10天前做的笔试题来问我代码有一个问题知不知道，代码也不给看；太久远了根本记不清，而且做笔试的时候无法编译无法调试，根本印象不深，后面给了一些提示，也算是回答上来了</p>
<p>问了一下锁，我说不知道，但是我知道事务，说了一下</p>
<p>最后问有没有想要提问的，我回答没有，<br>
然后就反问我对他们公司了解多少，<br>
我说有所欠缺，<br>
然后嘲讽我说，不知道还不问，<br>
我的内心（有病吧，大家都赶时间，我了解nm呢，你招我进去再说不行吗，问情商这么低的问题）<br>
我回答，这些太基础了，可以自己了解，不爱问这种问题</p>
<p>后面听说总共也就只有一面</p>
<hr>
<p><br><br><br></p>
<h3 id="6-星环科技">6. 星环科技</h3>
<p>24届春招-分布式存储开发工程师<br>
<strong>笔试题</strong></p>
<p><strong>第一题</strong>：</p>
<p>一个job有很多task，task是最小分配单元；<br>
需要模拟一大批job到来，处理机的处理；<br>
输出job的完成时间；</p>
<p><strong>输入</strong></p>
<p>第一行输入n, m；n表示job数量，m表示处理机数目<br>
接下来n行，每行输入三个数a（job到达时间）, b（job的task数量）, c（完成task所需要的时间）</p>
<p>规定第i行的到达时间一定小于第i-1行</p>
<p><strong>输出</strong></p>
<p>输出n行，每行表示对应job的完成时间</p>
<p><strong>样例</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2 3<br>0 2 5<br>2 1 4<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>6<br></code></pre></td></tr></table></figure>
<br>
<p><strong>第二题</strong>：</p>
<p>翻译百灵鸟的语言</p>
<p><code>.</code>表示“叽”，<code>_</code>表示“啾”</p>
<p><strong>输入</strong></p>
<p>第一行输入n；<br>
接下来n行输入百灵鸟的单词；<br>
最后一行输入需要翻译的句子</p>
<p><strong>样例</strong></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4<br>.<br>._<br>__.<br>__..<br>__..._<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2<br></code></pre></td></tr></table></figure>
<p>解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__. / . / ._<br>__.. / ._<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h3 id="7-TCL">7. TCL</h3>
<p>笔试纯纯c++知识点，复习过就是送分</p>
<hr>
<p><br><br><br></p>
<h3 id="8-蚂蚁集团">8. 蚂蚁集团</h3>
<p><strong>笔试</strong>：选择比较难，编程全是送分</p>
<h3 id="……面太多了，后面懒得写了，三十场……"><strong>……面太多了，后面懒得写了，三十场……</strong></h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.com">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.com/posts/65115/">https://gxblogs.com/posts/65115/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.com" target="_blank">GXBLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%82%E8%81%8C/">求职</a></div><div class="post_share"><div class="social-share" data-image="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-28_23-36-48.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/34219/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-28_23-17-22.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/26732/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2024-03-24_20-02-53.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指offer</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%92%95"><span class="toc-text">手撕</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%9D%A2%E7%BB%8F"><span class="toc-text">C++面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">C++基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">C++面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">数据结构与算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E5%9C%BA"><span class="toc-text">职场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%8F%B8"><span class="toc-text">公司</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%87%E9%87%8F%E5%8D%87"><span class="toc-text">1. 宇量升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C"><span class="toc-text">2. 招银网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%AB%E6%89%8B"><span class="toc-text">3. 快手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4399"><span class="toc-text">4. 4399</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B7%B4%E4%BC%A6%E5%A6%82%E6%A2%AD"><span class="toc-text">5. 巴伦如梭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80"><span class="toc-text">6. 星环科技</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-TCL"><span class="toc-text">7. TCL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2"><span class="toc-text">8. 蚂蚁集团</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%A6%E2%80%A6%E9%9D%A2%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%8C%E5%90%8E%E9%9D%A2%E6%87%92%E5%BE%97%E5%86%99%E4%BA%86%EF%BC%8C%E4%B8%89%E5%8D%81%E5%9C%BA%E2%80%A6%E2%80%A6"><span class="toc-text">……面太多了，后面懒得写了，三十场……</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>