<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>设计模式（golang） | GXBLOGS</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考：https:&#x2F;&#x2F;github.com&#x2F;mohuishou&#x2F;go-design-pattern 参考课程：极客时间《设计模式之美》 资源：https:&#x2F;&#x2F;github.com&#x2F;ggw2021&#x2F;design-pattern-books   KISS 原则（Keep It Simple and Stupid，也常被译为 “保持简单愚蠢”）是设计、工程、管理等领域广泛遵循的重要原则，核心思想是让事">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式（golang）">
<meta property="og:url" content="https://gxblogs.com/posts/47697/index.html">
<meta property="og:site_name" content="GXBLOGS">
<meta property="og:description" content="参考：https:&#x2F;&#x2F;github.com&#x2F;mohuishou&#x2F;go-design-pattern 参考课程：极客时间《设计模式之美》 资源：https:&#x2F;&#x2F;github.com&#x2F;ggw2021&#x2F;design-pattern-books   KISS 原则（Keep It Simple and Stupid，也常被译为 “保持简单愚蠢”）是设计、工程、管理等领域广泛遵循的重要原则，核心思想是让事">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-03_16-16-49.png">
<meta property="article:published_time" content="2025-01-11T18:49:00.368Z">
<meta property="article:modified_time" content="2025-08-28T17:51:09.693Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-03_16-16-49.png"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.com/posts/47697/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: GXBLOGS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式（golang）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-29 01:51:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/highlight/Kimbiedark.css"><script src="/css/else/echarts.min.js"></script><script src="/css/else/wow.min.js"></script><script type="text/javascript" src="/css/else/echarts-gl.min.js"></script><script src="/css/else/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="/static/imgs/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-03_16-16-49.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GXBLOGS</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式（golang）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-11T18:49:00.368Z" title="发表于 2025-01-12 02:49:00">2025-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T17:51:09.693Z" title="更新于 2025-08-29 01:51:09">2025-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/47697/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/47697/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a></p>
<p>参考课程：极客时间《设计模式之美》<br>
资源：<a target="_blank" rel="noopener" href="https://github.com/ggw2021/design-pattern-books">https://github.com/ggw2021/design-pattern-books</a></p>
</blockquote>
<blockquote>
<p>KISS 原则（Keep It Simple and Stupid，也常被译为 “保持简单愚蠢”）是设计、工程、管理等领域广泛遵循的重要原则，核心思想是<strong>让事物保持简单易懂，避免过度复杂</strong>。它强调在解决问题或创造产品时，最简单的方案往往是最有效的。</p>
<p><strong>KISS 原则的起源与核心内涵</strong></p>
<ul>
<li><strong>起源</strong>：普遍认为该原则由美国海军工程师凯利・约翰逊（Kelly Johnson）提出。他在设计军用飞机时要求团队：“任何设计都必须简单到让新手在紧急情况下也能轻松操作”，因为复杂的系统在高压环境下容易出错。</li>
<li><strong>核心内涵</strong>：<br>
并非倡导 “愚蠢”，而是反对不必要的复杂。即 “<strong>用最简单的方式解决问题，避免冗余的步骤、概念或结构</strong>”。过度复杂会导致理解困难、执行低效、出错率高，而简单的方案更易维护、推广和优化。</li>
</ul>
<p><strong>KISS 原则的应用场景</strong></p>
<ol>
<li><strong>产品设计与开发</strong>
<ul>
<li>例如：苹果产品的极简界面，通过减少按钮和功能层级，让用户无需学习即可操作；微信的初期版本仅保留核心的聊天和社交功能，避免功能堆砌。</li>
<li>反面案例：早期某些功能机的菜单层级多达五六层，用户查找功能时极为繁琐，违背了 KISS 原则。</li>
</ul>
</li>
<li><strong>编程与技术领域</strong>
<ul>
<li>程序员常说 “代码越简单，bug 越少”。复杂的逻辑嵌套、冗余的代码会增加维护难度，而模块化、简洁的代码更易迭代。</li>
</ul>
</li>
<li><strong>沟通与管理</strong>
<ul>
<li>汇报工作时，用简洁的语言和图表传递核心信息，比冗长的 PPT 更有效；管理流程中，减少不必要的审批环节，能提升团队效率。</li>
</ul>
</li>
<li><strong>日常生活</strong>
<ul>
<li>例如：整理房间时，保留常用物品、精简冗余物品，能让空间更易用；制定计划时，聚焦核心目标而非罗列琐事，更易执行。</li>
</ul>
</li>
</ol>
<p><strong>为什么 KISS 原则有效？</strong></p>
<ul>
<li><strong>降低认知负荷</strong>：人类的注意力和理解能力有限，简单的事物更易被接受和记忆。</li>
<li><strong>减少出错概率</strong>：复杂系统中，一个环节的失误可能引发连锁反应，而简单系统的容错性更强。</li>
<li><strong>提升效率</strong>：无论是设计、执行还是维护，简单的方案往往更省时省力。</li>
</ul>
<p><strong>注意：简单≠简陋</strong></p>
<p>KISS 原则并非追求 “粗制滥造”，而是在<strong>满足核心需求的前提下，去除不必要的复杂</strong>。例如：一款优秀的工具，既能解决问题，又不会让用户为多余的功能付费或学习 —— 这才是 “简单” 的真正价值。</p>
<p>正如爱因斯坦所说：“<strong>凡事应该力求简单，直到不能再简单为止</strong>”（Everything should be made as simple as possible, but not simpler.），KISS 原则的本质，正是这种 “恰到好处的简单”。</p>
</blockquote>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-07-11_17-00-30.png" alt=""></p>
<h2 id="一、设计原则与思想：面向对象">一、设计原则与思想：面向对象</h2>
<h3 id="1-1-golang中的面向对象">1.1 golang中的面向对象</h3>
<blockquote>
<p><strong>按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。</strong></p>
<p>解释：以go为例，go没有继承的概念，却可以实现面向对象的开发风格效果，所以会反映到上面这句话。其实归根到底这是面向对象编程这种编程范式或编程风格<strong>没有一个统一的定义</strong>。</p>
</blockquote>
<p>我对golang的面向对象的理解如下：</p>
<p><strong>（一）封装</strong></p>
<ol>
<li>实现结构体</li>
<li>实现结构体方法</li>
</ol>
<br>
<p><strong>（二）抽象</strong></p>
<p>定义接口</p>
<br>
<p><strong>（三）继承</strong></p>
<p>嵌套/组合结构体</p>
<br>
<p><strong>（四）多态</strong></p>
<p>结构体实现接口方法</p>
<p>使用方式一：直接NewFun()的时候返回接口类型（推荐，更好的屏蔽细节）<br>
使用方式二：NewFun()的时候返回的是结构体类型，最后参数是接口类型</p>
<br>
<p>总结c++（使用抽象类实现接口效果）, java（原生接口语法）, golang（原生接口语法）, 这些静态语言的面向对象玩法都差不多。python, js这样的动态语言略微不同，这是由动态语言特性带来的，例如不需要显式的抽象和多态，直接借助duck-typing的特性可以轻松实现。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">duck-typing来隐式实现抽象和多态的实例 </summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">record</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(“I write a log into file.”)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DB</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">record</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(“I insert data into db. ”)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">recorder</span>):<br>    recorder.record()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    logger = Logger()<br>    db = DB()<br>    test(logger)<br>    test(db)<br></code></pre></td></tr></table></figure>
</div></details> 
<hr>
<p><br><br><br></p>
<h3 id="1-2-三大特性？四大特性？（pending）">1.2 三大特性？四大特性？（pending）</h3>
<p>目前对于面向对象特性的总结存在分歧</p>
<p>观点一：三大特性</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<p>观点二：四大特性</p>
<ol>
<li>继承</li>
<li><strong>抽象</strong></li>
<li>继承</li>
<li>多态</li>
</ol>
<p>为什么会有这种分歧呢？抽象为什么可以排除在面向对象编程特性之外呢？</p>
<hr>
<p><br><br><br></p>
<h3 id="1-3-看似面向对象，实则面向过程？">1.3 看似面向对象，实则面向过程？</h3>
<p><strong>（一）滥用getter、setter方法</strong> （顺手加上 或者 IDE插件自动生成）</p>
<p>非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。</p>
<p><strong>推荐做法：非必要不添加</strong></p>
<br>
<p><strong>（二）滥用全局变量和全局方法</strong></p>
<br>
<p><strong>（三）定义数据和方法分离的类</strong></p>
<p>传统的MVC结构分为Model层、Controller层、View层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。而在每一层中，我们又会定义相应的VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。这就是典型的面向过程的编程风格。</p>
<p>实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种Web项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分Web项目都是基于这种开发模式来开发呢？</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">贫血模型与充血模型（觉得抽象可以看下一个例子） </summary><div class="toggle-content"><p>在面向对象编程和软件架构中，“贫血模型”（Anemic Domain Model）和 “充血模型”（Rich Domain Model）是两种对立的领域模型设计风格，核心区别在于<strong>数据与业务逻辑的封装方式</strong>。这两个概念由计算机科学家马丁・福勒（Martin Fowler）提出，用于描述业务对象（如 BO、Domain 类）的设计模式。</p>
<p><strong>一、贫血模型（Anemic Domain Model）</strong></p>
<p><strong>定义</strong>：贫血模型是指业务对象仅包含数据（成员变量）和简单的 get/set 方法，不包含任何业务逻辑，所有业务逻辑都被转移到独立的服务类（如 Service 类）中。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>数据与逻辑分离</strong>：对象只 “装数据”，不 “做事情”，业务逻辑集中在 Service 层。</li>
<li><strong>违背面向对象封装性</strong>：面向对象的核心是 “数据与行为绑定”，而贫血模型更像 “结构化编程” 的延续（将数据和函数分开）。</li>
<li><strong>常见于传统分层架构</strong>：例如在基于 MVC 的传统开发中，BO（业务对象）通常是贫血模型，Service 类负责所有业务处理。</li>
</ul>
<p><strong>举例：</strong></p>
<p>一个 “订单” 贫血模型可能长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 贫血模型的订单BO</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderBO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-comment">// 只有get/set方法，无业务逻辑</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getOrderId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> orderId; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderId</span><span class="hljs-params">(Long orderId)</span> &#123; <span class="hljs-built_in">this</span>.orderId = orderId; &#125;<br>    <span class="hljs-comment">// ...其他get/set方法</span><br>&#125;<br><br><span class="hljs-comment">// 业务逻辑全部在Service中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">// 计算订单金额（业务逻辑）</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculateAmount</span><span class="hljs-params">(OrderBO order)</span> &#123; ... &#125;<br>    <span class="hljs-comment">// 变更订单状态（业务逻辑）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStatus</span><span class="hljs-params">(OrderBO order, String newStatus)</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>二、充血模型（Rich Domain Model）</strong></p>
<p><strong>定义</strong>：充血模型是指业务对象既包含数据，又包含与自身相关的业务逻辑，业务逻辑被 “封装” 在对象内部，服务类（Service）仅负责协调和编排，不处理具体业务细节。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>数据与逻辑绑定</strong>：对象既 “装数据”，也 “做事情”，符合面向对象的 “封装” 特性（对象自己管理自己的状态和行为）。</li>
<li><strong>服务类简化</strong>：Service 层不再包含复杂业务逻辑，主要负责调用领域对象的方法、处理跨领域协作或外部依赖（如数据库、第三方服务）。</li>
<li><strong>常见于 DDD（领域驱动设计）</strong>：在 DDD 中，Domain 类（领域对象）通常是充血模型，是业务逻辑的核心载体。</li>
</ul>
<p><strong>举例：</strong></p>
<p>同一个 “订单” 的充血模型可能长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 充血模型的订单Domain类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-comment">// 包含业务逻辑：计算金额</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculateAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 逻辑内置于对象中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.amount.multiply(<span class="hljs-comment">/* 折扣规则 */</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 包含业务逻辑：变更状态（自带校验）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStatus</span><span class="hljs-params">(String newStatus)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isValidStatus(newStatus)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;无效状态&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.status = newStatus;<br>    &#125;<br><br>    <span class="hljs-comment">// 私有辅助方法（封装细节）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidStatus</span><span class="hljs-params">(String status)</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// get方法保留（可能不提供set方法，避免外部随意修改）</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getOrderId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> orderId; &#125;<br>&#125;<br><br><span class="hljs-comment">// Service层仅负责协调，不处理具体业务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// 调用领域对象的方法完成业务</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">finalAmount</span> <span class="hljs-operator">=</span> order.calculateAmount();<br>        order.updateStatus(<span class="hljs-string">&quot;已处理&quot;</span>);<br>        <span class="hljs-comment">// 处理跨领域协作或持久化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>三、为什么叫 “贫血” 和 “充血”？</strong></p>
<p>这两个名字是一种形象的比喻：</p>
<ul>
<li><strong>贫血</strong>：形容对象 “没有灵魂”，只有空壳数据，缺乏业务行为能力，如同 “贫血” 的人没有活力。</li>
<li><strong>充血</strong>：形容对象 “充满活力”，不仅有数据，还有处理自身业务的能力，如同 “充血” 的组织有旺盛的功能。</li>
</ul>
<p><strong>四、两种模型的适用场景</strong></p>
<ul>
<li><strong>贫血模型</strong>：适合简单业务系统，开发速度快，易于理解（尤其是团队熟悉结构化思维时），但业务复杂后会导致 Service 类臃肿、逻辑分散。</li>
<li><strong>充血模型</strong>：适合复杂业务系统（如金融、电商核心业务），通过封装提高代码复用性和可维护性，更符合面向对象设计，但对开发者的业务理解和面向对象功底要求较高。</li>
</ul>
<p>总之，两种模型没有绝对优劣，选择取决于业务复杂度、团队技术栈和开发习惯。DDD 推崇充血模型，正是因为它能更好地应对复杂业务领域的设计挑战。</p>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">贫血模型与充血模型处理http请求逻辑 </summary><div class="toggle-content"><p>我们可以通过一个 “用户下单” 的 HTTP 请求场景，分别用<strong>贫血模型</strong>和<strong>充血模型</strong>的处理流程来对比，直观理解两种模式的差异。</p>
<p><strong>场景说明</strong></p>
<p>假设我们有一个电商系统，客户端发送一个创建订单的 HTTP 请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http">POST /api/orders<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><br>&#123;<br>  &quot;userId&quot;: 1001,<br>  &quot;productIds&quot;: [101, 102],  // 商品ID列表<br>  &quot;couponId&quot;: 501             // 优惠券ID（可选）<br>&#125;<br></code></pre></td></tr></table></figure>
<p>系统需要完成的业务逻辑：</p>
<ol>
<li>校验商品库存是否充足；</li>
<li>根据商品价格和优惠券计算最终订单金额；</li>
<li>生成订单并保存到数据库；</li>
<li>返回订单 ID 和最终金额。</li>
</ol>
<br>
<p><strong>一、贫血模型的处理流程</strong></p>
<p>在贫血模型中，<strong>数据（OrderBO）和业务逻辑（OrderService）完全分离</strong>，流程如下：</p>
<ol>
<li><strong>Controller 层接收请求</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/api/orders&quot;)</span><br>    <span class="hljs-keyword">public</span> OrderResponse <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderRequest request)</span> &#123;<br>        <span class="hljs-comment">// 1. 将请求参数转换为贫血模型的BO（仅含数据）</span><br>        <span class="hljs-type">OrderBO</span> <span class="hljs-variable">orderBO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBO</span>();<br>        orderBO.setUserId(request.getUserId());<br>        orderBO.setProductIds(request.getProductIds());<br>        orderBO.setCouponId(request.getCouponId());<br><br>        <span class="hljs-comment">// 2. 调用Service处理所有业务逻辑</span><br>        <span class="hljs-type">OrderBO</span> <span class="hljs-variable">resultBO</span> <span class="hljs-operator">=</span> orderService.createOrder(orderBO);<br><br>        <span class="hljs-comment">// 3. 转换为响应返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderResponse</span>(resultBO.getOrderId(), resultBO.getFinalAmount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>贫血模型的 OrderBO（仅含数据）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 贫血模型：只有数据和get/set，无任何业务逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderBO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br>    <span class="hljs-keyword">private</span> Long userId;<br>    <span class="hljs-keyword">private</span> List&lt;Long&gt; productIds;<br>    <span class="hljs-keyword">private</span> Long couponId;<br>    <span class="hljs-keyword">private</span> BigDecimal finalAmount;<br><br>    <span class="hljs-comment">// 仅get/set方法，无业务逻辑</span><br>    <span class="hljs-comment">// ...省略get/set</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>Service 层集中处理所有业务逻辑</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductRepository productRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CouponRepository couponRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepo;<br><br>    <span class="hljs-keyword">public</span> OrderBO <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderBO orderBO)</span> &#123;<br>        <span class="hljs-comment">// 1. 校验商品库存（业务逻辑1）</span><br>        <span class="hljs-keyword">for</span> (Long productId : orderBO.getProductIds()) &#123;<br>            <span class="hljs-type">ProductPO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productRepo.findById(productId);<br>            <span class="hljs-keyword">if</span> (product.getStock() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;商品&quot;</span> + productId + <span class="hljs-string">&quot;库存不足&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 计算订单金额（业务逻辑2）</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> BigDecimal.ZERO;<br>        <span class="hljs-keyword">for</span> (Long productId : orderBO.getProductIds()) &#123;<br>            total = total.add(productRepo.findById(productId).getPrice());<br>        &#125;<br>        <span class="hljs-comment">// 应用优惠券折扣</span><br>        <span class="hljs-keyword">if</span> (orderBO.getCouponId() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">CouponPO</span> <span class="hljs-variable">coupon</span> <span class="hljs-operator">=</span> couponRepo.findById(orderBO.getCouponId());<br>            total = total.subtract(coupon.getDiscount());<br>        &#125;<br>        orderBO.setFinalAmount(total);<br><br>        <span class="hljs-comment">// 3. 生成订单并保存（业务逻辑3）</span><br>        orderBO.setOrderId(generateOrderId());<br>        orderRepo.save(convertBOToPO(orderBO));<br><br>        <span class="hljs-keyword">return</span> orderBO;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他辅助方法（如ID生成、BO转PO等）</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心特点</strong>：所有业务逻辑都在 Service 中，OrderBO 仅作为 “数据容器” 传递，自身不做任何决策。</p>
<br>
<p><strong>二、充血模型（DDD 模式）的处理流程</strong></p>
<p>在充血模型中，<strong>数据（Order 领域对象）和业务逻辑被封装在一起</strong>，Service 仅负责协调，流程如下：</p>
<ol>
<li><strong>Controller 层接收请求（与贫血模型类似，但传递的是领域对象）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/api/orders&quot;)</span><br>    <span class="hljs-keyword">public</span> OrderResponse <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderRequest request)</span> &#123;<br>        <span class="hljs-comment">// 1. 直接创建领域对象（充血模型，含数据和行为）</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setUserId(request.getUserId());<br>        order.setProductIds(request.getProductIds());<br>        order.setCouponId(request.getCouponId());<br><br>        <span class="hljs-comment">// 2. 调用Service协调处理（Service逻辑简化）</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">resultOrder</span> <span class="hljs-operator">=</span> orderService.createOrder(order);<br><br>        <span class="hljs-comment">// 3. 转换为响应返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderResponse</span>(resultOrder.getOrderId(), resultOrder.getFinalAmount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>充血模型的 Order 领域对象（含数据和业务逻辑）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 充血模型：数据+业务逻辑封装在一起</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br>    <span class="hljs-keyword">private</span> Long userId;<br>    <span class="hljs-keyword">private</span> List&lt;Long&gt; productIds;<br>    <span class="hljs-keyword">private</span> Long couponId;<br>    <span class="hljs-keyword">private</span> BigDecimal finalAmount;<br><br>    <span class="hljs-comment">// 业务逻辑1：校验商品库存（自己处理与自身相关的逻辑）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateStock</span><span class="hljs-params">(ProductRepository productRepo)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Long productId : productIds) &#123;<br>            <span class="hljs-type">ProductPO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productRepo.findById(productId);<br>            <span class="hljs-keyword">if</span> (product.getStock() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;商品&quot;</span> + productId + <span class="hljs-string">&quot;库存不足&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 业务逻辑2：计算最终金额（自己管理金额计算规则）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateFinalAmount</span><span class="hljs-params">(ProductRepository productRepo, CouponRepository couponRepo)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> BigDecimal.ZERO;<br>        <span class="hljs-keyword">for</span> (Long productId : productIds) &#123;<br>            total = total.add(productRepo.findById(productId).getPrice());<br>        &#125;<br>        <span class="hljs-comment">// 应用优惠券</span><br>        <span class="hljs-keyword">if</span> (couponId != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">CouponPO</span> <span class="hljs-variable">coupon</span> <span class="hljs-operator">=</span> couponRepo.findById(couponId);<br>            total = total.subtract(coupon.getDiscount());<br>        &#125;<br>        <span class="hljs-built_in">this</span>.finalAmount = total;<br>    &#125;<br><br>    <span class="hljs-comment">// 业务逻辑3：生成订单ID（自己管理ID生成规则）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateOrderId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = System.currentTimeMillis() + RandomUtils.nextInt(<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// get方法保留（可能限制set方法，避免外部随意修改状态）</span><br>    <span class="hljs-comment">// ...省略get方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>Service 层仅负责协调（不再处理具体业务逻辑）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductRepository productRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CouponRepository couponRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepo;<br><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// 1. 调用领域对象自身的方法处理业务逻辑</span><br>        order.validateStock(productRepo);       <span class="hljs-comment">// 校验库存（Order自己实现）</span><br>        order.calculateFinalAmount(productRepo, couponRepo);  <span class="hljs-comment">// 计算金额（Order自己实现）</span><br>        order.generateOrderId();                <span class="hljs-comment">// 生成ID（Order自己实现）</span><br><br>        <span class="hljs-comment">// 2. 仅负责跨依赖协调（如保存数据库）</span><br>        orderRepo.save(convertDomainToPO(order));<br><br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心特点</strong>：Order 领域对象自己 “做主”，包含与自身相关的业务逻辑（校验库存、计算金额等），Service 仅负责调用领域对象的方法并处理外部依赖（如数据库操作）。</p>
<br>
<p><strong>两种模式的核心差异对比</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>贫血模型</th>
<th>充血模型（DDD）</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务逻辑存放位置</td>
<td>集中在 Service 类中</td>
<td>封装在领域对象（如 Order）中</td>
</tr>
<tr>
<td>对象角色</td>
<td>仅作为数据容器（“哑巴对象”）</td>
<td>既是数据载体，也是业务逻辑执行者</td>
</tr>
<tr>
<td>Service 层职责</td>
<td>处理所有业务逻辑，代码可能臃肿</td>
<td>仅协调领域对象，逻辑简单</td>
</tr>
<tr>
<td>面向对象特性</td>
<td>违背封装（数据与行为分离）</td>
<td>符合封装（数据与行为绑定）</td>
</tr>
</tbody>
</table>
<p>通过 HTTP 请求的处理流程可以看出：<strong>贫血模型更像 “procedural（过程式）” 编程，而充血模型更符合 “object-oriented（面向对象）” 编程的初衷</strong>。在复杂业务场景中，充血模型能让代码更易维护（业务逻辑跟着数据走），而简单场景下贫血模型更直观。</p>
</div></details>
<br>
<p><strong>（三）啥都往同一个接口里面塞，完全不拆分</strong></p>
<p>在go中，最典型的就是对数据库操作抽象出来的一个接口，随着业务越来越复杂，这个接口越来越大，最后也就只起到一个封装的效果，多态式完全不可能的了（定义一个新的结构能够实现这么多方法基本不可能，这是我现在接受业务中代码设计的一个问题）</p>
<p>还是建议按照功能模块拆分一下的。</p>
<hr>
<p><br><br><br></p>
<h3 id="1-4-多用组合少用继承">1.4 多用组合少用继承</h3>
<p>在面向对象编程中，有一条非常经典的设计原则，那就是：<strong>组合优于继承，多用组合少用继承。</strong></p>
<p>go天然就没有继承的概念，只能组合～</p>
<br>
<p><strong>1.为什么不推荐使用继承？</strong></p>
<p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p>
<p><strong>2.组合相比继承有哪些优势？</strong></p>
<p>继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<p><strong>3.如何判断该用组合还是继承？</strong></p>
<p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<hr>
<p><br><br><br></p>
<h3 id="1-5-业务开发常用的基于贫血模型的MVC架构违背OOP吗？（摘抄）">1.5 业务开发常用的基于贫血模型的MVC架构违背OOP吗？（摘抄）</h3>
<p>很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的MVC三层架构开发模式。</p>
<p>虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F">反模式（anti-pattern）</a>。特别是<strong>领域驱动设计</strong>（Domain Driven Design，简称DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的DDD开发模式越来越被人提倡。所以，我打算用两节课的时间，结合一个虚拟钱包系统的开发案例，带你彻底弄清楚这两种开发模式。</p>
<p>考虑到你有可能不太了解我刚刚提到的这几个概念，所以，在正式进入实战项目的讲解之前，我先带你搞清楚下面几个问题：</p>
<ul>
<li>什么是贫血模型？什么是充血模型？</li>
<li>为什么说基于贫血模型的传统开发模式违反OOP?</li>
<li>基于贫血模型的传统开发模式既然违反OOP，那又为什么如此流行？</li>
<li>什么情况下我们应该考虑使用基于充血模型的DDD开发模式？</li>
</ul>
<p>好了，让我们带着这些问题，正式开始今天的学习吧！</p>
<br>
<p><strong>什么是基于贫血模型的传统开发模式？</strong></p>
<p>我相信，对于大部分的后端开发工程师来说，MVC三层架构都不会陌生。不过，为了统一我们之间对MVC的认识，我还是带你一块来回顾一下，什么是MVC三层架构。</p>
<p>MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会100%遵从MVC固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">mvc科普 </summary><div class="toggle-content"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mx4y1G7Hj/?share_source=copy_web&amp;vd_source=c0ee1246bfa2d7d9c98d48faf5bcd9fa">bilibili视频链接</a></p>
<p>模型：处理数据验证、逻辑、持久性</p>
<p>控制器：在模型和视图之间传递数据</p>
<p>视图：用于处理怎样显示信息</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-07-13_20-31-27.png" alt="img"></p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-07-13_20-36-07.png" alt="img"></p>
</div></details>
<p>比如，现在很多Web或者App项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为<strong>Repository层、Service层、Controller层</strong>。其中，<strong>Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口</strong>（也就是model层细分了一下，然后去掉view层）。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。</p>
<p>刚刚我们回顾了MVC三层开发架构。现在，我们再来看一下，什么是贫血模型？</p>
<p>实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">////////// Controller+VO(View Object) //////////</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span><br>  <br>    <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Long userId)</span> &#123;<br>        <span class="hljs-type">UserBo</span> <span class="hljs-variable">userBo</span> <span class="hljs-operator">=</span> userService.getUserById(userId);<br>        <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> [...convert userBo to userVo...];<br>        <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVo</span> &#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String cellphone;<br>&#125;<br><br><span class="hljs-comment">////////// Service+BO(Business Object) //////////</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserRepository userRepository; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span><br>  <br>    <span class="hljs-keyword">public</span> UserBo <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Long userId)</span> &#123;<br>        <span class="hljs-type">UserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> userRepository.getUserById(userId);<br>        <span class="hljs-type">UserBo</span> <span class="hljs-variable">userBo</span> <span class="hljs-operator">=</span> [...convert userEntity to userBo...];<br>        <span class="hljs-keyword">return</span> userBo;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBo</span> &#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String cellphone;<br>&#125;<br><br><span class="hljs-comment">////////// Repository+Entity //////////</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> &#123;<br>    <span class="hljs-keyword">public</span> UserEntity <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Long userId)</span> &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String cellphone;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们平时开发Web后端项目的时候，基本上都是这么组织代码的。其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。</p>
<p>从代码中，我们可以发现，UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作<strong>贫血模型</strong>（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<br>
<p><strong>什么是基于充血模型的DDD开发模式？</strong></p>
<p>刚刚我们讲了基于贫血模型的传统的开发模式。现在我们再讲一下，另外一种最近更加被推崇的开发模式：基于充血模型的DDD开发模式。</p>
<p><strong>首先，我们先来看一下，什么是充血模型？</strong></p>
<p>在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型</strong>（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<p><strong>接下来，我们再来看一下，什么是领域驱动设计？</strong></p>
<p>领域驱动设计，即DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在2004年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。</p>
<p>我们知道，除了监控、调用链追踪、API网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。</p>
<p>不过，我个人觉得，领域驱动设计有点儿类似敏捷开发、SOA、PAAS等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。</p>
<p>实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在Service层。</p>
<p>在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型（<strong>BO, Business Object, 业务对象</strong> 是一个核心概念，主要用于承载业务数据和部分业务处理逻辑），只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，<strong>基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain</strong>。</p>
<p>基于充血模型的DDD设计模式的概念，今天我们只是简单地介绍了一下。在下一节课中，我会结合具体的项目，通过代码来给你展示，如何基于这种开发模式来开发一个系统。</p>
<br>
<p><strong>为什么基于贫血模型的传统开发模式如此受欢迎？</strong></p>
<p>前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了OOP的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的Web项目，都是基于这种贫血模型的开发模式，甚至连Java Spring框架的官方demo，都是按照这种开发模式来编写的。</p>
<p>我们前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，我总结了下面三点原因。</p>
<p>第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于SQL的CRUD操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p>
<p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要事先做太多设计。</p>
<p>第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有Web项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p>
<br>
<p><strong>什么项目应该考虑使用基于充血模型的DDD开发模式？</strong></p>
<p>既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的DDD开发模式呢？</p>
<p>刚刚我们讲到，基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的DDD开发模式就可以呢？</p>
<p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到Service层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的DDD开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p>
<p>不夸张地讲，我们平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。</p>
<p>业务逻辑包裹在一个大的SQL语句中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的SQL语句，这就可能导致各种长得差不多、区别很小的SQL语句满天飞。</p>
<p>所以，在这个过程中，很少有人会应用领域模型、OOP的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p>
<p>如果我们在项目中，应用基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p>
<p>我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的DDD开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p>
<br>
<p><strong>重点回顾</strong></p>
<p>今天的内容到此就讲完了，我们来一起回顾一下，你应该掌握的重点内容。</p>
<p>我们平时做Web项目的业务开发，大部分都是基于贫血模型的MVC三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的DDD开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的DDD开发模式，是典型的面向对象的编程风格。</p>
<p>不过，DDD也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的DDD开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的DDD开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p>
<br>
<p><strong>课堂讨论</strong></p>
<p>今天课堂讨论的话题有两个。</p>
<ol>
<li>你做经历的项目中，有哪些是基于贫血模型的传统的开发模式？有哪些是基于充血模型的DDD开发模式呢？请简单对比一下两者的优劣。</li>
<li>对于我们举的例子中，UserEntity、UserBo、UserVo包含的字段都差不多，是否可以合并为一个类呢？</li>
</ol>
<p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>
<hr>
<p><br><br><br></p>
<h2 id="二、设计原则与思想：设计原则">二、设计原则与思想：设计原则</h2>
<p><br><br><br></p>
<hr>
<h2 id="三、设计原则与思想：规范与重构">三、设计原则与思想：规范与重构</h2>
<p><br><br><br></p>
<h2 id="四、设计模式与范式：创建型">四、设计模式与范式：创建型</h2>
<blockquote>
<p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p>
</blockquote>
<h3 id="4-1-单例模式">4.1 单例模式</h3>
<blockquote>
<p>有人觉得&quot;饿汉式&quot;方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p>
<p>如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
</blockquote>
<p><strong>（一）饿汉式</strong></p>
<p>“饿” 体现了 “迫切、提前准备” 的状态 —— 就像一个饿了很久的人，会提前把食物准备好，不等别人索要就已经就绪。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// Singleton 饿汉式单例</span><br><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> singleton *Singleton<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    singleton = &amp;Singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// GetInstance 获取实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *Singleton &#123;<br>    <span class="hljs-keyword">return</span> singleton<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>（二）懒汉式</strong></p>
<p>“懒” 体现了 “拖延、按需行动” 的状态 —— 就像一个懒惰的人，不到万不得已不会主动做事，只有当别人明确要求时才动手。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    lazySingleton *Singleton<br>    once          sync.Once<br>)<br><br><span class="hljs-comment">// GetLazyInstance 懒汉式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLazyInstance</span><span class="hljs-params">()</span></span> *Singleton &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        lazySingleton = &amp;Singleton&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> lazySingleton<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>每个coroutine一个单例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 单例结构</span><br><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span> &#123;<br>    ID <span class="hljs-type">string</span> <span class="hljs-comment">// 用于标识不同实例</span><br>&#125;<br><br><span class="hljs-comment">// 私有类型，用作上下文键，避免冲突</span><br><span class="hljs-keyword">type</span> singletonKey <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 将单例实例绑定到上下文中（如果不存在）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSingleton</span><span class="hljs-params">(ctx context.Context)</span></span> context.Context &#123;<br>    <span class="hljs-comment">// 检查上下文中是否已有实例</span><br>    <span class="hljs-keyword">if</span> _, ok := ctx.Value(singletonKey&#123;&#125;).(*Singleton); ok &#123;<br>        <span class="hljs-keyword">return</span> ctx <span class="hljs-comment">// 已有实例，直接返回</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建新实例并绑定到上下文中</span><br>    <span class="hljs-keyword">return</span> context.WithValue(ctx, singletonKey&#123;&#125;, &amp;Singleton&#123;<br>        ID: generateUniqueID(), <span class="hljs-comment">// 生成唯一ID用于标识实例</span><br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 从上下文中获取单例实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetSingleton</span><span class="hljs-params">(ctx context.Context)</span></span> *Singleton &#123;<br>    <span class="hljs-keyword">if</span> s, ok := ctx.Value(singletonKey&#123;&#125;).(*Singleton); ok &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;singleton not found in context&quot;</span>) <span class="hljs-comment">// 或者返回 nil，根据需求决定</span><br>&#125;<br><br><span class="hljs-comment">// 生成唯一ID（简化实现）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateUniqueID</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, time.Now().UnixNano())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    baseCtx := context.Background()<br>    <br>    <span class="hljs-comment">// 启动多个goroutine测试</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(goroutineID <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <br>            <span class="hljs-comment">// 为每个goroutine创建独立上下文</span><br>            ctx := WithSingleton(baseCtx)<br>            <br>            <span class="hljs-comment">// 同一个goroutine多次获取应该得到相同实例</span><br>            s1 := GetSingleton(ctx)<br>            s2 := GetSingleton(ctx)<br>            <br>            fmt.Printf(<span class="hljs-string">&quot;Goroutine %d: s1.ID=%s, s2.ID=%s, same instance: %v\n&quot;</span>,<br>                goroutineID, s1.ID, s2.ID, s1 == s2)<br>            <br>            <span class="hljs-comment">// 验证上下文唯一性：再次调用 WithSingleton 不会创建新实例</span><br>            ctx = WithSingleton(ctx)<br>            s3 := GetSingleton(ctx)<br>            fmt.Printf(<span class="hljs-string">&quot;Goroutine %d after re-wrap: s3.ID=%s, same instance: %v\n&quot;</span>,<br>                goroutineID, s3.ID, s1 == s3)<br>        &#125;(i)<br>    &#125;<br>    <br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。所以，今天，我就针对这个说法详细地讲讲这几个问题：单例这种设计模式存在哪些问题？为什么会被称为反模式？如果不用单例，该如何表示全局唯一类？有何替代的解决方案？</p>
<p><strong>单例存在哪些问题?</strong></p>
<ol>
<li><u>单例对OOP特性的支持不友好</u><br>
一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</li>
<li><u>单例会隐藏类之间的依赖关系</u><br>
因为直接使用即可</li>
<li><u>单例对代码的扩展性不友好</u></li>
<li><u>单例对代码的可测试性不友好</u></li>
<li><u>单例不支持有参数的构造函数</u></li>
</ol>
<p><strong>有何替代解决方案？</strong></p>
<p>看着没啥好办法，接着用吧。</p>
<p><strong>多例模式</strong></p>
<p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建3个对象。多例的实现也比较简单，通过一个Map来存储对象类型和对象之间的对应关系，来控制对象的个数。</p>
<hr>
<p><br><br><br></p>
<h3 id="4-2-工厂模式">4.2 工厂模式</h3>
<blockquote>
<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见。</p>
<p>重点是搞清楚应用场景：<strong>什么时候该用工厂模式？相对于直接new来创建对象，用工厂模式来创建究竟有什么好处呢</strong>？</p>
</blockquote>
<h4 id="4-2-1-工厂模式">4.2.1 工厂模式</h4>
<p><strong>简单工厂（Simple Factory）</strong></p>
<p>由于 Go 本身是没有构造函数的，一般而言我们采用 <code>NewName</code> 的方式创建对象/接口，当它<strong>返回的是接口</strong>的时候，其实就是简单工厂模式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;gopkg.in/yaml.v3&quot;</span><br>)<br><br><span class="hljs-comment">// IRuleConfigParser 配置解析器接口</span><br><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;<br>    Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// JsonRuleConfigParser JSON配置解析器</span><br><span class="hljs-keyword">type</span> JsonRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse 解析JSON数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j JsonRuleConfigParser)</span></span> Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> result <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">return</span> json.Unmarshal(data, &amp;result)<br>&#125;<br><br><span class="hljs-comment">// YamlRuleConfigParser YAML配置解析器</span><br><span class="hljs-keyword">type</span> YamlRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse 解析YAML数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y YamlRuleConfigParser)</span></span> Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> result <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">return</span> yaml.Unmarshal(data, &amp;result)<br>&#125;<br><br><span class="hljs-comment">// NewIRuleConfigParser 创建配置解析器的工厂方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParser</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> (IRuleConfigParser, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">switch</span> t &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:<br>        <span class="hljs-keyword">return</span> JsonRuleConfigParser&#123;&#125;, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;yaml&quot;</span>:<br>        <span class="hljs-keyword">return</span> YamlRuleConfigParser&#123;&#125;, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unsupported parser type: %s&quot;</span>, t)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br><br></p>
<p><strong>工厂方法</strong></p>
<p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 产品接口</span><br><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;<br>    Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// 具体产品</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParser)</span></span> Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">/* 解析JSON */</span> &#125;<br><br><span class="hljs-keyword">type</span> yamlRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yamlRuleConfigParser)</span></span> Parse(data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">/* 解析YAML */</span> &#125;<br><br><span class="hljs-comment">// 抽象工厂接口</span><br><span class="hljs-keyword">type</span> IRuleConfigParserFactory <span class="hljs-keyword">interface</span> &#123;<br>    CreateParser() IRuleConfigParser<br>&#125;<br><br><span class="hljs-comment">// 具体工厂类</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParserFactory <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParserFactory)</span></span> CreateParser() IRuleConfigParser &#123;<br>    <span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> yamlRuleConfigParserFactory <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yamlRuleConfigParserFactory)</span></span> CreateParser() IRuleConfigParser &#123;<br>    <span class="hljs-keyword">return</span> yamlRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 简单工厂（！！可选！！但推荐）：封装工厂方法的选择逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParserFactory</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> IRuleConfigParserFactory &#123;<br>    <span class="hljs-keyword">switch</span> t &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:<br>        <span class="hljs-keyword">return</span> jsonRuleConfigParserFactory&#123;&#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;yaml&quot;</span>:<br>        <span class="hljs-keyword">return</span> yamlRuleConfigParserFactory&#123;&#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>工厂方法 vs 简单工厂</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>简单工厂</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心类</td>
<td>一个工厂类负责所有产品的创建</td>
<td>一个抽象工厂接口和多个具体工厂类</td>
</tr>
<tr>
<td>新增产品</td>
<td>修改工厂类，违反开闭原则</td>
<td>添加新的具体工厂类，符合开闭原则</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单，适合创建逻辑简单的场景</td>
<td>复杂，适合创建逻辑复杂的场景</td>
</tr>
</tbody>
</table>
<br>
<p>个人感觉：没必要纠结工厂方法，这还不如简单工厂…即没有可读性，还没有使代码的到优化；怎么说的，就好像开发了一半，发现是错的，但是不承认，强行赋予意义。🤡</p>
<p><br><br></p>
<p><strong>抽象工厂</strong></p>
<p>假设你正在开发一个跨平台应用，需要支持 Windows、Linux、macOS 三种操作系统，每种系统都有不同的 UI 组件（按钮、文本框、对话框等）。你希望代码能根据当前系统自动创建对应的 UI 组件，同时保持组件之间的一致性（比如 Windows 风格的按钮只能和 Windows 风格的文本框搭配）。</p>
<p>这种场景下，抽象工厂模式就很合适：它定义一个 “工厂” 接口，负责创建一组相关产品（如按钮 + 文本框），而具体实现由子类（如 Windows 工厂、Linux 工厂）完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-comment">// IRuleConfigParser IRuleConfigParser</span><br><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;<br>    Parse(data []<span class="hljs-type">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// jsonRuleConfigParser jsonRuleConfigParser</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParser)</span></span> Parse(data []<span class="hljs-type">byte</span>) &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// ISystemConfigParser ISystemConfigParser</span><br><span class="hljs-keyword">type</span> ISystemConfigParser <span class="hljs-keyword">interface</span> &#123;<br>    ParseSystem(data []<span class="hljs-type">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// jsonSystemConfigParser jsonSystemConfigParser</span><br><span class="hljs-keyword">type</span> jsonSystemConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonSystemConfigParser)</span></span> ParseSystem(data []<span class="hljs-type">byte</span>) &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// IConfigParserFactory 工厂方法接口</span><br><span class="hljs-keyword">type</span> IConfigParserFactory <span class="hljs-keyword">interface</span> &#123;<br>    CreateRuleParser() IRuleConfigParser<br>    CreateSystemParser() ISystemConfigParser<br>&#125;<br><br><span class="hljs-keyword">type</span> jsonConfigParserFactory <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span></span> CreateRuleParser() IRuleConfigParser &#123;<br>    <span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span></span> CreateSystemParser() ISystemConfigParser &#123;<br>    <span class="hljs-keyword">return</span> jsonSystemConfigParser&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h4 id="4-2-2-Dependency-Injection框架">4.2.2 Dependency Injection框架</h4>
<p>golang 现有的依赖注入框架:</p>
<ul>
<li>使用反射实现的: <a target="_blank" rel="noopener" href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a></li>
<li>使用 generate 实现的: <a target="_blank" rel="noopener" href="https://github.com/google/wire">https://github.com/google/wire</a>  参考: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/taoxiaoxin/p/18119294">https://www.cnblogs.com/taoxiaoxin/p/18119294</a></li>
</ul>
<hr>
<br>
<p><br><br></p>
<h3 id="4-3-建造者模式">4.3 建造者模式</h3>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-07-15_17-07-48.png" alt=""></p>
<p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>
本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p>
<br>
<p><strong>建造者模式</strong></p>
<p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下，<strong>一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">const</span> (<br>    defaultMaxTotal = <span class="hljs-number">10</span><br>    defaultMaxIdle  = <span class="hljs-number">9</span><br>    defaultMinIdle  = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-comment">// ResourcePoolConfig resource pool</span><br><span class="hljs-keyword">type</span> ResourcePoolConfig <span class="hljs-keyword">struct</span> &#123;<br>    name     <span class="hljs-type">string</span><br>    maxTotal <span class="hljs-type">int</span><br>    maxIdle  <span class="hljs-type">int</span><br>    minIdle  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigBuilder <span class="hljs-keyword">struct</span> &#123;<br>    name     <span class="hljs-type">string</span><br>    maxTotal <span class="hljs-type">int</span><br>    maxIdle  <span class="hljs-type">int</span><br>    minIdle  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// SetName SetName</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>    &#125;<br>    b.name = name<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMinIdle SetMinIdle</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span></span> SetMinIdle(minIdle <span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> minIdle &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, minIdle)<br>    &#125;<br>    b.minIdle = minIdle<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMaxIdle SetMaxIdle</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxIdle(maxIdle <span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> maxIdle &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, maxIdle)<br>    &#125;<br>    b.maxIdle = maxIdle<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMaxTotal SetMaxTotal</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxTotal(maxTotal <span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> maxTotal &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt;= 0, input: %d&quot;</span>, maxTotal)<br>    &#125;<br>    b.maxTotal = maxTotal<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Build Build</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span></span> Build() (*ResourcePoolConfig, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> b.name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 设置默认值</span><br>    <span class="hljs-keyword">if</span> b.minIdle == <span class="hljs-number">0</span> &#123;<br>        b.minIdle = defaultMinIdle<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> b.maxIdle == <span class="hljs-number">0</span> &#123;<br>        b.maxIdle = defaultMaxIdle<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> b.maxTotal == <span class="hljs-number">0</span> &#123;<br>        b.maxTotal = defaultMaxTotal<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;max total(%d) cannot &lt; max idle(%d)&quot;</span>, b.maxTotal, b.maxIdle)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> b.minIdle &gt; b.maxIdle &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;max idle(%d) cannot &lt; min idle(%d)&quot;</span>, b.maxIdle, b.minIdle)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;<br>        name:     b.name,<br>        maxTotal: b.maxTotal,<br>        maxIdle:  b.maxIdle,<br>        minIdle:  b.minIdle,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>Go 常用的参数传递方法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ResourcePoolConfigOption option</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigOption <span class="hljs-keyword">struct</span> &#123;<br>    maxTotal <span class="hljs-type">int</span><br>    maxIdle  <span class="hljs-type">int</span><br>    minIdle  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// ResourcePoolConfigOptFunc to set option</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigOptFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *ResourcePoolConfigOption)</span></span><br><br><span class="hljs-comment">// NewResourcePoolConfig NewResourcePoolConfig</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResourcePoolConfig</span><span class="hljs-params">(name <span class="hljs-type">string</span>, opts ...ResourcePoolConfigOptFunc)</span></span> (*ResourcePoolConfig, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>    &#125;<br><br>    option := &amp;ResourcePoolConfigOption&#123;<br>        maxTotal: <span class="hljs-number">10</span>,<br>        maxIdle:  <span class="hljs-number">9</span>,<br>        minIdle:  <span class="hljs-number">1</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts &#123;<br>        opt(option)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> option.maxTotal &lt; <span class="hljs-number">0</span> || option.maxIdle &lt; <span class="hljs-number">0</span> || option.minIdle &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;args err, option: %v&quot;</span>, option)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;args err, option: %v&quot;</span>, option)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;<br>        name:     name,<br>        maxTotal: option.maxTotal,<br>        maxIdle:  option.maxIdle,<br>        minIdle:  option.minIdle,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h3 id="4-4-原型模式">4.4 原型模式</h3>
<blockquote>
<ul>
<li>
<p>这个模式在 Java、C++ 这种面向对象的语言不太常用，但是如果大家使用过 javascript 的话就会非常熟悉了，因为 js 本身是基于原型的面向对象语言，所以原型模式在 js 中应用非常广泛。</p>
  <details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">解释 </summary><div class="toggle-content"><blockquote>
<pre><code>简单说：**原型模式的核心是 “基于已有对象复制出新对象”**，而 JavaScript、Python 这类语言的设计天然支持这种模式，所以用得多。

**为什么 JS、Python 中原型模式用得多？**

1. **语言层面直接支持 “对象克隆”**
    - JS 中，`Object.create(原型对象)` 可以直接基于一个已有对象（原型）创建新对象，新对象自动继承原型的属性和方法。
        例：`const newObj = Object.create(oldObj);` 新对象 `newObj` 会 “克隆” `oldObj` 的特性。
    - Python 中，虽然没有 “原型链”，但可以通过 `copy.copy()`（浅拷贝）、`copy.deepcopy()`（深拷贝）快速复制一个对象，本质就是原型模式的应用。
2. **动态特性允许 “原型随时修改”**
    - JS 和 Python 都是动态语言，对象的属性 / 方法可以在运行时动态添加或修改。
        比如 JS 中，给原型对象加一个方法，所有基于它创建的新对象都会立刻拥有这个方法，这正是原型模式 “用原型统一管理共性” 的核心思想。
3. **弱化 “类” 的概念，更依赖 “对象”**
    - Java、C++ 是 “基于类” 的语言：必须先定义类（模板），才能创建对象，对象的复制也依赖类的构造逻辑，原型模式用得少。
    - JS（ES6 前无类）、Python（类是动态的）更倾向于 “基于对象”：直接用现有对象当 “模板”（原型）复制新对象，不需要先定义类，原型模式自然成了常用手段。

**一句话总结**

JS、Python 中，**“拿一个现成对象当原型，复制出相似对象” 的操作太容易了**（语言直接提供 API），而且符合它们 “灵活、动态” 的设计理念，所以原型模式用得多。而 Java、C++ 更依赖 “类” 来创建对象，原型模式就显得没那么必要。
</code></pre>
</blockquote>
</div></details> 
</li>
<li>
<p>接下来会按照一个类似课程中的例子使用深拷贝和浅拷贝结合的方式进行实现</p>
</li>
<li>
<p>需求: 假设现在数据库中有大量数据，包含了关键词，关键词被搜索的次数等信息，模块 A 为了业务需要</p>
<ul>
<li>会在启动时加载这部分数据到内存中</li>
<li>并且需要定时更新里面的数据</li>
<li>同时展示给用户的数据每次必须要是相同版本的数据，不能一部分数据来自版本 1 一部分来自版本 2</li>
</ul>
</li>
</ul>
</blockquote>
<p>主要就是一个深拷贝的问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> prototype<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Keyword 搜索关键字</span><br><span class="hljs-keyword">type</span> Keyword <span class="hljs-keyword">struct</span> &#123;<br>    Word      *<span class="hljs-type">string</span>    <span class="hljs-string">`json:&quot;word&quot;`</span><br>    Visit     *<span class="hljs-type">int</span>       <span class="hljs-string">`json:&quot;visit&quot;`</span><br>    UpdatedAt time.Time <span class="hljs-string">`json:&quot;updatedAt&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Clone 这里使用序列化与反序列化的方式深拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k *Keyword)</span></span> Clone() *Keyword &#123;<br>    <span class="hljs-keyword">var</span> newKeyword Keyword<br>    b, err := json.Marshal(k)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    err = json.Unmarshal(b, &amp;newKeyword)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;newKeyword<br>&#125;<br><br><span class="hljs-comment">// Keywords 关键字 map</span><br><span class="hljs-keyword">type</span> Keywords <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Keyword<br><br><span class="hljs-comment">// Clone 复制一个新的 keywords</span><br><span class="hljs-comment">// updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(words Keywords)</span></span> Clone(updatedWords []*Keyword) Keywords &#123;<br>    newKeywords := Keywords&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> words &#123;<br>        <span class="hljs-comment">// 这里是浅拷贝，直接拷贝了地址</span><br>        newKeywords[k] = v<br>    &#125;<br><br>    <span class="hljs-comment">// 替换掉需要更新的字段，这里用的是深拷贝</span><br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> updatedWords &#123;<br>        <span class="hljs-keyword">if</span> word != <span class="hljs-literal">nil</span> &#123;<br>            newKeywords[word.Word] = word.Clone()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newKeywords<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h2 id="五、设计模式与范式：结构型">五、设计模式与范式：结构型</h2>
<blockquote>
<p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</p>
</blockquote>
<h3 id="5-1-代理模式">5.1 代理模式</h3>
<p><strong>代理模式</strong>（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p>grpc也使用了这个设计模式。</p>
<br>
<p><strong>静态代理</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// IUser IUser</span><br><span class="hljs-keyword">type</span> IUser <span class="hljs-keyword">interface</span> &#123;<br>    Login(username, password <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// User 用户</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// Login 用户登录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> Login(username, password <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 不实现细节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// UserProxy 代理类</span><br><span class="hljs-keyword">type</span> UserProxy <span class="hljs-keyword">struct</span> &#123;<br>    user *User<br>&#125;<br><br><span class="hljs-comment">// NewUserProxy NewUserProxy</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserProxy</span><span class="hljs-params">(user *User)</span></span> *UserProxy &#123;<br>    <span class="hljs-keyword">return</span> &amp;UserProxy&#123;<br>        user: user,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Login 登录，和 user 实现相同的接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *UserProxy)</span></span> Login(username, password <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// before 这里可能会有一些统计的逻辑</span><br>    start := time.Now()<br><br>    <span class="hljs-comment">// 这里是原有的业务逻辑</span><br>    <span class="hljs-keyword">if</span> err := p.user.Login(username, password); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// after 这里可能也有一些监控统计的逻辑</span><br>    log.Printf(<span class="hljs-string">&quot;user login cost time: %s&quot;</span>, time.Now().Sub(start))<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>动态代理</strong></p>
<p>动态代理的<strong>核心目的之一</strong>就是避免 “为每个接口、每个方法手动编写代理逻辑” 的重复劳动，实现 “一次编码，批量增强”。</p>
<p>go不好搞，放弃了</p>
<hr>
<p><br><br><br></p>
<h3 id="5-2-桥接模式">5.2 桥接模式</h3>
<p><strong>桥接模式</strong>，也叫作<strong>桥梁模式</strong>，英文是<strong>Bridge Design Pattern</strong>。这个模式可以说是23种设计模式中最难理解的模式之一。</p>
<p>用不上先忽略。</p>
<hr>
<p><br><br><br></p>
<h3 id="5-3-装饰器模式">5.3 装饰器模式</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.com">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.com/posts/47697/">https://gxblogs.com/posts/47697/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.com" target="_blank">GXBLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-03_16-16-49.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/39272/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-07_15-28-02.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jwt - go</div></div></a></div><div class="next-post pull-right"><a href="/posts/19502/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-08_10-26-59.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">connection pool</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/19502/" title="connection pool"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-08_10-26-59.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="title">connection pool</div></div></a></div><div><a href="/posts/45078/" title="go代码模块记录"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-03-20_10-54-38.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-22</div><div class="title">go代码模块记录</div></div></a></div><div><a href="/posts/14787/" title="Go‘s 数据结构"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-08-05_14-52-01.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="title">Go‘s 数据结构</div></div></a></div><div><a href="/posts/47995/" title="go编程规范"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-04-02_10-51-17.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-06</div><div class="title">go编程规范</div></div></a></div><div><a href="/posts/10689/" title="live reloading go with air"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-04-07_15-14-45.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="title">live reloading go with air</div></div></a></div><div><a href="/posts/51798/" title="pprof"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-08-28_22-00-26.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-29</div><div class="title">pprof</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">一、设计原则与思想：面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-golang%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1 golang中的面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%88pending%EF%BC%89"><span class="toc-text">1.2 三大特性？四大特性？（pending）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%9C%8B%E4%BC%BC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%9E%E5%88%99%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.3 看似面向对象，实则面向过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-text">1.4 多用组合少用继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E8%BF%9D%E8%83%8COOP%E5%90%97%EF%BC%9F%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89"><span class="toc-text">1.5 业务开发常用的基于贫血模型的MVC架构违背OOP吗？（摘抄）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">二、设计原则与思想：设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E8%A7%84%E8%8C%83%E4%B8%8E%E9%87%8D%E6%9E%84"><span class="toc-text">三、设计原则与思想：规范与重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="toc-text">四、设计模式与范式：创建型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1 单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2.1 工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Dependency-Injection%E6%A1%86%E6%9E%B6"><span class="toc-text">4.2.2 Dependency Injection框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.3 建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.4 原型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%EF%BC%9A%E7%BB%93%E6%9E%84%E5%9E%8B"><span class="toc-text">五、设计模式与范式：结构型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 装饰器模式</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/pluginsSrc/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>