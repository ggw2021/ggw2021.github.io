<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++笔记 | GXBLOGS</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="万能头： 1#include&lt;bits&#x2F;stdc++.h&gt;  C++基础知识 1. 常量 在C++中，常量是使用关键字const声明的，意味着一旦被赋值后，它的值就不能被改变。常量提供了一种保护变量不被无意或有意修改的方式，有助于提高程序的可读性和维护性。以下是一些关于C++常量的关键点：  基本常量   使用const关键字创建常量。 必须在声明时初始化。  1const int M">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="https://gxblogs.com/posts/34219/index.html">
<meta property="og:site_name" content="GXBLOGS">
<meta property="og:description" content="万能头： 1#include&lt;bits&#x2F;stdc++.h&gt;  C++基础知识 1. 常量 在C++中，常量是使用关键字const声明的，意味着一旦被赋值后，它的值就不能被改变。常量提供了一种保护变量不被无意或有意修改的方式，有助于提高程序的可读性和维护性。以下是一些关于C++常量的关键点：  基本常量   使用const关键字创建常量。 必须在声明时初始化。  1const int M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-17-22.png">
<meta property="article:published_time" content="2024-03-28T15:39:23.113Z">
<meta property="article:modified_time" content="2024-04-09T07:54:07.827Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-17-22.png"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.com/posts/34219/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: GXBLOGS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-09 15:54:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/highlight/Kimbiedark.css"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/gh/graingert/WOW@master/dist/wow.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="/static/imgs/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-17-22.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GXBLOGS</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-28T15:39:23.113Z" title="发表于 2024-03-28 23:39:23">2024-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-09T07:54:07.827Z" title="更新于 2024-04-09 15:54:07">2024-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">49.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>187分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/34219/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/34219/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>万能头</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br></code></pre></td></tr></table></figure>
<br>
<h2 id="C-基础知识">C++基础知识</h2>
<h3 id="1-常量">1. 常量</h3>
<p>在C++中，常量是使用关键字<code>const</code>声明的，意味着一旦被赋值后，它的值就不能被改变。常量提供了一种保护变量不被无意或有意修改的方式，有助于提高程序的可读性和维护性。以下是一些关于C++常量的关键点：</p>
<ol>
<li><strong>基本常量</strong></li>
</ol>
<ul>
<li>使用<code>const</code>关键字创建常量。</li>
<li>必须在声明时初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_USERS = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ol start="2">
<li><strong>枚举常量</strong></li>
</ol>
<ul>
<li>枚举（Enumeration）是一种用户定义的类型，它包含一组命名的整型常量。</li>
<li>使用<code>enum</code>关键字声明。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ol start="3">
<li><strong>宏常量</strong></li>
</ol>
<ul>
<li>使用预处理器指令<code>#define</code>来定义。</li>
<li>宏在编译之前被处理，替换文本中所有的宏名称。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br></code></pre></td></tr></table></figure>
<hr>
<br>
<ol start="4">
<li><strong>字面量常量</strong></li>
</ol>
<ul>
<li>直接出现在代码中的值，如整数<code>10</code>，浮点数<code>3.14</code>，字符<code>'A'</code>，字符串<code>&quot;Hello&quot;</code>。</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">为什么字面量常量是常量？ </summary><div class="toggle-content"><p>字面量常量是常量，因为它们表示固定的值，不能被修改。在C++（以及其他编程语言）中，当你在代码中直接使用一个值，如数字<code>42</code>、字符<code>'A'</code>或字符串<code>&quot;Hello&quot;</code>时，这些值就是字面量。字面量的特点是它们在源代码中直接出现，且它们的值在编写代码的时候就已经确定，而不是在程序运行时计算得到的。</p>
<p><strong>为什么是常量？</strong></p>
<ul>
<li><strong>不变性</strong>：字面量表示的值是不变的。例如，数字<code>5</code>总是<code>5</code>，字符串<code>&quot;world&quot;</code>总是<code>&quot;world&quot;</code>。这种不变性是字面量被视为常量的直接原因。</li>
<li><strong>内存效率</strong>：在编译时，编译器知道字面量的值，并且可以进行优化。因为这些值是不变的，所以在程序的执行期间不需要为它们分配可变存储空间。</li>
<li><strong>安全性</strong>：将字面量视为常量可以防止程序意外改变它们的值，这增加了代码的安全性和预测性。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>考虑以下代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10是一个整数字面量常量</span><br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// &#x27;A&#x27;是一个字符字面量常量</span><br></code></pre></td></tr></table></figure>
<p>在这些示例中，<code>10</code>和<code>'A'</code>都是字面量常量。你不能去“改变”<code>10</code>的值变成<code>11</code>，或者改变<code>'A'</code>成<code>'B'</code>，它们固有地代表了它们的值。你可以改变变量<code>x</code>和<code>c</code>的值，但字面量<code>10</code>和<code>'A'</code>本身的含义是不可改变的。</p>
<p><strong>结论</strong>：</p>
<p>理解字面量常量作为常量的原因，帮助我们在编写代码时更清楚地理解值的不变性和表达式的含义，这对于编写可读性高、稳定和高效的代码非常重要。</p>
</div></details>
<hr>
<br>
<ol start="5">
<li><code>constexpr</code> <strong>常量表达式</strong></li>
</ol>
<ul>
<li>C++11引入了<code>constexpr</code>，用于定义编译时常量表达式，这意味着表达式的值在编译时就已经确定。</li>
<li>可用于函数、对象的构造函数等更复杂的场景。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看constexpr </summary><div class="toggle-content"><p><code>constexpr</code>是C++11引入的一个关键字，用于定义常量表达式。这意味着表达式的值在编译时就已经确定，而不是在程序运行时计算。使用<code>constexpr</code>可以让你声明变量、函数等为编译时常量，从而提高程序的性能和可靠性。</p>
<p><strong>基本概念</strong></p>
<p><code>constexpr</code>指示编译器验证变量的值或函数的返回值是否可以在编译时确定。这对于优化很有帮助，因为编译器可以在编译期间计算出这些值，减少运行时的计算开销。</p>
<p><strong><code>constexpr</code>变量</strong></p>
<p>一个<code>constexpr</code>变量必须立即初始化，并且其初始化表达式必须在编译时可求值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> max_size = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 正确，100是编译时常数</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> limit = max_size + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 正确，max_size是一个constexpr变量，因此max_size+1也是编译时常数</span><br></code></pre></td></tr></table></figure>
<p><strong><code>constexpr</code>函数</strong></p>
<p><code>constexpr</code>函数能够在编译时对其输入进行计算，只要提供给它的参数是编译时常数。这意味着，你可以用<code>constexpr</code>函数初始化<code>constexpr</code>变量，或者在需要编译时常数表达式的上下文中使用它们。</p>
<p><code>constexpr</code>函数有几个限制，例如在C++11和C++14中，函数体只能包含非常有限的代码。从C++14开始，这些限制放宽了，允许包含更多类型的语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sq = <span class="hljs-built_in">square</span>(<span class="hljs-number">9</span>);  <span class="hljs-comment">// 编译时计算square(9)</span><br></code></pre></td></tr></table></figure>
<p><strong>与<code>const</code>的区别</strong></p>
<ul>
<li><code>const</code>用于定义常量，这意味着一旦赋值后，该变量的值就不能改变。但<code>const</code>变量的值不一定在编译时就已知。</li>
<li><code>constexpr</code>表示表达式的值可以（并且必须）在编译时求值。这适用于变量、函数等。</li>
</ul>
<p><strong>使用场景</strong></p>
<p><code>constexpr</code>在需要编译时常量表达式，例如数组大小、整数模板参数等场合特别有用。它们还可以用于性能优化，因为<code>constexpr</code>允许在编译时而非运行时进行计算。</p>
<p><strong>注意事项</strong></p>
<ul>
<li><code>constexpr</code>函数不一定总是在编译时被求值。如果你在运行时用非常量表达式作为参数调用一个<code>constexpr</code>函数，该调用仍然可以工作，但计算将在运行时进行。</li>
<li>使用<code>constexpr</code>要求编译器支持C++11或更高版本。</li>
</ul>
<p>总之，<code>constexpr</code>是C++中一个强大的特性，它提供了一种在编译时而不是运行时进行计算的方法，有助于提高程序的效率和可靠性。</p>
</div></details>
<hr>
<br>
<p><strong>常量指针与指针常量</strong></p>
<ul>
<li>常量指针(<code>const</code>指针)：指向常量的指针，不能通过该指针修改所指向的值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-type">const</span>* ptr;        <span class="hljs-comment">// 和上面是等价的</span><br></code></pre></td></tr></table></figure>
<ul>
<li>指针常量：指针本身是常量，不能指向别的地址，但所指向的值可以修改。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;var;<br></code></pre></td></tr></table></figure>
<ul>
<li>同时使用：既不能修改指针指向，也不能通过指针修改值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;var;<br></code></pre></td></tr></table></figure>
<p>理解并正确使用常量是C++编程中的基本技能之一，有助于创建更安全、更健壮的程序。</p>
<hr>
<br>
<br>
<h3 id="2-关键字">2. 关键字</h3>
<table>
<thead>
<tr>
<th style="text-align:left">C++ Only</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>bool</strong></td>
<td><strong>catch</strong></td>
<td><strong>class</strong></td>
<td><strong>const_cast</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>constexpr</strong></td>
<td><strong>dynamic_cast</strong></td>
<td><strong>explicit</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>friend</strong></td>
<td><strong>inline</strong></td>
<td><strong>mutable</strong></td>
<td><strong>namespace</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>new</strong></td>
<td><strong>nullptr</strong></td>
<td><strong>operator</strong></td>
<td><strong>private</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>protected</strong></td>
<td><strong>public</strong></td>
<td><strong>reinterpret_cast</strong></td>
<td><strong>static_cast</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>template</strong></td>
<td><strong>this</strong></td>
<td><strong>throw</strong></td>
<td><strong>true</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>try</strong></td>
<td><strong>typeid</strong></td>
<td><strong>typename</strong></td>
<td><strong>using</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>virtual</strong></td>
<td><strong>wchar_t</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Common<br />Keywords</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">auto</td>
<td>break</td>
<td>case</td>
<td>char</td>
<td>const</td>
</tr>
<tr>
<td style="text-align:left">continue</td>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
</tr>
<tr>
<td style="text-align:left">enum</td>
<td>extern</td>
<td>float</td>
<td>for</td>
<td>goto</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td>int</td>
<td>long</td>
<td>register</td>
<td>return</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>signed</td>
<td>sizeof</td>
<td>static</td>
<td>struct</td>
</tr>
<tr>
<td style="text-align:left">switch</td>
<td>typedef</td>
<td>union</td>
<td>unsigned</td>
<td>void</td>
</tr>
<tr>
<td style="text-align:left">volatile</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">auto </summary><div class="toggle-content"><p>C语言和C++中的<code>auto</code>关键字确实都存在，但它们的用途和含义随着C++11的引入发生了显著变化。</p>
<p><strong>C语言中的<code>auto</code></strong></p>
<p>在C语言中，<code>auto</code>关键字用于声明自动局部变量。然而，由于局部变量默认就是自动（automatic）存储类别的，所以在实际C程序中，<code>auto</code>关键字几乎从未被显式使用。其用法主要是语法上的，而不带有实际的操作意义。</p>
<p>例如，以下两个声明在C中是等价的，<code>auto</code>关键字是多余的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> var = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> var = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<p><strong>C++中的<code>auto</code></strong></p>
<p>在C++11及其之后的版本中，<code>auto</code>关键字的含义被重新定义用于类型推断。这意味着编译器会根据变量的初始值自动推断出变量的类型。这一变化极大地提高了代码的可读性和编写的便捷性，特别是对于复杂类型（如迭代器或者lambda表达式的类型）来说。</p>
<p>在C++11中，你可以这样使用<code>auto</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x 被推断为 int</span><br><span class="hljs-keyword">auto</span> y = <span class="hljs-number">1.5</span>; <span class="hljs-comment">// y 被推断为 double</span><br></code></pre></td></tr></table></figure>
<p>在这里，<code>auto</code>使得编码更加简洁，并且能够很容易地适应类型的变化，而不需要修改每一个变量的声明。</p>
<p><strong>总结</strong>:</p>
<ul>
<li>在<strong>C语言</strong>中，<code>auto</code>是一个几乎不被使用的关键字，因为它指明了默认的存储类别（自动存储类别），而这是局部变量的默认行为。</li>
<li>在<strong>C++</strong> 中，<code>auto</code>关键字被重新定义，用于启用类型推断，极大地提升了编程的便利性和代码的通用性。</li>
</ul>
<p>这种变化体现了C++对于简化编程复杂性和提高语言灵活性的持续努力。</p>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">volatile </summary><div class="toggle-content"><p><code>volatile</code>关键字在C和C++语言中被用来告诉编译器，一个变量的值可能以编译器不预期的方式被改变。这意味着使用<code>volatile</code>声明的变量不应该被编译器优化，因为它的值可能会在程序的控制流之外被修改。这个关键字主要用于两个场景：</p>
<ol>
<li><strong>硬件访问</strong></li>
</ol>
<p>当程序需要直接与硬件设备交互时，该设备的状态或数据可能会独立于程序的任何操作而改变。例如，一个硬件寄存器的值可能由外部事件（如硬件中断）而非程序本身的写操作所修改。在这种情况下，使用<code>volatile</code>可以防止编译器做出假设并错误地优化掉对这些外部状态的读取或写入操作。</p>
<ol start="2">
<li><strong>多线程应用</strong></li>
</ol>
<p>在多线程应用程序中，一个线程可能修改另一个线程可以访问的变量。如果没有<code>volatile</code>，编译器可能会认为一个线程中的循环检查这个变量永远不会结束，因为在该线程的控制流中，变量看似没有被修改。使用<code>volatile</code>可以避免这样的优化，确保变量的读取或写入直接反映在内存中，从而允许线程安全地检查和修改变量。</p>
<p><strong>使用示例</strong></p>
<p>假设有一个表示硬件状态的变量，或者在多线程环境下共享的变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> hardwareStatus;<br></code></pre></td></tr></table></figure>
<p>这里，<code>volatile</code>关键字告诉编译器，<code>hardwareStatus</code>变量的值可能在程序执行过程中随时被外部因素改变，因此在每次访问时都需要直接从内存中读取它的值，而不能仅仅依赖于寄存器中的可能已经优化过的副本。</p>
<p><strong>注意事项</strong></p>
<p>虽然<code>volatile</code>对于上述用例非常重要，但它并不保证变量访问的原子性或线程间的同步。对于需要原子操作或同步的场景，应该使用专门的同步机制或原子操作，如互斥锁（mutexes）或C++11中的原子类型（<code>std::atomic</code>）。</p>
<p>总之，<code>volatile</code>关键字是编程中用于特定用途的低级工具，正确使用时可以确保程序能够正确地与硬件交互或处理多线程中的共享数据。然而，它并不是解决并发问题的万能钥匙，需要谨慎使用。</p>
</div></details>
<hr>
<br>
<p><br><br></p>
<h3 id="3-数据类型">3. 数据类型</h3>
<p>在64位机器上，C++基本数据类型的大小可能会根据不同的编译器和操作系统有所不同。然而，有一些通用的规则可以作为参考。以下是一些常见的C++数据类型在大多数64位环境中的典型大小：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool</code></td>
<td>1</td>
</tr>
<tr>
<td><code>char</code></td>
<td>1</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>2 或 4</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>2</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>4</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td>4 或 8</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>8 或 16</td>
</tr>
<tr>
<td>指针（如<code>int*</code>）</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>几点需要注意的是：</p>
<ul>
<li><code>wchar_t</code>的大小依赖于编译器和平台。在Windows上通常是2字节，而在Linux和macOS上通常是4字节。</li>
<li><code>long</code>类型在Windows的64位版本中仍然是4字节，而在大多数Unix-like系统（包括Linux和macOS）中，<code>long</code>是8字节。</li>
<li><code>long double</code>的大小也依赖于编译器和平台，它可能是和<code>double</code>一样，或者更大，例如16字节。</li>
</ul>
<p>以上信息提供了一个大致的指导，但最准确的方法是使用<code>sizeof</code>运算符直接在目标平台上进行检查。例如，你可以写一个简单的C++程序来打印不同类型的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of int: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of long: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;<br>    <span class="hljs-comment">// 以此类推，打印其他类型的大小</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，你可以获得在你的特定编译器和操作系统上各种数据类型的确切大小。</p>
<hr>
<p><br><br><br></p>
<h3 id="4-字面量">4. 字面量</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3.14</span>    <span class="hljs-comment">// double</span><br><span class="hljs-number">3.14f</span>   <span class="hljs-comment">// float</span><br><span class="hljs-number">3e2</span>     <span class="hljs-comment">// double, 科学计数法，指数必须为整数</span><br></code></pre></td></tr></table></figure>
<p><code>cout</code> <code>printf</code>没有指定输出精度的话，最多输出6位有效数字（小数点前的也算有效数字）</p>
<hr>
<p><br><br><br></p>
<h3 id="5-转义字符">5. 转义字符</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>转义字符</strong></th>
<th style="text-align:left"><strong>含义</strong></th>
<th style="text-align:left"><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警报</td>
<td style="text-align:left">007</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">退格(BS) ，将当前位置移到前一列</td>
<td style="text-align:left">008</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页(FF)，将当前位置移到下页开头</td>
<td style="text-align:left">012</td>
</tr>
<tr>
<td style="text-align:left"><strong>\n</strong></td>
<td style="text-align:left"><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td style="text-align:left"><strong>010</strong></td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车(CR) ，将当前位置移到本行开头</td>
<td style="text-align:left">013</td>
</tr>
<tr>
<td style="text-align:left"><strong>\t</strong></td>
<td style="text-align:left"><strong>水平制表(HT) （跳到下一个TAB位置）</strong></td>
<td style="text-align:left"><strong>009</strong></td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表(VT)</td>
<td style="text-align:left">011</td>
</tr>
<tr>
<td style="text-align:left"><strong>\</strong></td>
<td style="text-align:left"><strong>代表一个反斜线字符&quot;&quot;</strong></td>
<td style="text-align:left"><strong>092</strong></td>
</tr>
<tr>
<td style="text-align:left">’</td>
<td style="text-align:left">代表一个单引号（撇号）字符</td>
<td style="text-align:left">039</td>
</tr>
<tr>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">代表一个双引号字符</td>
<td style="text-align:left">034</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">代表一个问号</td>
<td style="text-align:left">063</td>
</tr>
<tr>
<td style="text-align:left">\0</td>
<td style="text-align:left">数字0</td>
<td style="text-align:left">000</td>
</tr>
<tr>
<td style="text-align:left">\ddd</td>
<td style="text-align:left">8进制转义字符，d范围0~7</td>
<td style="text-align:left">3位8进制</td>
</tr>
<tr>
<td style="text-align:left">\xhh</td>
<td style="text-align:left">16进制转义字符，h范围0~9，a~f，A~F</td>
<td style="text-align:left">3位16进制</td>
</tr>
</tbody>
</table>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">怎么理解水平制表符 </summary><div class="toggle-content"><p>前面没有满八个位置，就补几个空格来满足</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tyy\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234\tyy\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234567\tyy\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;12345678\tyy\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;123456789\tyy\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">        yy<br>1234    yy<br>1234567 yy<br>12345678        yy<br>123456789       yy<br><br></code></pre></td></tr></table></figure>
</div></details>
<hr>
<p><br><br><br></p>
<h3 id="6-宏定义">6. 宏定义</h3>
<p>宏定义不一定非要写在源代码的开头。在C和C++中，宏是通过预处理器指令定义的，这意味着它们在编译之前被处理。宏定义可以出现在源文件的任何地方，但是它只会影响它定义之后的代码。因此，宏定义通常放在文件的开始部分，以确保它们在整个文件中都有效，这是一种常见的做法，但并非强制要求。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>作用域</strong>：宏的作用范围从定义点开始，到文件结束或被<code>#undef</code>指令取消定义。如果你希望一个宏在整个文件中都有效，将其定义在文件开头是有意义的。</li>
<li><strong>组织性</strong>：为了代码的清晰和易于维护，常常将宏定义放在文件顶部或专门的头文件中。这样做有助于其他开发者快速了解文件或项目中使用的宏。</li>
<li><strong>条件编译</strong>：有时，宏定义会根据条件编译指令来进行定义，这可能会出现在文件的任何位置。例如，根据不同的操作系统来定义不同的宏。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>宏定义可以在文件的任何位置进行，只要在使用之前定义即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG <span class="hljs-string">&quot;Defined after using.&quot;</span></span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, MSG); <span class="hljs-comment">// 使用宏定义</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>MSG</code>宏定义在<code>main</code>函数内部，仅在定义之后的代码中有效。如果尝试在定义之前使用<code>MSG</code>，编译器会报错，因为在那个点上它还没有被定义。</p>
<p><strong>结论</strong>：</p>
<p>尽管宏定义可以写在源代码的任何位置，但将它们组织在文件开头或在专门的头文件中是一种更清晰、更易于管理的做法。这种组织方式可以提高代码的可读性和可维护性。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">#undef </summary><div class="toggle-content"><p><code>#undef</code> 指令在C和C++中用于取消宏定义。当你不再需要一个宏，或者想要重新定义它时，<code>#undef</code> 可以用来移除当前的宏定义。这样做可以防止宏的意外重定义，或者在特定的代码区域内限制宏的作用域。</p>
<p><strong>使用方式</strong>:</p>
<p>使用 <code>#undef</code> 非常简单，只需要跟上你想要取消定义的宏的名称。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br><span class="hljs-comment">// 使用PI...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> PI</span><br><span class="hljs-comment">// 从这一点开始，PI不再定义</span><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong>:</p>
<p>假设你有一个宏，用于在调试模式下打印日志信息，但在发布版本中你不希望包含这些日志信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG <span class="hljs-comment">// 开启调试模式</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg) printf(<span class="hljs-string">&quot;Log: %s\n&quot;</span>, msg)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 使用LOG宏...</span><br>LOG(<span class="hljs-string">&quot;This is a debug message.&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> LOG</span><br><span class="hljs-comment">// 从这一点开始，LOG宏不再可用</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>LOG</code> 宏根据是否定义了 <code>DEBUG</code> 来改变行为。通过在不需要它之后使用 <code>#undef</code>，可以确保它不会在后续的代码中被误用。</p>
<p><strong>注意事项</strong>:</p>
<ul>
<li>使用 <code>#undef</code> 取消宏定义后，如果需要再次使用相同的宏名称，你必须重新定义它。</li>
<li><code>#undef</code> 对后续的代码块生效，对其前面的代码没有影响。</li>
<li>在大型项目中，谨慎使用宏定义和 <code>#undef</code>，因为它们如果被滥用，可能会使代码难以理解和维护。</li>
<li>尽管 <code>#undef</code> 可以用来限制宏的作用域，但在现代C++中，更推荐使用常量、内联函数或者模板来代替宏，以提高代码的安全性和清晰度。</li>
</ul>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">#define _CRT_SECURE_NO_WARNINGS </summary><div class="toggle-content"><p><code>#define _CRT_SECURE_NO_WARNINGS</code>这种用法与我们通常定义宏来创建常量或宏函数略有不同。它不是用来直接替换代码中的文本，而是作为一种特殊的标记，用于影响编译器的行为。这类宏定义主要用于配置编译环境或控制编译器的特定行为，而不是用于代码中的直接替换。</p>
<p><strong>常规宏定义</strong>：</p>
<p>常规的宏定义通常有以下两种形式：</p>
<ol>
<li>
<p><strong>定义常量</strong>：用宏来定义一个常量值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br></code></pre></td></tr></table></figure>
<p>在这里，每当预处理器遇到<code>PI</code>，它都会用<code>3.14159</code>来替换它。</p>
</li>
<li>
<p><strong>定义宏函数</strong>：定义一个宏函数，允许在代码中使用类似函数调用的语法来执行代码替换，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br></code></pre></td></tr></table></figure>
<p>这里，<code>SQUARE(x)</code>会被替换为计算<code>x</code>平方的表达式。</p>
</li>
</ol>
<p><strong>特殊的宏定义</strong>：</p>
<p>与常规宏定义不同，<code>#define _CRT_SECURE_NO_WARNINGS</code>这样的宏并不直接影响代码的内容替换，而是用作编译器的配置指示。这说明宏定义在C和C++中的应用非常灵活，不仅限于文字替换：</p>
<ul>
<li><strong>控制编译器行为</strong>：某些宏用于开启或关闭编译器的特定功能，如<code>_CRT_SECURE_NO_WARNINGS</code>。</li>
<li><strong>配置编译环境</strong>：通过定义或取消定义宏来启用或禁用代码中的特定部分，通常用于跨平台兼容性或条件编译。</li>
<li><strong>平台特定的定义</strong>：操作系统或编译器可能会预定义一些宏，用于标识平台特性或编译环境。</li>
</ul>
<p><strong>结论</strong>：</p>
<p><code>#define _CRT_SECURE_NO_WARNINGS</code>与常规宏定义的主要区别在于它的目的和效果。它不是用来替换代码中的文本，而是用来配置编译器的行为，避免在使用旧版C运行时函数时产生的安全警告。这种类型的宏定义体现了宏的另一种强大用途，即控制编译过程和环境的配置，而不仅仅是代码中的文本替换。</p>
</div></details>
<hr>
<br>
<p>C和C++中的预处理器指令不仅限于<code>#define</code>，还包括一系列其他有用的指令，它们在编译之前处理源代码，用于条件编译、文件包含、宏定义等。以下是一些常用的预处理器指令：</p>
<ol>
<li><code>#include</code></li>
</ol>
<p>用于包含头文件，将文件的内容直接插入到当前位置。有两种形式：</p>
<ul>
<li><code>#include &lt;filename&gt;</code>：用于标准库头文件。</li>
<li><code>#include &quot;filename&quot;</code>：用于项目内的头文件。</li>
</ul>
<ol start="2">
<li><code>#define</code></li>
</ol>
<p>定义宏，可以是对象（常量值）或函数（带参数的宏）。</p>
<ol start="3">
<li><code>#undef</code></li>
</ol>
<p>取消已定义的宏的定义。</p>
<ol start="4">
<li><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code></li>
</ol>
<p>用于条件编译。根据条件是否满足，决定是否编译代码段。</p>
<ol start="5">
<li><code>#ifdef</code>, <code>#ifndef</code></li>
</ol>
<p>检查宏是否被定义：</p>
<ul>
<li><code>#ifdef</code>：如果宏已定义，则编译下面的代码。</li>
<li><code>#ifndef</code>：如果宏未定义，则编译下面的代码。</li>
</ul>
<ol start="6">
<li><code>#error</code></li>
</ol>
<p>当遇到此指令时，预处理器会显示一个错误消息并停止编译。</p>
<ol start="7">
<li><code>#pragma</code></li>
</ol>
<p>提供了一种标准化的方法，用于向编译器传递特定的指令。编译器可能会忽略它不认识的<code>#pragma</code>指令。</p>
<ol start="8">
<li><code>#line</code></li>
</ol>
<p>允许改变编译器的当前行号和文件名，对调试和错误报告很有用。</p>
<p><strong>使用示例</strong>:</p>
<ul>
<li>
<p><strong>#include 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>#define 和 #undef 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> PI</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>条件编译示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Debug mode is on.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>#error 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> REQUIRED_MACRO</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;REQUIRED_MACRO is not defined&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>预处理器指令是C和C++编程中强大的工具，允许程序员对编译过程有更细致的控制，包括代码的条件编译、配置管理和错误检测等。正确和有效地使用这些指令可以提高代码的可移植性、灵活性和可维护性。</p>
<hr>
<p><br><br><br></p>
<hr>
<h3 id="7-分文件编写">7. 分文件编写</h3>
<p>C++和C语言在分文件编写方面有很多相似之处，因为C++在很大程度上保持了与C的兼容性。然而，由于C++引入了类、模板和命名空间等新特性，因此C++分文件编写时还需要考虑这些特性的特定需求。下面是一些基本原则和区别：</p>
<p><strong>相似之处</strong>：</p>
<ol>
<li>
<p><strong>头文件（.h或.hpp）</strong>：在C和C++中，头文件用于声明函数、变量、类等。它们允许在多个源文件之间共享这些声明，避免重复代码。</p>
</li>
<li>
<p><strong>源文件（.c或.cpp）</strong>：源文件包含函数、类方法的实现代码。在分文件编写中，头文件被包含在源文件中，以提供必要的声明。</p>
</li>
<li>
<p><strong>预处理指令</strong>：<code>#include</code>预处理指令在C和C++中都用于包含头文件，这使得函数、类的声明在源文件中可用。</p>
</li>
</ol>
<p><strong>C++特有的考虑因素</strong>：</p>
<ol>
<li>
<p><strong>类声明与定义</strong>：在C++中，类通常在头文件中声明，在源文件中定义（实现）。这意味着类的成员函数在头文件中被声明，在一个或多个源文件中被定义。</p>
</li>
<li>
<p><strong>模板</strong>：C++的模板（包括类模板和函数模板）通常在头文件中完全定义。由于模板需要在编译时实例化，它们的定义（实现）通常与声明放在同一个头文件中，而不是分开到源文件中。</p>
</li>
<li>
<p><strong>内联函数</strong>：C++允许函数在头文件中被声明为<code>inline</code>，这样做的目的是减少小函数的调用开销。虽然内联函数也可以在C中通过宏实现，但C++的<code>inline</code>关键字提供了类型安全和更好的编程风格。</p>
</li>
<li>
<p><strong>命名空间</strong>：C++支持命名空间，这是C不具备的特性。命名空间可以用于头文件和源文件中，以避免命名冲突。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<ul>
<li>
<p><strong>C++头文件（myclass.hpp）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// myclass.hpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYCLASS_HPP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYCLASS_HPP</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>C++源文件（myclass.cpp）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// myclass.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myclass.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 实现</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>结论</strong>：</p>
<p>虽然C++和C在分文件编写方面有很多相似之处，但C++的一些高级特性（如类、模板和命名空间）引入了额外的考虑因素。理解这些差异有助于有效地组织和维护C++项目的代码。</p>
<hr>
<br>
<p>确实，你可以通过<code>extern</code>关键字在C或C++中实现不同源文件间的函数或变量的共享，而不必依赖于头文件。<code>extern</code>用于声明一个变量或函数是在别处定义的，这样做可以在不同的源文件之间共享同一个全局变量或函数。不过，这种方式相比于使用头文件来说，管理起来更为繁琐，特别是在大型项目中，而且容易出错。</p>
<p><strong>使用<code>extern</code>分文件编写的基本方法</strong>：</p>
<p>假设你有两个源文件，<code>file1.cpp</code>和<code>file2.cpp</code>，你想在<code>file2.cpp</code>中使用<code>file1.cpp</code>定义的变量或函数。</p>
<p><strong>file1.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionFromFirstFile</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function in file 1&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">42</span>; <span class="hljs-comment">// 全局变量定义</span><br></code></pre></td></tr></table></figure>
<p><strong>file2.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">functionFromFirstFile</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar; <span class="hljs-comment">// 外部变量声明</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">functionFromFirstFile</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>维护性</strong>：随着项目规模的增大，如果不使用头文件而仅依赖于<code>extern</code>声明，每次外部符号的定义变更时，都需要手动更新所有引用了这些符号的文件。这大大增加了维护的难度和出错的几率。</li>
<li><strong>可读性和组织性</strong>：使用头文件不仅可以使项目结构更清晰，还可以通过条件编译、宏等预处理指令提供更多的灵活性和控制。</li>
<li><strong>重复声明问题</strong>：对于<code>extern</code>变量，如果在多个文件中需要访问，每个文件都需要重复声明，增加了冗余。</li>
</ul>
<p><strong>结论</strong>：</p>
<p>虽然理论上可以通过<code>extern</code>关键字在没有头文件的情况下进行分文件编写，但这种做法并不推荐，特别是对于中大型项目。使用头文件可以更好地组织代码，减少重复，提高代码的可读性和可维护性。在实际开发中，<strong><u>头文件是分文件编程的最佳实践之一</u></strong>。</p>
<hr>
<br>
<p><br><br></p>
<h3 id="8-指针">8. 指针</h3>
<ul>
<li><strong><u>概念</u></strong>：</li>
</ul>
<p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过&quot; * &quot;操作符，操作指针变量指向的内存空间，这个过程称为<strong>解引用</strong></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">指针和指针变量 </summary><div class="toggle-content"><p>指针和指针变量这两个术语经常被互换使用，但如果我们要区分它们，可以这样理解：</p>
<p><strong>指针（Pointer）</strong></p>
<ul>
<li><strong>概念上的指针</strong>：指针本质上是一个内存地址，指向存储数据的某个位置。它是编程语言中的一个抽象概念，用于表示访问其他变量的能力。</li>
<li>在许多情况下，当我们谈论指针时，我们实际上是在讨论存储内存地址的变量或者某种方式上的引用，这可以是一个具体的内存地址，也可以是通过某种方式（如通过指针变量）获得的内存地址。</li>
</ul>
<p><strong>指针变量（Pointer Variable）</strong></p>
<ul>
<li><strong>实体上的指针</strong>：指针变量是一种特殊类型的变量，用于存储内存地址。这意味着，指针变量具有存储其他变量地址的能力，通过这个地址，可以访问或修改该地址处的数据。</li>
<li>指针变量是具体的、可以操作的实体。在C或C++代码中，你可以声明指针变量，给它赋值（一个地址），并通过它访问或修改它指向的数据。</li>
</ul>
<p><strong>区别和联系</strong></p>
<ul>
<li><strong>区别</strong>：从最严格的意义上讲，指针是一个内存地址，而指针变量是存储这个内存地址的变量。因此，指针是一个更广泛的概念，而指针变量是这个概念在程序中的具体实现。</li>
<li><strong>联系</strong>：在实际应用中，这两个术语经常被互换使用，因为指针变量是实现指针概念的主要方式。当你声明一个指针变量并操作它时，你实际上是在操作指针，即内存地址。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>; <span class="hljs-comment">// 一个普通的整型变量</span><br>    <span class="hljs-type">int</span>* ptr = &amp;value; <span class="hljs-comment">// ptr 是一个指针变量，存储了 value 的地址</span><br>    <span class="hljs-comment">// 在这里，ptr 就是指针变量，&amp;value 是一个指针（内存地址）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，<code>ptr</code>是一个指针变量，因为它是一个变量，用于存储<code>value</code>变量的地址。而<code>&amp;value</code>产生一个指向<code>value</code>的指针，即<code>value</code>的内存地址。在日常使用中，指针和指针变量这两个术语往往可以互换，尤其是在上下文清楚地表明了讨论的是变量还是它所存储的地址时。</p>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>指针所占的内存空间</u></strong></li>
</ul>
<p>C++中指针的大小通常与所在平台的机器字长（或地址总线宽度）相匹配。机器字长指的是CPU一次性可以处理数据的位数，它直接关联到操作系统可以直接寻址的内存空间大小。在32位系统上，指针的大小通常是32位（4字节），而在64位系统上，指针的大小通常是64位（8字节）。</p>
<p>这样设计的主要原因是为了使指针能够有效地访问整个可寻址的内存空间。在32位系统上，4字节指针可以寻址最多(2^{32})个地址，即4GB的内存空间。在64位系统上，8字节指针可以寻址最多(2^{64})个地址，理论上可以达到16EB（Exabytes，百万TB）的内存空间，尽管实际上由于硬件和操作系统的限制，并不能全部使用这么多内存。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>尽管指针大小通常与机器字长相匹配，但这不是一个由C++语言标准强制规定的规则。语言标准没有指定指针的具体大小，这取决于编译器和目标平台的实现。</li>
<li>指针类型的大小（无论是指向整型、浮点型还是类对象的指针）在特定平台上通常是相同的，但指针与指向的数据类型的大小无关。即，一个指向<code>int</code>的指针和一个指向<code>double</code>的指针，在同一个平台上大小是相同的。</li>
<li>函数指针的大小也通常与其他类型的指针相同，但在某些特殊的架构或编译器设置中，它们的大小可能会有所不同。</li>
</ul>
<p>总的来说，虽然在大多数情况下，指针的大小确实等于机器字长，但这是基于特定平台的约定和实现，而非C++语言标准的强制要求。</p>
<p><strong>验证</strong>：</p>
<p>VS studio2017 这里可以修改：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-29_14-12-43.png" alt=""></p>
<p>x86（32位机器）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span> *) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出为</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>x64：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span> *) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span> *) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出为</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>空指针</u></strong>：</li>
</ul>
<p>指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong> 初始化指针变量</p>
<p><strong>注意：</strong> 空指针指向的内存是不可以访问的</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">NULL 还是 nullptr? </summary><div class="toggle-content"><p>在C++中，<code>nullptr</code>和<code>NULL</code>都可以用来表示空指针，但它们之间存在一些重要的区别，特别是在C++11及以后的版本中。</p>
<p><strong>NULL</strong></p>
<ul>
<li><code>NULL</code>在C++（和C）程序中长期被用作表示空指针的值。在C++中，<code>NULL</code>通常被定义为<code>0</code>，基于C++对整数到指针隐式转换的支持，这意味着将整数<code>0</code>赋值给指针变量时，它会被视为一个空指针。</li>
<li>使用<code>NULL</code>可能会引起一些混淆和问题，特别是在函数重载的情况下，因为<code>NULL</code>实际上是整数<code>0</code>，它可以与整数类型匹配，这可能不是预期的行为。</li>
</ul>
<p><strong>nullptr</strong></p>
<ul>
<li><code>nullptr</code>是C++11引入的一个新的关键字，专门用来表示空指针。它的类型是<code>nullptr_t</code>，可以自动转换为任何原生指针类型，但不会被错误地转换为整数类型。</li>
<li>使用<code>nullptr</code>可以提高代码的清晰度和安全性，特别是在涉及函数重载和模板函数的场景中，它能够明确表示空指针，避免与整数<code>0</code>混淆。</li>
</ul>
<p><strong>推荐使用nullptr</strong></p>
<p>鉴于<code>nullptr</code>提供了类型安全的空指针表示，以及更好的兼容性和清晰性，推荐在C++11及以后的版本中使用<code>nullptr</code>来表示空指针。这样可以减少潜在的混淆，尤其是在涉及重载和模板的复杂情况下。</p>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理整数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理字符指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// 可能调用 func(int)，这取决于NULL的定义</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 明确调用 func(char*)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，使用<code>nullptr</code>可以确保调用正确的<code>func</code>函数版本，而使用<code>NULL</code>可能会产生歧义。</p>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>野指针</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span><br>    <span class="hljs-type">int</span> * p = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x1100</span>;<br><br>    <span class="hljs-comment">//访问野指针报错 </span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-29_14-27-49.png" alt=""></p>
<p><strong>总结</strong>：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
<hr>
<br>
<ul>
<li><strong><u>const修饰指针</u></strong></li>
</ul>
<p><strong>常量指针与指针常量</strong></p>
<ul>
<li>常量指针(<code>const</code>指针)：指向常量的指针，不能通过该指针修改所指向的值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-type">const</span>* ptr;        <span class="hljs-comment">// 和上面是等价的</span><br></code></pre></td></tr></table></figure>
<ul>
<li>指针常量：指针本身是常量，不能指向别的地址，但所指向的值可以修改。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;var;<br></code></pre></td></tr></table></figure>
<ul>
<li>同时使用：既不能修改指针指向，也不能通过指针修改值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;var;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>智能指针</u></strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18B4y187uL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">C++现代实用教程:智能指针_哔哩哔哩_bilibili</a></p>
<hr>
<br>
<ul>
<li><strong><u>more</u></strong></li>
</ul>
<p>更多指针内容可以查看本站文章<a href="https://gxblogs.com/posts/16719/#:~:text=%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E3%80%82-,%E6%8C%87%E9%92%88,-%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6">C语言笔记 | GXBLOGS</a>：【目录】随手记&gt;指针</p>
<hr>
<p><br><br><br></p>
<p><br><br><br></p>
<h2 id="C-核心知识">C++核心知识</h2>
<h3 id="1-内存">1. 内存</h3>
<p>是的，C++的内存模型基本上和C语言非常相似，因为C++是以C为基础构建的，并保留了C的很多特性和概念。C++程序的内存布局通常包括以下几个区域：</p>
<ol>
<li><strong>栈（Stack）</strong></li>
</ol>
<ul>
<li>用于存放函数的局部变量、函数参数以及函数的返回地址等。栈是自上而下扩展的数据结构，具有后进先出的特性。当函数调用时，新的栈帧（包含函数的局部变量和其他上下文信息）被推入栈中；当函数返回时，栈帧被弹出。</li>
</ul>
<ol start="2">
<li><strong>堆（Heap）</strong></li>
</ol>
<ul>
<li>用于动态内存分配。与栈不同，堆是由程序员通过<code>new</code>（在C++中）或<code>malloc</code>（在C中）等操作手动分配和释放的。堆的大小不是固定的，可以动态扩展或缩小。</li>
</ul>
<ol start="3">
<li><strong>全局/静态存储区（Global/Static Area）</strong></li>
</ol>
<ul>
<li>存放全局变量和静态变量。这些变量在程序的整个生命周期内都存在。在C++中，全局对象的构造和静态对象的初始化发生在<code>main</code>函数执行之前，它们的析构/销毁发生在<code>main</code>函数执行结束后。</li>
</ul>
<ol start="4">
<li><strong>常量存储区（Constants Area）</strong></li>
</ol>
<ul>
<li>存放常量数据，如字符串字面值和其他常量表达式。这部分通常是只读的，在某些编译器实现中，它可能是<code>.rodata</code>(Read-Only Data)段的一部分。</li>
</ul>
<ol start="5">
<li><strong>代码区（Code Area）</strong></li>
</ol>
<ul>
<li>存放程序的二进制代码，即编译后的机器指令。这部分通常也是只读的，防止程序的指令在运行时被意外或恶意修改。</li>
</ul>
<p><strong>C++的一些特殊考虑</strong>：</p>
<p>虽然C++和C在内存布局方面非常相似，但C++引入了对象模型和RAII（Resource Acquisition Is Initialization）等概念，使得内存管理更加复杂。例如：</p>
<ul>
<li><strong>对象的内存管理</strong>：C++通过构造函数和析构函数自动管理对象的生命周期，支持对象的动态创建（在堆上）和自动销毁。</li>
<li><strong>智能指针</strong>：C++提供了智能指针如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等，以便更安全地管理堆上的内存。</li>
</ul>
<p>总的来说，C++保留了C语言的内存模型，并在此基础上增加了面向对象和自动资源管理等特性，使得内存管理更为灵活和安全。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">malloc和new </summary><div class="toggle-content"><p>在C++中，<code>malloc</code>和<code>new</code>都可以用来在堆上分配内存，但它们之间存在一些关键的区别，包括它们分配的内存区域的处理方式。以下是<code>malloc</code>和<code>new</code>最主要的区别：</p>
<ol>
<li><strong>构造函数和析构函数</strong></li>
</ol>
<ul>
<li><strong><code>new</code></strong>：分配内存的同时会调用对象的构造函数，为对象的初始化提供了机会。相应地，<code>delete</code>会调用对象的析构函数，确保资源得到释放。</li>
<li><strong><code>malloc</code></strong>：仅仅分配内存，不会调用构造函数。因此，当使用<code>malloc</code>分配内存给对象时，对象的成员不会被自动初始化。相应地，<code>free</code>释放内存但不会调用析构函数。</li>
</ul>
<ol start="2">
<li><strong>类型安全</strong></li>
</ol>
<ul>
<li><strong><code>new</code></strong>：返回分配对象的正确类型的指针，不需要类型转换。</li>
<li><strong><code>malloc</code></strong>：返回<code>void*</code>类型的指针，需要显式转换为目标类型的指针。</li>
</ul>
<ol start="3">
<li><strong>错误处理</strong></li>
</ol>
<ul>
<li><strong><code>new</code></strong>：在内存分配失败时，会抛出<code>std::bad_alloc</code>异常（除非使用了<code>new (nothrow)</code>）。</li>
<li><strong><code>malloc</code></strong>：在内存分配失败时，返回<code>NULL</code>。</li>
</ul>
<ol start="4">
<li><strong>分配数组</strong></li>
</ol>
<ul>
<li>使用<code>new[]</code>和<code>delete[]</code>可以为数组分配和释放内存，同时为数组中的每个对象调用构造函数和析构函数。</li>
<li>而<code>malloc</code>和<code>free</code>则没有这样的能力，它们仅仅分配和释放原始内存，不负责对象的构造和析构。</li>
</ul>
<ol start="5">
<li><strong>内存分配区域</strong></li>
</ol>
<p>尽管<code>malloc</code>和<code>new</code>在技术上都是在堆区分配内存，但实际上C++标准并没有严格规定<code>new</code>和<code>malloc</code>分配的内存区域必须是同一个。在大多数实现中，它们都是从同一块堆内存中分配内存的，但<code>new</code>可能涉及更复杂的内存管理策略（例如，使用内存池）。因此，<code>new</code>和<code>malloc</code>分配的内存区域在表现上可能有细微的不同，尤其是在处理对象构造和析构时。</p>
<p><strong>结论</strong></p>
<p>尽管<code>malloc</code>和<code>new</code>都用于内存分配，但由于<code>new</code>和<code>delete</code>提供了类型安全、自动调用构造函数和析构函数的特性，它们是C++推荐的内存分配和释放方式。使用<code>new</code>和<code>delete</code>可以让代码更加安全、简洁和面向对象。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h3 id="2-new">2. new</h3>
<p>在C++中，<code>new</code>关键字用于动态分配内存，并根据需要进行对象的构造。与C语言的<code>malloc</code>函数相比，<code>new</code>不仅分配内存，还会自动调用对象的构造函数（如果分配的是一个对象），使得内存分配和对象初始化一步到位。此外，<code>new</code>还提供了类型安全，确保分配的内存类型与所需类型匹配。</p>
<p><strong>基本用法</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 分配一个int大小的内存，并返回指向这块内存的指针</span><br>*ptr = <span class="hljs-number">5</span>; <span class="hljs-comment">// 在分配的内存中存储值5</span><br></code></pre></td></tr></table></figure>
<p>在上面的例子中，<code>new int</code>动态分配了足够存储一个<code>int</code>类型值的内存，并返回一个指向这块内存的指针。与此同时，分配的内存被自动初始化。</p>
<p><strong>带有初始化的用法</strong>:</p>
<p><code>new</code>也支持在分配内存时进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配并初始化为10</span><br></code></pre></td></tr></table></figure>
<p>对于自定义类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br>MyClass* myObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配内存并调用构造函数</span><br></code></pre></td></tr></table></figure>
<p><strong>数组的分配</strong>:</p>
<p><code>new</code>还可以用于分配对象数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 分配一个10个int的数组</span><br></code></pre></td></tr></table></figure>
<p>数组分配时不支持直接初始化每个元素，但你可以使用后面的括号来初始化POD（Plain Old Data，简单旧数据类型）类型数组的元素为零：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>](); <span class="hljs-comment">// 分配并初始化为0</span><br></code></pre></td></tr></table></figure>
<p><strong><code>delete</code>关键字</strong></p>
<p>分配的动态内存必须手动释放，以避免内存泄露。这是通过<code>delete</code>关键字（对于单个对象）或<code>delete[]</code>关键字（对于对象数组）来完成的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放单个对象</span><br><span class="hljs-keyword">delete</span>[] array; <span class="hljs-comment">// 释放对象数组</span><br></code></pre></td></tr></table></figure>
<p><strong>异常处理</strong>:</p>
<p>当<code>new</code>无法分配足够的内存时，默认行为是抛出一个<code>std::bad_alloc</code>异常。这可以通过异常处理机制来捕获并处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    MyClass* myObject = <span class="hljs-keyword">new</span> MyClass;<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e) &#123;<br>    <span class="hljs-comment">// 处理内存分配失败</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有一个<code>nothrow</code>版本的<code>new</code>，在内存分配失败时，不抛出异常，而是返回<code>nullptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-built_in">new</span>(std::nothrow) <span class="hljs-type">int</span>;<br><span class="hljs-keyword">if</span> (!ptr) &#123;<br>    <span class="hljs-comment">// 处理内存分配失败</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>总结</strong>:</p>
<p><code>new</code>关键字在C++中是用于动态内存分配的强大工具，提供了类型安全、自动对象初始化以及异常处理等机制。与<code>delete</code>一起使用，它们构成了C++中动态内存管理的基础。使用<code>new</code>和<code>delete</code>时，开发者需要负责匹配地使用它们，以确保每次分配的内存都被适时释放，避免内存泄漏。</p>
<hr>
<br>
<ul>
<li><strong><u>实例</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//全局常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//打印地址</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;b &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;g_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;g_b &lt;&lt; endl;<br><br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">10</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_b &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_b &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">局部变量a地址为： 9828232<br>局部变量b地址为： 9828220<br>全局变量g_a地址为： 16236544<br>全局变量g_b地址为： 16236548<br>静态变量s_a地址为： 16236552<br>静态变量s_b地址为： 16236556<br>字符串常量地址为： 16227316<br>字符串常量地址为： 16227332<br>全局常量c_g_a地址为： 16227120<br>全局常量c_g_b地址为： 16227124<br>局部常量c_l_a地址为： 9828208<br>局部常量c_l_b地址为： 9828196<br></code></pre></td></tr></table></figure></div></details>
<hr>
<br>
<p><br><br></p>
<h3 id="3-智能指针">3. 智能指针</h3>
<blockquote>
<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cpp_learner/article/details/118912592">C++ 智能指针 - 全部用法详解-CSDN博客</a></p>
</blockquote>
<h4 id="3-1-为什么使用智能指针">3.1 为什么使用智能指针</h4>
<p>一句话带过：智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放<code>new</code>出来的内存，从而<strong>避免内存泄漏</strong>！</p>
<p>如下例子就是内存泄露的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// 动态分配内存，没有释放就return</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memoryLeak1</span><span class="hljs-params">()</span> </span>&#123;<br>    string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;动态分配内存！&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">memoryLeak2</span><span class="hljs-params">()</span> </span>&#123;<br>    string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;内存泄露！&quot;</span>);<br><br>    <span class="hljs-comment">// ...此处省略一万行代码</span><br><br>    <span class="hljs-comment">// 发生某些异常，需要结束函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 另外，使用try、catch结束函数，也会造成内存泄漏！</span><br>       <br><br>    <span class="hljs-keyword">delete</span> str;	<span class="hljs-comment">// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>    <span class="hljs-built_in">memoryLeak1</span>();<br><br>    <span class="hljs-built_in">memoryLeak2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>memoryLeak1函数中，new了一个字符串指针，但是没有delete就已经return结束函数了，导致内存没有被释放，内存泄露！<br>
memoryLeak2函数中，new了一个字符串指针，虽然在函数末尾有些释放内存的代码delete str，但是在delete之前就已经return了，所以内存也没有被释放，内存泄露！</p>
<p>使用指针，我们没有释放，就会造成内存泄露。但是我们使用普通对象却不会！</p>
<p><strong>思考</strong>：如果我们分配的动态内存都交由有生命周期的对象来处理，那么在对象过期时，让它的析构函数删除指向的内存，这看似是一个 very nice 的方案？</p>
<p>智能指针就是通过这个原理来解决指针自动释放的问题！</p>
<ol>
<li>C++98 提供了 <code>auto_ptr</code> 模板的解决方案</li>
<li>C++11 增加 <code>unique_ptr</code>、<code>shared_ptr</code> 和<code>weak_ptr</code></li>
</ol>
<hr>
<p><br><br><br></p>
<h4 id="3-2-auto-ptr">3.2 auto_ptr</h4>
<p><code>auto_ptr</code> 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将<code>new</code>获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用 <code>delete</code> 来释放内存！</p>
<br>
<ul>
<li><strong>用法</strong>:</li>
</ul>
<p>头文件: <code>#include &lt; memory &gt;</code><br>
用 法: <code>auto_ptr&lt;类型&gt; 变量名(new 类型)</code></p>
<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">auto_ptr&lt; string &gt; <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(“我要成为大牛~ 变得很牛逼！”))</span></span>;<br>auto_ptr&lt;vector&lt; <span class="hljs-type">int</span> &gt;&gt; <span class="hljs-built_in">av</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt; <span class="hljs-type">int</span> &gt;());<br></code></pre></td></tr></table></figure>
<br>
<ul>
<li><strong>例</strong>：</li>
</ul>
<p>我们先定义一个类，类的构造函数和析构函数都输出一个字符串用作提示！<br>
定义一个私有成员变量，赋值20.<br>
再定义一个私有成员方法用于返回这个私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的构造函数...&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的析构函数...&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDebug</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;debug; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> debug = <span class="hljs-number">20</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>当我们直接new这个类的对象，却没有释放时。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    Test *test = <span class="hljs-keyword">new</span> Test;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/20210719201408423.jpg" alt=""></p>
<p>可以看到，只是打印了构造函数这个字符串，而析构函数的字符却没有被打印，说明并没有调用析构函数！这就导致了内存泄露！<br>
解决内存泄露的办法，要么手动<code>delete</code>，要么使用智能指针！</p>
<br>
<ul>
<li><strong>使用智能指针</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br></code></pre></td></tr></table></figure>
<p>智能指针可以像普通指针那样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>再看看输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>    <span class="hljs-comment">//Test *test = new Test;</span><br>    <span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/20210720090148973.png" alt=""></p>
<p><strong>为什么智能指针可以像普通指针那样使用</strong>？？？<br>
因为其里面重载了 <code>*</code> 和 <code>-&gt;</code> 运算符， <code>*</code> 返回普通对象，而 <code>-&gt;</code> 返回指针对象。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/20210720090724526.png" alt=""></p>
<p>具体原因不用深究，只需知道他为什么可以这样操作就像！<br>
函数中返回的是调用get()方法返回的值，那么这个<code>get()</code>是什么呢？</p>
<p>智能指针的三个常用函数：</p>
<ol>
<li>
<p><code>get()</code> 获取智能指针托管的指针地址</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>Test *tmp = test.<span class="hljs-built_in">get</span>();	    <span class="hljs-comment">// 获取指针返回</span><br>cout &lt;&lt; <span class="hljs-string">&quot;tmp-&gt;debug：&quot;</span> &lt;&lt; tmp-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>但我们一般不会这样使用，因为都可以直接使用智能指针去操作，除非有一些特殊情况。<br>
<strong>函数原型</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">_NODISCARD _Ty * <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// return wrapped pointer</span><br>    <span class="hljs-keyword">return</span> (_Myptr);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>release()</code> 取消智能指针对动态内存的托管</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>Test *tmp2 = test.<span class="hljs-built_in">release</span>();    <span class="hljs-comment">// 取消智能指针对动态内存的托管</span><br><span class="hljs-keyword">delete</span> tmp2;    <span class="hljs-comment">// 之前分配的内存需要自己手动释放</span><br></code></pre></td></tr></table></figure>
<p>也就是智能指针不再对该指针进行管理，改由管理员进行管理！<br>
<strong>函数原型</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">_Ty * <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">// return wrapped pointer and give up ownership</span><br>    _Ty * _Tmp = _Myptr;<br>    _Myptr = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> (_Tmp);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>reset()</code> 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>test.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 释放掉智能指针托管的指针内存，并将其置NULL</span><br><br>test.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>());  <span class="hljs-comment">// 释放掉智能指针托管的指针内存，并将参数指针取代之</span><br></code></pre></td></tr></table></figure>
<p>reset函数会将参数的指针(不指定则为NULL)，与托管的指针比较，如果地址不一致，那么就会析构掉原来托管的指针，然后使用参数的指针替代之。然后智能指针就会托管参数的那个指针了。<br>
<strong>函数原型</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(_Ty * _Ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">// destroy designated object and store new pointer</span><br>    <span class="hljs-keyword">if</span> (_Ptr != _Myptr)<br>        <span class="hljs-keyword">delete</span> _Myptr;<br>    _Myptr = _Ptr;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<br>
<ul>
<li><strong>使用建议</strong>：</li>
</ul>
<ol>
<li>
<p>尽可能不要将<code>auto_ptr</code> 变量定义为全局变量或指针；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 没有意义，全局变量也是一样</span><br>auto_ptr&lt;Test&gt; *tp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto_ptr</span>&lt;Test&gt;(<span class="hljs-keyword">new</span> Test);	<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>除非自己知道后果，不要把<code>auto_ptr</code> 智能指针赋值给同类型的另外一个智能指针；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>t1 = t2;    <span class="hljs-comment">// 不要这样操作...</span><br></code></pre></td></tr></table></figure>
 <details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">why? </summary><div class="toggle-content"><p>这段代码展示了<code>std::auto_ptr</code>的一个特别之处，这个特别之处在于它的拷贝行为。当你执行<code>t1 = t2;</code>这一操作时，你实际上是在做两件事：</p>
<ol>
<li>
<p><strong>转移所有权</strong>：<code>std::auto_ptr</code>有一个所谓的“独占”所有权模型，意味着一个<code>auto_ptr</code>对象在任何时刻只能拥有一个对动态分配对象的所有权。当你将一个<code>auto_ptr</code>赋值给另一个时（在这里是<code>t1 = t2;</code>），你实际上将<code>t2</code>所拥有的对象的所有权转移给了<code>t1</code>。在赋值后，<code>t1</code>将指向<code>t2</code>之前所拥有的对象，而<code>t2</code>将变为null。</p>
</li>
<li>
<p><strong>可能导致悬垂指针</strong>：由于<code>t2</code>的所有权被转移了，<code>t2</code>现在是空的（null）。如果你在赋值操作之后试图使用<code>t2</code>，你将访问一个null指针，这可能导致未定义的行为。更糟糕的是，如果<code>t1</code>之前已经拥有一个对象的所有权，那么这次赋值操作将导致<code>t1</code>原来指向的对象被删除（因为<code>auto_ptr</code>在转移所有权时会删除自己原来管理的对象），这就可能导致原来的资源泄露，如果还有其他指针指向这个被<code>t1</code>释放的对象，它们就变成了悬垂指针。</p>
</li>
</ol>
<p>因此，使用<code>std::auto_ptr</code>时，需要非常小心地管理所有权，以避免资源泄漏和悬垂指针的问题。正是由于这种复杂且容易出错的所有权管理，<code>std::auto_ptr</code>已经在C++11标准中被废弃，并被更现代且安全的智能指针如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>所取代。这些现代智能指针提供了更清晰、更安全的所有权语义，使得资源管理更加简单和直观。</p>
</div></details>
</li>
<li>
<p>C++11 后auto_ptr 已经被“抛弃”，已使用unique_ptr替代！C++11后不建议使用auto_ptr。</p>
</li>
<li>
<p><strong>auto_ptr 被C++11抛弃的主要原因</strong></p>
<p><strong>1).</strong> 复制或者赋值都会改变资源的所有权</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto_ptr 被C++11抛弃的主要原因</span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span><br><span class="hljs-comment">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span><br>p1 = p2;	<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/20210720110118558.png" alt=""></p>
<p><strong>2).</strong> 在STL容器中使用<code>auto_ptr</code>存在着重大风险，因为容器内的元素必须支持可复制和可赋值</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;auto_ptr&lt;string&gt;&gt; vec;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P3&quot;</span>))</span></span>;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P4&quot;</span>))</span></span>;<br><br><span class="hljs-comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p4));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><br><span class="hljs-comment">// 风险来了：</span><br>vec[<span class="hljs-number">0</span>] = vec[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 如果进行赋值，问题又回到了上面一个问题中。</span><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/2021072011341696.png" alt=""></p>
<p><strong>3).</strong> 不支持对象数组的内存管理</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;    <span class="hljs-comment">// 不能这样定义</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>所以，C++11用更严谨的<code>unique_ptr</code> 取代了<code>auto_ptr</code>！</p>
<hr>
<p><br><br><br></p>
<h4 id="3-3-unique-ptr">3.3 unique_ptr</h4>
<p><code>auto_ptr</code>是用于C++11之前的智能指针。由于 <code>auto_ptr</code> 基于排他所有权模式：两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。<code>auto_ptr</code>主要有三大问题：</p>
<ol>
<li>复制和赋值会改变资源的所有权，不符合人的直觉。</li>
<li>在 STL 容器中使用<code>auto_ptr</code>存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。</li>
<li>不支持对象数组的操作</li>
</ol>
<p>以上问题已经在上面体现出来了，下面将使用<code>unique_ptr</code>解决这些问题。</p>
<p>所以，C++11用更严谨的<code>unique_ptr</code> 取代了<code>auto_ptr</code>！</p>
<p><code>unique_ptr</code> 和 <code>auto_ptr</code>用法几乎一样，除了一些特殊。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">std::move() </summary><div class="toggle-content"><p><code>std::move()</code>是C++11及之后标准中引入的一个标准库函数，它的作用是将其参数转换为右值引用。这个函数本身并不移动任何东西；它仅仅是一个类型转换函数，允许在特定的情况下启用移动语义。</p>
<p><strong>移动语义的基础</strong>：</p>
<p>在C++中，对象通常通过两种方式传递：复制和移动。复制是创建一个对象的副本，而移动是将资源从一个对象转移到另一个，通常在原对象不再需要这些资源的情况下进行。移动语义是C++11引入的一个特性，它允许资源的高效转移，减少了不必要的复制，从而提高程序的性能。</p>
<p><strong><code>std::move()</code>的工作原理</strong>：</p>
<ul>
<li><strong>类型转换</strong>：<code>std::move()</code>将其参数转换为对应的右值引用类型（<code>T&amp;&amp;</code>），这个转换提示编译器该对象可以安全地进行移动操作。这意味着，在调用<code>std::move()</code>后，可以使用该对象的移动构造函数或移动赋值操作符（如果它们被定义的话）。</li>
<li><strong>启用移动操作</strong>：通过将对象转换为右值引用，<code>std::move()</code>允许开发者在特定情况下显式地表示一个对象可以被&quot;移动&quot;。这是通过调用对象的移动构造函数或移动赋值操作符来实现的，这些操作通常比复制构造函数或赋值操作符更高效，因为它们仅涉及资源的转移而不是复制。</li>
</ul>
<p><strong>使用场景和注意事项</strong>：</p>
<ul>
<li><strong>所有权转移</strong>：当你想将一个对象的资源转移到另一个对象，并且原对象之后不再需要这些资源时，可以使用<code>std::move()</code>。</li>
<li><strong>临时对象和返回值</strong>：在处理临时对象或函数返回值时，编译器通常会自动利用移动语义。在这种情况下，通常不需要显式使用<code>std::move()</code>。</li>
<li><strong>谨慎使用</strong>：使用<code>std::move()</code>后，原对象处于一个有效但不可预测的状态。这意味着，除非对象被销毁或赋予新值，否则不应该再使用该对象。因此，<code>std::move()</code>应该谨慎使用，确保移动操作后不会再错误地使用被移动的对象。</li>
</ul>
<p>通过这样的机制，<code>std::move()</code>在C++中扮演着重要的角色，使得开发者能够更有效地控制对象的资源管理和性能优化。</p>
</div></details>
<br>
<ul>
<li><strong><u><code>unique_ptr</code>特性</u></strong></li>
</ul>
<ol>
<li>基于排他所有权模式：两个指针不能指向同一个资源</li>
<li>无法进行左值<code>unique_ptr</code>复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</li>
<li>保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。</li>
<li>在容器中保存指针是安全的</li>
</ol>
<p><strong>A</strong>. 无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br>	<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// p1 = p2;                     // 禁止左值赋值</span><br><span class="hljs-comment">// unique_ptr&lt;string&gt; p3(p2);  // 禁止左值赋值构造</span><br><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>;<br>p1 = std::<span class="hljs-built_in">move</span>(p2);   <span class="hljs-comment">// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure>
<p><strong>B</strong>. 在 STL 容器中使用<code>unique_ptr</code>，不允许直接赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;unique_ptr&lt;string&gt;&gt; vec;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P3&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P4&quot;</span>))</span></span>;<br><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p4));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">// vec[0] = vec[1];   /* 不允许直接赋值 */</span><br>vec[<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">move</span>(vec[<span class="hljs-number">1</span>]);     <span class="hljs-comment">// 需要使用move修饰，使得程序员知道后果</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;	<br><span class="hljs-comment">// 当然，运行后是直接报错的，因为vec[1]已经是NULL了，再继续访问就越界了。</span><br></code></pre></td></tr></table></figure>
<p><strong>C</strong>. 支持对象数组的内存管理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 会自动调用delete [] 函数去释放内存</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;    <span class="hljs-comment">// 支持这样定义</span><br></code></pre></td></tr></table></figure>
<p>除了上面<strong>ABC</strong>三项外，<code>unique_ptr</code>的其余用法都与<code>auto_ptr</code>用法一致。</p>
<ol>
<li>
<p><strong>构造</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的构造函数...&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的析构函数...&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do something......&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 自定义一个内存释放器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructTest</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Test *pt)</span> </span>&#123;<br>        pt-&gt;<span class="hljs-built_in">doSomething</span>();<br>        <span class="hljs-keyword">delete</span> pt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// unique_ptr&lt;T&gt; up; 空的unique_ptr，可以指向类型为T的对象</span><br>unique_ptr&lt;Test&gt; t1;<br><br><span class="hljs-comment">// unique_ptr&lt;T&gt; up1(new T());    定义unique_ptr,同时指向类型为T的对象</span><br><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br><span class="hljs-comment">// unique_ptr&lt;T[]&gt; up;    空的unique_ptr，可以指向类型为T[的数组对象</span><br>unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; t3;<br><br><span class="hljs-comment">// unique_ptr&lt;T[]&gt; up1(new T[]);    定义unique_ptr,同时指向类型为T的数组对象</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">t4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br><br><span class="hljs-comment">// unique_ptr&lt;T, D&gt; up();    空的unique_ptr，接受一个D类型的删除器D，使用D释放内存</span><br>unique_ptr&lt;Test, DestructTest&gt; t5;<br><br><span class="hljs-comment">// unique_ptr&lt;T, D&gt; up(new T());    定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存</span><br><span class="hljs-function">unique_ptr&lt;Test, DestructTest&gt; <span class="hljs-title">t6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br></code></pre></td></tr></table></figure>
 <details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">删除器（Deleter） </summary><div class="toggle-content"><p>删除器（Deleter）是与智能指针一起使用的一个对象或函数指针，用来自定义智能指针释放其所拥有资源的方式。在<code>std::unique_ptr</code>的上下文中，删除器提供了一种机制，允许开发者指定当智能指针被销毁时应如何清理其所管理的资源。这是非常有用的，特别是当你需要对一些非标准资源进行管理时，例如打开的文件句柄、数据库连接、或者是需要调用特殊函数来释放的内存。</p>
<p>在标准用法中，<code>std::unique_ptr</code>默认使用<code>delete</code>或<code>delete[]</code>来释放其管理的对象或数组。但是，通过提供一个自定义删除器，你可以覆盖这一默认行为，实现资源的特殊管理策略。</p>
<p><strong>如何使用删除器</strong>：</p>
<p>在你的示例中，<code>DestructTest</code>类被定义为一个删除器。它重载了<code>operator()</code>，使其能接受一个指向<code>Test</code>类型对象的指针。当<code>unique_ptr&lt;Test, DestructTest&gt;</code>需要释放其管理的对象时，它会调用这个删除器，而不是直接使用<code>delete</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructTest</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Test *pt)</span> </span>&#123;<br>        pt-&gt;<span class="hljs-built_in">doSomething</span>();<br>        <span class="hljs-keyword">delete</span> pt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个删除器首先调用<code>Test</code>对象的<code>doSomething</code>方法，然后使用<code>delete</code>来释放对象。这意味着，除了释放内存之外，你还可以执行一些清理工作，比如关闭文件、释放网络资源等。</p>
<p><strong>使用场景</strong></p>
<p>删除器的一些典型使用场景包括：</p>
<ul>
<li><strong>资源管理</strong>：当你需要对某些特定资源执行特定的释放策略时，比如使用特定的库函数来释放资源。</li>
<li><strong>调试和日志记录</strong>：在释放资源前进行日志记录，帮助调试。</li>
<li><strong>错误处理和资源回收</strong>：在释放资源前检查错误状态或进行必要的资源回收。</li>
</ul>
<p><strong>创建带删除器的<code>unique_ptr</code></strong></p>
<p>你可以这样创建一个带有自定义删除器的<code>unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;Test, DestructTest&gt; <span class="hljs-title">t6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br></code></pre></td></tr></table></figure>
<p>这行代码创建了一个<code>unique_ptr</code>，它管理一个<code>Test</code>对象，并且当<code>unique_ptr</code>被销毁或重新赋值时，将使用<code>DestructTest</code>删除器来释放<code>Test</code>对象。这提供了一种灵活的方式来控制资源的释放过程。</p>
<p><strong>总结</strong></p>
<p>自定义删除器为智能指针提供了额外的灵活性，使得资源管理更加安全和灵活。通过使用删除器，你可以确保即使在需要特殊处理的场景下，资源也能被正确管理。</p>
</div></details>
</li>
<li>
<p><strong>赋值</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t8</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>t7 = std::<span class="hljs-built_in">move</span>(t8);	<span class="hljs-comment">// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理</span><br>t7-&gt;<span class="hljs-built_in">doSomething</span>();<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主动释放对象</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t9</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-comment">// 法一：t9 = NULL;</span><br><span class="hljs-comment">// 法二：t9 = nullptr;</span><br><span class="hljs-comment">// 法三：t9.reset();</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>放弃对象的控制权</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Test *t10 = t9.<span class="hljs-built_in">release</span>();<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>重置</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">t9.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Test);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<br>
<ul>
<li><strong><u><code>auto_ptr</code> 与 <code>unique_ptr</code>智能指针的内存管理陷阱</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">auto_ptr&lt;string&gt; p1;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;智能指针的内存管理陷阱&quot;</span>);<br>p1.<span class="hljs-built_in">reset</span>(str);	<span class="hljs-comment">// p1托管str指针</span><br>&#123;<br>    auto_ptr&lt;string&gt; p2;<br>    p2.<span class="hljs-built_in">reset</span>(str);	<span class="hljs-comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span><br>&#125;<br><br><span class="hljs-comment">// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str：&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>这是由于<code>auto_ptr</code> 与 <code>unique_ptr</code>的排他性所导致的！<br>
<strong>为了解决这样的问题，我们可以使用<code>shared_ptr</code>指针指针！</strong></p>
<hr>
<p><br><br><br></p>
<h4 id="3-4-share-ptr">3.4 share_ptr</h4>
<p>熟悉了<code>unique_ptr</code> 后，其实我们发现<code>unique_ptr</code> 这种排他型的内存管理并不能适应所有情况，有很大的局限！如果需要多个指针变量共享怎么办？</p>
<p>如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，引用计数加1，当智能指针析构时，引用计数减1，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它！这就是 <code>shared_ptr</code> 采用的策略！</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/5f693d90c02c4a9ab4d888be04f83e0f.png" alt=""></p>
<ul>
<li><strong><u>例</u></strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> v) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;no = v;<br>        cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \t no = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;no &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \t no = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;no &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> no;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数，内存删除</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructPerson</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Person *pt)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;DestructPerson...&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> pt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>引用计数的使用</strong></p>
<p>调用<strong>use_count</strong>函数可以获得当前托管指针的引用计数。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">shared_ptr&lt;Person&gt; sp1;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>))</span></span>;<br><br><span class="hljs-comment">// 获取智能指针管控的共享指针的数量    use_count()：引用计数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1    use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2    use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-comment">// 共享</span><br>sp1 = sp2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1    use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2    use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp1    use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2    use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2    use_count() = &quot;</span> &lt;&lt; sp3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>如上代码，<code>sp1 = sp2;</code> 和 <code>shared_ptr&lt; Person &gt; sp3(sp1);</code>就是在使用引用计数了。</p>
<p><code>sp1 = sp2;</code> → <code>sp1</code>和<code>sp2</code>共同托管同一个指针，所以他们的引用计数为2；</p>
<p><code>shared_ptr&lt; Person &gt; sp3(sp1);</code> → <code>sp1</code>和<code>sp2</code>和<code>sp3</code>共同托管同一个指针，所以他们的引用计数为3；</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/efb700f8babf4fe1ac4cfe088da15bc9.png" alt=""></p>
</li>
<li>
<p><strong>构造</strong></p>
<p><strong>1).</strong> <code>shared_ptr&lt; T &gt; sp1;</code> 空的<code>shared_ptr</code>，可以指向类型为<code>T</code>的对象</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">shared_ptr&lt;Person&gt; sp1;<br>Person *person1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-number">1</span>);<br>sp1.<span class="hljs-built_in">reset</span>(person1);	<span class="hljs-comment">// 托管person1</span><br></code></pre></td></tr></table></figure>
<p><strong>2).</strong> <code>shared_ptr&lt; T &gt; sp2(new T());</code> 定义<code>shared_ptr</code>,同时指向类型为<code>T</code>的对象</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>3).</strong> <code>shared_ptr&lt;T[]&gt; sp4;</code> 空的<code>shared_ptr</code>，可以指向类型为<code>T[]</code>的数组对象，<u>C++17后支持</u></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">shared_ptr&lt;Person[]&gt; sp4;<br></code></pre></td></tr></table></figure>
<p><strong>4).</strong> <code>shared_ptr&lt;T[]&gt; sp5(new T[] &#123; … &#125;);</code> 指向类型为<code>T</code>的数组对象，<u>C++17后支持</u></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;Person[]&gt; <span class="hljs-title">sp5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person[<span class="hljs-number">5</span>] &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>5).</strong> <code>shared_ptr&lt; T &gt; sp6(NULL, D());</code> 空的<code>shared_ptr</code>，接受一个<code>D</code>类型的删除器，使用<code>D</code>释放内存</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp6</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>, DestructPerson())</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>6).</strong> <code>shared_ptr&lt; T &gt; sp7(new T(), D())</code>; 定义<code>shared_ptr</code>,指向类型为<code>T</code>的对象，接受一个<code>D</code>类型的删除器，使用<code>D</code>删除器来释放内存</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">8</span>), DestructPerson())</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>初始化</strong></p>
<p><strong>1).</strong> 方式一：构造函数</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">// int(10) 的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(up1)</span></span>;          <span class="hljs-comment">// 使用智能指针up1构造up2, 此时int(10) 引用计数为2</span><br></code></pre></td></tr></table></figure>
<p><strong>2).</strong> 方式二：使用<code>make_shared</code> 初始化对象，分配内存效率更高(<strong>推荐使用</strong>)<br>
<code>make_shared</code>函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>;</p>
<p>用法：<br>
<code>make_shared&lt;类型&gt;(构造类型对象需要的参数列表);</code></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>); <span class="hljs-comment">// 多个参数以逗号&#x27;,&#x27;隔开，最多接受十个</span><br>shared_ptr&lt;string&gt; up4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-string">&quot;字符串&quot;</span>);<br>shared_ptr&lt;Person&gt; up5 = <span class="hljs-built_in">make_shared</span>&lt;Person&gt;(<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>赋值</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptrr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">// int(10) 的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// int(11) 的引用计数为1</span><br>up1 = up2;   <span class="hljs-comment">// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主动释放对象</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptrr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// up1 = nullptr ;	// int(10) 的引用计数减1,计数归零内存释放 </span><br><span class="hljs-comment">// 或</span><br><span class="hljs-comment">// up1 = NULL; // 作用同上 </span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>重置</strong></p>
<p>首先<code>p1</code>是一个指针！</p>
<p><code>p.reset() ;</code> 将p重置为空指针，所管理对象引用计数减1<br>
<code>p.reset(p1);</code>将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控<br>
<code>p.reset(p1,d);</code> 将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器</p>
</li>
<li>
<p><strong>交换</strong></p>
<p><code>p1</code> 和 <code>p2</code> 是智能指针</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::<span class="hljs-built_in">swap</span>(p1,p2); <span class="hljs-comment">// 交换p1 和p2 管理的对象，原对象的引用计数不变</span><br>p1.<span class="hljs-built_in">swap</span>(p2);      <span class="hljs-comment">// 交换p1 和p2 管理的对象，原对象的引用计数不变</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<br>
<ul>
<li><strong><u><code>shared_ptr</code>使用陷阱</u></strong></li>
</ul>
<p><code>shared_ptr</code>作为被管控的对象的成员时，小心因循环引用造成无法释放资源!</p>
<p>如下代码：<br>
Boy类中有Girl的智能指针；<br>
Girl类中有Boy的智能指针；<br>
当他们交叉互相持有对方的管理对象时…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Boy</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Boy 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Boy</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Boy 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Girl</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Girl 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Girl</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Girl 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br>    <span class="hljs-comment">// 陷阱用法</span><br>    spBoy-&gt;<span class="hljs-built_in">setGirlFriend</span>(spGirl);<br>    spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br>    <span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">useTrap</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行截图：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/12cc6f26f5974fd4ba3f73eea9d5a0f8.png" alt=""></p>
<p><strong>循环引用问题</strong>：</p>
<p>在这个例子中，<code>Boy</code>和<code>Girl</code>类的对象互相持有对方的<code>shared_ptr</code>：</p>
<ul>
<li>当<code>spBoy-&gt;setGirlFriend(spGirl);</code>被调用时，<code>Boy</code>对象持有了一个指向<code>Girl</code>对象的<code>shared_ptr</code>，这使得<code>Girl</code>对象的引用计数增加到2。</li>
<li>当<code>spGirl-&gt;setBoyFriend(spBoy);</code>被调用时，<code>Girl</code>对象持有了一个指向<code>Boy</code>对象的<code>shared_ptr</code>，这使得<code>Boy</code>对象的引用计数增加到2。</li>
</ul>
<p>此时，每个对象都通过<code>shared_ptr</code>被另一个对象持有，形成了一个循环引用。即使在<code>useTrap()</code>函数执行完毕后，<code>spBoy</code>和<code>spGirl</code>的生命周期结束，它们的引用计数减少了1，变成了1，但由于互相持有，它们的引用计数永远不会达到0，导致<code>Boy</code>和<code>Girl</code>对象都不会被析构和释放。</p>
<p><strong>所以在使用shared_ptr智能指针时，要注意避免对象交叉使用智能指针的情况！</strong> 否则会导致内存泄露！</p>
<p>当然，这也是有办法解决的，那就是使用<code>weak_ptr</code>弱指针。</p>
<p>针对上面的情况，还讲一下另一种情况。如果是单方获得管理对方的共享指针，那么这样着是可以正常释放掉的！<br>
例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br>    <span class="hljs-comment">// 单方获得管理</span><br>    <span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>    spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>反过来也是一样的！</p>
<p>这是什么原因呢？</p>
<ol>
<li>首先释放spBoy，但是因为girl对象里面的智能指针还托管着boy，boy的引用计数为2，所以释放spBoy时，引用计数减1，boy的引用计数为1；</li>
<li>在释放spGirl，girl的引用计数减1，为零，开始释放girl的内存，因为girl里面还包含有托管boy的智能指针对象，所以也会进行boyFriend的内存释放，boy的引用计数减1，为零，接着开始释放boy的内存。最终所有的内存都释放了。</li>
</ol>
<hr>
<p><br><br><br></p>
<h4 id="3-5-weak-ptr">3.5 weak_ptr</h4>
<p><code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来<strong>协助</strong> <code>shared_ptr</code> 工作, <strong>它只可以从一个 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 对象构造</strong>, 它的构造和析构<u>不会引起引用记数的增加或减少</u>。 同时<code>weak_ptr</code> 没有重载<code>*</code>和<code>-&gt;</code>但可以使用 <code>lock</code> 获得一个可用的 <code>shared_ptr</code> 对象。</p>
<ol>
<li>
<p>弱指针的使用；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">weak_ptr wpGirl_1;         <span class="hljs-comment">// 定义空的弱指针</span><br><span class="hljs-function">weak_ptr <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>; <span class="hljs-comment">// 使用共享指针构造</span><br>wpGirl_1 = spGirl;         <span class="hljs-comment">// 允许共享指针赋值给弱指针</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>弱指针也可以获得引用计数；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">wpGirl_1.<span class="hljs-built_in">use_count</span>();<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>弱指针不支持 <code>*</code> 和 <code>-&gt;</code> 对指针的访问；<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/638a22f9e63f4a4db26715d9bcaf5a9a.jpg" alt=""></p>
</li>
<li>
<p>在必要的使用可以转换成共享指针 <code>lock()</code>；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">shared_ptr&lt;Girl&gt; sp_girl;<br>sp_girl = wpGirl_1.<span class="hljs-built_in">lock</span>();<br><br><span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br><span class="hljs-comment">// 弱指针的使用</span><br>weak_ptr&lt;Girl&gt; wpGirl_1;            <span class="hljs-comment">// 定义空的弱指针</span><br><span class="hljs-function">weak_ptr&lt;Girl&gt; <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>;    <span class="hljs-comment">// 使用共享指针构造</span><br>wpGirl_1 = spGirl;                  <span class="hljs-comment">// 允许共享指针赋值给弱指针</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;spGirl \t use_count = &quot;</span> &lt;&lt; spGirl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;wpGirl_1 \t use_count = &quot;</span> &lt;&lt; wpGirl_1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>	<br><span class="hljs-comment">// 弱指针不支持 * 和 -&gt; 对指针的访问</span><br><span class="hljs-comment">/*wpGirl_1-&gt;setBoyFriend(spBoy);</span><br><span class="hljs-comment">(*wpGirl_1).setBoyFriend(spBoy);*/</span><br><br><span class="hljs-comment">// 在必要的使用可以转换成共享指针</span><br>shared_ptr&lt;Girl&gt; sp_girl;<br>sp_girl = wpGirl_1.<span class="hljs-built_in">lock</span>();<br><br>cout &lt;&lt; sp_girl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>当然这只是一些使用上的小例子，具体用法如下：</p>
<p><strong>解决循环引用问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Boy</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Boy 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Boy</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Boy 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br><br><br>        <span class="hljs-comment">// 在必要的使用可以转换成共享指针</span><br>        shared_ptr&lt;Girl&gt; sp_girl;<br>        sp_girl = <span class="hljs-keyword">this</span>-&gt;girlFriend.<span class="hljs-built_in">lock</span>();<br><br>        cout &lt;&lt; sp_girl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>        <span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>        sp_girl = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    weak_ptr&lt;Girl&gt; girlFriend;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Girl</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Girl 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Girl</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Girl 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br>    spBoy-&gt;<span class="hljs-built_in">setGirlFriend</span>(spGirl);<br>    spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">useTrap</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/962aac5ecd4b4960b4e94d611befc5e5.jpg" alt=""></p>
<p>在类中使用弱指针接管共享指针，在需要使用时就转换成共享指针去使用即可！</p>
<p>自此问题完美解决！</p>
<br>
<ul>
<li><strong><u><code>expired</code>函数的用法</u></strong></li>
</ul>
<p><code>expired</code>：判断当前<code>weak_ptr</code>智能指针是否还有托管的对象，有则返回<code>false</code>，无则返回<code>true</code></p>
<p>如果返回<code>true</code>，等价于 <code>use_count() == 0</code>，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。</p>
<p><strong>示例</strong><br>
演示如何用 expired 检查指针的合法性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; gw;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true</span><br>    <span class="hljs-keyword">if</span> (!gw.<span class="hljs-built_in">expired</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;gw is valid\n&quot;</span>;    <span class="hljs-comment">// 有效的，还有托管的指针</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;gw is expired\n&quot;</span>;  <span class="hljs-comment">// 过期的，没有托管的指针</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-keyword">auto</span> sp = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br>        gw = sp;<br><br>        <span class="hljs-built_in">f</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 当&#123; &#125;体中的指针生命周期结束后，再来判断其是否还有托管的指针</span><br>    <span class="hljs-built_in">f</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/c8f3629ecba64a42b3ae0a57196c7ca8.png" alt=""></p>
<p>在 { } 中，sp的生命周期还在，gw还在托管着make_shared赋值的指针(sp)，所以调用f()函数时打印&quot;gw is valid\n&quot;;<br>
当执行完 { } 后，sp的生命周期已经结束，已经调用析构函数释放make_shared指针内存(sp)，gw已经没有在托管任何指针了，调用expired()函数返回true，所以打印&quot;gw is expired\n&quot;;</p>
<hr>
<p><br><br><br></p>
<h4 id="3-6-智能指针的使用陷阱">3.6 智能指针的使用陷阱</h4>
<ol>
<li>
<p>不要把一个原生指针给多个智能指针管理;</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-function">unique_ptr&lt; <span class="hljs-type">int</span> &gt; <span class="hljs-title">up1</span><span class="hljs-params">(x)</span></span>;<br><span class="hljs-function">unique_ptr&lt; <span class="hljs-type">int</span> &gt; <span class="hljs-title">up2</span><span class="hljs-params">(x)</span></span>;<br><span class="hljs-comment">// 警告! 以上代码使up1 up2指向同一个内存,非常危险</span><br><span class="hljs-comment">// 或以下形式：</span><br>up1.<span class="hljs-built_in">reset</span>(x);<br>up2.<span class="hljs-built_in">reset</span>(x);<br></code></pre></td></tr></table></figure>
 <details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看解释 </summary><div class="toggle-content"><p>示例代码展示了<code>std::unique_ptr</code>的一个非常关键的错误使用方式，即两个<code>std::unique_ptr</code>实例被设置为指向同一个动态分配的内存。这是非常危险的，因为<code>std::unique_ptr</code>被设计为拥有其指向对象的<strong>独占所有权</strong>，意味着当一个<code>std::unique_ptr</code>对象被销毁时，它会自动删除其管理的内存。如果有两个<code>std::unique_ptr</code>指向同一个内存地址，当其中一个<code>std::unique_ptr</code>被销毁（或者其<code>reset</code>方法被调用）时，它会删除内存，而另一个<code>std::unique_ptr</code>仍然认为它拥有那块内存的所有权，这将在其析构或<code>reset</code>时再次尝试删除同一块内存，导致未定义行为，最常见的是程序崩溃。</p>
<p><strong>结论</strong></p>
<p>永远不要让两个<code>unique_ptr</code>指向同一块内存。这种做法违背了<code>unique_ptr</code>的设计原则，并且会导致运行时错误。正确的资源管理和智能指针的使用是现代C++中非常重要的一部分，需要仔细设计以避免这类问题。</p>
</div></details>
</li>
<li>
<p>记得使用<code>u.release()</code>的返回值;<br>
在调用<code>u.release()</code>时是不会释放<code>u</code>所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.</p>
</li>
<li>
<p>禁止<code>delete</code> 智能指针 <code>get</code> 函数返回的指针;<br>
如果我们主动释放掉 <code>get</code> 函数获得的指针，那么智能指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果!</p>
</li>
<li>
<p>禁止用任何类型智能指针 <code>get</code> 函数返回的指针去初始化另外一个智能指针！</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt; <span class="hljs-type">int</span> &gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// 一个典型的错误用法 shared_ptr&lt; int &gt; sp4(sp1.get());</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>总结：</p>
<p>智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！</p>
</blockquote>
<hr>
<p><br><br><br></p>
<h3 id="4-引用">4. 引用</h3>
<p>C++中的引用本质上是对另一个变量的别名，它提供了另一种访问变量的方式。从实现的角度看，引用通常是通过指针来实现的，但这对于C++程序员是透明的，即编程时你不需要也不应该将引用视为指针。</p>
<p><strong>实现细节</strong>:</p>
<ul>
<li><strong>编译器处理</strong>：编译器在处理引用时，内部会将引用视为指向被引用变量的指针。当你通过引用访问变量时，编译器生成的代码实际上是通过这个指针来访问变量的。</li>
<li><strong>语义层面的差异</strong>：尽管在实现层面引用可能通过指针实现，但引用和指针在语义上有明显区别。<u>引用在定义时必须被初始化，并且不能被重新绑定到另一个变量</u>；而指针可以在任何时候被赋予新的地址值。</li>
</ul>
<p><strong>编译阶段的处理</strong>：</p>
<ul>
<li><strong>引用的创建</strong>：在编译阶段，当声明一个引用时，编译器确保引用被正确地初始化为某个变量的别名。这可能涉及到调整代码，以确保通过引用的访问被转换为对实际变量的访问。</li>
<li><strong>引用的使用</strong>：当通过引用读写变量时，编译器生成的代码并不是对引用本身的操作，而是直接对被引用的变量进行操作。这意味着，尽管引用的实现可能依赖于指针，但使用引用的代码与直接操作变量的代码在效果上是一致的，没有额外的间接层或性能开销。</li>
</ul>
<p><strong>举例说明</strong>:</p>
<p>假设有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; ref = x;<br>ref = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure>
<p>在这段代码中，<code>ref</code>是变量<code>x</code>的引用。从程序员的视角看，<code>ref</code>就是<code>x</code>的另一个名字。在编译阶段，编译器处理对<code>ref</code>的赋值操作，就如同直接对<code>x</code>赋值一样，确保<code>x</code>的值被更新为20。实际生成的机器码将直接反映这一操作，而不会表现出任何间接引用的痕迹。</p>
<p><strong>结论</strong>:</p>
<p>虽然C++标准没有规定引用必须通过指针来实现，但在很多编译器的实现中，引用的行为是通过指针实现的。关键的区别在于，引用提供的是一种更安全、更直观的语法来间接操作变量，同时在语义上隐藏了指针的复杂性。引用的引入，使得C++支持更丰富的编程模式，如函数参数传递、操作符重载等，同时保持了代码的简洁性和效率。</p>
<hr>
<br>
<ul>
<li><strong><u>引用做函数返回值</u></strong></li>
</ul>
<p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">//返回静态变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//不能返回局部变量的引用</span><br>    <span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">test01</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;        <span class="hljs-comment">// 第一次结果正确，是因为编译器做了保留</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;        <span class="hljs-comment">// 第二次结果错误，是因为a的内存已经释放</span><br><br>    <span class="hljs-comment">//如果函数做左值，那么必须返回引用</span><br>    <span class="hljs-type">int</span>&amp; ref2 = <span class="hljs-built_in">test02</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ref = 10<br>ref = 2077998048<br>ref2 = 20<br>ref2 = 20<br>ref2 = 1000<br>ref2 = 1000<br></code></pre></td></tr></table></figure></div></details>
<hr>
<br>
<ul>
<li><strong><u>常量引用</u></strong></li>
</ul>
<p><strong>作用：</strong> 常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加<u>const修饰形参</u>，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 引用使用的场景，通常用来修饰形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// v += 10;</span><br>    cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br>    <span class="hljs-comment">// 加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// ref = 100;  //加入const后不可以修改变量</span><br>    cout &lt;&lt; ref &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 函数中利用常量引用防止误操作修改实参</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">showValue</span>(a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>GPT4：</p>
<p>在C++中，尝试将一个非<code>const</code>引用绑定到临时对象（如字面量<code>10</code>）是不合法的，因此，<code>int &amp;a = 10;</code>这条语句会导致编译错误。非<code>const</code>引用需要绑定到一个可修改的左值（lvalue），而字面量<code>10</code>是一个右值（rvalue），意味着它是一个临时的值，不可以被修改。</p>
<p>相反，<code>const int &amp;a = 10;</code>是合法的，因为<code>const</code>引用可以绑定到临时对象。在这种情况下，编译器会为临时值<code>10</code>创建一个匿名的、不可修改的临时变量，并让<code>a</code>引用它。这是一个允许<code>const</code>引用绑定到右值的特例，主要用途是允许函数参数以<code>const</code>引用的方式接受临时对象，以提高效率和灵活性。</p>
<p><strong>示例解释</strong>：</p>
<ul>
<li><strong>不合法的示例</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误: 非const引用不能绑定到临时对象</span><br></code></pre></td></tr></table></figure>
<p>这个示例试图将一个非<code>const</code>引用<code>a</code>绑定到字面量<code>10</code>上。因为字面量<code>10</code>是一个临时的右值，不能被修改，所以这是不合法的。</p>
<ul>
<li><strong>合法的示例</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法: const引用可以绑定到临时对象</span><br></code></pre></td></tr></table></figure>
<p>这里，<code>const int &amp;a = 10;</code>声明了一个<code>const</code>引用<code>a</code>，并将其绑定到字面量<code>10</code>上。尽管<code>10</code>是一个临时右值，但由于<code>a</code>是<code>const</code>引用，所以这是允许的。这种方式常用于函数参数传递，使得函数可以接受临时对象作为输入，同时避免了复制的开销。</p>
<p><strong>结论</strong>：</p>
<p>在C++中，非<code>const</code>引用不能绑定到临时对象上，而<code>const</code>引用可以。这反映了C++设计中的一个基本原则：通过限制对数据的修改来增加代码的安全性和灵活性。在实践中，这意味着你应该使用<code>const</code>引用来传递那些不需要修改的临时对象，以提高效率和代码的可读性。</p>
<hr>
<p><br><br></p>
<br>
<h3 id="5-函数">5. 函数</h3>
<ul>
<li><strong><u>函数默认参数</u></strong></li>
</ul>
<p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>规则</strong>：</p>
<ol>
<li>如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</li>
<li>如果函数声明有默认值，函数实现的时候就不能有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func1</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>√：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>×：（报错为：重定义默认参数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">20</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">30</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>占位参数</u></strong></li>
</ul>
<p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong>  <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 函数占位参数 ，占位参数也可以有默认参数</span><br><span class="hljs-comment">// void func(int a, int = 10) &#123;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>函数重载</u></strong></li>
</ul>
<p><strong>作用</strong>：函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件</strong>：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意</strong>: 函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<ul>
<li><strong><u>函数重载注意事项</u></strong></li>
</ul>
<ul>
<li>引用作为重载条件？</li>
<li>函数重载碰到函数默认参数？</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//函数重载注意事项</span><br><span class="hljs-comment">//1、引用作为重载条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//2、函数重载碰到函数默认参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//调用无const</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span><br><br><br>    <span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h3 id="6-类和对象">6. 类和对象</h3>
<blockquote>
<p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong></p>
<p>C++认为<strong>万事万物都皆为对象</strong>，对象上有其属性和行为</p>
<p><strong>例如：</strong>：</p>
<p>人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>具有相同性质的<strong>对象</strong>，我们可以抽象称为<strong>类</strong>，人属于人类，车属于车类</p>
</blockquote>
<br>
<h4 id="6-1-封装">6.1 封装</h4>
<p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<hr>
<br>
<ul>
<li><strong><u>封装的意义一</u></strong></li>
</ul>
<p>在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong>  <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong> 设计一个圆类，求圆的周长</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 圆周率</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-comment">// 1、封装的意义</span><br><span class="hljs-comment">// 将属性和行为作为一个整体，用来表现生活中的事物</span><br><br><span class="hljs-comment">// 封装一个圆类，求圆的周长</span><br><span class="hljs-comment">// class代表设计一个类，后面跟着的是类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 访问权限  公共的权限</span><br><br>    <span class="hljs-comment">// 属性</span><br>    <span class="hljs-type">int</span> m_r;<span class="hljs-comment">// 半径</span><br><br>    <span class="hljs-comment">// 行为</span><br>    <span class="hljs-comment">// 获取到圆的周长</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 2 * pi  * r</span><br>        <span class="hljs-comment">// 获取圆的周长</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 通过圆类，创建圆的对象</span><br>    <span class="hljs-comment">// c1就是一个具体的圆</span><br>    Circle c1;<br>    c1.m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">// 给圆对象的半径 进行赋值操作</span><br><br>    <span class="hljs-comment">// 2 * pi * 10 = = 62.8</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">calculateZC</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>封装的意义二</u></strong></li>
</ul>
<p>C++中类的访问权限控制是面向对象编程的核心特性之一，它帮助封装和隐藏了类的内部实现，只暴露必要的接口给类的使用者。C++提供了三种访问权限修饰符：<code>public</code>、<code>protected</code>和<code>private</code>，它们定义了类成员（包括数据成员和成员函数）的访问范围。</p>
<p><strong>public</strong></p>
<ul>
<li><strong>含义</strong>：被<code>public</code>修饰的成员可以在任何地方被访问，无论是类的内部还是外部。</li>
<li><strong>用途</strong>：通常用来定义类的接口，即那些可以安全地被类的使用者直接访问和使用的成员。</li>
</ul>
<p><strong>protected</strong></p>
<ul>
<li><strong>含义</strong>：被<code>protected</code>修饰的成员在类内部和派生类（子类）中可以被访问，但不能被类的实例直接访问。</li>
<li><strong>用途</strong>：<code>protected</code>成员主要用于继承关系中，允许子类访问和修改这些被保护的成员，同时对外隐藏实现细节。</li>
</ul>
<p><strong>private</strong></p>
<ul>
<li><strong>含义</strong>：被<code>private</code>修饰的成员只能被类的成员函数和友元函数（通过<code>friend</code>声明）访问，对类的使用者是不可见的。</li>
<li><strong>用途</strong>：<code>private</code>成员用于实现类的内部逻辑，是类的实现细节，它们对类的使用者是隐藏的。</li>
</ul>
<p><strong>默认访问权限</strong></p>
<ul>
<li><strong>类</strong>：如果不显式指定访问权限，则类的成员<strong>默认是<code>private</code></strong> 的。</li>
<li><strong>结构体（struct）</strong>：结构体的成员<strong>默认是<code>public</code></strong> 的。这是结构体和类的一个主要区别，尽管它们在C++中都支持成员函数和继承等面向对象的特性。</li>
</ul>
<p><strong>访问权限示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> publicVar; <span class="hljs-comment">// 可以在任何地方访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicMethod</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 可以在任何地方访问</span><br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> protectedVar; <span class="hljs-comment">// 只能在类内部、友元和派生类中访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">protectedMethod</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 只能在类内部、友元和派生类中访问</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar; <span class="hljs-comment">// 只能在类内部和友元中访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 只能在类内部和友元中访问</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClass</span> : <span class="hljs-keyword">public</span> MyClass &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        publicVar = <span class="hljs-number">1</span>; <span class="hljs-comment">// OK</span><br>        protectedVar = <span class="hljs-number">2</span>; <span class="hljs-comment">// OK</span><br>        <span class="hljs-comment">// privateVar = 3; // 错误：privateVar在派生类中不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.publicVar = <span class="hljs-number">1</span>; <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// obj.protectedVar = 2; // 错误：protectedVar在类外部不可访问</span><br>    <span class="hljs-comment">// obj.privateVar = 3; // 错误：privateVar在类外部不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过正确使用访问权限修饰符，可以确保类的内部状态被适当地保护，同时向类的使用者提供一个清晰、稳定的接口。这有助于提高代码的可维护性和可扩展性。</p>
<hr>
<br>
<ul>
<li><u><strong>成员属性设置为私有</strong></u></li>
</ul>
<p><strong>优点1：</strong> 将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong> 对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//姓名设置可读可写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        m_Name = name;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Name;<br>    &#125;<br><br><br>    <span class="hljs-comment">//获取年龄 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Age;<br>    &#125;<br>    <span class="hljs-comment">//设置年龄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;???&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        m_Age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//Idol设置为只写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setIdol</span><span class="hljs-params">(string Idol)</span> </span>&#123;<br>        m_Idol = Idol;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string m_Name; <span class="hljs-comment">//可读可写  姓名</span><br><br>    <span class="hljs-type">int</span> m_Age; <span class="hljs-comment">//只读  年龄</span><br><br>    string m_Idol; <span class="hljs-comment">//只写  Idol</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Person p;<br>    <span class="hljs-comment">//姓名设置</span><br>    p.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">//年龄设置</span><br>    p.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">50</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">//Idol设置</span><br>    p.<span class="hljs-built_in">setIdol</span>(<span class="hljs-string">&quot;马嘉祺&quot;</span>);<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;Idol： &quot; &lt;&lt; p.m_Idol &lt;&lt; endl;  //只写属性，不可以读取</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>类的声明和定义分离</u></strong></li>
</ul>
<p>在实际的C++项目中，将类的声明和定义分别放在不同的文件中是一种常见且推荐的做法。这种做法不仅有助于代码的组织和管理，还能提高编译效率。具体来说，类的声明通常放在头文件（<code>.h</code>或<code>.hpp</code>文件）中，而类成员函数的定义则放在源文件（<code>.cpp</code>文件）中。</p>
<p><strong>类的声明</strong>:</p>
<p>类的声明提供了关于类的基本信息，包括类的名称、它包含的数据成员（属性）以及成员函数（方法）的原型。类的声明基本上是类的一个接口说明，告诉使用者可以如何与类的对象进行交互，而无需了解具体的实现细节。</p>
<p><strong>示例：MyClass.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYCLASS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYCLASS_H</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 一个成员函数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> myDataMember; <span class="hljs-comment">// 一个数据成员</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p><strong>类的定义</strong>:</p>
<p>类的定义包含了数据成员和成员函数的具体实现。将定义放在源文件中，可以隐藏实现细节，同时允许在不影响使用类的代码的情况下更改这些实现。此外，当类定义发生变化时，只需重新编译实现该类的源文件，而不是所有包含了类声明的头文件的源文件，这样可以减少编译依赖，提高编译效率。</p>
<p><strong>示例：MyClass.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br>MyClass::<span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">myDataMember</span>(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 构造函数的实现</span><br>&#125;<br><br>MyClass::~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-comment">// 析构函数的实现</span><br>    <span class="hljs-comment">// 清理资源</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myMethod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 成员函数的实现</span><br>    <span class="hljs-comment">// 方法实现</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用类</strong>:</p>
<p>当其他源文件需要使用<code>MyClass</code>时，只需包含类的头文件。这样，编译器在编译这些源文件时就能够识别<code>MyClass</code>的存在和它的接口，而无需知道类成员函数的具体实现。</p>
<p><strong>示例：main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj; <span class="hljs-comment">// 创建MyClass的对象</span><br>    obj.<span class="hljs-built_in">myMethod</span>(); <span class="hljs-comment">// 调用成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>总结</strong>:</p>
<p>将类的声明和定义分别放在头文件和源文件中是C++项目中的一种最佳实践。这种做法有助于提高代码的可读性和可维护性，同时减少不必要的编译依赖，提高编译效率。</p>
<hr>
<br>
<p><br><br></p>
<h4 id="6-2-构造函数和析构函数">6.2 构造函数和析构函数</h4>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">用析构函数来释放内存 </summary><div class="toggle-content"><p>当一个类的对象被销毁时，C++不会自动释放对象中指针成员所指向的动态分配的内存。这是因为C++运行时系统不会跟踪指针所指向的内存；管理这块内存的责任在于开发者。如果你在类中使用了指向动态分配内存的指针，你需要在类的析构函数中显式地释放这块内存，以避免内存泄漏。</p>
<p><strong>为什么需要显式释放内存</strong></p>
<p>C++提供了自动内存管理的机制，如栈上的自动变量，其生命周期由编译器自动管理。然而，对于通过<code>new</code>操作符在堆上动态分配的内存，C++要求程序员显式地调用<code>delete</code>来释放内存。这种设计给予了程序员更大的灵活性和控制权，但也带来了更大的责任，特别是在异常安全和资源管理方面。</p>
<p><strong>示例：使用析构函数释放内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-comment">// 构造函数动态分配内存</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数释放内存</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>MyClass</code>的构造函数中分配了一个整数的动态内存，析构函数中释放了这块内存。当<code>MyClass</code>的对象离开其作用域被销毁时，析构函数会自动被调用，从而释放动态分配的内存。</p>
<p><strong>内存管理的最佳实践</strong></p>
<p>为了避免内存泄漏和其他资源管理错误，C++11引入了智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>），它们可以自动管理动态分配的内存。使用智能指针，你可以避免直接使用原始指针带来的大多数内存管理问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; data;<br><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>std::unique_ptr</code>接管了动态内存的生命周期管理。当<code>MyClass</code>的对象被销毁时，<code>std::unique_ptr</code>的析构函数会自动释放其所管理的内存，无需手动编写析构代码来释放内存。</p>
<p>总之，虽然C++不会自动释放对象中指针所指向的内存，但通过合理使用析构函数和智能指针，可以有效管理动态分配的资源，避免内存泄漏。</p>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>构造函数的分类及调用</u></strong></li>
</ul>
<p>两种分类方式：</p>
<ul>
<li>
<p>按参数分为： 有参构造和无参构造</p>
</li>
<li>
<p>按类型分为： 普通构造和拷贝构造</p>
</li>
</ul>
<p>三种调用方式：</p>
<ul>
<li>
<p>括号法</p>
</li>
<li>
<p>显示法</p>
</li>
<li>
<p>隐式转换法</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参（默认）构造函数</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>        age = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        age = p.age;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参（默认）构造函数</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>        age = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        age = p.age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><span class="hljs-comment">//调用无参构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-comment">//调用有参的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//2.1  括号法，常用</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br>    <span class="hljs-comment">//Person p2();</span><br><br>    <span class="hljs-comment">//2.2 显式法</span><br>    Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);<br>    Person p3 = <span class="hljs-built_in">Person</span>(p2);<br>    <span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br>    <span class="hljs-comment">//2.3 隐式转换法</span><br>    Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>    Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br><br>    <span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br>    <span class="hljs-comment">//Person(p4);  // 编译器认为是Person p4; 然后发生重定义错误</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><span class="hljs-comment">//调用无参构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-comment">//调用有参的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//2.1  括号法，常用</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br>    <span class="hljs-comment">//Person p2();</span><br><br>    <span class="hljs-comment">//2.2 显式法</span><br>    Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);<br>    Person p3 = <span class="hljs-built_in">Person</span>(p2);<br>    <span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br>    <span class="hljs-comment">//2.3 隐式转换法</span><br>    Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>    Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br><br>    <span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br>    <span class="hljs-comment">//Person p5(p4);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">构造函数一定是公有的吗？ </summary><div class="toggle-content"><p>构造函数不一定非要设置为公有（public）。将构造函数设置为公有是最常见的情况，因为这允许在类的外部创建对象实例。然而，在某些特定的设计场景中，将构造函数设置为受保护（protected）或私有（private）也是有意义的。这样做通常与设计模式相关，比如单例模式、工厂模式或者是当你想限制对象创建方式时。</p>
<p><strong>私有构造函数</strong></p>
<p>当你将构造函数设置为私有时，这意味着不能在类的外部直接实例化该类。这种技术常用于实现如单例模式这样的设计模式。</p>
<p><strong>单例模式示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance; <span class="hljs-comment">// 保证这是一个单例</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-comment">// 禁用拷贝构造和赋值运算符</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Singleton</code>类的构造函数是私有的，这防止了类的外部直接创建<code>Singleton</code>类的实例。相反，实例通过<code>getInstance</code>静态成员函数访问，确保类只有一个实例。</p>
<p><strong>受保护的构造函数</strong>：</p>
<p>将构造函数设置为受保护的，这意味着只有该类及其派生类能够调用这个构造函数。</p>
<p><strong>受保护构造函数示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;&#125; <span class="hljs-comment">// 受保护构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">Base</span>() &#123;&#125; <span class="hljs-comment">// 派生类可以访问受保护的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这种情况下，只有<code>Base</code>类的派生类可以创建<code>Base</code>类的实例，这可以用在当你想要限制类的实例化，使之只能作为基类被继承时。</p>
<p><strong>总结</strong>：</p>
<p>构造函数不必总是公有的。根据类的设计目的，将构造函数设为私有或受保护的也是合理且有用的设计决策。通过限制构造函数的访问级别，你可以更精细地控制对象的创建和类的使用方式，以满足特定的设计需求。</p>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">如果没有显式定义拷贝构造函数，那是如何拷贝的？ </summary><div class="toggle-content"><p>拷贝构造函数是一种特殊的构造函数，其作用是初始化一个新对象作为现有对象的副本。它确实可以看作是一种能够接受同类对象作为参数的重载构造函数，但它有特定的形式和用途。拷贝构造函数的典型声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">const</span> ClassName&amp; other);<br></code></pre></td></tr></table></figure>
<p>这里的<code>ClassName</code>代表类名，<code>other</code>是对另一个同类型对象的引用，该引用是常量，意味着拷贝构造函数不应修改被拷贝的对象。</p>
<p><strong>拷贝构造函数的特点</strong>：</p>
<ol>
<li><strong>参数</strong>：拷贝构造函数的参数是当前类类型的一个常量引用。它不接受其他类型的参数。</li>
<li><strong>作用</strong>：用于在以下几种情况下创建一个对象的副本：
<ul>
<li>显式或隐式地将一个对象作为参数传递给函数。</li>
<li>从函数返回一个对象。</li>
<li>用一个对象初始化另一个对象。</li>
</ul>
</li>
<li><strong>默认行为</strong>：如果没有为类显式定义拷贝构造函数，C++编译器会自动生成一个默认的拷贝构造函数，执行成员逐个拷贝（通常是浅拷贝）。</li>
<li><strong>深拷贝 vs 浅拷贝</strong>：如果类成员包括指向动态分配内存的指针，通常需要显式定义拷贝构造函数来实现深拷贝，以避免潜在的内存管理问题。</li>
</ol>
<br>
<p>如果你没有为你的类显式定义一个拷贝构造函数，C++编译器会为你自动生成一个默认的拷贝构造函数。这个自动生成的拷贝构造函数执行的是浅拷贝（shallow copy），意味着它会逐个复制对象的所有成员变量到新对象中，这个复制过程是按成员的位复制（bitwise copy）进行的。</p>
<p><strong>浅拷贝的含义和影响</strong>:</p>
<ul>
<li><strong>对于非指针类型的成员</strong>，浅拷贝简单地复制其值。这对于内置数据类型（如<code>int</code>、<code>float</code>等）和包含这些类型的复合数据类型通常是足够的。</li>
<li><strong>对于指针类型的成员</strong>，浅拷贝只复制指针的值，而不复制指针所指向的数据。因此，原始对象和拷贝对象的指针成员将指向同一个内存地址。这可能会导致问题，如：
<ul>
<li>当原始对象或拷贝对象被销毁时，它们的析构函数可能尝试释放同一个内存地址，造成双重释放问题（double-free）。</li>
<li>修改一个对象中的动态分配数据也会影响另一个对象，因为它们共享同一个数据。</li>
</ul>
</li>
</ul>
<p><strong>深拷贝</strong>:</p>
<p>为了解决浅拷贝可能导致的问题，特别是在类成员包含指向动态分配内存的指针时，可以显式定义自己的拷贝构造函数来实现深拷贝（deep copy）。深拷贝不仅复制指针的值，还复制指针所指向的数据到新的内存地址，这样原始对象和拷贝对象就有了各自独立的数据副本，互不干扰。</p>
<p><strong>示例</strong>:</p>
<p>下面是一个演示默认拷贝构造函数只执行浅拷贝的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    MyClass obj2 = obj1; <span class="hljs-comment">// 使用默认拷贝构造函数，浅拷贝</span><br>    <span class="hljs-comment">// 此时obj1.data和obj2.data指向同一块内存</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果<code>MyClass</code>需要深拷贝行为，你应该显式定义一个拷贝构造函数来正确复制<code>data</code>成员指向的内存。</p>
<p><strong>总结</strong>:</p>
<p>当类中没有显式定义拷贝构造函数时，C++编译器生成的默认拷贝构造函数执行浅拷贝。这在许多情况下是合理的，但如果类成员包含指针指向动态分配的内存，就需要考虑实现深拷贝以避免潜在的内存管理问题。</p>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>拷贝构造函数的调用时机</u></strong></li>
</ul>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = age;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = p.mAge;<br>    &#125;<br>    <span class="hljs-comment">//析构函数在释放内存之前调用</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span><br>    <span class="hljs-function">Person <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>    Person newman2 = man; <span class="hljs-comment">//拷贝构造</span><br><br>    <span class="hljs-comment">//Person newman3;</span><br>    <span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span><br>&#125;<br><br><span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><br><span class="hljs-comment">//相当于Person p1 = p;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p; <span class="hljs-comment">//无参构造函数</span><br>    <span class="hljs-built_in">doWork</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3. 以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p1;<br>    cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p1 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p = <span class="hljs-built_in">doWork2</span>();<br>    cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br>    <span class="hljs-comment">//test02();</span><br>    <span class="hljs-built_in">test03</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>构造函数调用规则</u></strong></li>
</ul>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<hr>
<br>
<ul>
<li><strong><u>初始化列表</u></strong></li>
</ul>
<p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong> <code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">////传统方式初始化</span><br>    <span class="hljs-comment">//Person(int a, int b, int c) &#123;</span><br>    <span class="hljs-comment">//    m_A = a;</span><br>    <span class="hljs-comment">//    m_B = b;</span><br>    <span class="hljs-comment">//    m_C = c;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//初始化列表方式初始化</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) :<span class="hljs-built_in">m_A</span>(a), <span class="hljs-built_in">m_B</span>(b), <span class="hljs-built_in">m_C</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<h4 id="6-3-类的成员">6.3 类的成员</h4>
<ul>
<li><strong><u>类对象作为类的成员</u></strong></li>
</ul>
<p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    A a；<br>&#125;<br></code></pre></td></tr></table></figure>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Phone</span>(string name)<br>    &#123;<br>        m_PhoneName = name;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Phone</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    string m_PhoneName;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 初始化列表可以告诉编译器调用哪一个构造函数</span><br>    <span class="hljs-built_in">Person</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    string m_Name;<br>    Phone m_Phone;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 当类中成员是其他类对象时，我们称该成员为 对象成员</span><br>    <span class="hljs-comment">// 构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br>    <span class="hljs-comment">// 析构顺序与构造相反</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;<br>    p.<span class="hljs-built_in">playGame</span>();<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>静态成员</u></strong></li>
</ul>
<p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1</strong> ：静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><br>    <span class="hljs-comment">//静态成员变量特点：</span><br>    <span class="hljs-comment">//1 在编译阶段分配内存</span><br>    <span class="hljs-comment">//2 类内声明，类外初始化</span><br>    <span class="hljs-comment">//3 所有对象共享同一份数据</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//静态成员变量也是有访问权限的</span><br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> Person::m_B = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//静态成员变量两种访问方式</span><br><br>    <span class="hljs-comment">//1、通过对象</span><br>    Person p1;<br>    p1.m_A = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;<br><br>    Person p2;<br>    p2.m_A = <span class="hljs-number">200</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="hljs-comment">//共享同一份数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;<br><br>    <span class="hljs-comment">//2、通过类名</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;<br><br><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例2</strong>：静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//静态成员函数特点：</span><br>    <span class="hljs-comment">//1 程序共享一个函数</span><br>    <span class="hljs-comment">//2 静态成员函数只能访问静态成员变量</span><br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>        m_A = <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span><br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br>    <span class="hljs-type">int</span> m_B; <span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//静态成员函数也是有访问权限的</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func2调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//静态成员变量两种访问方式</span><br><br>    <span class="hljs-comment">//1、通过对象</span><br>    Person p1;<br>    p1.<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-comment">//2、通过类名</span><br>    Person::<span class="hljs-built_in">func</span>();<br><br><br>    <span class="hljs-comment">//Person::func2(); //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<h4 id="6-4-对象模型和this指针">6.4 对象模型和this指针</h4>
<ul>
<li><strong><u>对象模型</u></strong></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">C和C++的空结构体所占内存 </summary><div class="toggle-content"><p>C语言中的空结构体和C++中的空结构体在所占用的内存大小方面有所不同。在C语言中，空结构体的大小未明确规定，不同的编译器可能会有不同的处理方式；而在C++中，空结构体的大小为1字节。这是因为C++标准规定了每个对象必须有一个独一无二的地址，即使是空对象也不例外，因此空结构体至少占用1字节的空间，以确保它可以被唯一地标识。这个规定有助于C++支持面向对象的特性，如多态和继承。</p>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">结构体与类 </summary><div class="toggle-content"><p>在C++中，结构体（<code>struct</code>）可以被看作是一个默认访问权限为<code>public</code>的类。除了默认的访问权限不同（类的默认访问权限是<code>private</code>），结构体和类在C++中几乎是相同的，都支持成员函数、继承、多态等面向对象的特性。这意味着你可以使用结构体来定义带有数据成员和成员函数的复杂类型，就像使用类一样</p>
</div></details>
<p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        mA = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//非静态成员变量占对象空间</span><br>    <span class="hljs-type">int</span> mA;<br>    <span class="hljs-comment">//静态成员变量不占对象空间</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> mB;<br>    <span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//静态成员函数也不占对象空间</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Person) &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>this指针概念</u></strong></li>
</ul>
<p>通过阅读刚才的内容，我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用<code>return *this;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br><br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>        <span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    <span class="hljs-comment">// 链式编程</span><br>    p2.<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>空指针访问成员函数</u></strong></li>
</ul>
<p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 空指针访问成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		cout &lt;&lt; mAge &lt;&lt; endl;<br>	&#125;<br><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Person * p = <span class="hljs-literal">nullptr</span>;<br>	p-&gt;<span class="hljs-built_in">ShowClassName</span>(); <span class="hljs-comment">// 空指针，可以调用成员函数</span><br>	p-&gt;<span class="hljs-built_in">ShowPerson</span>();  <span class="hljs-comment">// 但是如果成员函数中用到了this指针，就不可以了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-built_in">test01</span>();<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>const修饰成员函数</u></strong></li>
</ul>
<p><strong>常函数</strong>：</p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象</strong>：</p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        m_A = <span class="hljs-number">0</span>;<br>        m_B = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br>    <span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//const Type* const pointer;</span><br>        <span class="hljs-comment">//this = nullptr; //不能修改指针的指向 Person* const this;</span><br>        <span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br>        <span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br>        <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//mA = 10000;</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br><br><br><span class="hljs-comment">//const修饰对象  常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> Person person; <span class="hljs-comment">//常量对象  </span><br>    cout &lt;&lt; person.m_A &lt;&lt; endl;<br>    <span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span><br>    person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span><br><br>    <span class="hljs-comment">//常对象访问成员函数</span><br>    person.<span class="hljs-built_in">MyFunc</span>(); <span class="hljs-comment">//常对象不能调用const的函数</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<br>
<br>
<h4 id="6-5-友元">6.5 友元</h4>
<blockquote>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 <strong>friend</strong></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
</blockquote>
<br>
<ul>
<li><strong><u>全局函数做友元</u></strong></li>
</ul>
<p>在C++中，将全局函数声明为类的友元，以允许它访问类的私有和保护成员，并不要求这个声明一定要位于类定义的最上方。友元声明可以放在类定义的任何位置，只要它出现在类的访问控制区域内即可。重要的是确保友元声明在类内部，并且友元函数的定义可以在类的外部。这样，友元函数就能够访问类的所有成员，包括私有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>	<span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br>	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br>	<span class="hljs-built_in">Building</span>()<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>		<span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>	&#125;<br><br><br><span class="hljs-keyword">public</span>:<br>	string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><br><span class="hljs-keyword">private</span>:<br>	string m_BedRoom; <span class="hljs-comment">//卧室</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Building b;<br>	<span class="hljs-built_in">goodGay</span>(&amp;b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>	<span class="hljs-built_in">test01</span>();<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>类做友元</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">goodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    goodGay gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>成员函数做友元</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">goodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    goodGay  gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<p><br><br></p>
<h4 id="6-6-运算符重载">6.6 运算符重载</h4>
<blockquote>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
</blockquote>
<br>
<ul>
<li><strong><u>加号运算符重载</u></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;&#125;;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_A = a;<br>        <span class="hljs-keyword">this</span>-&gt;m_B = b;<br>    &#125;<br>    <span class="hljs-comment">//成员函数实现 + 号运算符重载</span><br>    Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        Person temp;<br>        temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A + p.m_A;<br>        temp.m_B = <span class="hljs-keyword">this</span>-&gt;m_B + p.m_B;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现 + 号运算符重载</span><br><span class="hljs-comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="hljs-comment">//    Person temp(0, 0);</span><br><span class="hljs-comment">//    temp.m_A = p1.m_A + p2.m_A;</span><br><span class="hljs-comment">//    temp.m_B = p1.m_B + p2.m_B;</span><br><span class="hljs-comment">//    return temp;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//运算符重载 可以发生函数重载 </span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p2, <span class="hljs-type">int</span> val)<br>&#123;<br>    Person temp;<br>    temp.m_A = p2.m_A + val;<br>    temp.m_B = p2.m_B + val;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>    <span class="hljs-comment">//成员函数方式</span><br>    Person p3 = p2 + p1;  <span class="hljs-comment">//相当于 p2.operaor+(p1)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;<br><br><br>    Person p4 = p3 + <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 operator+(p3,10)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载（重载加号，就做好加号的事，别弄成乘啊除啊）</p>
<hr>
<br>
<ul>
<li><strong><u>左移运算符重载</u></strong></li>
</ul>
<p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_A = a;<br>        <span class="hljs-keyword">this</span>-&gt;m_B = b;<br>    &#125;<br><br>    <span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span><br>    <span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现左移重载</span><br><span class="hljs-comment">//ostream对象只能有一个</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; p.m_B;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>    cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//链式编程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
<hr>
<br>
<ul>
<li><strong><u>递增运算符重载</u></strong></li>
</ul>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyInteger</span>() &#123;<br>        m_Num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//前置++</span><br>    MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        <span class="hljs-comment">//先++</span><br>        m_Num++;<br>        <span class="hljs-comment">//再返回</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//后置++</span><br>	<span class="hljs-comment">//int代表占位参数，可以用于区分前置和后置递增</span><br>    MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-comment">//先返回</span><br>        MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br>        m_Num++;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;<br>    out &lt;&lt; myint.m_Num;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><br><span class="hljs-comment">//前置++ 先++ 再返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    MyInteger myInt;<br>    cout &lt;&lt; ++myInt &lt;&lt; endl;<br>    cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//后置++ 先返回 再++</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    MyInteger myInt;<br>    cout &lt;&lt; myInt++ &lt;&lt; endl;<br>    cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结： 前置递增返回引用，后置递增返回值</p>
<hr>
<br>
<ul>
<li><strong><u>赋值运算符重载</u></strong></li>
</ul>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-comment">//将年龄数据开辟到堆区</span><br>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>    &#125;<br><br>    <span class="hljs-comment">//重载赋值运算符 </span><br>    Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//编译器提供的代码是浅拷贝</span><br>        <span class="hljs-comment">//m_Age = p.m_Age;</span><br><br>        <span class="hljs-comment">//提供深拷贝 解决浅拷贝的问题</span><br>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Age);<br><br>        <span class="hljs-comment">//返回自身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//年龄的指针</span><br>    <span class="hljs-type">int</span> *m_Age;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><br>    p3 = p2 = p1; <span class="hljs-comment">//赋值操作</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-comment">//int a = 10;</span><br>    <span class="hljs-comment">//int b = 20;</span><br>    <span class="hljs-comment">//int c = 30;</span><br><br>    <span class="hljs-comment">//c = b = a;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>关系运算符重载</u></strong></li>
</ul>
<p><strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>    &#125;;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    string m_Name;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int a = 0;</span><br>    <span class="hljs-comment">//int b = 0;</span><br><br>    <span class="hljs-function">Person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a != b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>函数调用运算符重载</u></strong></li>
</ul>
<ul>
<li>函数调用运算符 <code>()</code> 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为<u>仿函数</u></li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string text)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; text &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//重载的（）操作符 也称为仿函数</span><br>    MyPrint myFunc;<br>    <span class="hljs-built_in">myFunc</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> v1 + v2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyAdd add;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br>    <span class="hljs-comment">//匿名对象调用  </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h4 id="6-7-继承">6.7 继承</h4>
<p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/1544861202252.png" alt="1544861202252"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<hr>
<br>
<ul>
<li><strong><u>继承的基本语法</u></strong></li>
</ul>
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">继承的语法 </summary><div class="toggle-content"><p>在C++中，类继承的基本语法是在派生类的声明中使用冒号（<code>:</code>）跟随一个或多个基类。基类可以是<code>public</code>、<code>protected</code>或<code>private</code>继承，这些访问修饰符决定了基类成员在派生类中的访问权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-comment">// 基类成员</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// 派生类成员</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Derived</code>类公开地（<code>public</code>）继承自<code>Base</code>类，意味着<code>Base</code>类的公有成员和保护成员在<code>Derived</code>类中保持其原有的访问级别。</p>
</div></details>
<p><strong>普通实现</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Java页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//Python页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">left</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//C++页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    CPP cp;<br>    cp.<span class="hljs-built_in">header</span>();<br>    cp.<span class="hljs-built_in">footer</span>();<br>    cp.<span class="hljs-built_in">left</span>();<br>    cp.<span class="hljs-built_in">content</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//公共页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Java页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//Python页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">left</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//C++页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    CPP cp;<br>    cp.<span class="hljs-built_in">header</span>();<br>    cp.<span class="hljs-built_in">footer</span>();<br>    cp.<span class="hljs-built_in">left</span>();<br>    cp.<span class="hljs-built_in">content</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>继承的好处：<strong>可以减少重复的代码</strong></p>
<p><code>class A : public B;</code></p>
<p>A 类称为 子类 或 派生类</p>
<p>B 类称为 父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<hr>
<br>
<ul>
<li><strong><u>继承的方式</u></strong></li>
</ul>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/image-20240331111153108.png" alt="image-20240331111153108"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-comment">// 公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">// 可访问 public权限</span><br>        m_B; <span class="hljs-comment">// 可访问 protected权限</span><br>        <span class="hljs-comment">// m_C; // 不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son1 s1;<br>    s1.m_A; <span class="hljs-comment">// 其他类只能访问到公共权限</span><br>&#125;<br><br><span class="hljs-comment">// 保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">protected</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">// 可访问 protected权限</span><br>        m_B; <span class="hljs-comment">// 可访问 protected权限</span><br>        <span class="hljs-comment">// m_C; // 不可访问</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son2 s;<br>    <span class="hljs-comment">// s.m_A; // 不可访问</span><br>&#125;<br><br><span class="hljs-comment">// 私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base3</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span> :<span class="hljs-keyword">private</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">// 可访问 private权限</span><br>        m_B; <span class="hljs-comment">// 可访问 private权限</span><br>        <span class="hljs-comment">// m_C; // 不可访问</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandSon3</span> :<span class="hljs-keyword">public</span> Son3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br>        <span class="hljs-comment">// m_A;</span><br>        <span class="hljs-comment">// m_B;</span><br>        <span class="hljs-comment">// m_C;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>继承中的对象模型</u></strong></li>
</ul>
<p><strong>问题</strong>：从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> m_C; <span class="hljs-comment">//私有成员只是被隐藏了，但是还是会继承下去</span><br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-built_in">test01</span>();<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用工具查看：</p>
<p><img src="/static/imgs/loading.gif" data-original="C:/Users/GGW_2021/AppData/Roaming/Typora/typora-user-images/image-20240331112648057.png" alt="image-20240331112648057"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： <code>cl /d1 reportSingleClassLayout查看的类名 所属文件名</code></p>
<p>效果如下图：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-31_11-31-27.png" alt="1545882158050"></p>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
<hr>
<br>
<ul>
<li><strong><u>继承中构造和析构顺序</u></strong></li>
</ul>
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br>    Son s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<hr>
<br>
<ul>
<li><strong><u>继承中 同名成员 处理方式</u></strong></li>
</ul>
<p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">200</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本(重载)的同名成员函数</span><br>    <span class="hljs-comment">// 如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son s;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<hr>
<br>
<ul>
<li><strong><u>继承中 同名静态成员 处理方式</u></strong></li>
</ul>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m_A = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// 同名成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过对象访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>    Son s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 通过类名访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;<br>    <span class="hljs-comment">// 第一个::代表通过类名方式访问, 第二个::代表访问父类作用域下</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 同名成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过对象访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>    Son s;<br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>    Son::<span class="hljs-built_in">func</span>();<br>    Son::Base::<span class="hljs-built_in">func</span>();<br>    <span class="hljs-comment">// 出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br>    Son::Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
<hr>
<br>
<ul>
<li><strong><u>多继承语法</u></strong></li>
</ul>
<p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">100</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">// 开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-comment">// 语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        m_C = <span class="hljs-number">300</span>;<br>        m_D = <span class="hljs-number">400</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_C;<br>    <span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><br><span class="hljs-comment">// 多继承容易产生成员同名的情况</span><br><span class="hljs-comment">// 通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<hr>
<br>
<ul>
<li><strong><u>菱形继承</u></strong></li>
</ul>
<p><strong>菱形继承概念</strong>：</p>
<p>两个派生类继承同一个基类</p>
<p>又有某个类同时继承者两个派生类</p>
<p>这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例</strong>：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/image-20240331152052488.png" alt="image-20240331152052488"></p>
<p><strong>菱形继承问题</strong>：</p>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</li>
<li>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">// 继承前加virtual关键字后，变为虚继承</span><br><span class="hljs-comment">// 此时公共的父类Animal称为虚基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span> : <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SheepTuo st;<br>    st.Sheep::m_Age = <span class="hljs-number">100</span>;<br>    st.Tuo::m_Age = <span class="hljs-number">200</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>工具查看：<code>cl /d1 reportSingleClassLayout查看的类名 所属文件名</code></p>
<p>没使用<code>virtual</code>:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-31_15-26-53.png" alt=""></p>
<p>使用：<code>virtual</code>:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-31_15-25-50.png" alt=""></p>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<hr>
<p><br><br><br></p>
<h4 id="6-8-多态">6.8 多态</h4>
<ul>
<li><strong><u>多态的基本概念</u></strong></li>
</ul>
<p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Speak函数就是虚函数</span><br>    <span class="hljs-comment">// 函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">// 我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="hljs-comment">// 如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="hljs-comment">// 如果函数地址在运行阶段才能确定，就是动态联编</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSpeak</span><span class="hljs-params">(Animal &amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 多态满足条件： </span><br><span class="hljs-comment">// 1、有继承关系</span><br><span class="hljs-comment">// 2、子类重写父类中的虚函数</span><br><span class="hljs-comment">// 多态使用：</span><br><span class="hljs-comment">// 父类指针或引用指向子类对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">DoSpeak</span>(cat);<br><br><br>    Dog dog;<br>    <span class="hljs-built_in">DoSpeak</span>(dog);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p><strong>重写</strong>：函数返回值类型、函数名、参数列表完全一致称为重写</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">virtual关键字 </summary><div class="toggle-content"><p>C++中的<code>virtual</code>关键字是面向对象编程中的一个重要特性，它主要用于实现多态。以下是<code>virtual</code>关键字的详细描述：</p>
<p><strong>定义和作用</strong></p>
<ul>
<li><strong>定义</strong>：<code>virtual</code>是C++中用来修饰成员函数的一个关键字。当一个类中的成员函数被声明为虚函数时，就允许在派生类中重写该函数，实现多态性。</li>
<li><strong>作用</strong>：<code>virtual</code>关键字使得在通过基类指针或引用调用成员函数时，能够根据对象的实际类型调用到派生类中的对应函数，而非基类中的版本。这种机制称为<strong>动态绑定</strong>或<strong>后期绑定</strong>。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>实现多态</strong>：通过<code>virtual</code>关键字，可以在基类中定义虚函数，然后在派生类中重写这些虚函数，根据对象的实际类型来调用相应的函数。</li>
<li><strong>接口规范</strong>：在抽象基类（包含至少一个纯虚函数的类）中，使用<code>virtual</code>关键字定义纯虚函数，强制要求派生类必须实现这些函数。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Display of Base&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// C++11 引入的 override 关键字确保了重写的正确性</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Display of Derived&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>虚析构函数</strong>：如果一个类被用作基类，通常应该将其析构函数声明为虚析构函数，这确保了通过基类指针删除派生类对象时能够调用正确的析构函数。</li>
<li><strong>继承和重写</strong>：在派生类中重写虚函数时，函数的签名（包括参数类型和const修饰符）必须与基类中的虚函数完全一致，否则不会被视为重写。</li>
<li><strong>性能考虑</strong>：虚函数的调用比非虚函数的调用有更多的开销，因为需要通过虚函数表（vtable）来动态地解析调用。因此，当性能是关键考虑时，应谨慎使用虚函数。</li>
</ul>
<p>通过使用<code>virtual</code>关键字，C++支持运行时的多态性，使得代码更加灵活和可扩展。然而，正确地使用<code>virtual</code>关键字也需要对C++的面向对象机制有深入的理解。</p>
</div></details>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1et411b73Z/?p=136&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">54 类和对象-多态-多态的原理剖析_哔哩哔哩_bilibili</a></p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">虚函数和虚函数表 </summary><div class="toggle-content"><p>虚函数和虚函数表是C++实现多态性的核心机制。让我们深入了解这两个概念。</p>
<p><strong>虚函数（Virtual Function）</strong></p>
<p>虚函数是在基类中使用<code>virtual</code>关键字声明的成员函数，它可以在派生类中被重写（Override）。虚函数允许派生类根据对象的实际类型来调用相应的函数，实现运行时多态。这意味着，如果有一个基类指针或引用指向一个派生类对象，那么通过这个指针或引用调用虚函数时，调用的将是派生类中的版本（如果派生类中有重写的话）。</p>
<p><strong>虚函数表（Virtual Table，简称vtable）</strong></p>
<p>虚函数表是一个实现细节，用于支持运行时的多态性。每个使用虚函数的类都有一个虚函数表。这个表是一个编译器在编译时期生成的静态数组，用于存储指向类的虚函数的指针。每个对象都包含一个指向其类的虚函数表的指针（称为vptr），通过这个指针可以找到对应的虚函数实现。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>虚函数表的创建</strong>：编译器为每一个包含虚函数的类生成一个虚函数表。这个表包含了指向类中每个虚函数实现的指针。如果派生类重写了基类中的虚函数，则派生类的虚函数表中会存储指向这些新实现的指针。</li>
<li><strong>对象的vptr</strong>：每个对象实例都会包含一个指针（vptr），指向其类的虚函数表。这个指针在对象被创建时自动设置。</li>
<li><strong>虚函数的调用</strong>：当调用一个对象的虚函数时，实际上是通过对象的vptr来访问虚函数表，然后通过虚函数表找到相应函数的地址，最后调用该函数。</li>
</ol>
<p><strong>示例</strong></p>
<p>考虑以下的类定义和函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::func() called&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived::func() called&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>obj-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 输出 &quot;Derived::func() called&quot;</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，尽管<code>obj</code>的静态类型是<code>Base*</code>，但由于<code>func</code>是虚函数，并且<code>obj</code>实际指向<code>Derived</code>对象，所以调用的是<code>Derived</code>中的<code>func</code>实现。</p>
<p><strong>优点与局限</strong></p>
<ul>
<li><strong>优点</strong>：虚函数和虚函数表提供了一种强大的机制，允许C++程序在运行时进行函数调用的决策，从而实现多态性和动态绑定。</li>
<li><strong>局限</strong>：虚函数的使用增加了一定的运行时开销，因为每次虚函数调用都需要通过虚函数表来解析函数地址。此外，每个对象因为包含vptr而稍微增加了内存占用。</li>
</ul>
<p>虚函数和虚函数表是C++中实现面向对象编程核心特性之一，理解它们的工作原理对于深入学习C++非常重要。</p>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>多态案例一：计算器类</u></strong></li>
</ul>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 普通实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>        &#125;<br>        <span class="hljs-comment">// 如果要提供新的运算，需要修改源码</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 普通实现测试</span><br>    Calculator c;<br>    c.m_Num1 = <span class="hljs-number">10</span>;<br>    c.m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><br><br><span class="hljs-comment">// 多态实现</span><br><span class="hljs-comment">// 抽象计算器类</span><br><span class="hljs-comment">// 多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">// 加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 减法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 乘法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建加法计算器</span><br>    AbstractCalculator *abc = <span class="hljs-keyword">new</span> AddCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;  <span class="hljs-comment">// 用完了记得销毁</span><br><br>    <span class="hljs-comment">// 创建减法计算器</span><br>    abc = <span class="hljs-keyword">new</span> SubCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br><br>    <span class="hljs-comment">// 创建乘法计算器</span><br>    abc = <span class="hljs-keyword">new</span> MulCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// test01();</span><br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
<hr>
<br>
<ul>
<li><strong><u>纯虚函数和抽象类</u></strong></li>
</ul>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-comment">// 类中只要有一个纯虚函数就称为抽象类</span><br>    <span class="hljs-comment">// 抽象类无法实例化对象</span><br>    <span class="hljs-comment">// 子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base * base = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// base = new Base; //  错误，抽象类无法实例化对象</span><br>    base = <span class="hljs-keyword">new</span> Son;<br>    base-&gt;<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">delete</span> base;<span class="hljs-comment">// 记得销毁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>多态案例二：制作饮品</u></strong></li>
</ul>
<p><strong>案例描述</strong>：</p>
<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 抽象制作饮品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDrinking</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 规定流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">Boil</span>();<br>        <span class="hljs-built_in">Brew</span>();<br>        <span class="hljs-built_in">PourInCup</span>();<br>        <span class="hljs-built_in">PutSomething</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 制作咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 制作茶水</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 业务函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">(AbstractDrinking* drink)</span> </span>&#123;<br>    drink-&gt;<span class="hljs-built_in">MakeDrink</span>();<br>    <span class="hljs-keyword">delete</span> drink;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Coffee);<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Tea);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<ul>
<li><strong><u>虚析构和纯虚析构</u></strong></li>
</ul>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">virtual</span> ~类名()&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>纯虚析构语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-keyword">virtual</span> ~类名() = <span class="hljs-number">0</span>;<br>类名::~类名()&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>与其他纯虚函数不同，纯虚析构函数需要提供一个定义，原因如下：</p>
<ol>
<li><strong>析构过程需要调用析构函数的定义</strong>：当删除一个指向派生类对象的基类指针时，C++的析构机制会首先调用派生类的析构函数，然后沿着继承链向上调用基类的析构函数。即使是纯虚析构函数，也需要有一个定义，因为在对象销毁时，基类的析构函数最终会被调用。</li>
<li><strong>防止未定义行为</strong>：如果纯虚析构函数没有定义，当它被调用时（如在派生类对象的销毁过程中），程序可能会遇到链接错误或未定义行为，因为编译器期望存在一个可调用的函数体。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Animal</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 析构函数加上virtual关键字，变成虚析构函数</span><br>    <span class="hljs-comment">// virtual ~Animal()</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// 	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br><br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string name)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;<br>        m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; *m_Name &lt;&lt; <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Cat</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_Name;<br>            m_Name = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br>    <span class="hljs-comment">// 通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br>    <span class="hljs-comment">// 怎么解决？给基类增加一个虚析构函数</span><br>    <span class="hljs-comment">// 虚析构函数就是用来解决通过父类指针释放子类对象</span><br>    <span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>
<p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
</li>
<li>
<p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
</li>
<li>
<p>拥有纯虚析构函数的类也属于抽象类</p>
</li>
</ol>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">纯虚构函数的缺席 </summary><div class="toggle-content"><p>通常，构造函数不可以声明为纯虚函数。构造函数的目的是初始化对象的状态，而纯虚函数的概念是要求派生类提供具体的实现。在对象构建时，基类的构造函数会在派生类构造函数之前被调用，以确保对象的基类部分被正确初始化。这意味着在构造阶段，没有逻辑上的需求或机制来支持“纯虚构造函数”，因为基类部分需要在派生类之前构建，且构造过程不能延迟到派生类提供实现。</p>
<p><strong>为什么不能有虚构造函数</strong>：</p>
<ul>
<li><strong>构造阶段的类型确定性</strong>：构造函数的目的是初始化对象。在构造函数执行时，对象的类型已经被明确确定，不需要动态绑定。此外，构造函数调用遵循从基类到派生类的顺序，确保了对象的各个部分按正确的顺序被初始化。</li>
<li><strong>vptr的初始化</strong>：在构造函数执行期间，vptr会被设置为指向当前正在构造的类的虚函数表。这意味着，在基类的构造函数中，vptr指向基类的虚函数表，在派生类的构造函数中，vptr会被更新为指向派生类的虚函数表。这个过程是自动发生的，且完全由编译器控制，以保证虚函数调用的正确性。</li>
</ul>
</div></details>
<hr>
<br>
<ul>
<li><strong><u>多态案例三：电脑组装</u></strong></li>
</ul>
<p><strong>案例描述</strong>：</p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 抽象CPU类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 抽象的计算函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象显卡类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 抽象的显示函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象内存条类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 抽象的存储函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)<br>    &#123;<br>        m_cpu = cpu;<br>        m_vc = vc;<br>        m_mem = mem;<br>    &#125;<br><br>    <span class="hljs-comment">// 提供工作的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 让零件工作起来，调用接口</span><br>        m_cpu-&gt;<span class="hljs-built_in">calculate</span>();<br><br>        m_vc-&gt;<span class="hljs-built_in">display</span>();<br><br>        m_mem-&gt;<span class="hljs-built_in">storage</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 提供析构函数 释放3个电脑零件</span><br>    ~<span class="hljs-built_in">Computer</span>()<br>    &#123;<br><br>        <span class="hljs-comment">// 释放CPU零件</span><br>        <span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_cpu;<br>            m_cpu = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 释放显卡零件</span><br>        <span class="hljs-keyword">if</span> (m_vc != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_vc;<br>            m_vc = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 释放内存条零件</span><br>        <span class="hljs-keyword">if</span> (m_mem != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_mem;<br>            m_mem = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    CPU * m_cpu; <span class="hljs-comment">// CPU的零件指针</span><br>    VideoCard * m_vc; <span class="hljs-comment">// 显卡零件指针</span><br>    Memory * m_mem; <span class="hljs-comment">// 内存条零件指针</span><br>&#125;;<br><br><span class="hljs-comment">// 具体厂商</span><br><span class="hljs-comment">// Intel厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Lenovo厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 第一台电脑零件</span><br>    CPU * intelCpu = <span class="hljs-keyword">new</span> IntelCPU;<br>    VideoCard * intelCard = <span class="hljs-keyword">new</span> IntelVideoCard;<br>    Memory * intelMem = <span class="hljs-keyword">new</span> IntelMemory;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 创建第一台电脑</span><br>    Computer * computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intelCpu, intelCard, intelMem);<br>    computer1-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 第二台电脑组装</span><br>    Computer * computer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> LenovoVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>    computer2-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 第三台电脑组装</span><br>    Computer * computer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> IntelVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>    computer3-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer3;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h3 id="7-作用域解析运算符">7. 作用域解析运算符::</h3>
<p>作用域解析运算符（<code>::</code>）在C++中用于指定一个特定的作用域，这个运算符可以用于多种情况，包括访问全局变量、指定类成员、访问命名空间中的成员等。以下是作用域解析运算符的一些主要用途和示例：</p>
<ol>
<li><strong>访问类的静态成员</strong></li>
</ol>
<p>当在类的外部访问其静态成员时，使用作用域解析运算符来指定成员所属的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义静态成员变量</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::staticVar = <span class="hljs-number">5</span>; <span class="hljs-comment">// 使用作用域解析运算符访问静态成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>定义类外的成员函数</strong></li>
</ol>
<p>对于在类声明外定义的成员函数（包括构造函数和析构函数），使用作用域解析运算符来指定这些函数属于哪个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 函数实现</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>解决命名冲突</strong></li>
</ol>
<p>作用域解析运算符可以用来访问被局部变量隐藏的全局变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = <span class="hljs-number">5</span>; <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>; <span class="hljs-comment">// 局部变量，隐藏了同名的全局变量</span><br>    std::cout &lt;&lt; ::value; <span class="hljs-comment">// 使用作用域解析运算符访问全局变量value</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li><strong>访问命名空间中的成员</strong></li>
</ol>
<p>当存在命名空间时，作用域解析运算符用于指定特定命名空间中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; MyNamespace::value; <span class="hljs-comment">// 访问命名空间中的成员</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li><strong>指定继承中的成员</strong></li>
</ol>
<p>在继承关系中，子类可以使用作用域解析运算符来访问被遮蔽（隐藏）的父类成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        Base::<span class="hljs-built_in">myFunction</span>(); <span class="hljs-comment">// 调用父类中的myFunction</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>作用域解析运算符<code>::</code>是C++中一个非常重要的特性，它提供了一种明确指定作用域的方式，有助于管理和访问不同作用域中的成员，解决命名冲突，以及明确地表达程序员的意图。通过恰当使用作用域解析运算符，可以增强代码的可读性和可维护性。</p>
<hr>
<p><br><br><br></p>
<h3 id="8-模板">8. 模板</h3>
<blockquote>
<p>模板的概念</p>
<p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板（PPT模版）</p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
</blockquote>
<br>
<h4 id="8-1-函数模版">8.1 函数模版</h4>
<ul>
<li>C++另一种编程思想称为 <strong>泛型编程</strong> ，主要利用的技术就是模板</li>
<li>C++提供两种模板机制: <strong>函数模板</strong> 和 <strong>类模板</strong></li>
</ul>
<br>
<ul>
<li><strong><u>函数模板作用</u></strong></li>
</ul>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或定义<br></code></pre></td></tr></table></figure>
<p><u>函数模板的声明和定义在大多数情况下需要放在一起</u>，尤其是当模板被定义在头文件中时。这是因为函数模板的实例化发生在编译时，而不是链接时。编译器需要看到模板定义才能生成模板的实例，即具体化的函数。</p>
<p><strong>解释</strong>：</p>
<p><code>template</code> — 声明创建模板</p>
<p><code>typename</code> — 表面其后面的符号是一种数据类型，可以用<code>class</code>代替</p>
<p><code>T</code> — 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 交换整型函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapInt</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">// 交换浮点型函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapDouble</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; a, <span class="hljs-type">double</span>&amp; b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">// 利用模板提供通用的交换函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">// swapInt(a, b);</span><br><br>    <span class="hljs-comment">// 利用模板实现交换</span><br>    <span class="hljs-comment">// 1、自动类型推导</span><br>    <span class="hljs-built_in">mySwap</span>(a, b);<br><br>    <span class="hljs-comment">// 2、显示指定类型</span><br>    <span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 <code>template</code></li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<hr>
<br>
<ul>
<li><strong><u>函数模版注意事项</u></strong>：</li>
</ul>
<ul>
<li>自动类型推导，必须推导出一致的数据类型<code>T</code>,才可以使用</li>
<li>模板必须要确定出<code>T</code>的数据类型，才可以使用</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 利用模板提供通用的交换函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><br><span class="hljs-comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br>    <span class="hljs-built_in">mySwap</span>(a, b); <span class="hljs-comment">// 正确，可以推导出一致的T</span><br>    <span class="hljs-comment">// mySwap(a, c); // 错误，推导不出一致的T类型</span><br>&#125;<br><br><br><span class="hljs-comment">// 2、模板必须要确定出T的数据类型，才可以使用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// func(); // 错误，模板不能独立使用，必须确定出T的类型</span><br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// 利用显示指定类型的方式，给T一个类型，才可以使用该模板</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<hr>
<br>
<ul>
<li><u><strong>函数模板案例</strong></u></li>
</ul>
<p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从小到大，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* 快排 */</span><br><span class="hljs-comment">// --------------------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123; <span class="hljs-comment">// 划分</span><br>    T pivotVal = arr[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivotVal) right--;<br>        arr[left] = arr[right];<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivotVal) left++;<br>        arr[right] = arr[left];<br>    &#125;<br>    arr[left] = pivotVal;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, left, right);<br>        <span class="hljs-built_in">quickSort</span>(arr, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// --------------------------------------------------------------------------</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试char数组</span><br>    <span class="hljs-type">char</span> charArr[] = <span class="hljs-string">&quot;bdcfeagh&quot;</span>;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(charArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>);<br>    <span class="hljs-built_in">quickSort</span>(charArr, <span class="hljs-number">0</span>, num - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printArray</span>(charArr, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试int数组</span><br>    <span class="hljs-type">int</span> intArr[] = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(intArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">quickSort</span>(intArr, <span class="hljs-number">0</span>, num - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printArray</span>(intArr, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<hr>
<br>
<ul>
<li><strong><u>普通函数与函数模板区别</u></strong>:</li>
</ul>
<ul>
<li>普通函数 调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板 调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAdd01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myAdd02</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br>    cout &lt;&lt; <span class="hljs-built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="hljs-comment">// 正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span><br><br>    <span class="hljs-comment">// myAdd02(a, c); //  报错，使用自动类型推导时，不会发生隐式类型转换</span><br><br>    <span class="hljs-built_in">myAdd02</span>&lt;<span class="hljs-type">int</span>&gt;(a, c); <span class="hljs-comment">// 正确，如果用显示指定类型，可以发生隐式类型转换</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型<code>T</code></p>
<hr>
<br>
<ul>
<li><strong><u>普通函数与函数模板的调用规则</u></strong></li>
</ul>
<p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//普通函数与函数模板调用规则</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;调用的模板&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b, T c)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br>    <span class="hljs-comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">myPrint</span>(a, b); <span class="hljs-comment">//调用普通函数</span><br><br>    <span class="hljs-comment">//2、可以通过空模板参数列表来强制调用函数模板</span><br>    myPrint&lt;&gt;(a, b); <span class="hljs-comment">//调用函数模板</span><br><br>    <span class="hljs-comment">//3、函数模板也可以发生重载</span><br>    <span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">myPrint</span>(a, b, c); <span class="hljs-comment">//调用重载的函数模板</span><br><br>    <span class="hljs-comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br>    <span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-built_in">myPrint</span>(c1, c2); <span class="hljs-comment">//调用函数模板</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<hr>
<ul>
<li><strong><u>函数模版声明和定义分离</u></strong></li>
</ul>
<p>同一文件下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exampleFunction</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exampleFunction</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 实现细节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<br>
<h4 id="8-2-模板的局限性">8.2 模板的局限性</h4>
<p><strong>局限性</strong>：</p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &gt; b) &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，如果T的数据类型传入的是像<code>Person</code>这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>    &#125;<br>    string m_Name;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//普通函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="hljs-comment">//具体化优先于常规模板</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-comment">//内置数据类型可以直接使用通用的函数模板</span><br>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(a, b);<br>    <span class="hljs-keyword">if</span> (ret)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a == b &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a != b &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//自定义数据类型，不会调用普通的函数模板</span><br>    <span class="hljs-comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span><br>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(p1, p2);<br>    <span class="hljs-keyword">if</span> (ret)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<hr>
<br>
<br>
<br>
<h4 id="8-3-类模板">8.3 类模板</h4>
<ul>
<li><strong><u>类模板作用</u></strong>：</li>
</ul>
<p>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>类<br></code></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<p><code>template</code> — 声明创建模板</p>
<p><code>typename</code> — 表面其后面的符号是一种数据类型，可以用<code>class</code>代替</p>
<p><code>T</code> — 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;mName = name;<br>        <span class="hljs-keyword">this</span>-&gt;mAge = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    NameType mName;<br>    AgeType mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 指定NameType 为string类型，AgeType 为 int类型</span><br>    Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">P1</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">999</span>);<br>    P1.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：类模板和函数模板语法相似，在声明模板<code>template</code>后面加类，此类称为类模板</p>
<hr>
<br>
<ul>
<li><u><strong>类模板与函数模板区别</strong></u></li>
</ul>
<p>区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;mName = name;<br>        <span class="hljs-keyword">this</span>-&gt;mAge = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    NameType mName;<br>    AgeType mAge;<br>&#125;;<br><br><span class="hljs-comment">//1、类模板没有自动类型推导的使用方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span><br>    Person &lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">//必须使用显示指定类型的方式，使用类模板</span><br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-comment">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string&gt; <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">999</span>); <span class="hljs-comment">//类模板中的模板参数列表 可以指定默认参数</span><br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<hr>
<br>
<ul>
<li><strong><u>类模板中成员函数创建时机</u></strong></li>
</ul>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person1 show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person2 show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    T obj;<br><br>    <span class="hljs-comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; obj.<span class="hljs-built_in">showPerson1</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123; obj.<span class="hljs-built_in">showPerson2</span>(); &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyClass&lt;Person1&gt; m;<br><br>    m.<span class="hljs-built_in">fun1</span>();<br><br>    <span class="hljs-comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<hr>
<br>
<ul>
<li><u><strong>类模板对象做函数参数</strong></u></li>
</ul>
<blockquote>
<p>tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>()<br></code></pre></td></tr></table></figure>
<p>查看类型是什么</p>
</blockquote>
<p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型 — 直接显示对象的数据类型</li>
<li>参数模板化 — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化 — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;mName = name;<br>        <span class="hljs-keyword">this</span>-&gt;mAge = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    NameType mName;<br>    AgeType mAge;<br>&#125;;<br><br><span class="hljs-comment">//1、指定传入的类型   （用这种就行）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson1</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt; &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printPerson1</span>(p);<br>&#125;<br><br><span class="hljs-comment">//2、参数模板化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">90</span>);<br>    <span class="hljs-built_in">printPerson2</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3、整个类模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson3</span><span class="hljs-params">(T &amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>    p.<span class="hljs-built_in">showPerson</span>();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">printPerson3</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">test03</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<hr>
<br>
<ul>
<li><strong><u>类模板与继承</u></strong></li>
</ul>
<p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    T m;<br>&#125;;<br><br><span class="hljs-comment">// class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-comment">// 必须指定一个类型</span><br>&#123;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son c;<br>&#125;<br><br><span class="hljs-comment">// 类模板继承类模板 ,可以用T2指定父类中的T类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">public</span> Base&lt;T2&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son2</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son2&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; child1;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<hr>
<br>
<ul>
<li><u><strong>类模板成员函数类外实现</strong></u></li>
</ul>
<p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 类模板中成员函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员函数类内声明</span><br>    <span class="hljs-built_in">Person</span>(T1 name, T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    T1 m_Name;<br>    T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>    <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">// 成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<hr>
<br>
<ul>
<li><strong><u>类模板分文件编写</u></strong></li>
</ul>
<p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含<code>.cpp</code>源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code>，<code>.hpp</code>是约定的名称，并不是强制</li>
</ul>
<p><strong>示例</strong>：</p>
<p><code>person.hpp</code>中代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name, T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    T1 m_Name;<br>    T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">//构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>    <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类模板分文件编写<code>.cpp</code>中代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//#include &quot;person.h&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.cpp&quot;</span> <span class="hljs-comment">//解决方式1，包含cpp源文件</span></span><br><br><span class="hljs-comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为<code>.hpp</code></p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">.h和.hpp </summary><div class="toggle-content"><p><code>.hpp</code>和<code>.h</code>文件在功能上是相同的，都被用来声明C++中的类、函数、模板等。它们之间的区别主要是命名约定，而非功能差异。使用哪一个主要取决于个人或项目团队的偏好。</p>
<p><strong><code>.h</code> 文件</strong></p>
<ul>
<li>最初用于C语言头文件。</li>
<li>在C++中也被广泛使用。</li>
<li>有时用来表示可以被C和C++共同使用的代码。</li>
</ul>
<p><strong><code>.hpp</code> 文件</strong></p>
<ul>
<li>显式地表示这是一个C++头文件。</li>
<li>帮助在复杂的项目中区分C头文件和C++头文件。</li>
<li>某些项目或组织可能优先选择这种扩展名来强调代码是C++特有的，<u>尤其是在包含模板定义时</u>。</li>
</ul>
</div></details>
<hr>
<br>
<ul>
<li><u><strong>类模板与友元</strong></u></li>
</ul>
<p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><br><span class="hljs-comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-comment">//1、全局函数配合友元   类内实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printPerson</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-comment">//全局函数配合友元  类外实现</span><br>    <span class="hljs-comment">// 加空模版参数裂变，告诉编译器这是个模版声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(T1 name, T2 age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    T1 m_Name;<br>    T2 m_Age;<br><br>&#125;;<br><br><span class="hljs-comment">//1、全局函数在类内实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">printPerson</span>(p);<br>&#125;<br><br><br><span class="hljs-comment">//2、全局函数在类外实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">printPerson2</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：<strong>建议</strong>全局函数做<strong>类内实现</strong>，用法简单，而且编译器可以直接识别</p>
<hr>
<br>
<ul>
<li><strong><u>类模板案例</u></strong></li>
</ul>
<p>案例描述: 实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p>文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">├─myArray.hpp    # 类模板<br>│<br>└─test.cpp       # 测试使用<br></code></pre></td></tr></table></figure>
<p><code>myArray.hpp</code>中代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">int</span> capacity)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>        pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br>    &#125;<br><br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> MyArray &amp; arr)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_Size = arr.m_Size;<br>        <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++)<br>        &#123;<br>            <span class="hljs-comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span><br>            <span class="hljs-comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span><br>            <span class="hljs-keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//重载= 操作符  防止浅拷贝问题</span><br>    MyArray&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyArray&amp; myarray) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br>            <span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_Size = myarray.m_Size;<br>        <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;pAddress[i] = myarray[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//重载[] 操作符  arr[0]</span><br>    T&amp; <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> index)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;pAddress[index]; <span class="hljs-comment">//不考虑越界，用户自己去处理</span><br>    &#125;<br><br>    <span class="hljs-comment">//尾插法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Capacity == <span class="hljs-keyword">this</span>-&gt;m_Size)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;pAddress[<span class="hljs-keyword">this</span>-&gt;m_Size] = val;<br>        <span class="hljs-keyword">this</span>-&gt;m_Size++;<br>    &#125;<br><br>    <span class="hljs-comment">//尾删法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Size == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;m_Size--;<br>    &#125;<br><br>    <span class="hljs-comment">//获取数组容量</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//获取数组大小</span><br>    <span class="hljs-function"><span class="hljs-type">int</span>	<span class="hljs-title">getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Size;<br>    &#125;<br><br><br>    <span class="hljs-comment">//析构</span><br>    ~<span class="hljs-built_in">MyArray</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br>            <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T * pAddress;  <span class="hljs-comment">//指向一个堆空间，这个空间存储真正的数据</span><br>    <span class="hljs-type">int</span> m_Capacity; <span class="hljs-comment">//容量</span><br>    <span class="hljs-type">int</span> m_Size;   <span class="hljs-comment">// 大小</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>测试<code>test.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myArray.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printIntArray</span><span class="hljs-params">(MyArray&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//测试内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        array1.<span class="hljs-built_in">Push_back</span>(i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printIntArray</span>(array1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array2</span><span class="hljs-params">(array1)</span></span>;<br>    array2.<span class="hljs-built_in">Pop_back</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">printIntArray</span>(array2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//测试自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;&#125;<br>    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string m_Name;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPersonArray</span><span class="hljs-params">(MyArray&lt;Person&gt;&amp; personArr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; personArr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建数组</span><br>    <span class="hljs-function">MyArray&lt;Person&gt; <span class="hljs-title">pArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;韩信&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;妲己&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;王昭君&quot;</span>, <span class="hljs-number">15</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">24</span>)</span></span>;<br><br>    <span class="hljs-comment">//插入数据</span><br>    pArray.<span class="hljs-built_in">Push_back</span>(p1);<br>    pArray.<span class="hljs-built_in">Push_back</span>(p2);<br>    pArray.<span class="hljs-built_in">Push_back</span>(p3);<br>    pArray.<span class="hljs-built_in">Push_back</span>(p4);<br>    pArray.<span class="hljs-built_in">Push_back</span>(p5);<br><br>    <span class="hljs-built_in">printPersonArray</span>(pArray);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<hr>
<p><br><br><br></p>
<h3 id="9-强制类型转换运算符">9. 强制类型转换运算符</h3>
<blockquote>
<p>参考文章： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258975506">C++四种强制类型转换介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>隐式类型转换是编译器自动隐式进行的，需要在代码中体现，而显示类型转换由程序员明确指定。</p>
<p>C++支持C风格的强制转换，但是C风格的强制转换可能带来一些隐患，让一些问题难以发现。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">C风格的强制转换可能带来一些隐患 </summary><div class="toggle-content"><p>C风格的强制类型转换（如 <code>(int)x</code> 或 <code>(void*)ptr</code>）在C++中仍然是支持的，主要是为了保持与C语言的兼容性。然而，C风格的转换较为粗糙，它不区分转换的类型和目的，这可能导致几种潜在问题，使得代码中的错误和安全隐患难以被发现：</p>
<ol>
<li>
<p><strong>类型安全问题</strong>：C风格转换不进行类型检查，允许几乎任何类型的转换，即使这些转换在逻辑上没有意义或是危险的。这种宽松的类型检查使得程序更容易出错。</p>
</li>
<li>
<p><strong>隐式转换的不明确性</strong>：使用C风格转换，阅读代码的人可能难以理解转换的真正意图。比如，它可能是为了去除<code>const</code>属性，也可能是进行了不安全的指针转换，或者是两种类型之间的正常转换。这种不明确性使得代码难以维护和理解。</p>
</li>
<li>
<p><strong>误用导致的未定义行为</strong>：由于C风格转换允许进行宽泛的转换，开发者可能不小心使用错误的转换，导致未定义行为。比如，将一个对象指针转换为一个完全不相关类型的指针，然后通过这个转换后的指针来访问数据，可能会破坏对象的内存布局。</p>
</li>
<li>
<p><strong>破坏const安全</strong>：C风格转换可以轻易地移除对象的<code>const</code>属性，这可能导致原本不应被修改的数据被意外或非法修改，从而破坏程序的正确性。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<p>假设有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* ip = (<span class="hljs-type">int</span>*)&amp;ci; <span class="hljs-comment">// C风格转换去除了const属性</span><br>*ip = <span class="hljs-number">20</span>; <span class="hljs-comment">// 未定义行为，因为试图修改一个const对象</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br>Base* b = <span class="hljs-keyword">new</span> Base;<br>Derived* d = (Derived*)b; <span class="hljs-comment">// 不安全的向下转型，如果b不是指向Derived类型的对象，行为未定义</span><br></code></pre></td></tr></table></figure>
<p>在这些例子中，C风格的转换掩盖了潜在的问题，使它们难以通过编译器警告或错误被发现。</p>
<p>因此，推荐使用C++提供的四种强制类型转换运算符，因为它们能更明确地表达转换的意图，并提供了更严格的类型检查。这有助于避免上述问题，使代码更安全、更易于理解和维护。</p>
</div></details>
<p>所以C++提供了一组适用于不同场景的强制转换的函数：</p>
<ul>
<li><code>static_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
</ul>
<p>下面对这四种转换操作的适用场景分别进行说明。</p>
<hr>
<p><br><br><br></p>
<ul>
<li><strong><code>static_cast </code></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">static_cast</span>&lt;type&gt;(expression)<br></code></pre></td></tr></table></figure>
<p>该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint x = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x); <span class="hljs-comment">// 转换正确</span><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> y = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(x); <span class="hljs-comment">// 转换正确</span><br></code></pre></td></tr></table></figure>
<p>需要注意的是：<code>static_cast</code> <u>没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全</u>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>;<br>uint y = <span class="hljs-built_in">static_cast</span>&lt;uint&gt;(x) <span class="hljs-comment">// 转换错误</span><br><br><span class="hljs-type">double</span> x = <span class="hljs-number">1.23</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x) <span class="hljs-comment">// 转换丢失精度</span><br></code></pre></td></tr></table></figure>
<p><code>static_cast</code> 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：</p>
<ul>
<li><code>static_cast</code> 进行上行转换是安全的，即把派生类的指针转换为基类的；</li>
<li><code>static_cast</code> 进行下行转换是不安全的，即把基类的指针转换为派生类的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 上行转换，派生类→基类</span><br>Derive* d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>Base* b = <span class="hljs-built_in">static_cast</span>&lt;Base*&gt;(d);<br><br><span class="hljs-comment">// 下行转换，基类→派生类</span><br>Base* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Derive* d = <span class="hljs-built_in">static_cast</span>&lt;Derive*&gt;(b);<br></code></pre></td></tr></table></figure>
<p>这是因为派生类包含基类信息，所以上行转换（只能调用基类的方法和成员变量），一般是安全的；</p>
<p>而基类没有派生类的任何信息，而下行转换后会用到派生类的方法和成员变量，这些基类都没有，很容易“指鹿为马”，或指向不存在的空间。</p>
<hr>
<p><br><br><br></p>
<ul>
<li><strong><code>dynamic_cast</code></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">dynamic_cast</span>&lt;type&gt;(expression)<br></code></pre></td></tr></table></figure>
<p><code>dynamic_cast</code> 主要用于类层次间的上行转换或下行转换。<u>在进行上行转换时，<code>dynamic_cast</code> 和 <code>static_cast</code> 的效果是一样的，但在下行转换时，<code>dynamic_cast</code> 具有类型检查的功能，比 <code>static_cast</code> 更安全</u>。</p>
<p>比如下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am Base.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am Derive.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 上行转换</span><br>    Derive* d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;d1: &quot;</span> &lt;&lt; d1 &lt;&lt; endl;<br><br>    Base* b1 = <span class="hljs-built_in">dynamic_cast</span>&lt;Base*&gt;(d1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;b1: &quot;</span> &lt;&lt; b1 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 下行转换</span><br>    Base* b2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;b2: &quot;</span> &lt;&lt; b2 &lt;&lt; endl;<br><br>    Derive* d2 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive*&gt;(b2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;d2: &quot;</span> &lt;&lt; d2 &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">d1: 0128C6D0<br>b1: 0128C6D0<br>b2: 012924E8<br>d2: 00000000<br><br></code></pre></td></tr></table></figure></div></details>
<p>在进行下行转换时，从基类 b2 到 d2 时，d2 会改为空指针（0x0），这正是 <code>dynamic_cast</code> 提升安全的功能。这个检查主要来自虚函数表。</p>
<blockquote>
<p>在C++面向对象的思想中，虚函数是实现多态的关键机制。当一个类中有虚函数时，那么编译器就会构建出一个虚函数表来指示这些函数的地址。当用基类的指针指向派生类的对象，调用方法时就会根据虚函数表找到对应派生类的方法。</p>
</blockquote>
<p>注意：B <u>要有虚函数，否则会编译出错</u>；<code>static_cast</code>则没有这个限制。</p>
<p>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。</p>
<hr>
<p><br><br><br></p>
<ul>
<li><strong><code>const_cast</code></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">const_cast</span>&lt;type&gt;(expression)<br></code></pre></td></tr></table></figure>
<p>该运算符用来修改 expression 的 <code>const</code> 或 <code>volatile</code> 属性。这里需要注意：expression 和 type 的类型一样的。</p>
<p>比如下面的代码，指针 px 由于有 <code>const</code> 修饰，无法直接通过其修改 x 的值，但又期望能修改 x 的值时，怎么办呢？这时就需要用到 <code>const_cast</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;before: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* px = &amp;x;<br>    <span class="hljs-comment">// *px = 2; // 编译错误</span><br>    <span class="hljs-type">int</span>* py = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(px);<br>    *py = <span class="hljs-number">2</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;px: &quot;</span> &lt;&lt; px &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;py: &quot;</span> &lt;&lt; py &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;after : &quot;</span> &lt;&lt; x &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before: 1<br>px: 006FFE58<br>py: 006FFE58<br>after : 2<br><br></code></pre></td></tr></table></figure></div></details>
<p>可以看出，px 和 py 指向同一个地址，但通过 py 就可以修改 x 的值了。</p>
<p>这是因为通过<code>const_cast</code>，就把 <code>const</code> 类型的指针 px 转换成非 <code>const</code> 类型的指针 py 了。</p>
<hr>
<p><br><br><br></p>
<ul>
<li><strong><code>reinterpret_cast</code></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">reinterpret_cast</span>&lt;type&gt;(expression)<br></code></pre></td></tr></table></figure>
<p>该运算符可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">uint64_t</span> p_val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(p);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p    :&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p_val:&quot;</span> &lt;&lt; hex &lt;&lt; p_val &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看输出 </summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">p    :00A80180<br>p_val:a80180<br><br></code></pre></td></tr></table></figure></div></details>
<p>上述代码把指针 p 的地址值转换成了 <code>uint64_t</code> 类型的整数值。</p>
<p>这个转换是“最不安全”的。不推荐使用。</p>
<hr>
<p><br><br><br></p>
<ul>
<li><strong><u>总结</u></strong></li>
</ul>
<p>综上，在使用强制类型转换时，需要首先考虑清楚使用目的，总结如下：</p>
<ul>
<li><code>static_cast</code>：基本类型转换，低风险；</li>
<li><code>dynamic_cast</code>：类层次间的上行转换或下行转换，低风险；</li>
<li><code>const_cast</code>：去 <code>const</code> 属性，低风险；</li>
<li><code>reinterpret_cast</code>：转换不相关的类型，高风险。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.com">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.com/posts/34219/">https://gxblogs.com/posts/34219/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.com" target="_blank">GXBLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-17-22.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/65115/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-36-48.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面经</div></div></a></div><div class="next-post pull-right"><a href="/posts/26732/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-24_20-02-53.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指offer</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/15764/" title="C++ STL"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-28_20-20-59.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="title">C++ STL</div></div></a></div><div><a href="/posts/16719/" title="C语言笔记"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-01_14-23-35.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-01</div><div class="title">C语言笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">C++基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F"><span class="toc-text">1. 常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2. 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">4. 字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">5. 转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">6. 宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-text">7. 分文件编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8C%87%E9%92%88"><span class="toc-text">8. 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86"><span class="toc-text">C++核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98"><span class="toc-text">1. 内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-new"><span class="toc-text">2. new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">3. 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">3.1 为什么使用智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-auto-ptr"><span class="toc-text">3.2 auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-unique-ptr"><span class="toc-text">3.3 unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-share-ptr"><span class="toc-text">3.4 share_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-weak-ptr"><span class="toc-text">3.5 weak_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="toc-text">3.6 智能指针的使用陷阱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8"><span class="toc-text">4. 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0"><span class="toc-text">5. 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%B0%81%E8%A3%85"><span class="toc-text">6.1 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">6.2 构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">6.3 类的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-text">6.4 对象模型和this指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%8F%8B%E5%85%83"><span class="toc-text">6.5 友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">6.6 运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-%E7%BB%A7%E6%89%BF"><span class="toc-text">6.7 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-%E5%A4%9A%E6%80%81"><span class="toc-text">6.8 多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">7. 作用域解析运算符::</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%A8%A1%E6%9D%BF"><span class="toc-text">8. 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88"><span class="toc-text">8.1 函数模版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">8.2 模板的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">8.3 类模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">9. 强制类型转换运算符</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>