<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剑指offer | GXBLOGS</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="根据这个站刷的：剑指 Offer 题解 | CS-Notes 面试笔记 (cyc2018.xyz)  题目总数76           &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例         var myChart &#x3D; echarts.init(document.getElementById(&#39;echarts8320&#39;));          &#x2F;&#x2F; 指定图表的配置项和数据">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="https://gxblogs.com/posts/26732/index.html">
<meta property="og:site_name" content="GXBLOGS">
<meta property="og:description" content="根据这个站刷的：剑指 Offer 题解 | CS-Notes 面试笔记 (cyc2018.xyz)  题目总数76           &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例         var myChart &#x3D; echarts.init(document.getElementById(&#39;echarts8320&#39;));          &#x2F;&#x2F; 指定图表的配置项和数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-24_20-02-53.png">
<meta property="article:published_time" content="2024-03-24T15:56:14.695Z">
<meta property="article:modified_time" content="2024-06-20T19:17:14.188Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="算法与数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-24_20-02-53.png"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.com/posts/26732/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: GXBLOGS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-21 03:17:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/highlight/Kimbiedark.css"><script src="/css/else/echarts.min.js"></script><script src="/css/else/wow.min.js"></script><script type="text/javascript" src="/css/else/echarts-gl.min.js"></script><script src="/css/else/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="/static/imgs/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-24_20-02-53.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GXBLOGS</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-24T15:56:14.695Z" title="发表于 2024-03-24 23:56:14">2024-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-20T19:17:14.188Z" title="更新于 2024-06-21 03:17:14">2024-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/26732/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/26732/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>根据这个站刷的：<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">剑指 Offer 题解 | CS-Notes 面试笔记 (cyc2018.xyz)</a></p>
</blockquote>
<p><strong>题目总数76</strong></p>
<div id="echarts8320" style="width: 100%;height: 400px;margin: 0 auto"></div>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts8320'));

        // 指定图表的配置项和数据
        var option = 
option = {
tooltip: {
 trigger: 'item'
},
legend: {
 top: '5%',
 left: 'center'
},
series: [
 {
   name: 'Access From',
   type: 'pie',
   radius: ['40%', '70%'],
   avoidLabelOverlap: false,
   itemStyle: {
     borderRadius: 10,
     borderColor: '#fff',
     borderWidth: 2
   },
   label: {
     show: false,
     position: 'center'
   },
   emphasis: {
     label: {
       show: true,
       fontSize: 40,
       fontWeight: 'bold'
     }
   },
   labelLine: {
     show: false
   },
   data: [
     { value: 55, name: '已完成' },     
     { value: 16, name: '未完成' },
     { value: 5, name: '题目丢失' },
   ]
 }
]
};


        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<h2 id="错误总结">错误总结</h2>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">初始化错误 </summary><div class="toggle-content"><p><strong>错误</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">order</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;    <span class="hljs-comment">// 记录字符最早出现的次序；</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>;   <span class="hljs-comment">// 标记是否出现过；</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>正确</strong>：</p>
<p>在C++中，类的成员变量不能在类内部进行初始化，需要在构造函数中或者类外部进行初始化。因此，你不能在类的定义中直接对<code>order</code>和<code>mark</code>进行初始化，会导致编译错误。</p>
<p>解决方法是将变量的初始化移到构造函数中，或者在类外部进行初始化。</p>
<p>以下是修正后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() : <span class="hljs-built_in">order</span>(<span class="hljs-number">256</span>, <span class="hljs-string">&#x27;\0&#x27;</span>), <span class="hljs-built_in">mark</span>(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">// 在构造函数中进行初始化</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">char</span>&gt; order;    <span class="hljs-comment">// 记录字符最早出现的次序；</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; mark;      <span class="hljs-comment">// 标记是否出现过；</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个修正后的版本中，我们将<code>order</code>和<code>mark</code>的初始化移到了构造函数中，并且将它们从类的定义中移动到了私有成员变量部分。这样就能够正确地初始化这两个向量。</p>
<br>
<p>问：</p>
<p>为什么<code>int cnt = 0;</code>这样的可以呢</p>
<p>GPT：</p>
<p>在C++中，你可以在类的定义内部初始化非静态成员变量，但是这只适用于常规的数据类型（例如int、double等）和某些类类型（例如std::string）。</p>
<p>这种方式的初始化是一种方便的语法糖，它允许你在类的定义中直接指定成员变量的初始值，而不需要在构造函数中显式地初始化它们。编译器会在对象创建时自动调用合适的构造函数来初始化这些成员变量。</p>
<p>例如，下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 直接在类内部初始化成员变量 cnt</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>cnt</code>被初始化为0，这意味着当创建一个<code>MyClass</code>对象时，它的<code>cnt</code>成员变量会自动被设置为0。</p>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">string生命周期问题 </summary><div class="toggle-content"><p>来自下面的 - <strong>树小节中的题目序列化二叉树</strong></p>
<p>实际上，<code>std::string</code>的<code>c_str()</code>方法并不返回一个新的<code>char[]</code>数组。它返回的是一个指向内部数据结构中以<code>'\0'</code>结尾的字符数组的指针。这个返回的指针是<code>const char*</code>类型，指向的内存区域由<code>std::string</code>对象管理，你不应该尝试修改它指向的内容。重要的是，这个指针仅在相关的<code>std::string</code>对象没有被修改（包括但不限于内容的修改、重新分配内存等）和没有被销毁的情况下保持有效。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>生命周期管理</strong>：返回的<code>const char*</code>指针所指向的内存是由<code>std::string</code>对象负责管理的。如果<code>std::string</code>对象被销毁或其内容被修改（可能导致重新分配内存），那么之前通过<code>c_str()</code>获得的指针可能会变得无效。</li>
<li><strong>非独立的内存区域</strong>：<code>c_str()</code>方法返回的指针并不指向一个独立分配的内存区域，而是直接指向<code>std::string</code>内部用于存储字符串的内存。因此，没有必要（也不应该）尝试释放这个指针指向的内存。</li>
</ul>
</div></details>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">new的问题 </summary><div class="toggle-content"><p>也是来自下面的 - <strong>树小节中的题目序列化二叉树</strong></p>
<p>这是一个常见的错误，很容易被忽视。在C++中：</p>
<ul>
<li><code>new char[ans.length() + 1]</code> 正确地分配了一个字符数组，长度为<code>ans.length() + 1</code>。</li>
<li><code>new char(ans.length() + 1)</code> 则是分配了单个字符，并用<code>ans.length() + 1</code>的值来初始化它（这通常不是您想要的结果）。</li>
</ul>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="数组与矩阵">数组与矩阵</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&amp;tqId=11203&amp;tab=answerKey&amp;from=cyc_github">3. 数组中重复的数字</a>_</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            时间复杂度 O(N)，空间复杂度 O(1)</span><br><span class="hljs-comment">            思想第i个位置放值为i</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (numbers[i] != i) &#123;<br>                <span class="hljs-keyword">if</span> (numbers[i] == numbers[numbers[i]]) &#123;<br>                    <span class="hljs-keyword">return</span> numbers[i];<br>                &#125;<br>                <span class="hljs-built_in">swap</span>(numbers[i], numbers[numbers[i]]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>目标：时间复杂度 O(M + N)，空间复杂度 O(1)</p>
<ol>
<li>
<p>设置一个索引<code>i</code>来表示行，初始值为<code>0</code>，另一个索引<code>j</code>来表示列，初始值为<code>n - 1</code>。</p>
</li>
<li>
<p>当<code>i &lt; m</code>且<code>j &gt;= 0</code></p>
<p>时进行搜索：</p>
<ul>
<li>如果<code>target</code>等于<code>matrix[i][j]</code>，返回<code>true</code>。</li>
<li>如果<code>target</code>小于<code>matrix[i][j]</code>，则<code>target</code>不可能在当前列中，因此<code>j--</code>。</li>
<li>如果<code>target</code>大于<code>matrix[i][j]</code>，则<code>target</code>不可能在当前行中，因此<code>i++</code>。</li>
</ul>
</li>
<li>
<p>如果退出循环，说明没有找到<code>target</code>，返回<code>false</code>。</p>
</li>
</ol>
<p>为什么从右上角开始，因为每一次操作都可以缩小查找范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) &#123;<br>                j--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&amp;tqId=11155&amp;tab=answerKey&amp;from=cyc_github">5. 替换空格</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录中写过原题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>         <span class="hljs-comment">// --计算空格数--</span><br>        <span class="hljs-type">int</span> oldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; oldSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) cnt++;<br>        &#125;<br>        <span class="hljs-comment">// --扩大数组，加上所有空格的大小（本来就占用一个了）--</span><br>        s.<span class="hljs-built_in">resize</span>(oldSize + cnt *<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> newSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// --slow遍历，fast指向下一个存放的位置--</span><br>        <span class="hljs-type">int</span> slow = oldSize - <span class="hljs-number">1</span>, fast = newSize - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (slow &lt; fast) &#123;<br>            <span class="hljs-keyword">if</span> (s[slow] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[fast--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[fast--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[fast--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                slow--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> s[fast--] = s[slow--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">29. 顺时针打印矩阵</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录中写过类似的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;LEFT_, DOWN_, RIGHT_, UP_&#125;;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOver</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 检查是否越界</span><br>        <span class="hljs-keyword">if</span> (i &gt;= m || j &gt;= n || i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mark</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));     <span class="hljs-comment">// 标记数组，0未访问过，1访问过</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 当前位置</span><br>        <span class="hljs-type">int</span> t = m * n;<br>        Direction d = RIGHT_; <span class="hljs-comment">// 当前的方向</span><br>        <span class="hljs-keyword">while</span> (t--) &#123;<br>            <span class="hljs-keyword">switch</span> (d) &#123;<br>                <span class="hljs-keyword">case</span> LEFT_: &#123;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(i, j, m, n) &amp;&amp; mark[i][j] == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 记录 + 标记 + 前进</span><br>                        ans.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>                        mark[i][j] = <span class="hljs-number">1</span>;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 回退 + 转向 + 前进</span><br>                        j--;<br>                        t++;<br>                        d = DOWN_;<br>                        i++;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> DOWN_: &#123;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(i, j, m, n) &amp;&amp; mark[i][j] == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 记录 + 标记 + 前进</span><br>                        ans.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>                        mark[i][j] = <span class="hljs-number">1</span>;<br>                        i++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 回退 + 转向 + 前进</span><br>                        i--;<br>                        t++;<br>                        d = RIGHT_;<br>                        j--;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> RIGHT_: &#123;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(i, j, m, n) &amp;&amp; mark[i][j] == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 记录 + 标记 + 前进</span><br>                        ans.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>                        mark[i][j] = <span class="hljs-number">1</span>;<br>                        j--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 回退 + 转向 + 前进</span><br>                        j++;<br>                        t++;<br>                        d = UP_;<br>                        i--;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> UP_: &#123;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(i, j, m, n) &amp;&amp; mark[i][j] == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 记录 + 标记 + 前进</span><br>                        ans.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>                        mark[i][j] = <span class="hljs-number">1</span>;<br>                        i--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 回退 + 转向 + 前进</span><br>                        i++;<br>                        t++;<br>                        d = LEFT_;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">50. 第一个只出现一次的字符位置</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>ASCII实际上确实有128个不同的符号，这是因为它是一个7位的字符编码标准，覆盖了从0到127的值。但是，经常有一种扩展的ASCII版本被称为“扩展ASCII”或“8位ASCII”，它使用了第八位来扩展字符集，允许256个不同的值（从0到255）。</p>
<p>在很多情况下，尽管原始ASCII只定义了128个字符，程序员仍然会创建一个大小为256的数组，来包含可能的扩展ASCII字符。这是一种预防措施，以确保程序可以处理非标准的ASCII值，尤其是那些可能出现在某些特殊文本编码或者用户输入中的字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// 标记出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>            cnt[c]++;<br>        &#125;<br>        <span class="hljs-comment">// 再次遍历字符串，查找第一个出现次数为1的字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[str[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="栈队列堆">栈队列堆</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">9. 用两个栈实现队列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 将队尾栈全部压到队头栈</span><br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-type">int</span> tmp = stack1.<span class="hljs-built_in">top</span>();<br>                stack1.<span class="hljs-built_in">pop</span>();<br>                stack2.<span class="hljs-built_in">push</span>(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;  <span class="hljs-comment">// 队尾</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;  <span class="hljs-comment">// 队头</span><br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">30. 包含 min 函数的栈</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        同步操作两个栈</span><br><span class="hljs-comment">        特别之处：minStack压栈，比栈顶小直接放，比栈顶大复制一份栈顶</span><br><span class="hljs-comment">    */</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; commonStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minStack;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        commonStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span> (minStack.<span class="hljs-built_in">empty</span>()) minStack.<span class="hljs-built_in">push</span>(value);     <span class="hljs-comment">// 第一个直接放</span><br>        <span class="hljs-keyword">else</span> minStack.<span class="hljs-built_in">push</span>(value &lt; minStack.<span class="hljs-built_in">top</span>() ? value : minStack.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        commonStack.<span class="hljs-built_in">pop</span>();<br>        minStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> commonStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">31. 栈的压入、弹出序列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pushV int整型vector </span><br><span class="hljs-comment">     * @param popV int整型vector </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pushV, vector&lt;<span class="hljs-type">int</span>&gt;&amp; popV)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pushV.<span class="hljs-built_in">size</span>() != popV.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; imitate;     <span class="hljs-comment">// 用一个栈来模拟这个过程</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : pushV) &#123;<br>            imitate.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">while</span> (!imitate.<span class="hljs-built_in">empty</span>() &amp;&amp; imitate.<span class="hljs-built_in">top</span>() == popV[j]) &#123;<br>                imitate.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (imitate.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">40. 最小的 K 个数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param input int整型vector </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : input) <br>            heap.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(heap.<span class="hljs-built_in">top</span>());<br>            heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">41.1 数据流中的中位数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路：</span><br><span class="hljs-comment">        建立两个堆，一个大根堆，一个小根堆，然后使得</span><br><span class="hljs-comment">        - 奇数时：两个根的数量相差一</span><br><span class="hljs-comment">        - 偶数时：两个根数量相等</span><br><span class="hljs-comment">        - 大根堆中的数字都小于小根堆（也就是比较堆顶大小）</span><br><span class="hljs-comment">        [大根堆，中位数，小根堆]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        实现:</span><br><span class="hljs-comment">        以下实现中</span><br><span class="hljs-comment">        - 奇数时，minHeap比maxHeap多一个</span><br><span class="hljs-comment">        - 偶数时，minHeap和maxHeap数量相等</span><br><span class="hljs-comment">    */</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        cnt++;<br>        <span class="hljs-comment">// 特判只有一个和两个的时候</span><br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; minHeap.<span class="hljs-built_in">top</span>()) &#123;<br>                maxHeap.<span class="hljs-built_in">push</span>(minHeap.<span class="hljs-built_in">top</span>());<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>                minHeap.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>            <span class="hljs-keyword">else</span> maxHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 其他情况</span><br>        <span class="hljs-keyword">if</span> (num &gt;= maxHeap.<span class="hljs-built_in">top</span>() &amp;&amp; num &lt;= minHeap.<span class="hljs-built_in">top</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                maxHeap.<span class="hljs-built_in">push</span>(num);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; maxHeap.<span class="hljs-built_in">top</span>()) &#123;<br>            maxHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;     <span class="hljs-comment">// 补一个给minHeap来维持数量差</span><br>                minHeap.<span class="hljs-built_in">push</span>(maxHeap.<span class="hljs-built_in">top</span>());<br>                maxHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 补一个给maxHeap来维持数量差</span><br>                maxHeap.<span class="hljs-built_in">push</span>(minHeap.<span class="hljs-built_in">top</span>());<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)(maxHeap.<span class="hljs-built_in">top</span>() + minHeap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// minHeap比maxHeap的数量多一个</span><br>            <span class="hljs-keyword">return</span> minHeap.<span class="hljs-built_in">top</span>();<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">41.2 字符流中第一个不重复的字符</a><br>
学习一下这一题的变量初始化</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>比较前面的找到第一个不重复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() : <span class="hljs-built_in">order</span>(<span class="hljs-number">256</span>, <span class="hljs-string">&#x27;\0&#x27;</span>), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">// 在构造函数中进行初始化</span><br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt[ch] == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 首次出现</span><br>           order.<span class="hljs-built_in">push_back</span>(ch);<br>           cnt[ch]++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> cnt[ch]++;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">// 用order[]来限制每次操作都为O(1)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; order.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[order[i]] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> order[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">char</span>&gt; order;    <span class="hljs-comment">// 记录字符最早出现的次序；</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; cnt;      <span class="hljs-comment">// 标记是否出现过；</span><br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">59. 滑动窗口的最大值 </a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>法一：堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param num int整型vector </span><br><span class="hljs-comment">     * @param size int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            分析：每次移动都会出去一个，进来一个</span><br><span class="hljs-comment">            思路：维护一个大根堆</span><br><span class="hljs-comment">            但是出堆怎么解决呢？</span><br><span class="hljs-comment">            问了gpt，堆内存的是(索引，值)</span><br><span class="hljs-comment">            1. 出堆：如果堆顶索引不在窗口内，就一直出堆</span><br><span class="hljs-comment">            2. 入堆：新元素入堆</span><br><span class="hljs-comment">            但是这样的最坏时间复杂度是o(n log n)啊</span><br><span class="hljs-comment">        */</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span> || size &gt; num.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> ans;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; maxHeap;     <span class="hljs-comment">// (索引，值)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;    <span class="hljs-comment">// 初始窗口</span><br>            maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(num[i], i));<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(maxHeap.<span class="hljs-built_in">top</span>().first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num.<span class="hljs-built_in">size</span>() - size; i++) &#123;   <span class="hljs-comment">// 窗口为i ~ i+size-1</span><br>            <span class="hljs-comment">// 1. 出堆</span><br>            <span class="hljs-keyword">while</span> (!maxHeap.<span class="hljs-built_in">empty</span>() &amp;&amp; maxHeap.<span class="hljs-built_in">top</span>().second &lt; i) maxHeap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 2. 入堆</span><br>            maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(num[i + size - <span class="hljs-number">1</span>], i + size - <span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// 3. 当前最大值</span><br>            ans.<span class="hljs-built_in">push_back</span>(maxHeap.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>法二：双端队列</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="双指针">双指针</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">57.1 和为 S 的两个数字</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>法一：双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array,<span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = array.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> curSum = array[left] + array[right];<br>            <span class="hljs-keyword">if</span> (curSum == sum) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(array[left]);<br>                ans.<span class="hljs-built_in">push_back</span>(array[right]);<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curSum &gt; sum) right--;  <span class="hljs-comment">// 变小点</span><br>            <span class="hljs-keyword">else</span> left++;    <span class="hljs-comment">// 变大点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>法二：哈希表（代码随想录中刷过）</p>
</div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">57.2 和为 S 的连续正数序列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param sum int整型 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (curSum == sum) &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) tmp.<span class="hljs-built_in">push_back</span>(i);<br>                ans.<span class="hljs-built_in">push_back</span>(tmp);<br>                <span class="hljs-comment">// 继续寻找</span><br>                curSum -= left;<br>                left++; <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curSum &gt; sum)  &#123;   <span class="hljs-comment">// 太大了，减点</span><br>                curSum -= left;<br>                left++;<br>            &#125;     <br>            <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 太小了，加点</span><br>                right++;<br>                curSum += right;<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">58.1 翻转单词顺序列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            思路：先翻转单词，在翻转全部</span><br><span class="hljs-comment">        */</span> <br>        string ans;<br>        <span class="hljs-type">bool</span> status = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 是否是单词</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">bool</span> old_status = status;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27; &#x27;</span>) status = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> status = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 由false跳true，表示接下来是单词</span><br>            <span class="hljs-keyword">if</span> (old_status == <span class="hljs-literal">false</span> &amp;&amp; status == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> curi = i;<br>                <span class="hljs-keyword">while</span> (i &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[i] !=  <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>                i--;    <span class="hljs-comment">// 回退一下，for循环有i++</span><br>                <span class="hljs-comment">// 翻转单词</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= curi; j--) ans.<span class="hljs-built_in">push_back</span>(str[j]); <br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">pop_back</span>();     <span class="hljs-comment">// 去掉最后一个单词后面的空格</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-type">char</span> tmp = ans[i];<br>            ans[i] = ans[j];<br>            ans[j] = tmp;<br>            i++, j--;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">58.2 左旋转字符串</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(string &amp;str, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;  <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-keyword">for</span> (;left &lt; right; left++, right--) &#123;<br>            <span class="hljs-type">char</span> tmp = str[left];<br>            str[left] = str[right];<br>            str[right] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            思路：先将两个子串翻转，再总体翻转</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> str;    <span class="hljs-comment">// 特俗情况：str为空</span><br>        n %= str.<span class="hljs-built_in">size</span>();                <span class="hljs-comment">// 特俗情况：n&gt;str.size();</span><br>        <span class="hljs-built_in">reverseString</span>(str, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverseString</span>(str, n, str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverseString</span>(str, <span class="hljs-number">0</span>, str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="链表">链表</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">6. 从尾到头打印链表</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        用回溯法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">traverse</span>(ans, head);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans, ListNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traverse</span>(ans, node-&gt;next);<br>        ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// --初值为空的情况--</span><br>        <span class="hljs-keyword">if</span> (!head)  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// --增加一个哨兵节点--</span><br>        ListNode* head0 = <span class="hljs-keyword">new</span> ListNode;<br>        head0-&gt;next = head;<br>        ListNode* tmp = head0;<br>        <span class="hljs-comment">// --遍历--</span><br>        <span class="hljs-keyword">while</span> (tmp) &#123;<br>            <span class="hljs-comment">// --删除--</span><br>            <span class="hljs-keyword">if</span> (tmp-&gt;next &amp;&amp; tmp-&gt;next-&gt;val == val) &#123;<br>                ListNode* need2Delete = tmp-&gt;next;<br>                tmp-&gt;next = tmp-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> need2Delete;<br>                <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 不然会跳判</span><br>            &#125;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head0-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">18.2 删除链表中重复的结点</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!pHead) <span class="hljs-keyword">return</span> pHead;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;  <span class="hljs-comment">// &lt;val , 出现次数&gt;</span><br>        <span class="hljs-built_in">traverse</span>(pHead, cnt);<br>        ListNode *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        head-&gt;next = pHead;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[p-&gt;next-&gt;val] &gt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 出现次数大于1的删除</span><br>                ListNode *need2delete = p-&gt;next;<br>                p-&gt;next = p-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> need2delete;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode *node, map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;cnt)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (cnt.<span class="hljs-built_in">count</span>(node-&gt;val) == <span class="hljs-number">0</span>) cnt.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(node-&gt;val, <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> cnt[node-&gt;val]++;<br>        <span class="hljs-built_in">traverse</span>(node-&gt;next, cnt);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&amp;tqId=11167&amp;tab=answerKey&amp;from=cyc_github">22. 链表中倒数第 K 个结点</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录类似题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct ListNode *next;</span><br><span class="hljs-comment"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *fast = pHead;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; k--) fast = fast-&gt;next;  <br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// 比k还短</span><br>        <span class="hljs-keyword">while</span> (fast) &#123;<br>            fast = fast-&gt;next;<br>            pHead = pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>[23. 链表中环的入口结点](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/23. 链表中环的入口结点.html)</li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">24. 反转链表</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录中刷过，用的方法不一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct ListNode *next;</span><br><span class="hljs-comment"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 头插法</span><br>        ListNode *head0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            ListNode *tmp = p;<br>            p = p-&gt;next;<br>            tmp-&gt;next = head0-&gt;next;<br>            head0-&gt;next = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head0-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">25. 合并两个排序的链表</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct ListNode *next;</span><br><span class="hljs-comment"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead1 ListNode类 </span><br><span class="hljs-comment">     * @param pHead2 ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        ListNode *head0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *p = head0;<br>        <span class="hljs-keyword">while</span> (pHead1 &amp;&amp; pHead2) &#123;<br>            <span class="hljs-keyword">if</span> (pHead1-&gt;val &gt; pHead2-&gt;val) &#123;<br>                p-&gt;next = pHead2;<br>                pHead2 = pHead2-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = pHead1;<br>                pHead1 = pHead1-&gt;next;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pHead1) p-&gt;next = pHead1;<br>        <span class="hljs-keyword">else</span> p-&gt;next = pHead2;<br>        <span class="hljs-keyword">return</span> head0-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">35. 复杂链表的复制</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            看题解了</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 第一步，在每个节点的后面插入复制的节点。</span><br>        RandomListNode *p = pHead;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            RandomListNode *newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(p-&gt;label);<br>            newNode-&gt;next = p-&gt;next;<br>            p-&gt;next = newNode;<br>            p = p-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 第二步，对复制节点的 random 链接进行赋值。</span><br>        p = pHead;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;random != <span class="hljs-literal">nullptr</span>) <br>                p-&gt;next-&gt;random = p-&gt;random-&gt;next;<br>            p = p-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 第三步，拆分。（原链表也要还原，不然出错）</span><br>        RandomListNode* copyHead = pHead-&gt;next;<br>        RandomListNode* tmp;<br>        p = pHead;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            tmp = p-&gt;next;<br>            p-&gt;next = tmp-&gt;next;<br>            <span class="hljs-keyword">if</span>(tmp-&gt;next) tmp-&gt;next = tmp-&gt;next-&gt;next;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> copyHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">52. 两个链表的第一个公共结点</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">lenListNode</span>(pHead1);<br>        <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">lenListNode</span>(pHead2);<br>		<span class="hljs-comment">// 让1链表更长</span><br>		<span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;<br>			<span class="hljs-built_in">swap</span>(len1, len2);<br>			<span class="hljs-built_in">swap</span>(pHead1, pHead2);<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 - len2; i++, pHead1 = pHead1-&gt;next);<br>		<span class="hljs-keyword">for</span> (; pHead1; pHead1 = pHead1-&gt;next, pHead2 = pHead2-&gt;next) &#123;<br>			<span class="hljs-keyword">if</span> (pHead1 == pHead2) <span class="hljs-keyword">return</span> pHead1;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenListNode</span><span class="hljs-params">(ListNode *node)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">lenListNode</span>(node-&gt;next) + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="树">树</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">7. 重建二叉树</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct TreeNode *left;</span><br><span class="hljs-comment"> *	struct TreeNode *right;</span><br><span class="hljs-comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param preOrder int整型vector </span><br><span class="hljs-comment">     * @param vinOrder int整型vector </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vinOrder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rebuidBTree</span>(preOrder, vinOrder, <br>                    <span class="hljs-number">0</span>, preOrder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, <br>                    <span class="hljs-number">0</span>, vinOrder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">rebuidBTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vinOrder, </span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">int</span> preBegin, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span> vinBegin, <span class="hljs-type">int</span> vinEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preBegin &gt; preEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode *newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preOrder[preBegin]);<br>        <span class="hljs-type">int</span> vinRootIndex = vinBegin;<br>        <span class="hljs-keyword">for</span> (; <br>            vinRootIndex &lt;= vinEnd &amp;&amp; vinOrder[vinRootIndex] != preOrder[preBegin]; <br>            vinRootIndex++) ;<br>        newNode-&gt;left = <span class="hljs-built_in">rebuidBTree</span>(preOrder, vinOrder, <br>                            preBegin+<span class="hljs-number">1</span>, preBegin + (vinRootIndex - vinBegin), <br>                            vinBegin, vinRootIndex - <span class="hljs-number">1</span>);<br>        newNode-&gt;right = <span class="hljs-built_in">rebuidBTree</span>(preOrder, vinOrder, <br>                            preBegin + (vinRootIndex - vinBegin) + <span class="hljs-number">1</span>, preEnd,<br>                            vinRootIndex + <span class="hljs-number">1</span>, vinEnd);<br>        <span class="hljs-keyword">return</span> newNode; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">8. 二叉树的下一个结点</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        <span class="hljs-comment">// 情况1. 有右子树，那就在自己的右子树中不断向左寻找</span><br>        TreeLinkNode *nextNode = pNode-&gt;right;<br>        <span class="hljs-keyword">while</span> (nextNode &amp;&amp; nextNode-&gt;left) nextNode = nextNode-&gt;left;<br>        <span class="hljs-keyword">if</span> (nextNode) <span class="hljs-keyword">return</span> nextNode;<br>        <span class="hljs-comment">// 情况2. 没有右子树，则向上遍历，找到自己处于的某棵最小左子树，那么根节点就是下一个</span><br>        nextNode = pNode-&gt;next;<br>        TreeLinkNode *old_nextNode = pNode;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (nextNode) &#123;<br>            <span class="hljs-keyword">if</span> (nextNode-&gt;left == old_nextNode) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            old_nextNode = nextNode;<br>            nextNode = nextNode-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> nextNode;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">26. 树的子结构</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录做过类似：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/description/">572. 另一棵树的子树 - 力扣（LeetCode）</a></p>
<p>注意这题是<u>子结构</u>，不是子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStruct</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// --1. 子树都为空--</span><br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// --2. 子树有一个不为空--</span><br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// --3. 子树都不为空--</span><br>        <span class="hljs-keyword">if</span> (p-&gt;val == q-&gt;val      <span class="hljs-comment">// 自己是否相等</span><br>            &amp;&amp; <span class="hljs-built_in">isSubStruct</span>(p-&gt;left, q-&gt;left)  <span class="hljs-comment">// p左子树和q左子树是否相等</span><br>            &amp;&amp; <span class="hljs-built_in">isSubStruct</span>(p-&gt;right, q-&gt;right))  <span class="hljs-comment">// p右子树和q右子树是否相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;	<span class="hljs-comment">// 特判空的情况</span><br>		<span class="hljs-keyword">if</span> (!pRoot1) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStruct</span>(pRoot1, pRoot2) <br>            || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2) <br>            || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&amp;tqId=11171&amp;tab=answerKey&amp;from=cyc_github">27. 二叉树的镜像</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct TreeNode *left;</span><br><span class="hljs-comment"> *	struct TreeNode *right;</span><br><span class="hljs-comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-built_in">traverse</span>(pRoot);<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode *&amp;node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">traverse</span>(node-&gt;left);<br>        <span class="hljs-built_in">traverse</span>(node-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=101 lang=cpp</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [101] 对称二叉树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">preOrdertraverse</span><span class="hljs-params">(TreeNode *t1, TreeNode *t2)</span> </span>&#123;<br>        <span class="hljs-comment">// --1. 子树都为空--</span><br>        <span class="hljs-keyword">if</span> (!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// --2. 子树有一个不为空--</span><br>        <span class="hljs-keyword">if</span> (t1 &amp;&amp; !t2 || !t1 &amp;&amp; t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// --3. 子树都不为空--</span><br>        <span class="hljs-keyword">if</span> (t1-&gt;val == t2-&gt;val      <span class="hljs-comment">// 自己是否相等</span><br>            &amp;&amp; <span class="hljs-built_in">preOrdertraverse</span>(t1-&gt;left, t2-&gt;right)  <span class="hljs-comment">// t1左子树和t2右子树是否相等</span><br>            &amp;&amp; <span class="hljs-built_in">preOrdertraverse</span>(t1-&gt;right, t2-&gt;left))  <span class="hljs-comment">// t1右子树和t2左子树是否相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">preOrdertraverse</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br><br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">32.1 从上往下打印二叉树</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>		queue&lt;TreeNode *&gt; que;<br>		que.<span class="hljs-built_in">push</span>(root);<br>		<span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>			TreeNode *curNode = que.<span class="hljs-built_in">front</span>();<br>			que.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">if</span> (curNode) &#123;<br>				ans.<span class="hljs-built_in">push_back</span>(curNode-&gt;val);<br>				que.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>				que.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">32.2 把二叉树打印成多行</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>代码随想录中的类似题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct TreeNode *left;</span><br><span class="hljs-comment"> *	struct TreeNode *right;</span><br><span class="hljs-comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>        <span class="hljs-keyword">if</span> (!pRoot) <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> curLevelNum = que.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 当前层的个数</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; curLevelAns;<br>            <span class="hljs-keyword">while</span>(curLevelNum--) &#123;<br>                TreeNode *curNode = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                curLevelAns.<span class="hljs-built_in">push_back</span>(curNode-&gt;val);<br>                <span class="hljs-keyword">if</span> (curNode-&gt;left) que.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>                <span class="hljs-keyword">if</span> (curNode-&gt;right) que.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(curLevelAns);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>
<p>32.3 按之字形顺序打印二叉树 （牛客下架了，也没找到别的题）</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">33. 二叉搜索树的后序遍历序列</a></p>
</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sequence.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traverse</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;  <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> rootVal = sequence[right];<br>        <span class="hljs-comment">// 假设正确的情况下，找到左子树的右边界</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = right<span class="hljs-number">-1</span>; i &gt;= left &amp;&amp; rootVal &lt; sequence[i]; i--);<br>        <span class="hljs-comment">// 假设右子树成功，验证左子树</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (sequence[j] &gt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对于这个root来说没问题，接着找</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traverse</span>(sequence, left, i)<br>                &amp;&amp; <span class="hljs-built_in">traverse</span>(sequence, i + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>
<p>34.二叉树中和为某一值的路径（牛客下架了，也没找到别的题）</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">36. 二叉搜索树与双向链表</a></p>
</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		思路：中序遍历纪委二叉搜索树的递增序</span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!pRootOfTree) <span class="hljs-keyword">return</span> pRootOfTree;	<span class="hljs-comment">// 特判直接为空，不然whie处报错</span><br>		slow = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// 一前一后来修改指针</span><br>		<span class="hljs-built_in">traverse</span>(pRootOfTree);<br>        <span class="hljs-keyword">while</span> (pRootOfTree-&gt;left) pRootOfTree = pRootOfTree-&gt;left;<br>		<span class="hljs-keyword">return</span> pRootOfTree;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	TreeNode *slow;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode *node)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>		<span class="hljs-built_in">traverse</span>(node-&gt;left);<br>		<span class="hljs-keyword">if</span> (slow == <span class="hljs-literal">nullptr</span>) node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-keyword">else</span> &#123;<br>			node-&gt;left = slow;<br>			slow-&gt;right = node;<br>		&#125;<br>		slow = node;	<span class="hljs-comment">// 更新slow</span><br>		<span class="hljs-built_in">traverse</span>(node-&gt;right);<br>		<br>	&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">37. 序列化二叉树</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>其他样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;8,4,12,2,6,10,14,1,3,5,7,9,11,13,15&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        参考了一下怎么存字符串的</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string ans;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* curNode = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!curNode) ans += <span class="hljs-string">&quot;#!&quot;</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans += <span class="hljs-built_in">to_string</span>(curNode-&gt;val) + <span class="hljs-string">&#x27;!&#x27;</span>;     <span class="hljs-comment">// push_back只能插字符</span><br>                que.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 把样例的搞成 1!2!3!#!#!6!7!#!#!#!#!</span><br>        <span class="hljs-comment">// return (char*)ans.c_str();   // 这么写是错的，因为这个函数结束时，string变量的生命周期结束了，</span><br>        <span class="hljs-comment">// 然后这个指针悬空了</span><br><br>        <span class="hljs-comment">// char* res = new char(ans.length() + 1);      // tmd，[]写成()，害我改了两个多小时</span><br>        <span class="hljs-type">char</span>* res = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ans.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(res, ans.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span> || str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果树为空</span><br>        <span class="hljs-type">int</span> num, curIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">getNum</span>(str, curIndex,<br>                    num)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果无法获取一个数字，返回nullptr</span><br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* curNode = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getNum</span>(str, curIndex, num)) &#123; <span class="hljs-comment">// 左子树</span><br>                curNode-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>                que.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getNum</span>(str, curIndex, num)) &#123; <span class="hljs-comment">// 右子树</span><br>                curNode-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>                que.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 从curIndex处开始取出一个数字，然后返回给num，如果是#则返回false</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">int</span>&amp; curIndex, <span class="hljs-type">int</span>&amp; num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str[curIndex] == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 没有了</span><br>        <span class="hljs-keyword">if</span> (str[curIndex] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            curIndex += <span class="hljs-number">2</span>;      <span class="hljs-comment">// 移动到&#x27;!&#x27;后面</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 说明接下来是数字了</span><br>        string n;<br>        <span class="hljs-keyword">while</span> (str[curIndex] == <span class="hljs-string">&#x27;+&#x27;</span> <br>            || str[curIndex] == <span class="hljs-string">&#x27;-&#x27;</span><br>            || str[curIndex] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[curIndex] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            n.<span class="hljs-built_in">push_back</span>(str[curIndex]);<br>            curIndex++;<br>        &#125;<br>        curIndex++;      <span class="hljs-comment">// 移动到&#x27;!&#x27;后面</span><br>        num = <span class="hljs-built_in">stoi</span>(n);  <span class="hljs-comment">// 转为数字</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>
<p>54.二叉查找树的第 K 个结点 （牛客下架了，也没找到别的题）</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">55.1 二叉树的深度</a></p>
</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!pRoot) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left), <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">55.2 平衡二叉树</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *	int val;</span><br><span class="hljs-comment"> *	struct TreeNode *left;</span><br><span class="hljs-comment"> *	struct TreeNode *right;</span><br><span class="hljs-comment"> *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-built_in">TreeDepth</span>(pRoot);<br>        <span class="hljs-keyword">return</span> isBalance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> isBalance = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">TreeDepth</span>(node-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">TreeDepth</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) isBalance = <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">68. 树中两个节点的最低公共祖先</a></p>
<p>可以再看看这题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>（代码随想录中刷的）</p>
</li>
</ul>
<hr>
<p><br><br><br></p>
<h2 id="贪心思想">贪心思想</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&amp;tqId=33257&amp;tab=answerKey&amp;from=cyc_github">14. 剪绳子</a>	<strong>重点学一下这一题的动态规划</strong></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><ul>
<li><strong>贪心解法</strong>：</li>
</ul>
<p>这个问题实质上转化为了求函数 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">y = \left(\frac{n}{m}\right)^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2543em;vertical-align:-0.35em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9043em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span>) 的最大值，其中 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>) 是变量，(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>) 是常数。解决这个问题的关键是理解，当每段绳子的长度趋近于 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>)（自然对数的底数，约等于2.71828）时，乘积 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>) 达到最大。这是因为数学上可以证明，以 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>) 为底的对数函数的增长速度与其函数值的增长速度相匹配，从而使得乘积最大化。</p>
<p>但在实际操作中，由于绳子长度必须是整数，我们不能直接用 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>) 来分割绳子。因此，我们需要找到最接近 (e) 的整数，来近似达到最大乘积。最接近 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>) 的整数是 2 和 3，而由于 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mfrac><mi>n</mi><mn>3</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">3^{\frac{n}{3}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8471em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8471em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>) 的增长速度比 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">2^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8471em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8471em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>) 要快，所以选择3作为分割绳子的最优长度。</p>
<p>简而言之，虽然基于公式 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">y = \left(\frac{n}{m}\right)^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2543em;vertical-align:-0.35em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9043em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span>) 求解时，我们试图找到某个最优的 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>) 使得 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>) 最大，但实际的最优策略涉及到将绳子尽可能分为长度为3的段，原因是这样分割接近于使每段长度等于自然对数的底 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>)，在整数限制下可以获得最大乘积。</p>
<p>ps：如果没有要求整数的话，就变成求极值的问题了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; little&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;     <span class="hljs-comment">// 前几个数特殊解决</span><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> little[n];<br>        <span class="hljs-comment">// 长度为3的个数</span><br>        <span class="hljs-type">int</span> n3 = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 长度为2的个数</span><br>        <span class="hljs-type">int</span> tmp = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> n2;<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 将1补成2</span><br>            n3--;<br>            n2 = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> n2 = tmp == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 乘起来</span><br>        <span class="hljs-type">int</span> mul = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n3--) mul *= <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (n2--) mul *= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mul;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>动态规划</strong>：</li>
</ul>
<p>动态规划是解决这类优化问题的一个非常有效的方法，特别是当问题可以被分解成一系列重叠的子问题时。对于这个特定的绳子切割问题，动态规划的思想是从底向上（从最小的子问题开始）计算每个长度的绳子的最大乘积，直到计算出原始长度的绳子的最大乘积为止。</p>
<p>动态规划算法的基本步骤如下：</p>
<ol>
<li>
<p><strong>定义状态</strong>：首先定义一个数组 <code>dp[]</code>，其中 <code>dp[i]</code> 表示长度为 <code>i</code> 的绳子切割后得到的最大乘积。</p>
</li>
<li>
<p><strong>初始状态</strong>：初始化 <code>dp[1] = 1</code>，虽然按题目要求，绳子至少要切一刀，但这里初始化 <code>dp[1]</code> 是为了后续计算的方便。实际上，由于长度为1的绳子不能切割，这个值在逻辑上是不会被直接使用的。</p>
</li>
<li>
<p><strong>状态转移方程</strong>：考虑长度为 <code>i</code> 的绳子，我们可以选择第一刀切割的位置 <code>j</code>（<code>1 &lt;= j &lt; i</code>），这样绳子就被分成了长度为 <code>j</code> 和 <code>i-j</code> 的两段。对于这两段绳子，我们可以选择继续切割或不切割，以获得最大乘积，因此 <code>dp[i]</code> 可以通过遍历所有可能的 <code>j</code> 来计算得出：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mo stretchy="false">{</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>×</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dp[i] = \max_{1 \leq j &lt; i}\{ \max(j, dp[j]) \times \max(i-j, dp[i-j]) \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6138em;vertical-align:-0.8638em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8638em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])}</span></span></span></span></span></p>
<p>这里使用 <code>max(j, dp[j])</code> 是因为我们可以选择不再进一步切割长度为 <code>j</code> 的那段绳子，即直接取 <code>j</code> 本身的长度作为乘积的一部分，或者是切割后的最大乘积 <code>dp[j]</code>。</p>
</li>
<li>
<p><strong>计算顺序</strong>：从左到右依次计算 <code>dp[2], dp[3], ..., dp[n]</code> 的值。</p>
</li>
<li>
<p><strong>结果</strong>：最终 <code>dp[n]</code> 就是长度为 <code>n</code> 的绳子切割后得到的最大乘积。</p>
</li>
</ol>
<p>使用动态规划解决这个问题，当绳子长度为8时，得到的最大乘积确实是18。这个结果与题目中给出的示例相匹配，说明动态规划方法是有效的。</p>
<p>动态规划是一个强大的工具，尤其适用于解决那些可以被分解成重叠子问题的优化问题。这个方法通过避免重复计算相同的子问题来提高效率，从而能够高效地解决许多看似复杂的问题。希望这个解释和示例代码能帮助你复习和加深对动态规划的理解！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; little&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;     <span class="hljs-comment">// 前几个数特殊解决</span><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> little[n];<br>        <span class="hljs-comment">// 动态规划</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j, dp[j]) * <span class="hljs-built_in">max</span>(i-j, dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<br>
<br>
<p><strong>问</strong>：</p>
<p>我怎么从0得出这个思路?</p>
<p><strong>GPT4</strong>：</p>
<p>从零开始构建动态规划（DP）解决方案的思路涉及理解问题的本质、识别重叠子问题、定义状态和决策，并形成状态转移方程。下面是一步步的指南，以帮助你自己从零开始得出动态规划的解决思路：</p>
<ol>
<li><strong>理解问题</strong></li>
</ol>
<p>首先彻底理解问题的要求和限制。在这个例子中，问题是如何将一根绳子切割成多段，使得这些段的长度乘积最大。</p>
<ol start="2">
<li><strong>分析子问题</strong></li>
</ol>
<p>观察问题是否可以分解成更小的子问题。对于绳子切割问题，可以考虑每一次切割后剩下的部分作为一个新的子问题，即如果你已经决定了第一刀切在哪里，那么剩下的部分怎么切割以获得最大乘积就成为了一个新问题。</p>
<ol start="3">
<li><strong>定义状态</strong></li>
</ol>
<p>动态规划的核心在于状态的定义。在这个问题中，状态可以定义为 <code>dp[i]</code>，表示长度为 <code>i</code> 的绳子切割后得到的最大乘积。</p>
<ol start="4">
<li><strong>找出状态转移方程</strong></li>
</ol>
<p>考虑如何从已知的状态得到未知的状态。对于绳子切割问题，如果你考虑第一次切割产生的两段绳子，你可以用已知的最大乘积来计算更长绳子的最大乘积。这可以表述为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>×</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = \max_{1 \leq j &lt; i} (\max(j, dp[j]) \times \max(i-j, dp[i-j]))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6138em;vertical-align:-0.8638em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8638em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]))</span></span></span></span></span></p>
<p>这里考虑了所有可能的第一次切割位置 <code>j</code>，并用已知的最大乘积来计算新的最大乘积。</p>
<ol start="5">
<li><strong>初始化基础状态</strong></li>
</ol>
<p>确定最简单的子问题，并给出它们的解。对于这个问题，最简单的情况就是长度为1的绳子，虽然它不能切割，但我们可以将 <code>dp[1]</code> 设置为1，以便它能在状态转移方程中使用。</p>
<ol start="6">
<li><strong>确定遍历顺序</strong></li>
</ol>
<p>根据状态转移方程的依赖关系确定计算状态的顺序。通常情况下，你需要先计算出所有小问题的解，然后才能解决更大的问题。在本例中，你应该从小到大计算 <code>dp[i]</code>。</p>
<ol start="7">
<li><strong>实现并优化</strong></li>
</ol>
<p>将上述思路转化为代码。一旦完成基本实现，可以考虑是否有空间或时间优化的可能，比如通过避免不必要的计算来优化。</p>
<p>通过遵循这些步骤，即使对动态规划不太熟悉，你也可以逐步构建出解决复杂问题的DP解决方案。随着练习，你将能更快地识别和定义问题的DP结构。</p>
<br>
<p><strong>问</strong>：</p>
<p>是需要有一个逐步扩展的过程吗，就像i由2到n</p>
<p><strong>GPT4</strong>:</p>
<p>是的，动态规划（DP）的核心思想之一就是逐步构建解，从最小的子问题开始，逐渐扩展到整个问题的解。这个“逐步扩展”的过程通常体现在通过迭代计算从基本情况（通常是最小的子问题）开始，一直到目标问题大小的状态值。在绳子切割问题中，这正是通过逐渐增加绳子长度（即逐步扩展 <code>i</code> 从 2 到 <code>n</code>）来实现的。</p>
<p>这个过程背后的逻辑是：</p>
<ol>
<li>
<p><strong>基础情况</strong>：确定一些基础情况（最小的子问题），这些是直接可以知道答案的情况，比如在很多问题中，长度为 0 或 1 的情况。对于绳子切割问题，虽然 <code>dp[1]</code> 实际上不直接用于计算（因为至少要切一刀），但它帮助定义了DP数组的基础。</p>
</li>
<li>
<p><strong>状态转移</strong>：通过已解决的子问题来解决更大的问题。每次循环迭代，你考虑一个稍大一点的问题（即绳子的长度），并尝试基于已经计算出的较小问题的解来找到当前问题的解。这意味着每一步都建立在之前步骤的基础上。</p>
</li>
<li>
<p><strong>逐步扩展</strong>：从最基本的情况开始，逐步增加问题的规模，直到达到目标规模（<code>n</code>）。这个过程是通过外层循环实现的，<code>i</code> 从 2 到 <code>n</code> 的遍历就是这个“逐步扩展”的体现。</p>
</li>
<li>
<p><strong>利用之前的计算结果</strong>：在计算每一步时，都会利用之前计算的结果。这是动态规划节省时间的关键所在，避免了对同一子问题的重复计算。</p>
</li>
</ol>
<p>通过这种方式，动态规划确保了每个子问题只被解决一次，并且每次解决都是建立在之前已解决的子问题之上，最终达到解决整个问题的目的。这种方法不仅提高了效率，而且通过将问题分解为更易于管理的小块，也简化了复杂问题的解决方案。</p>
<br>
<p><strong>问</strong>：</p>
<p>为什么会设置这样一个dp数组</p>
<p><strong>GPT4</strong>：</p>
<p>选择构建一个动态规划（DP）数组是动态规划方法的核心部分，它出于以下几个关键原因：</p>
<ol>
<li><strong>存储中间结果</strong></li>
</ol>
<p>DP方法解决问题的方式是将问题分解成一系列重叠的子问题，然后解决每一个子问题。DP数组用于存储这些子问题的解，确保每个子问题只被计算一次。这样，当一个子问题在求解过程中多次遇到时，我们可以直接从DP数组中取得其结果，而不是重新计算。</p>
<ol start="2">
<li><strong>避免重复计算</strong></li>
</ol>
<p>许多优化问题涉及到大量的重叠子问题。如果不存储这些子问题的解，我们可能会重复解决相同的问题，导致算法的效率极低。DP数组通过记录每个子问题的解，帮助我们避免这种不必要的重复工作，从而显著提高算法的效率。</p>
<ol start="3">
<li><strong>实现状态转移</strong></li>
</ol>
<p>DP数组不仅仅是用来存储结果。它的结构和组织方式还能帮助我们以一种系统的方式实现状态转移。状态转移方程描述了从一个或多个较小子问题的解如何得到当前问题的解。DP数组使我们能够按照一定的顺序（通常是从小到大）计算并更新状态，确保在计算当前状态时，所有需要的前置状态都已经被计算并存储。</p>
<ol start="4">
<li><strong>简化问题解决方案</strong></li>
</ol>
<p>DP数组为我们提供了一种将复杂问题简化为易于管理的小块的方法。通过逐步填充DP数组，我们可以逐渐构建出问题的解决方案。这种方法有助于我们直观地理解问题的结构，以及不同子问题是如何组合在一起解决整个问题的。</p>
<ol start="5">
<li><strong>支持反向追踪解决方案</strong></li>
</ol>
<p>对于某些问题，仅仅知道最优解的值是不够的，我们还可能想知道如何达到这个最优解（例如，切割绳子的最佳方案是什么）。DP数组的结构使得在完成所有计算后，我们可以从最终状态开始反向追踪，找到构建这个最优解的每一步。</p>
<p>总而言之，构建DP数组是实现动态规划方法的基础，它不仅可以帮助我们以高效的方式存储和利用计算结果，而且也是理解和解决问题的关键组成部分。通过DP数组，我们能够将复杂问题分解成小问题，逐步构建解决方案，并最终以高效的方式解决整个问题。</p>
</div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">63. 股票的最大利润</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>要解决这个问题，我们可以采用一种称为“一次遍历”的方法。思路是遍历整个股价数组，记录并更新我们遇到的最低股价，以及在每一天卖出时可能得到的最大利润。我们只需要遍历一次数组，就可以找到买入和卖出的最佳时机，从而获得最大利润。</p>
<p>算法步骤如下：</p>
<ol>
<li>初始化两个变量：<code>minPrice</code>（到目前为止的最低股价）和 <code>maxProfit</code>（到目前为止的最大利润）。可以将 <code>minPrice</code> 初始化为正无穷大，<code>maxProfit</code> 初始化为0。</li>
<li>遍历价格数组 <code>prices</code>：
<ul>
<li>对于每一天的价格 <code>prices[i]</code>
<ul>
<li>更新 <code>minPrice</code> 为 <code>min(minPrice, prices[i])</code>，即当前价格和之前最低价格中的较小值。</li>
<li>更新 <code>maxProfit</code> 为 <code>max(maxProfit, prices[i] - minPrice)</code>，即当前价格与最低购买价格之差（如果这个差值大于之前的最大利润，就更新最大利润）。</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束后，<code>maxProfit</code> 将包含最大利润。如果没有利润可得，这个值将是0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minPrice = <span class="hljs-number">0x7ffffff</span>;<br>        <span class="hljs-type">int</span> MaxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : prices) &#123;<br>            minPrice = <span class="hljs-built_in">min</span>(minPrice, i);<br>            MaxProfit = <span class="hljs-built_in">max</span>(MaxProfit, i - minPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> MaxProfit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="二分查找">二分查找</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">11. 旋转数组的最小数字</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>注意：有重复数字</p>
<p>其他样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[1,0,1,1,1]<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 修改循环条件为left &lt; right</span><br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123; <span class="hljs-comment">// 如果中间元素小于右侧元素，最小值在左侧</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123; <span class="hljs-comment">// 如果中间元素大于右侧元素，最小值在右侧</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当中间元素等于右侧元素，无法判断最小值位置，右指针左移</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">53. 数字在排序数组中出现的次数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>法一：时间复杂度可能会退化为O(n);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 先二分，再左右找</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == k) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到k，跳出循环</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; k) left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 调整左边界</span><br>            <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 调整右边界</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] == k; i--, ans++);  <span class="hljs-comment">// 往左</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] == k; i++, ans++);  <span class="hljs-comment">// 往右</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>法二：二分找到左右两边的k就能直接知道数量</p>
<p>如果要使用两次二分查找来分别找到<code>k</code>第一次和最后一次出现的位置，进而计算出<code>k</code>在数组中出现的次数，你可以按照下面的方式实现。这种方法会确保整体的时间复杂度为<code>O(log n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 找到k第一次出现的位置</span><br>        <span class="hljs-type">int</span> first = <span class="hljs-built_in">findFirstK</span>(nums, k);<br>        <span class="hljs-comment">// 如果k不在数组中，则first返回-1，直接返回0</span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 找到k最后一次出现的位置</span><br>        <span class="hljs-type">int</span> last = <span class="hljs-built_in">findLastK</span>(nums, k);<br>        <span class="hljs-comment">// 返回k出现的次数，即last-first+1</span><br>        <span class="hljs-keyword">return</span> last - first + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirstK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; k) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; k) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] != k) &#123; <span class="hljs-comment">// 找到k的第一个位置</span><br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续在左半边搜索</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 没找到k</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLastK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; k) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; k) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] != k) &#123; <span class="hljs-comment">// 找到k的最后一个位置</span><br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续在右半边搜索</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 没找到k</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这段代码首先定义了<code>findFirstK</code>和<code>findLastK</code>两个函数来分别找到<code>k</code>第一次和最后一次出现的位置。这两个函数通过二分查找实现，区别仅在于在找到一个<code>k</code>后如何决定是返回当前位置还是继续查找。在<code>findFirstK</code>中，如果找到一个<code>k</code>且它是数组的第一个元素或其前一个元素不是<code>k</code>，那么它就是第一个<code>k</code>；在<code>findLastK</code>中，如果找到一个<code>k</code>且它是数组的最后一个元素或其后一个元素不是<code>k</code>，那么它就是最后一个<code>k</code>。这样，通过计算这两个位置的差值加一，就可以得到<code>k</code>在数组中出现的总次数。</p>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="分治">分治</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">16. 数值的整数次方</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-comment">// O(n)的直接乘就好，下面是时、空复杂度都是O(logn)的</span><br>        <span class="hljs-keyword">if</span> (base == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;<br>        <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/base;<br>        <span class="hljs-type">int</span> half = exponent / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">double</span> res = <span class="hljs-built_in">Power</span>(base, half);<br>        <span class="hljs-keyword">return</span> res * res * <span class="hljs-built_in">Power</span>(base, exponent % <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="搜索">搜索</h2>
<ul>
<li>
<p>12.矩阵中的路径 （牛客下架了，也没找到别的题）</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">13. 机器人的运动范围</a></p>
</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 是否访问过这个位置</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, visited, threshold, rows, cols);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 类似求连通分量</span><br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-type">int</span> dirX[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 上，左，下，右</span><br>    <span class="hljs-type">int</span> dirY[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;   <span class="hljs-comment">// 上，左，下，右</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> curX, <span class="hljs-type">int</span> curY, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited, <span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>        <span class="hljs-comment">// 当前点可走吗？走过了吗</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isLeThreshold</span>(threshold, curX, curY) || visited[curX][curY]) <span class="hljs-keyword">return</span>;<br>        visited[curX][curY] = <span class="hljs-literal">true</span>;<br>        cnt++;<br>        <span class="hljs-comment">// 找下一个点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nextX = curX + dirX[i];<br>            <span class="hljs-type">int</span> nextY = curY + dirY[i];<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isOver</span>(nextX, nextY, rows, cols)) &#123;<br>                <span class="hljs-built_in">dfs</span>(nextX, nextY, visited, threshold, rows, cols);<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-comment">// 是否越界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOver</span><span class="hljs-params">(<span class="hljs-type">int</span> curX, <span class="hljs-type">int</span> curY, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curX &gt; rows - <span class="hljs-number">1</span> || curX &lt; <span class="hljs-number">0</span> || curY &gt; cols - <span class="hljs-number">1</span> || curY &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否小于等于阈值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLeThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> curX, <span class="hljs-type">int</span> curY)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curX) &#123;<br>            sum += curX % <span class="hljs-number">10</span>;<br>            curX /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curY) &#123;<br>            sum += curY % <span class="hljs-number">10</span>;<br>            curY /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum &lt;= threshold) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">38. 字符串的排列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>其他样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&quot;qwertyuio&quot;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(str.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">dfs</span>(str, visited, ans, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;str, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited, vector&lt;string&gt; &amp;ans, string tmpStr, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth == str.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(tmpStr);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">// 用来处理aab这种样例</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 找到一个未选的走</span><br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span> &amp;&amp; cnt[str[i]] == <span class="hljs-number">0</span>) &#123;<br>                cnt[str[i]]++;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(str, visited, ans, tmpStr += str[i], depth + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 回退</span><br>                tmpStr.<span class="hljs-built_in">pop_back</span>();<br>                visited[i] = <span class="hljs-literal">false</span>; <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</div></details>
<hr>
<p><br><br><br></p>
<h2 id="排序">排序</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&amp;tqId=11166&amp;tab=answerKey&amp;from=cyc_github">21. 调整数组顺序使奇数位于偶数前面</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param array int整型vector </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            思路：类似冒泡排序，出现 偶奇 相邻的情况就交换二者的位置</span><br><span class="hljs-comment">            时空复杂度正好符合进阶的要求</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((array[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &amp;&amp; (array[j + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-built_in">swap</span>(array[j], array[j + <span class="hljs-number">1</span>]);<br>                    flag = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 提前终止</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">45. 把数组排成最小的数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>其他样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[39,397,6]<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面</span><br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), compare);<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) <br>            ans += <span class="hljs-built_in">to_string</span>(numbers[i]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        string str_a = <span class="hljs-built_in">to_string</span>(a);<br>        string str_b = <span class="hljs-built_in">to_string</span>(b);<br>        <span class="hljs-keyword">return</span> str_a + str_b &lt; str_b + str_a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">51. 数组中的逆序对</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>一点思路没有，问GPT了</p>
<p>GPT4：使用归并排序</p>
<p>通过一个具体的例子，比如数组 <code>[1, 20, 6, 4, 5]</code>，来模拟整个归并排序和计算逆序对的过程。</p>
<p>初始数组：<code>[1, 20, 6, 4, 5]</code></p>
<ol>
<li>
<p><strong>分割数组</strong>直到每个子数组只有一个元素，因为单个元素的数组自然是有序的，不需要比较。</p>
<ul>
<li>分割成 <code>[1, 20, 6]</code> 和 <code>[4, 5]</code></li>
<li>再分 <code>[1, 20, 6]</code> 为 <code>[1]</code> 和 <code>[20, 6]</code>；<code>[4, 5]</code> 已经是分不可分。</li>
<li><code>[20, 6]</code> 分为 <code>[20]</code> 和 <code>[6]</code>。</li>
</ul>
</li>
<li>
<p><strong>合并过程中计算逆序对</strong>：</p>
<ul>
<li>合并 <code>[20]</code> 和 <code>[6]</code>，得到 <code>[6, 20]</code>，这里有1个逆序对 <code>(20, 6)</code>。</li>
<li>接下来，我们合并 <code>[1]</code> 和 <code>[6, 20]</code>，得到 <code>[1, 6, 20]</code>，没有增加新的逆序对。</li>
<li>同时，<code>[4, 5]</code> 本身已经是有序的，无需计算。</li>
<li>最后，合并 <code>[1, 6, 20]</code> 和 <code>[4, 5]</code>，当我们将 <code>4</code> 插入到 <code>[1, 6, 20]</code> 中时，<code>4</code> 会和 <code>6, 20</code> 形成逆序对，共2个新的逆序对。当 <code>5</code> 被插入时，它也会与 <code>6, 20</code> 形成逆序对，再增加2个逆序对。</li>
</ul>
</li>
</ol>
<p>通过上述分解和合并的过程，我们可以详细追踪逆序对的形成：</p>
<ul>
<li>在合并 <code>[20]</code> 和 <code>[6]</code> 时形成1个逆序对。</li>
<li>在最后一步合并 <code>[1, 6, 20]</code> 和 <code>[4, 5]</code> 时，<code>4</code> 和 <code>5</code> 分别与 <code>[6, 20]</code> 形成2个和2个逆序对，共4个。</li>
</ul>
<p>所以，对于初始数组 <code>[1, 20, 6, 4, 5]</code>，总共有5个逆序对。</p>
<p>这个过程展示了如何通过分割数组直到它们变得足够小，然后在合并的过程中计算逆序对的数量，同时也保持了数组的有序性。归并排序不仅帮助我们排序，而且在合并过程中很自然地就计算出了逆序对的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>; <br>            <span class="hljs-built_in">mergeSort</span>(nums, left, mid);<br>            <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>            <span class="hljs-built_in">merge</span>(nums, left, mid, right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; numsLeft;<br>        vector&lt;<span class="hljs-type">int</span>&gt; numsRight;<br>        <span class="hljs-comment">// 复制为两个子数组，临时数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= mid; numsLeft.<span class="hljs-built_in">push_back</span>(nums[i]), i++);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; numsRight.<span class="hljs-built_in">push_back</span>(nums[i]), i++);<br>        <span class="hljs-type">int</span> indexL = <span class="hljs-number">0</span>, indexR = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-keyword">for</span> (; i &lt;= right &amp;&amp; indexL &lt; numsLeft.<span class="hljs-built_in">size</span>() &amp;&amp; indexR &lt; numsRight.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (numsLeft[indexL] &lt;= numsRight[indexR]) &#123;<br>                nums[i] = numsLeft[indexL];<br>                indexL++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                nums[i] = numsRight[indexR];<br>                cnt += numsLeft.<span class="hljs-built_in">size</span>() - indexL;    <span class="hljs-comment">// 计数</span><br>                cnt %= <span class="hljs-number">1000000007</span>;      <span class="hljs-comment">// 取模防止溢出</span><br>                indexR++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 剩下的直接放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = indexL; j &lt; numsLeft.<span class="hljs-built_in">size</span>(); nums[i++] = numsLeft[j], j++);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = indexR; j &lt; numsRight.<span class="hljs-built_in">size</span>(); nums[i++] = numsRight[j], j++);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<hr>
<p><br><br><br></p>
<h2 id="动态规划">动态规划</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">10.1 斐波那契数列</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> x1 = <span class="hljs-number">1</span>, x2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        n -= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (n--) &#123;<br>            sum = x1 + x2;<br>            x1 = x2;<br>            x2 = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">10.2 矩形覆盖</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(number+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= number; i++) &#123;<br>            <span class="hljs-comment">// 取下一块，取下两块</span><br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以明显看出来上面就是斐波那契数列，那我们可以将空间复杂度降为O(1)：</p>
<p>小小的区别就是，初值不一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> x1 = <span class="hljs-number">1</span>, x2 = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        number -= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (number--) &#123;<br>            sum = x1 + x2;<br>            x1 = x2;<br>            x2 = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">10.3 跳台阶</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>和前两题几乎一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param number int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> x1 = <span class="hljs-number">1</span>, x2 = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        number -= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (number--) &#123;<br>            sum = x1 + x2;<br>            x1 = x2;<br>            x2 = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">10.4 变态跳台阶</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>动态规划：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param number int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(number + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 至少都可以直接跳一次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                dp[i] += dp[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>进阶的要求</strong>：</p>
<p><strong>数学推导</strong></p>
<p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去…，那么</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1) = f(n-2) + f(n-3) + ... + f(0)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<p>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去… ，那么</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-2) + ... + f(0)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<p>综上可得</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) - f(n-1) = f(n-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>即</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = 2*f(n-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param number int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, number - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</div></details>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab">47. 礼物的最大价值</a></p>
</li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p><strong>样例 1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 6<br>200 300 400 500 600 700<br>800 900 100 200 300 400<br>500 600 700 800 900 1000<br>600 700 800 900 1000 200<br>700 800 900 1000 200 300<br>800 900 1000 200 300 400<br></code></pre></td></tr></table></figure>
<p>预期输出：<code>6800</code></p>
<p><strong>样例 2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 6<br>500 600 700 800 900 1000<br>400 500 600 700 800 900<br>300 400 500 600 700 800<br>200 300 400 500 600 700<br>100 200 300 400 500 600<br>100 200 300 400 500 600<br></code></pre></td></tr></table></figure>
<p>预期输出：<code>8100</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    思路：动态规划</span><br><span class="hljs-comment">    present[][]表示礼物数组</span><br><span class="hljs-comment">    dp[][]记录礼物最大值</span><br><span class="hljs-comment">    算法dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + present[i][j];</span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>    <span class="hljs-comment">// max()</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;present, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(cols, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + present[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; j - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) <br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + present[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> &amp;&amp; j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + present[i][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = present[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][cols - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows, cols;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;rows, &amp;cols);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">present</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(cols));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;present[i][j]);<br>    Solution solution;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, solution.<span class="hljs-built_in">getMost</span>(present, rows, cols));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 64 位输出请用 printf(\&quot;%lld\&quot;)</span><br></code></pre></td></tr></table></figure>
</div></details>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=265&amp;tqId=39289&amp;ru=/exam/oj">48. 最长不含重复字符的子字符串</a></p>
</li>
<li>
<p>[49. 丑数](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/49. 丑数.html)</p>
</li>
<li>
<p>[60. n 个骰子的点数](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/60. n 个骰子的点数.html)</p>
</li>
<li>
<p>[66. 构建乘积数组](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/66. 构建乘积数组.html)</p>
</li>
</ul>
<hr>
<p><br><br><br></p>
<h2 id="数学">数学</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">39.数组中出现次数超过一半的数字</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            思路：计数cnt，与当前字符相同++，不同-- </span><br><span class="hljs-comment">            但是这样只能找到一个候选的，因为有可能不存在超过半数的，但是这题保证有解了</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">struct</span> &#123;<br>            <span class="hljs-type">int</span> val;<br>            <span class="hljs-type">int</span> cnt;<br>        &#125; ans;<br>        ans.val = numbers[<span class="hljs-number">0</span>];<br>        ans.cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ans.val == numbers[i]) ans.cnt++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans.cnt--;<br>                <span class="hljs-keyword">if</span> (ans.cnt &lt; <span class="hljs-number">0</span>) &#123;<br>                    ans.val = numbers[i];<br>                    ans.cnt = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>
<p>[62. 圆圈中最后剩下的数](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/62. 圆圈中最后剩下的数.html)</p>
</li>
<li>
<p>[43. 从 1 到 n 整数中 1 出现的次数](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/43. 从 1 到 n 整数中 1 出现的次数.html)</p>
</li>
</ul>
<hr>
<p><br><br><br></p>
<h2 id="位运算">位运算</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">15. 二进制中 1 的个数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 根据题意，int 32bit的情况下</span><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++, n &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; tmp) == <span class="hljs-number">1</span>) cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>[56. 数组中只出现一次的数字](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/56. 数组中只出现一次的数字.html)</li>
</ul>
<hr>
<p><br><br><br></p>
<h2 id="其它">其它</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4436c93e568c48f6b28ff436173b997f?tpId=265&amp;tqId=39279&amp;ru=/exam/oj">17. 打印从 1 到最大的 n 位数</a></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>感觉这题和这个网站作者想要我们练习的不一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 最大位数</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        n = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ans.<span class="hljs-built_in">push_back</span>(i), i++);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>19.正则表达式匹配 （牛客下架了，也没找到别的题）</li>
<li>[20. 表示数值的字符串](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/20. 表示数值的字符串.html)</li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/29311ff7404d44e0b07077f4201418f5?tpId=265&amp;tqId=39335&amp;ru=/exam/oj">44. 数字序列中的某一位数字</a> <strong>需要用long long</strong></li>
</ul>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">查看代码 </summary><div class="toggle-content"><p>看题解析写的</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：通过对每个区间起点数字的计算，按照上述规律求得该区间的位数，n不断减去它前面区间的位数，定位到属于它的区间。</li>
<li>step 2：通过除以位数定位n在哪个数字上，用字符串形式表示。</li>
<li>step 3：通过在字符串上位置对几位数取模定位目标数字。</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://uploadfiles.nowcoder.com/images/20220422/397721558_1650627393558/4FA988E5F50C66C9E0EE0E4741810A38" alt="alt"></p>
<p>用例输入 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1000000000<br></code></pre></td></tr></table></figure>
<p>预期输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; little&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> little[n];<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> level = <span class="hljs-number">1</span>; <span class="hljs-comment">// 数位长度</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">9</span>; <span class="hljs-comment">// 当前数位长度下的数字总数</span><br>        <span class="hljs-comment">// 确定 n 所在的数字长度区间</span><br>        <span class="hljs-keyword">while</span> (n &gt; level * count) &#123;<br>            n -= level * count;<br>            level++;<br>            count *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> index = (n - <span class="hljs-number">1</span>) / level; <span class="hljs-comment">// 计算在当前长度区间的第几个数字</span><br>        <span class="hljs-type">int</span> offset = (n - <span class="hljs-number">1</span>) % level; <span class="hljs-comment">// 计算在该数字中的位置</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> start = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, level - <span class="hljs-number">1</span>); <span class="hljs-comment">// 当前长度区间的起始数字</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = start + index; <span class="hljs-comment">// 目标数字</span><br>        <br>        string numStr = <span class="hljs-built_in">to_string</span>(num);<br>        <span class="hljs-keyword">return</span> numStr[offset] - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 提取并返回正确的数字</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div></details>
<ul>
<li>[46. 把数字翻译成字符串](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/46. 把数字翻译成字符串.html)</li>
<li>[61. 扑克牌顺子](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/61. 扑克牌顺子.html)</li>
<li>[64. 求 1+2+3+…+n](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/64. 求 1+2+3+…+n.html)</li>
<li>[65. 不用加减乘除做加法](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/65. 不用加减乘除做加法.html)</li>
<li>[67. 把字符串转换成整数](<a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">https://www.cyc2018.xyz/算法/剑指</a> Offer 题解/67. 把字符串转换成整数.html)</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.com">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.com/posts/26732/">https://gxblogs.com/posts/26732/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.com" target="_blank">GXBLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-24_20-02-53.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/65115/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2024-03-28_23-36-48.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面经</div></div></a></div><div class="next-post pull-right"><a href="/posts/15764/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/blogs/Snipaste_2023-01-28_20-20-59.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ STL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/30eda4c1/" title="二叉树学习笔记"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">二叉树学习笔记</div></div></a></div><div><a href="/posts/26877/" title="代码随想录刷题代码"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ggw2021/images@main/leetcode/carl/Snipaste_2023-04-12_18-54-09.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">代码随想录刷题代码</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93"><span class="toc-text">错误总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5"><span class="toc-text">数组与矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86"><span class="toc-text">栈队列堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">贪心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-text">分治</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">其它</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>