<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>golang并发编程 | GXBLOGS</title><meta name="author" content="ggw &amp; xpl"><meta name="copyright" content="ggw &amp; xpl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘抄自极客时间课程 go并发编程实战课：https:&#x2F;&#x2F;b.geekbang.org&#x2F;member&#x2F;course&#x2F;intro&#x2F;100061801  检查程序的工具：  race detector vet工具   一、开篇词 学习 Go 并发编程，有哪些困难？ 那学习 Go 并发会有哪些困难呢？ 主要总结为 5 大问题。  在面对并发难题时，感觉无从下手，不知道该用什么并发原语来解决问题。 如果多个">
<meta property="og:type" content="article">
<meta property="og:title" content="golang并发编程">
<meta property="og:url" content="https://gxblogs.com/posts/1808/index.html">
<meta property="og:site_name" content="GXBLOGS">
<meta property="og:description" content="摘抄自极客时间课程 go并发编程实战课：https:&#x2F;&#x2F;b.geekbang.org&#x2F;member&#x2F;course&#x2F;intro&#x2F;100061801  检查程序的工具：  race detector vet工具   一、开篇词 学习 Go 并发编程，有哪些困难？ 那学习 Go 并发会有哪些困难呢？ 主要总结为 5 大问题。  在面对并发难题时，感觉无从下手，不知道该用什么并发原语来解决问题。 如果多个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-09-30_16-11-15.png">
<meta property="article:published_time" content="2024-10-08T07:30:34.227Z">
<meta property="article:modified_time" content="2025-06-09T17:21:45.834Z">
<meta property="article:author" content="ggw &amp; xpl">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-09-30_16-11-15.png"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://gxblogs.com/posts/1808/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: ggw & xpl","link":"链接: ","source":"来源: GXBLOGS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-10 01:21:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/ggwsettings.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/highlight/Kimbiedark.css"><script src="/css/else/echarts.min.js"></script><script src="/css/else/wow.min.js"></script><script type="text/javascript" src="/css/else/echarts-gl.min.js"></script><script src="/css/else/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="/static/imgs/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-09-30_16-11-15.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GXBLOGS</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">golang并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T07:30:34.227Z" title="发表于 2024-10-08 15:30:34">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-09T17:21:45.834Z" title="更新于 2025-06-10 01:21:45">2025-06-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">84.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>292分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/1808/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/1808/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>摘抄自极客时间课程</p>
<p>go并发编程实战课：<a target="_blank" rel="noopener" href="https://b.geekbang.org/member/course/intro/100061801">https://b.geekbang.org/member/course/intro/100061801</a></p>
<br>
<p>检查程序的工具：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/race-detector">race detector</a></li>
<li>vet工具</li>
</ul>
<p><br><br><br></p>
<h2 id="一、开篇词">一、开篇词</h2>
<p>学习 Go 并发编程，有哪些困难？ 那学习 Go 并发会有哪些困难呢？</p>
<p>主要总结为 5 大问题。</p>
<ol>
<li>在面对并发难题时，感觉无从下手，不知道该用什么并发原语来解决问题。</li>
<li>如果多个并发原语都可以解决问题，那么，究竟哪个是最优解呢？比如说是用互斥锁，还是用 Channel。</li>
<li>不知道如何编排并发任务。并发编程不像是传统的串行编程，程序的运行存在着很大的不确定性。这个时候，就会面临一个问题，怎么才能让相应的任务按照你设想的流程运行呢？</li>
<li>有时候，按照正常理解的并发方式去实现的程序，结果莫名其妙就 panic 或者死锁了，排查起来非常困难。</li>
<li>已知的并发原语都不能解决并发问题，程序写起来异常复杂，而且代码混乱，容易出错。</li>
</ol>
<br>
<p>怎么提升 Go 并发编程能力？</p>
<p>学习这件事儿，最怕的就是不成体系，即使知识点之间是彼此独立的，也必定存在着联系。我们要做的，就是找出逻辑关系，拎出知识线。关于 Go 并发编程，可以分为两条主线，分别是知识主线和学习主线。具体是啥意思呢？可以看下面的这张知识地图。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/81fa1cfd8d39632d871baeedf4081ce3.webp" alt=""></p>
<p>从图中可以看到，在知识主线层面，这门课程的核心内容设计了 5 个模块：</p>
<ol>
<li>基本并发原语：在这部分，将会介绍 Mutex、RWMutex、Waitgroup、Cond、Pool、Context 等标准库中的并发原语，这些都是传统的并发原语，在其它语言中也很常见，是我们在并发编程中常用的类型。</li>
<li>原子操作：在这部分，会介绍 Go 标准库中提供的原子操作。原子操作是其它并发原语的基础，学会了你就可以自己创造新的并发原语。</li>
<li>Channel：Channel 类型是 Go 语言独特的类型，因为比较新，所以难以掌握。但是别怕，本文会带你全方位地学习 Channel 类型，你不仅能掌握它的基本用法，而且还能掌握它的处理场景和应用模式，避免踩坑。</li>
<li>扩展并发原语：目前来看，Go 开发组不准备在标准库中扩充并发原语了，但是还有一些并发原语应用广泛，比如信号量、SingleFlight、循环栅栏、ErrGroup 等。掌握了它们，就可以在处理一些并发问题时，取得事半功倍的效果。</li>
<li>分布式并发原语：分布式并发原语是应对大规模的应用程序中并发问题的并发类型。本文主要会介绍使用 etcd 实现的一些分布式并发原语，比如 Leader 选举、分布式互斥锁、分布式读写锁、分布式队列等，在处理分布式场景的并发问题时，特别有用。</li>
</ol>
<hr>
<p><br><br><br></p>
<h2 id="二、基本并发原语">二、基本并发原语</h2>
<h3 id="2-1-Mutex-如何解决资源并发访问问题">2.1 Mutex: 如何解决资源并发访问问题</h3>
<blockquote>
<p>说起并发访问问题，真是太常见了，比如多个 goroutine 并发更新同一个资源，像计数器；同时更新用户的账户信息；秒杀系统；往同一个 buffer 中并发写入数据等等。如果没有互斥控制，就会出现一些异常情况，比如计数器的计数不准确、用户的账户可能出现透支、秒杀系统出现超卖、buffer 中的数据混乱，等等，后果都很严重。</p>
<p>这些问题怎么解决呢？对，用互斥锁，那在 Go 语言里，就是 Mutex。 这节课，将会详细了解互斥锁的实现机制，以及 Go 标准库的互斥锁 Mutex 的基本使用方法。在后面的 3 小节里，还会讲解 Mutex 的具体实现原理、易错场景和一些拓展用法。</p>
</blockquote>
<h4 id="2-1-1-互斥锁的实现机制">2.1.1 互斥锁的实现机制</h4>
<p>互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。在学习它的具体实现原理前，我们要先搞懂一个概念，就是<strong>临界区</strong>。</p>
<p>在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</p>
<p>可以说，临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用，等等。</p>
<p>如果很多线程同步访问临界区，就会造成访问或操作错误，这当然不是我们希望看到的结果。所以，我们可以<strong>使用互斥锁，限定临界区只能同时由一个线程持有</strong>。</p>
<p>当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/44c08abdd0aff633ca932fc89386ebb8.webp" alt=""></p>
<p>互斥锁就很好地解决了资源竞争问题，有人也把互斥锁叫做排它锁。那在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。</p>
<p>根据 2019 年第一篇全面分析 Go 并发 Bug 的论文<a target="_blank" rel="noopener" href="https://songlh.github.io/paper/go-study.pdf">Understanding Real-World Concurrency Bugs in Go</a>，<strong>Mutex 是使用最广泛的同步原语</strong>（Synchronization primitives，有人也叫做<strong>并发原语</strong>。我们在这个课程中根据英文直译优先用同步原语，但是并发原语的指代范围更大，还可以包括任务编排的类型，所以后面我们讲 Channel 或者扩展类型时也会用并发原语）。关于同步原语，并没有一个严格的定义，你可以把它看作解决并发问题的一个基础的数据结构。</p>
<br>
<p>在这门课的前两个模块，会讲互斥锁 Mutex、读写锁 RWMutex、并发编排 WaitGroup、条件变量 Cond、Channel 等同步原语。</p>
<p>所以，在这里，先说一下同步原语的适用场景。</p>
<ul>
<li>共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。</li>
<li>任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。</li>
<li>消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。</li>
</ul>
<hr>
<br>
<p><br><br></p>
<h4 id="2-1-2-Mutex-的基本使用方法">2.1.2 Mutex 的基本使用方法</h4>
<p>在正式看 Mutex 用法之前呢，先看一下：Locker 接口。</p>
<p>在 Go 的标准库中，<code>package sync</code> 提供了锁相关的一系列同步原语，这个 package 还定义了一个 Locker 的接口，Mutex 就实现了这个接口。</p>
<p>Locker 的接口定义了锁同步原语的方法集：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span> &#123;<br>    Lock()<br>    Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，Go 定义的锁接口的方法集很简单，就是请求锁（Lock）和释放锁（Unlock）这两个方法，秉承了 Go 语言一贯的简洁风格。</p>
<p>但是，这个接口在实际项目应用得不多，因为我们一般会直接使用具体的同步原语，而不是通过接口。</p>
<p>我们这一讲介绍的 Mutex 以及后面会介绍的读写锁 RWMutex 都实现了 Locker 接口，所以首先把这个接口介绍了，让大家做到心中有数。</p>
<br>
<p>下面我们直接看 Mutex。</p>
<p>简单来说，<strong>互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m *Mutex)</span></span>Lock()<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m *Mutex)</span></span>Unlock()<br></code></pre></td></tr></table></figure>
<p><strong>当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权</strong>。</p>
<br>
<p>不加锁的例子：</p>
<p>我们创建了 10 个 goroutine，同时不断地对一个变量（count）进行加 1 操作，每个 goroutine 负责执行 10 万次的加 1 操作，我们期望的最后计数的结果是 10 * 100000 = 1000000 (一百万)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 使用WaitGroup等待10个goroutine完成</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-comment">// 对变量count执行10次加1</span><br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++ &#123;<br>                count++<br>            &#125;<br>        &#125;()<br>    &#125;<br>    <span class="hljs-comment">// 等待10个goroutine完成</span><br>    wg.Wait()<br>    fmt.Println(count)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这段代码中，我们使用 sync.WaitGroup 来等待所有的 goroutine 执行完毕后，再输出最终的结果。sync.WaitGroup 这个同步原语会在后面的课程中具体介绍，现在只需要知道，我们使用它来控制等待一组 goroutine 全部做完任务。</p>
<p>但是，每次运行，你都可能得到不同的结果，基本上不会得到理想中的一百万的结果。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/6080fdf493e047917aa099ea33279de2.webp" alt=""></p>
<br>
<p>这是为什么呢？</p>
<p>其实，这是因为，count++ 不是一个原子操作，它至少包含几个步骤，比如读取变量 count 的当前值，对这个值加 1，把结果再保存到 count 中。因为不是原子操作，就可能有并发的问题。</p>
<p>比如，10 个 goroutine 同时读取到 count 的值为 9527，接着各自按照自己的逻辑加 1，值变成了 9528，然后把这个结果再写回到 count 变量。但是，实际上，此时我们增加的总数应该是 10 才对，这里却只增加了 1，好多计数都被“吞”掉了。这是并发访问共享数据的常见错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// count++操作的汇编代码</span><br>MOVQ    <span class="hljs-string">&quot;&quot;</span>.count(SB), AX<br>LEAQ    <span class="hljs-number">1</span>(AX), CX<br>MOVQ    CX, <span class="hljs-string">&quot;&quot;</span>.count(SB)<br></code></pre></td></tr></table></figure>
<p>这个问题，有经验的开发人员还是比较容易发现的，但是，很多时候，并发问题隐藏得非常深，即使是有经验的人，也不太容易发现或者 Debug 出来。</p>
<br>
<p>针对这个问题，Go 提供了一个检测并发访问共享资源是否有问题的工具： <a target="_blank" rel="noopener" href="https://go.dev/blog/race-detector">race detector</a>，它可以帮助我们自动发现程序有没有 data race 的问题。</p>
<p>Go race detector 是基于 Google 的 C/C++ <a target="_blank" rel="noopener" href="https://github.com/google/sanitizers">sanitizers</a> 技术实现的，编译器通过探测所有的内存访问，加入代码能监视对这些内存地址的访问（读还是写）。在代码运行的时候，race detector 就能监控到对共享变量的非同步访问，出现 race 的时候，就会打印出警告信息。</p>
<p>我们来看看这个工具怎么用。 在编译（compile）、测试（test）或者运行（run）Go 代码的时候，加上 race 参数，就有可能发现并发问题。比如在上面的例子中，我们可以加上 race 参数运行，检测一下是不是有并发问题。如果你 <code>go run -race counter.go</code>，就会输出警告信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">go run -race counter.go<br>==================<br>WARNING: DATA RACE<br>Read at 0x00c00010a038 by goroutine 14:<br>  main.main.func1()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:18 +0x94<br><br>Previous write at 0x00c00010a038 by goroutine 6:<br>  main.main.func1()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:18 +0xa4<br><br>Goroutine 14 (running) created at:<br>  main.main()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:14 +0x74<br><br>Goroutine 6 (running) created at:<br>  main.main()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:14 +0x74<br>==================<br>==================<br>WARNING: DATA RACE<br>Write at 0x00c00010a038 by goroutine 14:<br>  main.main.func1()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:18 +0xa4<br><br>Previous write at 0x00c00010a038 by goroutine 6:<br>  main.main.func1()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:18 +0xa4<br><br>Goroutine 14 (running) created at:<br>  main.main()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:14 +0x74<br><br>Goroutine 6 (running) created at:<br>  main.main()<br>      /Users/guowei.gong/Documents/workspace/projects/learning/demo/counter.go:14 +0x74<br>==================<br>919480<br>Found 2 data race(s)<br>exit status 66<br>make: *** [run_race] Error 1<br><br>Process finished with exit code 2<br><br></code></pre></td></tr></table></figure>
<p>这个警告不但会告诉你有并发问题，而且还会告诉你哪个 goroutine 在哪一行对哪个变量有写操作，同时，哪个 goroutine 在哪一行对哪个变量有读操作，就是这些并发的读写访问，引起了 data race。</p>
<p>例子中的 goroutine 10 对内存地址 0x00c000126010 有读的操作（counter.go 文件第 16 行），同时，goroutine 7 对内存地址 0x00c000126010 有写的操作（counter.go 文件第 16 行）。而且还可能有多个 goroutine 在同时进行读写，所以，警告信息可能会很长。</p>
<p>虽然这个工具使用起来很方便，但是，因为它的实现方式，只能通过真正对实际地址进行读写访问的时候才能探测，所以它并不能在编译的时候发现 data race 的问题。而且，在运行的时候，只有在触发了 data race 之后，才能检测到，如果碰巧没有触发（比如一个 data race 问题只能在 2 月 14 号零点或者 11 月 11 号零点才出现），是检测不出来的。</p>
<p>而且，把开启了 race 的程序部署在线上，还是比较影响性能的。运行 go tool compile -race -S counter.go，可以查看计数器例子的代码，重点关注一下 count++ 前后的编译后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x002a 00042 (counter.go:13)    CALL    runtime.racefuncenter(SB)<br>......<br>0x0061 00097 (counter.go:14)    JMP     173<br>0x0063 00099 (counter.go:15)    MOVQ    AX, &quot;&quot;.j+8(SP)<br>0x0068 00104 (counter.go:16)    PCDATA  $0, $1<br>0x0068 00104 (counter.go:16)    MOVQ    &quot;&quot;.&amp;count+128(SP), AX<br>0x0070 00112 (counter.go:16)    PCDATA  $0, $0<br>0x0070 00112 (counter.go:16)    MOVQ    AX, (SP)<br>0x0074 00116 (counter.go:16)    CALL    runtime.raceread(SB)<br>0x0079 00121 (counter.go:16)    PCDATA  $0, $1<br>0x0079 00121 (counter.go:16)    MOVQ    &quot;&quot;.&amp;count+128(SP), AX<br>0x0081 00129 (counter.go:16)    MOVQ    (AX), CX<br>0x0084 00132 (counter.go:16)    MOVQ    CX, &quot;&quot;..autotmp_8+16(SP)<br>0x0089 00137 (counter.go:16)    PCDATA  $0, $0<br>0x0089 00137 (counter.go:16)    MOVQ    AX, (SP)<br>0x008d 00141 (counter.go:16)    CALL    runtime.racewrite(SB)<br>0x0092 00146 (counter.go:16)    MOVQ    &quot;&quot;..autotmp_8+16(SP), AX<br>......<br>0x00b6 00182 (counter.go:18)    CALL    runtime.deferreturn(SB)<br>0x00bb 00187 (counter.go:18)    CALL    runtime.racefuncexit(SB)<br>0x00c0 00192 (counter.go:18)    MOVQ    104(SP), BP<br>0x00c5 00197 (counter.go:18)    ADDQ    $112, SP<br></code></pre></td></tr></table></figure>
<p>在编译的代码中，增加了 runtime.racefuncenter、runtime.raceread、runtime.racewrite、runtime.racefuncexit 等检测 data race 的方法。通过这些插入的指令，Go race detector 工具就能够成功地检测出 data race 问题了。</p>
<p>总结一下，通过在编译的时候插入一些指令，在运行时通过这些插入的指令检测并发读写从而发现 data race 问题，就是这个工具的实现机制。</p>
<br>
<p>既然这个例子存在 data race 问题，我们就要想办法来解决它。这个时候，我们这节课的主角 Mutex 就要登场了，它可以轻松地消除掉 data race。 具体怎么做呢？下面，就结合这个例子，来具体讲一讲 Mutex 的基本用法。</p>
<p>我们知道，这里的共享资源是 count 变量，临界区是 count++，只要在临界区前面获取锁，在离开临界区的时候释放锁，就能完美地解决 data race 的问题了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 互斥锁保护计数器</span><br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    <span class="hljs-comment">// 计数器的值</span><br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 辅助变量，用来确认所有的goroutine都完成</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 启动10个gourontine</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-comment">// 累加10万次</span><br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++ &#123;<br>                mu.Lock()<br>                count++<br>                mu.Unlock()<br>            &#125;<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(count)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你再运行一下程序，就会发现，data race 警告没有了，系统干脆地输出了 1000000</p>
<p>这里有一点需要注意：Mutex 的零值是还没有 goroutine 等待的未加锁的状态，所以你不需要额外的初始化，直接声明变量（如 var mu sync.Mutex）即可。</p>
<br>
<p>那 Mutex 还有哪些用法呢？</p>
<p>很多情况下，Mutex 会嵌入到其它 struct 中使用，比如下面的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mu    sync.Mutex<br>    Count <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在初始化嵌入的 struct 时，也不必初始化这个 Mutex 字段，不会因为没有初始化出现空指针或者是无法获取到锁的情况。</p>
<p>有时候，我们还可以<strong>采用嵌入字段</strong>的方式。通过嵌入字段，你可以在这个 struct 上直接调用 Lock/Unlock 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> counter Counter<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++ &#123;<br>                counter.Lock()<br>                counter.Count++<br>                counter.Unlock()<br>            &#125;<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(counter.Count)<br>&#125;<br><br><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    Count <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>如果嵌入的 struct 有多个字段，我们一般会把 Mutex 放在要控制的字段上面，然后使用空格把字段分隔开来</strong>。</p>
<p>即使你不这样做，代码也可以正常编译，只不过，用这种风格去写的话，逻辑会更清晰，也更易于维护。</p>
<p>甚至，你还可以把获取锁、释放锁、计数加一的逻辑封装成一个方法，对外不需要暴露锁等逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 封装好的计数器</span><br>    <span class="hljs-keyword">var</span> counter Counter<br><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 启动10个goroutine</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            <span class="hljs-comment">// 执行10万次累加</span><br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++ &#123;<br>                counter.Incr() <span class="hljs-comment">// 受到锁保护的方法</span><br>            &#125;<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(counter.Count())<br>&#125;<br><br><span class="hljs-comment">// 线程安全的计数器类型</span><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    CounterType <span class="hljs-type">int</span><br>    Name        <span class="hljs-type">string</span><br><br>    mu    sync.Mutex<br>    count <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 加1的方法，内部使用互斥锁保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Incr() &#123;<br>    c.mu.Lock()<br>    c.count++<br>    c.mu.Unlock()<br>&#125;<br><br><span class="hljs-comment">// 得到计数器的值，也需要锁保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Count() <span class="hljs-type">uint64</span> &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    <span class="hljs-keyword">return</span> c.count<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p>在项目开发的初始阶段，我们可能并没有仔细地考虑资源的并发问题，因为在初始阶段，我们还不确定这个资源是否被共享。经过更加深入的设计，或者新功能的增加、代码的完善，这个时候，我们就需要考虑共享资源的并发问题了。</p>
<p>当然，如果你能在初始阶段预见到资源会被共享并发访问就更好了。 意识到共享资源的并发访问的早晚不重要，重要的是，一旦你意识到这个问题，你就要及时通过互斥锁等手段去解决。 比如 Docker issue <a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/37583">37583</a>、<a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/35517">35517</a>、<a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/32826">32826</a>、<a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/30696">30696</a>等、kubernetes issue <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/72361">72361</a>、<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/71617">71617</a>等，都是后来发现的 data race 而采用互斥锁 Mutex 进行修复的。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-2-Mutex：庖丁解牛看实现">2.2 Mutex：庖丁解牛看实现</h3>
<p>本节把 Mutex 的架构演进分成了四个阶段，下面给你画了一张图来说明。</p>
<p>“初版”的 Mutex 使用一个 flag 来表示锁是否被持有，实现比较简单；后来照顾到新来的 goroutine，所以会让新的 goroutine 也尽可能地先获取到锁，这是第二个阶段，我们把它叫作“给新人机会”；那么，接下来就是第三阶段“多给些机会”，照顾新来的和被唤醒的 goroutine；但是这样会带来饥饿问题，所以目前又加入了饥饿的解决方案，也就是第四阶段“解决饥饿”。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/c28531b47ff7f220d5bc3c9650180835.webp" alt=""></p>
<hr>
<br>
<p><br><br></p>
<h4 id="2-2-1-初版的互斥锁">2.2.1 初版的互斥锁</h4>
<p>我们先来看怎么实现一个最简单的互斥锁。在开始之前，你可以先想一想，如果是你，你会怎么设计呢？</p>
<p>你可能会想到，可以通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 flag 的值是 1，就代表锁已经被持有，那么，其它竞争的 goroutine 只能等待；如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。</p>
<p>实际上，Russ Cox 在 2008 年提交的第一版 Mutex 就是这样实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CAS操作，当时还没有抽象出atomic包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cas</span><span class="hljs-params">(val *<span class="hljs-type">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">semacquire</span><span class="hljs-params">(*<span class="hljs-type">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">semrelease</span><span class="hljs-params">(*<span class="hljs-type">int32</span>)</span></span><br><span class="hljs-comment">// 互斥锁的结构，包含两个字段</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    key  <span class="hljs-type">int32</span> <span class="hljs-comment">// 锁是否被持有的标识</span><br>    sema <span class="hljs-type">int32</span> <span class="hljs-comment">// 信号量专用，用以阻塞/唤醒goroutine</span><br>&#125;<br><br><span class="hljs-comment">// 保证成功在val上增加delta的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">xadd</span><span class="hljs-params">(val *<span class="hljs-type">int32</span>, delta <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        v := *val<br>        <span class="hljs-keyword">if</span> cas(val, v, v+delta) &#123;<br>            <span class="hljs-keyword">return</span> v + delta<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreached&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 请求锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-keyword">if</span> xadd(&amp;m.key, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//标识加1，如果等于1，成功获取到锁</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    semacquire(&amp;m.sema) <span class="hljs-comment">// 否则阻塞等待</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-keyword">if</span> xadd(&amp;m.key, <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 将标识减去1，如果等于0，则没有其它等待者</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    semrelease(&amp;m.sema) <span class="hljs-comment">// 唤醒其它阻塞的goroutine</span><br>&#125;    <br></code></pre></td></tr></table></figure>
<p>这里呢，先简单补充介绍下刚刚提到的 CAS。</p>
<p>CAS 指令<strong>将给定的值和一个内存地址中的值进行比较</strong>，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。那啥是原子性呢？如果你还不太理解这个概念，那么在这里只需要明确一点就行了，那就是<strong>原子性保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS 会返回失败</strong>。</p>
<p>CAS 是实现互斥锁和同步原语的基础，我们很有必要掌握它。</p>
<p>好了，我们继续来分析下刚才的这段代码。</p>
<p>虽然当时的 Go 语法和现在的稍微有些不同，而且标准库的布局、实现和现在的也有很大的差异，但是，这些差异不会影响我们对代码的理解，因为最核心的结构体（struct）和函数、方法的定义几乎是一样的。</p>
<p>Mutex 结构体包含两个字段：</p>
<ul>
<li>字段 key：是一个 flag，用来标识这个排外锁是否被某个 goroutine 所持有，如果 key 大于等于 1，说明这个排外锁已经被持有；</li>
<li>字段 sema：是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒。</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/825e23e1af96e78f3773e0b45de38e25.webp" alt=""></p>
<p>调用 Lock 请求锁的时候，通过 xadd 方法进行 CAS 操作（第 24 行），xadd 方法通过循环执行 CAS 操作直到成功，保证对 key 加 1 的操作成功完成。如果比较幸运，锁没有被别的 goroutine 持有，那么，Lock 方法成功地将 key 设置为 1，这个 goroutine 就持有了这个锁；如果锁已经被别的 goroutine 持有了，那么，当前的 goroutine 会把 key 加 1，而且还会调用 semacquire 方法（第 27 行），使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。</p>
<p>持有锁的 goroutine 调用 Unlock 释放锁时，它会将 key 减 1（第 31 行）。如果当前没有其它等待这个锁的 goroutine，这个方法就返回了。但是，如果还有等待此锁的其它 goroutine，那么，它会调用 semrelease 方法（第 34 行），利用信号量唤醒等待锁的其它 goroutine 中的一个。</p>
<p>所以，到这里，我们就知道了，初版的 Mutex 利用 CAS 原子操作，对 key 这个标志量进行设置。key 不仅仅标识了锁是否被 goroutine 所持有，还记录了当前持有和等待获取锁的 goroutine 的数量。</p>
<p>Mutex 的整体设计非常简洁，学习起来一点也没有障碍。但是，注意，要划重点了。</p>
<p><strong>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。</strong></p>
<p>这就带来了一个有趣而危险的功能。为什么这么说呢？</p>
<p>你看，其它 goroutine 可以强制释放锁，这是一个非常危险的操作，因为在临界区的 goroutine 可能不知道锁已经被释放了，还会继续执行临界区的业务操作，这可能会带来意想不到的结果，因为这个 goroutine 还以为自己持有锁呢，有可能导致 data race 问题。</p>
<p>所以，我们在使用 Mutex 的时候，必须要保证 goroutine 尽可能不去释放自己未持有的锁，一定要遵循“谁申请，谁释放”的原则。在真实的实践中，我们使用互斥锁的时候，很少在一个方法中单独申请锁，而在另外一个方法中单独释放锁，一般都会在同一个方法中获取锁和释放锁。</p>
<p>如果你接触过其它语言（比如 Java 语言）的互斥锁的实现，就会发现这一点和其它语言的互斥锁不同，所以，如果是从其它语言转到 Go 语言开发的同学，一定要注意。</p>
<p>以前，我们经常会基于性能的考虑，及时释放掉锁，所以在一些 if-else 分支中加上释放锁的代码，代码看起来很臃肿。而且，在重构的时候，也很容易因为误删或者是漏掉而出现死锁的现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>    mu    sync.Mutex<br>    count <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Bar() &#123;<br>    f.mu.Lock()<br><br>    <span class="hljs-keyword">if</span> f.count &lt; <span class="hljs-number">1000</span> &#123;<br>        f.count += <span class="hljs-number">3</span><br>        f.mu.Unlock() <span class="hljs-comment">// 此处释放锁</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    f.count++<br>    f.mu.Unlock() <span class="hljs-comment">// 此处释放锁</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>从 1.14 版本起，Go 对 defer 做了优化，采用更有效的内联方式，取代之前的生成 defer 对象到 defer chain 中，defer 对耗时的影响微乎其微了，所以基本上修改成下面简洁的写法也没问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Bar() &#123;<br>    f.mu.Lock()<br>    <span class="hljs-keyword">defer</span> f.mu.Unlock()<br><br><br>    <span class="hljs-keyword">if</span> f.count &lt; <span class="hljs-number">1000</span> &#123;<br>        f.count += <span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br><br>    f.count++<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样做的好处就是 Lock/Unlock 总是成对紧凑出现，不会遗漏或者多调用，代码更少。</p>
<p>但是，如果临界区只是方法中的一部分，为了尽快释放锁，还是应该第一时间调用 Unlock，而不是一直等到方法返回时才释放。</p>
<p>初版的 Mutex 实现之后，Go 开发组又对 Mutex 做了一些微调，比如把字段类型变成了 uint32 类型；调用 Unlock 方法会做检查；使用 atomic 包的同步原语执行原子操作等等，这些小的改动，都不是核心功能，你简单知道就行了，就不详细介绍了。</p>
<p>但是，初版的 Mutex 实现有一个问题：请求锁的 goroutine 会排队等待获取互斥锁。虽然这貌似很公平，但是从性能上来看，却不是最优的。因为如果我们能够把锁交给正在占用 CPU 时间片的 goroutine 的话，那就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。</p>
<p>接下来，我们就继续探索 Go 开发者是怎么解决这个问题的。</p>
<hr>
<p><br><br><br></p>
<h4 id="2-2-2-给新人机会">2.2.2 给新人机会</h4>
<p>Go 开发者在 2011 年 6 月 30 日的 commit 中对 Mutex 做了一次大的调整，调整后的 Mutex 实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    state <span class="hljs-type">int32</span><br>    sema  <span class="hljs-type">uint32</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span><br>    mutexWoken<br>    mutexWaiterShift = <span class="hljs-literal">iota</span><br>)<br></code></pre></td></tr></table></figure>
<p>虽然 Mutex 结构体还是包含两个字段，但是第一个字段已经改成了 state，它的含义也不一样了。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/4c4a3dd2310059821f41af7b84925615.webp" alt=""></p>
<p>state 是一个复合型的字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。所以，state 这一个字段被分成了三部分，代表三个数据。</p>
<p>请求锁的方法 Lock 也变得复杂了。复杂之处不仅仅在于对字段 state 的操作难以理解，而且代码逻辑也变得相当复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// Fast path: 幸运case，能够直接获取到锁</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    awoke := <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        old := m.state<br>        <span class="hljs-built_in">new</span> := old | mutexLocked <span class="hljs-comment">// 新状态加锁</span><br>        <span class="hljs-keyword">if</span> old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> = old + <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift <span class="hljs-comment">//等待者数量加一</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> awoke &#123;<br>            <span class="hljs-comment">// goroutine是被唤醒的，</span><br>            <span class="hljs-comment">// 新状态清除唤醒标志</span><br>            <span class="hljs-built_in">new</span> &amp;^= mutexWoken<br>        &#125;<br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<span class="hljs-comment">//设置新状态</span><br>            <span class="hljs-keyword">if</span> old&amp;mutexLocked == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 锁原状态未加锁</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            runtime.Semacquire(&amp;m.sema) <span class="hljs-comment">// 请求信号量</span><br>            awoke = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先是通过 CAS 检测 state 字段中的标志（第 3 行），如果没有 goroutine 持有锁，也没有等待持有锁的 gorutine，那么，当前的 goroutine 就很幸运，可以直接获得锁，这也是注释中的 Fast path 的意思。</p>
<p>如果不够幸运，state 不是零值，那么就通过一个循环进行检查。接下来的第 7 行到第 26 行这段代码虽然只有几行，但是理解起来却要费一番功夫，因为涉及到对 state 不同标志位的操作。这里的位操作以及操作后的结果和数值比较，并没有明确的解释，有时候你需要根据后续的处理进行推断。所以说，如果你充分理解了这段代码，那么对最新版的 Mutex 也会比较容易掌握了，因为你已经清楚了这些位操作的含义。</p>
<p>我们先前知道，如果想要获取锁的 goroutine 没有机会获取到锁，就会进行休眠，但是在锁释放唤醒之后，它并不能像先前一样直接获取到锁，还是要和正在请求锁的 goroutine 进行竞争。这会给后来请求锁的 goroutine 一个机会，也让 CPU 中正在执行的 goroutine 有更多的机会获取到锁，在一定程度上提高了程序的性能。</p>
<p>for 循环是不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&amp;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。</p>
<p>代码中的第 10 行将当前的 flag 设置为加锁状态，如果能成功地通过 CAS 把这个新值赋予 state（第 19 行和第 20 行），就代表抢夺锁的操作成功了。</p>
<p>不过，需要注意的是，如果成功地设置了 state 的值，但是之前的 state 是有锁的状态，那么，state 只是清除 mutexWoken 标志或者增加一个 waiter 而已。</p>
<p>请求锁的 goroutine 有两类，一类是新来请求锁的 goroutine，另一类是被唤醒的等待请求锁的 goroutine。锁的状态也有两种：加锁和未加锁。用一张表格，来说明一下 goroutine 不同来源不同状态下的处理逻辑。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/de281d2a9e022b2e026bb6126f28c9ac.webp" alt=""></p>
<br>
<p>刚刚说的都是获取锁，接下来，我们再来看看释放锁。释放锁的 Unlock 方法也有些复杂，我们来看一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-comment">// Fast path: drop lock bit.</span><br>    <span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="hljs-comment">//去掉锁标志</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//本来就没有加锁</span><br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>    &#125;<br><br>    old := <span class="hljs-built_in">new</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="hljs-comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span><br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>            runtime.Semrelease(&amp;m.sema)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        old = m.state<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面来解释一下这个方法。</p>
<p>第 3 行是尝试将持有锁的标识设置为未加锁的状态，这是通过减 1 而不是将标志位置零的方式实现。第 4 到 6 行还会检测原来锁的状态是否已经未加锁的状态，如果是 Unlock 一个未加锁的 Mutex 会直接 panic。</p>
<p>不过，即使将加锁置为未加锁的状态，这个方法也不能直接返回，还需要一些额外的操作，因为还可能有一些等待这个锁的 goroutine（有时候本文也把它们称之为 waiter）需要通过信号量的方式唤醒它们中的一个。所以接下来的逻辑有两种情况。</p>
<p>第一种情况，如果没有其它的 waiter，说明对这个锁的竞争的 goroutine 只有一个，那就可以直接返回了；如果这个时候有唤醒的 goroutine，或者是又被别人加了锁，那么，无需我们操劳，其它 goroutine 自己干得都很好，当前的这个 goroutine 就可以放心返回了。</p>
<p>第二种情况，如果有等待者，并且没有唤醒的 waiter，那就需要唤醒一个等待的 waiter。在唤醒之前，需要将 waiter 数量减 1，并且将 mutexWoken 标志设置上，这样，Unlock 就可以返回了。</p>
<p>通过这样复杂的检查、判断和设置，我们就可以安全地将一把互斥锁释放了。</p>
<p>相对于初版的设计，这次的改动主要就是，新来的 goroutine 也有机会先获取到锁，甚至一个 goroutine 可能连续获取到锁，打破了先来先得的逻辑。但是，代码复杂度也显而易见。</p>
<p>虽然这一版的 Mutex 已经给新来请求锁的 goroutine 一些机会，让它参与竞争，没有空闲的锁或者竞争失败才加入到等待队列中。但是其实还可以进一步优化。我们接着往下看。</p>
<hr>
<p><br><br><br></p>
<h4 id="2-2-3-多给些机会">2.2.3 多给些机会</h4>
<p>在 2015 年 2 月的改动中，如果新来的 goroutine 或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋（spin，通过循环不断尝试，spin 的逻辑是在<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580">runtime</a> 实现的）的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// Fast path: 幸运之路，正好获取到锁</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    awoke := <span class="hljs-literal">false</span><br>    iter := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span><br>        old := m.state <span class="hljs-comment">// 先保存当前锁的状态</span><br>        <span class="hljs-built_in">new</span> := old | mutexLocked <span class="hljs-comment">// 新状态设置加锁标志</span><br>        <span class="hljs-keyword">if</span> old&amp;mutexLocked != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 锁还没被释放</span><br>            <span class="hljs-keyword">if</span> runtime_canSpin(iter) &#123; <span class="hljs-comment">// 还可以自旋</span><br>                <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>                    awoke = <span class="hljs-literal">true</span><br>                &#125;<br>                runtime_doSpin()<br>                iter++<br>                <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 自旋，再次尝试请求锁</span><br>            &#125;<br>            <span class="hljs-built_in">new</span> = old + <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift<br>        &#125;<br>        <span class="hljs-keyword">if</span> awoke &#123; <span class="hljs-comment">// 唤醒状态</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>            &#125;<br>            <span class="hljs-built_in">new</span> &amp;^= mutexWoken <span class="hljs-comment">// 新状态清除唤醒标记</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>            <span class="hljs-keyword">if</span> old&amp;mutexLocked == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            runtime_Semacquire(&amp;m.sema) <span class="hljs-comment">// 阻塞等待</span><br>            awoke = <span class="hljs-literal">true</span> <span class="hljs-comment">// 被唤醒</span><br>            iter = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这次的优化，增加了第 13 行到 21 行、第 25 行到第 27 行以及第 36 行。现在来解释一下主要的逻辑，也就是第 13 行到 21 行。</p>
<p>如果可以 spin 的话，第 9 行的 for 循环会重新检查锁是否释放。对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，直接 spin 几次，可能就获得了锁。</p>
<hr>
<p><br><br><br></p>
<h4 id="2-2-4-解决饥饿">2.2.4 解决饥饿</h4>
<p>经过几次优化，Mutex 的代码越来越复杂，应对高并发争抢锁的场景也更加公平。但是你有没有想过，因为新来的 goroutine 也参与竞争，有可能每次都会被新来的 goroutine 抢到获取锁的机会，在极端情况下，等待中的 goroutine 可能会一直获取不到锁，这就是饥饿问题。</p>
<p>先前版本的 Mutex 遇到的也是同样的困境，“悲惨”的 goroutine 总是得不到锁。</p>
<p>Mutex 不能容忍这种事情发生。所以，2016 年 Go 1.9 中 Mutex 增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在 1 毫秒，并且修复了一个大 Bug：总是把唤醒的 goroutine 放在等待队列的尾部，会导致更加不公平的等待时间。</p>
<p>之后，2018 年，Go 开发者将 fast path 和 slow path 拆成独立的方法，以便内联，提高性能。2019 年也有一个 Mutex 的优化，虽然没有对 Mutex 做修改，但是，对于 Mutex 唤醒后持有锁的那个 waiter，调度器可以有更高的优先级去执行，这已经是很细致的性能优化了。</p>
<p>为了避免代码过多，这里只列出当前的 Mutex 实现。想要理解当前的 Mutex，我们需要好好泡一杯茶，仔细地品一品了。</p>
<p>当然，现在的 Mutex 代码已经复杂得接近不可读的状态了，而且代码也非常长，删减后占了几乎三页纸。但是，作为第一个要详细介绍的同步原语，本文还是希望能更清楚地剖析 Mutex 的实现，向你展示它的演化和为了一个貌似很小的 feature 不得不将代码变得非常复杂的原因。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/e0c23794c8a1d355a7a183400c036276.webp" alt=""></p>
<p>当然，你也可以暂时略过这一段，以后慢慢品，<strong>只需要记住，Mutex 绝不容忍一个 goroutine 被落下，永远没有机会获取锁。不抛弃不放弃是它的宗旨，而且它也尽可能地让等待较长的 goroutine 更有机会获取到锁</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    state <span class="hljs-type">int32</span><br>    sema  <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span><br>    mutexWoken<br>    mutexStarving <span class="hljs-comment">// 从state字段中分出一个饥饿标记</span><br>    mutexWaiterShift = <span class="hljs-literal">iota</span><br><br>    starvationThresholdNs = <span class="hljs-number">1e6</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// Fast path: 幸运之路，一下就获取到了锁</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span><br>    m.lockSlow()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> lockSlow() &#123;<br>    <span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span><br>    starving := <span class="hljs-literal">false</span> <span class="hljs-comment">// 此goroutine的饥饿标记</span><br>    awoke := <span class="hljs-literal">false</span> <span class="hljs-comment">// 唤醒标记</span><br>    iter := <span class="hljs-number">0</span> <span class="hljs-comment">// 自旋次数</span><br>    old := m.state <span class="hljs-comment">// 当前的锁的状态</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br>            <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>                awoke = <span class="hljs-literal">true</span><br>            &#125;<br>            runtime_doSpin()<br>            iter++<br>            old = m.state <span class="hljs-comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-built_in">new</span> := old<br>        <span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexLocked <span class="hljs-comment">// 非饥饿状态，加锁</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift <span class="hljs-comment">// waiter数量加1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexStarving <span class="hljs-comment">// 设置饥饿状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> awoke &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>                throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>            &#125;<br>            <span class="hljs-built_in">new</span> &amp;^= mutexWoken <span class="hljs-comment">// 新状态清除唤醒标记</span><br>        &#125;<br>        <span class="hljs-comment">// 成功设置新状态</span><br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>            <span class="hljs-comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span><br>            <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span><br>            &#125;<br>            <span class="hljs-comment">// 处理饥饿状态</span><br><br>            <span class="hljs-comment">// 如果以前就在队列里面，加入到队列头</span><br>            queueLifo := waitStartTime != <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>                waitStartTime = runtime_nanotime()<br>            &#125;<br>            <span class="hljs-comment">// 阻塞等待</span><br>            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 唤醒之后检查锁是否应该处于饥饿状态</span><br>            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>            old = m.state<br>            <span class="hljs-comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span><br>            <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>                    throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>                &#125;<br>                <span class="hljs-comment">// 有点绕，加锁并且将waiter数减1</span><br>                delta := <span class="hljs-type">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br>                <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br>                    delta -= mutexStarving <span class="hljs-comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span><br>                &#125;<br>                atomic.AddInt32(&amp;m.state, delta)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            awoke = <span class="hljs-literal">true</span><br>            iter = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            old = m.state<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-comment">// Fast path: drop lock bit.</span><br>    <span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br>        m.unlockSlow(<span class="hljs-built_in">new</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>        throw(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>        old := <span class="hljs-built_in">new</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br>            <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>                runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            old = m.state<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟之前的实现相比，当前的 Mutex 最重要的变化，就是增加饥饿模式。第 12 行将饥饿模式的最大等待时间阈值设置成了 1 毫秒，这就意味着，一旦等待者等待的时间超过了这个阈值，Mutex 的处理就有可能进入饥饿模式，优先让等待者先获取到锁，新来的同学主动谦让一下，给老同志一些机会。</p>
<p>通过加入饥饿模式，可以避免把机会全都留给新来的 goroutine，保证了请求锁的 goroutine 获取锁的公平性，对于我们使用锁的业务代码来说，不会有业务一直等待锁不被处理。</p>
<br>
<p>那么，接下来的部分就是选学内容了。如果你还有精力，并且对饥饿模式很感兴趣，那就一起继续来挑战吧。如果你现在理解起来觉得有困难，也没关系，后面可以随时回来复习。</p>
<p><strong>饥饿模式和正常模式</strong><br>
Mutex 可能处于两种操作模式下：正常模式和饥饿模式。</p>
<p>接下来我们分析一下 Mutex 对饥饿模式和正常模式的处理。</p>
<p>请求锁时调用的 Lock 方法中一开始是 fast path，这是一个幸运的场景，当前的 goroutine 幸运地获得了锁，没有竞争，直接返回，否则就进入了 lockSlow 方法。这样的设计，方便编译器对 Lock 方法进行内联，你也可以在程序开发中应用这个技巧。</p>
<p>正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</p>
<p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加入到等待队列的尾部。</p>
<p>如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p>
<ul>
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li>
<li>此 waiter 的等待时间小于 1 毫秒。</li>
</ul>
<p>正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。</p>
<p>饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。</p>
<p>接下来，我们逐步分析下 Mutex 代码的关键行，彻底搞清楚饥饿模式的细节。 我们从请求锁（lockSlow）的逻辑看起。</p>
<p>第 9 行对 state 字段又分出了一位，用来标记锁是否处于饥饿状态。现在一个 state 的字段被划分成了阻塞等待的 waiter 数量、饥饿标记、唤醒标记和持有锁的标记四个部分。</p>
<p>第 25 行记录此 goroutine 请求锁的初始时间，第 26 行标记是否处于饥饿状态，第 27 行标记是否是唤醒的，第 28 行记录 spin 的次数。</p>
<p>第 31 行到第 40 行和以前的逻辑类似，只不过加了一个不能是饥饿状态的逻辑。它会对正常状态抢夺锁的 goroutine 尝试 spin，和以前的目的一样，就是在临界区耗时很短的情况下提高性能。</p>
<p>第 42 行到第 44 行，非饥饿状态下抢锁。怎么抢？就是要把 state 的锁的那一位，置为加锁状态，后续 CAS 如果成功就可能获取到了锁。</p>
<p>第 46 行到第 48 行，如果锁已经被持有或者锁处于饥饿状态，我们最好的归宿就是等待，所以 waiter 的数量加 1。</p>
<p>第 49 行到第 51 行，如果此 goroutine 已经处在饥饿状态，并且锁还被持有，那么，我们需要把此 Mutex 设置为饥饿状态。</p>
<p>第 52 行到第 57 行，是清除 mutexWoken 标记，因为不管是获得了锁还是进入休眠，我们都需要清除 mutexWoken 标记。</p>
<p>第 59 行就是尝试使用 CAS 设置 state。如果成功，第 61 行到第 63 行是检查原来的锁的状态是未加锁状态，并且也不是饥饿状态的话就成功获取了锁，返回。</p>
<p>第 67 行判断是否第一次加入到 waiter 队列。到这里，你应该就能明白第 25 行为什么不对 waitStartTime 进行初始化了，我们需要利用它在这里进行条件判断。</p>
<p>第 72 行将此 waiter 加入到队列，如果是首次，加入到队尾，先进先出。如果不是首次，那么加入到队首，这样等待最久的 goroutine 优先能够获取到锁。此 goroutine 会进行休眠。</p>
<p>第 74 行判断此 goroutine 是否处于饥饿状态。注意，执行这一句的时候，它已经被唤醒了。</p>
<p>第 77 行到第 88 行是对锁处于饥饿状态下的一些处理。</p>
<p>第 82 行设置一个标志，这个标志稍后会用来加锁，而且还会将 waiter 数减 1。</p>
<p>第 84 行，设置标志，在没有其它的 waiter 或者此 goroutine 等待还没超过 1 毫秒，则会将Mutex 转为正常状态。</p>
<p>第 86 行则是将这个标识应用到 state 字段上。</p>
<p>释放锁（Unlock）时调用的 Unlock 的 fast path 不用多少，所以我们主要看 unlockSlow 方法就行。</p>
<p>如果 Mutex 处于饥饿状态，第 123 行直接唤醒等待队列中的 waiter。</p>
<p>如果 Mutex 处于正常状态，如果没有 waiter，或者已经有在处理的情况了，那么释放就好，不做额外的处理（第 112 行到第 114 行）。</p>
<p>否则，waiter 数减 1，mutexWoken 标志设置上，通过 CAS 更新 state 的值（第 115 行到第 119 行）。</p>
<br>
<p><strong>总结</strong></p>
<p>“罗马不是一天建成的”，Mutex 的设计也是从简单设计到复杂处理逐渐演变的。初版的 Mutex 设计非常简洁，充分展示了 Go 创始者的简单、简洁的设计哲学。但是，随着大家的使用，逐渐暴露出一些缺陷，为了弥补这些缺陷，Mutex 不得不越来越复杂。</p>
<p>有一点值得我们学习的，同时也体现了 Go 创始者的哲学，就是他们强调 Go 语言和标准库的稳定性，新版本要向下兼容，用新的版本总能编译老的代码。Go 语言从出生到现在已经 10 多年了，这个 Mutex 对外的接口却没有变化，依然向下兼容，即使现在 Go 出了两个版本，每个版本也会向下兼容，保持 Go 语言的稳定性，你也能领悟他们软件开发和设计的思想。</p>
<p>还有一点，你也可以观察到，为了一个程序 20% 的特性，你可能需要添加 80% 的代码，这也是程序越来越复杂的原因。所以，最开始的时候，如果能够有一个清晰而且易于扩展的设计，未来增加新特性时，也会更加方便。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-3-Mutex：4种易错场景大盘点">2.3 Mutex：4种易错场景大盘点</h3>
<p>上一讲，我们一起领略了 Mutex 的架构演进之美，现在我们已经清楚 Mutex 的实现细节了。当前 Mutex 的实现貌似非常复杂，其实主要还是针对饥饿模式和公平性问题，做了一些额外处理。但是，我们在第一讲中已经体验过了，Mutex 使用起来还是非常简单的，毕竟，它只有 Lock 和 Unlock 两个方法，使用起来还能复杂到哪里去？</p>
<p>正常使用 Mutex 时，确实是这样的，很简单，基本不会有什么错误，即使出现错误，也是在一些复杂的场景中，比如跨函数调用 Mutex 或者是在重构或者修补 Bug 时误操作。但是，我们使用 Mutex 时，确实会出现一些 Bug，比如说忘记释放锁、重入锁、复制已使用了的 Mutex 等情况。那在这一讲中，我们就一起来看看使用 Mutex 常犯的几个错误，做到“Bug 提前知，后面早防范”。</p>
<p>使用 Mutex 常见的错误场景有 4 类，分别是</p>
<ul>
<li>Lock/Unlock 不是成对出现、</li>
<li>Copy 已使用的 Mutex</li>
<li>重入</li>
<li>死锁</li>
</ul>
<br>
<h4 id="2-3-1-Lock-Unlock-不是成对出现">2.3.1 Lock/Unlock 不是成对出现</h4>
<p>Lock/Unlock 没有成对出现，就意味着会出现死锁的情况，或者是因为 Unlock 一个未加锁的 Mutex 而导致 panic。</p>
<p>我们先来看看缺少 Unlock 的场景，常见的有三种情况：</p>
<ol>
<li>代码中有太多的 if-else 分支，可能在某个分支中漏写了 Unlock；</li>
<li>在重构的时候把 Unlock 给删除了；</li>
<li>Unlock 误写成了 Lock。</li>
</ol>
<p>在这种情况下，锁被获取之后，就不会被释放了，这也就意味着，其它的 goroutine 永远都没机会获取到锁。</p>
<p>我们再来看缺少 Lock 的场景，这就很简单了，一般来说就是误操作删除了 Lock。 比如先前使用 Mutex 都是正常的，结果后来其他人重构代码的时候，由于对代码不熟悉，或者由于开发者的马虎，把 Lock 调用给删除了，或者注释掉了。比如下面的代码，mu.Lock() 一行代码被删除了，直接 Unlock 一个未加锁的 Mutex 会 panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><br><br><br></p>
<h4 id="2-3-2-Copy-已使用的-Mutex">2.3.2 Copy 已使用的 Mutex</h4>
<p>第二种误用是 Copy 已使用的 Mutex。在正式分析这个错误之前，先交代一个小知识点，那就是 <code>Package sync</code> 的同步原语在使用后是不能复制的。我们知道 Mutex 是最常用的一个同步原语，那它也是不能复制的。为什么呢？</p>
<p>原因在于，Mutex 是一个有状态的对象，它的 state 字段记录这个锁的状态。如果你要复制一个已经加锁的 Mutex 给一个新的变量，那么新的刚初始化的变量居然被加锁了，这显然不符合你的期望，因为你期望的是一个零值的 Mutex。关键是在并发环境下，你根本不知道要复制的 Mutex 状态是什么，因为要复制的 Mutex 是由其它 goroutine 并发访问的，状态可能总是在变化。</p>
<p>当然，你可能说，你说的我都懂，你的警告我都记下了，但是实际在使用的时候，一不小心就踩了这个坑，我们来看一个例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    Count <span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c Counter<br>    c.Lock()<br>    <span class="hljs-keyword">defer</span> c.Unlock()<br>    c.Count++<br>    foo(c) <span class="hljs-comment">// 复制锁</span><br>&#125;<br><br><span class="hljs-comment">// 这里Counter的参数是通过复制的方式传入的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(c Counter)</span></span> &#123;<br>    c.Lock()<br>    <span class="hljs-keyword">defer</span> c.Unlock()<br>    fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 12 行在调用 foo 函数的时候，调用者会复制 Mutex 变量 c 作为 foo 函数的参数，不幸的是，复制之前已经使用了这个锁，这就导致，复制的 Counter 是一个带状态 Counter。</p>
<p>怎么办呢？Go 在运行时，有死锁的检查机制（checkdead() 方法），它能够发现死锁的 goroutine。这个例子中因为复制了一个使用了的 Mutex，导致锁无法使用，程序处于死锁的状态。程序运行的时候，死锁检查机制能够发现这种死锁情况并输出错误信息，如下图中错误信息以及错误堆栈：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/cfb7a4a0e744c5ff534a676fd830d0ee.webp" alt=""></p>
<br>
<p>你肯定不想运行的时候才发现这个因为复制 Mutex 导致的死锁问题，那么你怎么能够及时发现问题呢？可以使用 <strong>vet 工具</strong>，把检查写在 Makefile 文件中，在持续集成的时候跑一跑，这样可以及时发现问题，及时修复。我们可以使用 go vet 检查这个 Go 文件：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/fa56520yy37009ca58d6640a933f01b8.webp" alt=""></p>
<p>你看，使用这个工具就可以发现 Mutex 复制的问题，错误信息显示得很清楚，是在调用 foo 函数的时候发生了 lock value 复制的情况，还告诉我们出问题的代码行数以及 copy lock 导致的错误。</p>
<p>那么，vet 工具是怎么发现 Mutex 复制使用问题的呢？我们简单分析一下。</p>
<p>检查是通过<a target="_blank" rel="noopener" href="https://github.com/golang/tools/blob/master/go/analysis/passes/copylock/copylock.go">copylock</a>分析器静态分析实现的。这个分析器会分析函数调用、range 遍历、复制、声明、函数返回值等位置，有没有锁的值 copy 的情景，以此来判断有没有问题。可以说，只要是实现了 Locker 接口，就会被分析。我们看到，下面的代码就是确定什么类型会被分析，其实就是实现了 Lock/Unlock 两个方法的 Locker 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> lockerType *types.Interface<br>  <br><span class="hljs-comment">// Construct a sync.Locker interface type.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    nullary := types.NewSignature(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>) <span class="hljs-comment">// func()</span><br>    methods := []*types.Func&#123;<br>        types.NewFunc(token.NoPos, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Lock&quot;</span>, nullary),<br>        types.NewFunc(token.NoPos, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Unlock&quot;</span>, nullary),<br>    &#125;<br>    lockerType = types.NewInterface(methods, <span class="hljs-literal">nil</span>).Complete()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实，有些没有实现 Locker 接口的同步原语（比如 WaitGroup），也能被分析。后面我们会介绍这种情况是怎么实现的。</p>
<hr>
<p><br><br><br></p>
<h4 id="2-3-3-重入">2.3.3 重入</h4>
<p>接下来，我们来讨论“重入”这个问题。在说这个问题前，我先解释一下个概念，叫“<strong>可重入锁</strong>”。</p>
<p>如果你学过 Java，可能会很熟悉 ReentrantLock，就是可重入锁，这是 Java 并发包中非常常用的一个同步原语。它的基本行为和互斥锁相同，但是加了一些扩展功能。</p>
<p>如果你没接触过 Java，也没关系，这里只是提一下，帮助会 Java 的同学对比来学。那下面来具体讲解可重入锁是咋回事儿。</p>
<p>当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。</p>
<p>了解了可重入锁的概念，那我们来看 Mutex 使用的错误场景。划重点了：<strong>Mutex 不是可重入的锁</strong>。</p>
<p>想想也不奇怪，因为 Mutex 的实现中没有记录哪个 goroutine 拥有这把锁。理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件。</p>
<p>所以，一旦误用 Mutex 的重入，就会导致报错。下面是一个误用 Mutex 的重入例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(l sync.Locker)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>    l.Lock()<br>    bar(l)<br>    l.Unlock()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">(l sync.Locker)</span></span> &#123;<br>    l.Lock()<br>    fmt.Println(<span class="hljs-string">&quot;in bar&quot;</span>)<br>    l.Unlock()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    l := &amp;sync.Mutex&#123;&#125;<br>    foo(l)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>写完这个 Mutex 重入的例子后，运行一下，你会发现类似下面的错误。程序一直在请求锁，但是一直没有办法获取到锁，结果就是 Go 运行时发现死锁了，没有其它地方能够释放锁让程序运行下去，你通过下面的错误堆栈信息就能定位到哪一行阻塞请求锁。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/0bc98ef74c15d9640806d52bf030f979.webp" alt=""></p>
<p>学到这里，你可能要问了，虽然标准库 Mutex 不是可重入锁，但是如果我就是想要实现一个可重入锁，可以吗？</p>
<p>可以，那我们就自己实现一个。这里的关键就是，实现的锁要能记住当前是哪个 goroutine 持有这个锁。以下提供两个方案。</p>
<ul>
<li>方案一：通过 hacker 的方式获取到 goroutine id，记录下获取锁的 goroutine id，它可以实现 Locker 接口。</li>
<li>方案二：调用 Lock/Unlock 方法时，由 goroutine 提供一个 token，用来标识它自己，而不是我们通过 hacker 的方式获取到 goroutine id，但是，这样一来，就不满足 Locker 接口了。</li>
</ul>
<p>可重入锁（递归锁）解决了代码重入或者递归调用带来的死锁问题，同时它也带来了另一个好处，就是我们可以要求，只有持有锁的 goroutine 才能 unlock 这个锁。这也很容易实现，因为在上面这两个方案中，都已经记录了是哪一个 goroutine 持有这个锁。</p>
<br>
<p>下面我们具体来看这两个方案怎么实现。</p>
<ul>
<li>
<p><strong>方案一：goroutine id</strong></p>
<p>这个方案的关键第一步是获取 goroutine id，方式有两种，分别是简单方式和 hacker 方式。</p>
<p>简单方式，就是通过 runtime.Stack 方法获取栈帧信息，栈帧信息里包含 goroutine id。你可以看看上面 panic 时候的贴图，goroutine id 明明白白地显示在那里。runtime.Stack 方法可以获取当前的 goroutine 信息，第二个参数为 true 会输出所有的 goroutine 信息，信息的格式如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">goroutine 1 [running]:<br>main.main()<br>        ....../main.go:19 +0xb1<br></code></pre></td></tr></table></figure>
<p>第一行格式为 goroutine xxx，其中 xxx 就是 goroutine id，你只要解析出这个 id 即可。解析的方法可以采用下面的代码：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GoID</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> buf [<span class="hljs-number">64</span>]<span class="hljs-type">byte</span><br>    n := runtime.Stack(buf[:], <span class="hljs-literal">false</span>)<br>    <span class="hljs-comment">// 得到id字符串</span><br>    idField := strings.Fields(strings.TrimPrefix(<span class="hljs-type">string</span>(buf[:n]), <span class="hljs-string">&quot;goroutine &quot;</span>))[<span class="hljs-number">0</span>]<br>    id, err := strconv.Atoi(idField)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;cannot get goroutine id: %v&quot;</span>, err))<br>    &#125;<br>    <span class="hljs-keyword">return</span> id<br>&#125;<br></code></pre></td></tr></table></figure>
<p>了解了简单方式，接下来我们来看 hacker 的方式，这也是我们方案一采取的方式。</p>
<p>首先，我们获取运行时的 g 指针，反解出对应的 g 的结构。每个运行的 goroutine 结构的 g 指针保存在当前 goroutine 的一个叫做 TLS 对象中。</p>
<p>第一步：我们先获取到 TLS 对象；</p>
<p>第二步：再从 TLS 中获取 goroutine 结构的 g 指针；</p>
<p>第三步：再从 g 指针中取出 goroutine id。</p>
<p>需要注意的是，不同 Go 版本的 goroutine 的结构可能不同，所以需要根据 Go 的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/89f687d6dbc11613f715d1644b4983905293dd33/src/runtime/runtime2.go#L412">不同版本</a>进行调整。当然了，如果想要搞清楚各个版本的 goroutine 结构差异，所涉及的内容又过于底层而且复杂，学习成本太高。怎么办呢？</p>
<p>我们可以重点关注一些库。我们没有必要重复发明轮子，直接使用第三方的库来获取 goroutine id 就可以了。 好消息是现在已经有很多成熟的方法了，可以支持多个 Go 版本的 goroutine id，给你推荐一个常用的库：<a target="_blank" rel="noopener" href="https://github.com/petermattis/goid">petermattis/goid</a>。</p>
<p>知道了如何获取 goroutine id，接下来就是最后的关键一步了，我们实现一个可以使用的可重入锁：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RecursiveMutex 包装一个Mutex,实现可重入</span><br><span class="hljs-keyword">type</span> RecursiveMutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    owner     <span class="hljs-type">int64</span> <span class="hljs-comment">// 当前持有锁的goroutine id</span><br>    recursion <span class="hljs-type">int32</span> <span class="hljs-comment">// 这个goroutine 重入的次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RecursiveMutex)</span></span> Lock() &#123;<br>    gid := goid.Get()<br>    <span class="hljs-comment">// 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入</span><br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) == gid &#123;<br>        m.recursion++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    m.Mutex.Lock()<br>    <span class="hljs-comment">// 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1</span><br>    atomic.StoreInt64(&amp;m.owner, gid)<br>    m.recursion = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RecursiveMutex)</span></span> Unlock() &#123;<br>    gid := goid.Get()<br>    <span class="hljs-comment">// 非持有锁的goroutine尝试释放锁，错误的使用</span><br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) != gid &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong the owner(%d): %d!&quot;</span>, m.owner, gid))<br>    &#125;<br>    <span class="hljs-comment">// 调用次数减1</span><br>    m.recursion--<br>    <span class="hljs-keyword">if</span> m.recursion != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果这个goroutine还没有完全释放，则直接返回</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 此goroutine最后一次调用，需要释放锁</span><br>    atomic.StoreInt64(&amp;m.owner, <span class="hljs-number">-1</span>)<br>    m.Mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面这段代码你可以拿来即用。我们一起来看下这个实现，真是非常巧妙，它相当于给 Mutex 打一个补丁，解决了记录锁的持有者的问题。可以看到，我们用 owner 字段，记录当前锁的拥有者 goroutine 的 id；recursion 是辅助字段，用于记录重入的次数。</p>
<p>提醒一点，尽管拥有者可以多次调用 Lock，但是也必须调用相同次数的 Unlock，这样才能把锁释放掉。这是一个合理的设计，可以保证 Lock 和 Unlock 一一对应。</p>
</li>
<li>
<p><strong>方案二：token</strong></p>
<p>方案一是用 goroutine id 做 goroutine 的标识，我们也可以让 goroutine 自己来提供标识。不管怎么说，Go 开发者不期望你利用 goroutine id 做一些不确定的东西，所以，他们没有暴露获取 goroutine id 的方法。</p>
<p>下面的代码是第二种方案。调用者自己提供一个 token，获取锁的时候把这个 token 传入，释放锁的时候也需要把这个 token 传入。通过用户传入的 token 替换方案一中 goroutine id，其它逻辑和方案一一致。</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Token方式的递归锁</span><br><span class="hljs-keyword">type</span> TokenRecursiveMutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    token     <span class="hljs-type">int64</span><br>    recursion <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-comment">// 请求锁，需要传入token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *TokenRecursiveMutex)</span></span> Lock(token <span class="hljs-type">int64</span>) &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.token) == token &#123; <span class="hljs-comment">//如果传入的token和持有锁的token一致，说明是递归调用</span><br>        m.recursion++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    m.Mutex.Lock() <span class="hljs-comment">// 传入的token不一致，说明不是递归调用</span><br>    <span class="hljs-comment">// 抢到锁之后记录这个token</span><br>    atomic.StoreInt64(&amp;m.token, token)<br>    m.recursion = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 释放锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *TokenRecursiveMutex)</span></span> Unlock(token <span class="hljs-type">int64</span>) &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.token) != token &#123; <span class="hljs-comment">// 释放其它token持有的锁</span><br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong the owner(%d): %d!&quot;</span>, m.token, token))<br>    &#125;<br>    m.recursion-- <span class="hljs-comment">// 当前持有这个锁的token释放锁</span><br>    <span class="hljs-keyword">if</span> m.recursion != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 还没有回退到最初的递归调用</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    atomic.StoreInt64(&amp;m.token, <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有递归调用了，释放锁</span><br>    m.Mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><br><br><br></p>
<h4 id="2-3-4-死锁">2.3.4 死锁</h4>
<p>我们来分析一下死锁产生的必要条件。如果你想避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。</p>
<ol>
<li><strong>互斥</strong>： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。</li>
<li><strong>持有和等待</strong>：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。</li>
<li><strong>不可剥夺</strong>：资源只能由持有它的 goroutine 来释放。</li>
<li><strong>环路等待</strong>：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。</li>
</ol>
<p>Go 运行时，有死锁探测的功能，能够检查出是否出现了死锁的情况，如果出现了，这个时候你就需要调整策略来处理了。</p>
<p>你可以引入一个第三方的锁，大家都依赖这个锁进行业务处理，比如现在政府推行的一站式政务服务中心。或者是解决持有等待问题，物业不需要看到派出所的证明才给开物业证明，等等。 好了，到这里，我们讲了使用 Mutex 常见的 4 类问题。你是不是觉得，哎呀，这几类问题也太不应该了吧，真的会有人犯这么基础的错误吗？ 还真是有。虽然 Mutex 使用起来很简单，但是，仍然可能出现使用错误的问题。而且，就连一些经验丰富的开发人员，也会出现一些 Mutex 使用的问题。接下来，我们围观几个非常流行的 Go 开发项目，看看这些错误是怎么产生和修复的。</p>
<hr>
<p><br><br><br></p>
<h4 id="2-3-5-流行的-Go-开发项目踩坑记">2.3.5 流行的 Go 开发项目踩坑记</h4>
<p><strong>Docker</strong></p>
<p>Docker 容器是一个开源的应用容器引擎，开发者可以以统一的方式，把他们的应用和依赖包打包到一个可移植的容器中，然后发布到任何安装了 docker 引擎的服务器上。 Docker 是使用 Go 开发的，也算是 Go 的一个杀手级产品了，它的 Mutex 相关的 Bug 也不少，我们来看几个典型的 Bug。</p>
<p><strong>issue 36114</strong></p>
<p>Docker 的<a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/36114/files">issue 36114</a> 是一个死锁问题。 原因在于，hotAddVHDsAtStart 方法执行的时候，执行了加锁 svm 操作。但是，在其中调用 hotRemoveVHDsAtStart 方法时，这个 hotRemoveVHDsAtStart 方法也是要加锁 svm 的。很不幸，Go 标准库中的 Mutex 是不可重入的，所以，代码执行到这里，就出现了死锁的现象。</p>
<p>针对这个问题，解决办法就是，再提供一个不需要锁的 hotRemoveVHDsNoLock 方法，避免 Mutex 的重入。</p>
<p><strong>issue 34881</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/34881/files">issue 34881</a>本来是修复 Docker 的一个简单问题，如果节点在初始化的时候，发现自己不是一个 swarm mananger，就快速返回，这个修复就几行代码，你看出问题来了吗？</p>
<p>在第 34 行，节点发现不满足条件就返回了，但是，<a target="_blank" rel="noopener" href="http://c.mu">c.mu</a> 这个锁没有释放！为什么会出现这个问题呢？其实，这是在重构或者添加新功能的时候经常犯的一个错误，因为不太了解上下文，或者是没有仔细看函数的逻辑，从而导致锁没有被释放。现在的 Docker 当然已经没有这个问题了。</p>
<p>这样的 issue 还有很多，就不一一列举了。推荐几个关于 Mutex 的 issue 或者 pull request，你可以关注一下，分别是 36840、37583、35517、35482、33305、32826、30696、29554、29191、28912、26507 等。</p>
<br>
<p><strong>Kubernetes</strong></p>
<p><strong>issue 45192</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/45192/files">issue 45192</a>也是一个返回时忘记 Unlock 的典型例子，和 docker issue 34881 犯的错误都是一样的。</p>
<p>两大知名项目的开发者都犯了这个错误，所以，你就可以知道，引入这个 Bug 是多么容易，记住晁老师这句话：<strong>保证 Lock/Unlock 成对出现，尽可能采用 defer mutex.Unlock 的方式，把它们成对、紧凑地写在一起</strong>。</p>
<br>
<p><strong>gRPC</strong></p>
<p>gRPC 是 Google 发起的一个开源远程过程调用 （Remote procedure call）系统。该系统基于 HTTP/2 协议传输，使用 Protocol Buffers 作为接口描述语言。它提供 Go 语言的实现。</p>
<p>即使是 Google 官方出品的系统，也有一些 Mutex 的 issue。</p>
<p><strong>issue 795</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/pull/795">issue 795</a>是一个你可能想不到的 bug，那就是将 Unlock 误写成了 Lock。</p>
<br>
<p><strong>etcd</strong></p>
<p>etcd 是一个非常知名的分布式一致性的 key-value 存储技术， 被用来做配置共享和服务发现。</p>
<p><strong>issue 10419</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/pull/10419/files">issue 10419</a>是一个锁重入导致的问题。 Store 方法内对请求了锁，而调用的 Compact 的方法内又请求了锁，这个时候，会导致死锁，一直等待，解决办法就是提供不需要加锁的 Compact 方法。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-4-Mutex：骇客编程，如何拓展额外功能？">2.4 Mutex：骇客编程，如何拓展额外功能？</h3>
<blockquote>
<p>“Hacker”一词指的是以一种非传统或未被官方直接支持的方式来修改或增强现有软件或系统。在这个上下文中，它特别指的是对Go语言中<code>sync.Mutex</code>互斥锁进行定制化扩展，以提供超出其标准功能集的特性。</p>
</blockquote>
<p>前面三讲，我们学习了互斥锁 Mutex 的基本用法、实现原理以及易错场景，可以说是涵盖了互斥锁的方方面面。如果能熟练掌握这些内容，那么，在大多数的开发场景中，都可以得心应手。</p>
<p>但是，在一些特定的场景中，这些基础功能是不足以应对的。这个时候，我们就需要开发一些扩展功能了。</p>
<p>举几个例子。 比如说，我们知道，如果互斥锁被某个 goroutine 获取了，而且还没有释放，那么，其他请求这把锁的 goroutine，就会阻塞等待，直到有机会获得这把锁。有时候阻塞并不是一个很好的主意，比如你请求锁更新一个计数器，如果获取不到锁的话没必要等待，大不了这次不更新，我下次更新就好了，如果阻塞的话会导致业务处理能力的下降。</p>
<p>再比如，如果我们要监控锁的竞争情况，一个监控指标就是，等待这把锁的 goroutine 数量。我们可以把这个指标推送到时间序列数据库中，再通过一些监控系统（比如 Grafana）展示出来。要知道，<strong>锁是性能下降的“罪魁祸首”之一，所以，有效地降低锁的竞争，就能够很好地提高性能。因此，监控关键互斥锁上等待的 goroutine 的数量，是我们分析锁竞争的激烈程度的一个重要指标</strong>。</p>
<p>实际上，不论是不希望锁的 goroutine 继续等待，还是想监控锁，我们都可以基于标准库中 Mutex 的实现，通过 Hacker 的方式，为 Mutex 增加一些额外的功能。这节课，就来教你实现几个扩展功能，包括实现 TryLock，获取等待者的数量等指标，以及实现一个线程安全的队列。</p>
<br>
<p><strong>TryLock</strong></p>
<p>我们可以为 Mutex 添加一个 TryLock 的方法，也就是尝试获取排外锁。PS：在 Go 1.18 官方标准库中，已经为 Mutex/RWMutex 增加了 TryLock 方法。</p>
<p>这个方法具体是什么意思呢？现在解释一下这里的逻辑。当一个 goroutine 调用这个 TryLock 方法请求锁的时候，如果这把锁没有被其他 goroutine 所持有，那么，这个 goroutine 就持有了这把锁，并返回 true；如果这把锁已经被其他 goroutine 所持有，或者是正在准备交给某个被唤醒的 goroutine，那么，这个请求锁的 goroutine 就直接返回 false，不会阻塞在方法调用上。</p>
<p>在实际开发中，如果要更新配置数据，我们通常需要加锁，这样可以避免同时有多个 goroutine 并发修改数据。有的时候，我们也会使用 TryLock。这样一来，当某个 goroutine 想要更改配置数据时，如果发现已经有 goroutine 在更改了，其他的 goroutine 调用 TryLock，返回了 false，这个 goroutine 就会放弃更改。</p>
<p>很多语言（比如 Java）都为锁提供了 TryLock 的方法，但是，<strong>Go 官方</strong><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/6123">issue 6123</a>有一个讨论（后来一些 issue 中也提到过），<strong>标准库的 Mutex 不会添加 TryLock 方法</strong>。虽然通过 Go 的 Channel 我们也可以实现 TryLock 的功能，但是基于 Channel 的实现我们会放在 Channel 那一讲中去介绍，这一次我们还是基于 Mutex 去实现，毕竟大部分的程序员还是熟悉传统的同步原语，而且传统的同步原语也不容易出错。所以这节课，还是希望带你掌握基于 Mutex 实现的方法。</p>
<p>那怎么实现一个扩展 TryLock 方法的 Mutex 呢？我们直接来看代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 复制Mutex定义的常量</span><br><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// 加锁标识位置</span><br>    mutexWoken              <span class="hljs-comment">// 唤醒标识位置</span><br>    mutexStarving           <span class="hljs-comment">// 锁饥饿标识位置</span><br>    mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 标识waiter的起始bit位置</span><br>)<br><br><span class="hljs-comment">// 扩展一个Mutex结构</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>&#125;<br><br><span class="hljs-comment">// 尝试获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> TryLock() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 如果能成功抢到锁</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)), <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果处于唤醒、加锁或者饥饿状态，这次请求就不参与竞争了，返回false</span><br>    old := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))<br>    <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving|mutexWoken) != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 尝试在竞争的状态下请求锁</span><br>    <span class="hljs-built_in">new</span> := old | mutexLocked<br>    <span class="hljs-keyword">return</span> atomic.CompareAndSwapInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)), old, <span class="hljs-built_in">new</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 17 行是一个 fast path，如果幸运，没有其他 goroutine 争这把锁，那么，这把锁就会被这个请求的 goroutine 获取，直接返回。</p>
<p>如果锁已经被其他 goroutine 所持有，或者被其他唤醒的 goroutine 准备持有，那么，就直接返回 false，不再请求，代码逻辑在第 23 行。</p>
<p>如果没有被持有，也没有其它唤醒的 goroutine 来竞争锁，锁也不处于饥饿状态，就尝试获取这把锁（第 29 行），不论是否成功都将结果返回。因为，这个时候，可能还有其他的 goroutine 也在竞争这把锁，所以，不能保证成功获取这把锁。</p>
<p>我们可以写一个简单的测试程序，来测试我们的 TryLock 的机制是否工作。</p>
<p>这个测试程序的工作机制是这样子的：程序运行时会启动一个 goroutine 持有这把我们自己实现的锁，经过随机的时间才释放。主 goroutine 会尝试获取这把锁。如果前一个 goroutine 一秒内释放了这把锁，那么，主 goroutine 就有可能获取到这把锁了，输出“got the lock”，否则没有获取到也不会被阻塞，会直接输出“can’t get the lock”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">try</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mu Mutex<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine持有一段时间的锁</span><br>        mu.Lock()<br>        time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">2</span>)) * time.Second)<br>        mu.Unlock()<br>    &#125;()<br><br>    time.Sleep(time.Second)<br><br>    ok := mu.TryLock() <span class="hljs-comment">// 尝试获取到锁</span><br>    <span class="hljs-keyword">if</span> ok &#123; <span class="hljs-comment">// 获取成功</span><br>        fmt.Println(<span class="hljs-string">&quot;got the lock&quot;</span>)<br>        <span class="hljs-comment">// do something</span><br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 没有获取到</span><br>    fmt.Println(<span class="hljs-string">&quot;can&#x27;t get the lock&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>获取等待者的数量等指标</strong></p>
<p>接下来，我们聊聊怎么获取等待者数量等指标。 第二讲中，我们已经学习了 Mutex 的结构。先来回顾一下 Mutex 的数据结构，如下面的代码所示。它包含两个字段，state 和 sema。前四个字节（int32）就是 state 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    state <span class="hljs-type">int32</span><br>    sema  <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Mutex 结构中的 state 字段有很多个含义，通过 state 字段，你可以知道锁是否已经被某个 goroutine 持有、当前是否处于饥饿状态、是否有等待的 goroutine 被唤醒、等待者的数量等信息。但是，state 这个字段并没有暴露出来，所以，我们需要想办法获取到这个字段，并进行解析。<br>
怎么获取未暴露的字段呢？</p>
<p>很简单，我们可以通过 unsafe 的方式实现。举一个例子，你一看就明白了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span><br>    mutexWoken<br>    mutexStarving<br>    mutexWaiterShift = <span class="hljs-literal">iota</span><br>)<br><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Count() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 获取state字段的值</span><br>    v := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))<br>    v = v &gt;&gt; mutexWaiterShift + (v &amp; mutexLocked)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子的第 14 行通过 unsafe 操作，我们可以得到 state 字段的值。第 15 行我们右移三位（这里的常量 mutexWaiterShift 的值为 3），就得到了当前等待者的数量。如果当前的锁已经被其他 goroutine 持有，那么，我们就稍微调整一下这个值，加上一个 1（第 16 行），你基本上可以把它看作是当前持有和等待这把锁的 goroutine 的总数。</p>
<p>state 这个字段的第一位是用来标记锁是否被持有，第二位用来标记是否已经唤醒了一个等待者，第三位标记锁是否处于饥饿状态，通过分析这个 state 字段我们就可以得到这些状态信息。我们可以为这些状态提供查询的方法，这样就可以实时地知道锁的状态了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 锁是否被持有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> IsLocked() <span class="hljs-type">bool</span> &#123;<br>    state := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))<br>    <span class="hljs-keyword">return</span> state&amp;mutexLocked == mutexLocked<br>&#125;<br><br><span class="hljs-comment">// 是否有等待者被唤醒</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> IsWoken() <span class="hljs-type">bool</span> &#123;<br>    state := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))<br>    <span class="hljs-keyword">return</span> state&amp;mutexWoken == mutexWoken<br>&#125;<br><br><span class="hljs-comment">// 锁是否处于饥饿状态</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> IsStarving() <span class="hljs-type">bool</span> &#123;<br>    state := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(&amp;m.Mutex)))<br>    <span class="hljs-keyword">return</span> state&amp;mutexStarving == mutexStarving<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以写一个程序测试一下，比如，在 1000 个 goroutine 并发访问的情况下，我们可以把锁的状态信息输出出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mu Mutex<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123; <span class="hljs-comment">// 启动1000个goroutine</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            mu.Lock()<br>            time.Sleep(time.Second)<br>            mu.Unlock()<br>        &#125;()<br>    &#125;<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// 输出锁的信息</span><br>    fmt.Printf(<span class="hljs-string">&quot;waitings: %d, isLocked: %t, woken: %t,  starving: %t\n&quot;</span>, mu.Count(), mu.IsLocked(), mu.IsWoken(), mu.IsStarving())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有一点你需要注意一下，在获取 state 字段的时候，并没有通过 Lock 获取这把锁，所以获取的这个 state 的值是一个瞬态的值，可能在你解析出这个字段之后，锁的状态已经发生了变化。不过没关系，因为你查看的就是调用的那一时刻的锁的状态。</p>
<br>
<p><strong>使用 Mutex 实现一个线程安全的队列</strong></p>
<p>最后，我们来讨论一下，如何使用 Mutex 实现一个线程安全的队列。</p>
<p>为什么要讨论这个话题呢？因为 Mutex 经常会和其他非线程安全（对于 Go 来说，我们其实指的是 goroutine 安全）的数据结构一起，组合成一个线程安全的数据结构。新数据结构的业务逻辑由原来的数据结构提供，而 Mutex 提供了锁的机制，来保证线程安全。</p>
<p>比如队列，我们可以通过 Slice 来实现，但是通过 Slice 实现的队列不是线程安全的，出队（Dequeue）和入队（Enqueue）会有 data race 的问题。这个时候，Mutex 就要隆重出场了，通过它，我们可以在出队和入队的时候加上锁的保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceQueue <span class="hljs-keyword">struct</span> &#123;<br>    data []<span class="hljs-keyword">interface</span>&#123;&#125;<br>    mu   sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSliceQueue</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (q *SliceQueue) &#123;<br>    <span class="hljs-keyword">return</span> &amp;SliceQueue&#123;data: <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>, n)&#125;<br>&#125;<br><br><span class="hljs-comment">// Enqueue 把值放在队尾</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *SliceQueue)</span></span> Enqueue(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    q.mu.Lock()<br>    q.data = <span class="hljs-built_in">append</span>(q.data, v)<br>    q.mu.Unlock()<br>&#125;<br><br><span class="hljs-comment">// Dequeue 移去队头并返回</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *SliceQueue)</span></span> Dequeue() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    q.mu.Lock()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.data) == <span class="hljs-number">0</span> &#123;<br>        q.mu.Unlock()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    v := q.data[<span class="hljs-number">0</span>]<br>    q.data = q.data[<span class="hljs-number">1</span>:]<br>    q.mu.Unlock()<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为标准库中没有线程安全的队列数据结构的实现，所以，你可以通过 Mutex 实现一个简单的队列。通过 Mutex 我们就可以为一个非线程安全的 data interface{}实现线程安全的访问。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-5-RWMutex：读写锁的实现原理及避坑指南">2.5 RWMutex：读写锁的实现原理及避坑指南</h3>
<p>在前面的四节课中，我们学习了第一个同步原语，即 Mutex，我们使用它来保证读写共享资源的安全性。不管是读还是写，我们都通过 Mutex 来保证只有一个 goroutine 访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在 Mutex 的保护下变成了串行访问，这个时候，使用 Mutex，对性能的影响就比较大。</p>
<p>怎么办呢？你是不是已经有思路了，对，就是区分读写操作。</p>
<p>具体解释一下。如果某个读操作的 goroutine 持有了锁，在这种情况下，其它读操作的 goroutine 就不必一直傻傻地等待了，而是可以并发地访问共享变量，这样我们就可以将串行的读变成并行读，提高读操作的性能。当写操作的 goroutine 持有锁的时候，它就是一个排外锁，其它的写操作和读操作的 goroutine，需要阻塞等待持有这个锁的 goroutine 释放锁。</p>
<p>这一类并发读写问题叫作readers-writers 问题，意思就是，同时可能有多个读或者多个写，但是只要有一个线程在执行写操作，其它的线程都不能执行读写操作。</p>
<p><strong>Go 标准库中的 RWMutex（读写锁）就是用来解决这类 readers-writers 问题的</strong>。所以，这节课，我们就一起来学习 RWMutex。本文会给你介绍读写锁的使用场景、实现原理以及容易掉入的坑，你一定要记住这些陷阱，避免在实际的开发中犯相同的错误。</p>
<br>
<p><strong>什么是 RWMutex？</strong></p>
<p>先简单解释一下读写锁 RWMutex。标准库中的 RWMutex 是一个 reader/writer 互斥锁。RWMutex 在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。</p>
<p>RWMutex 的方法也很少，总共有 5 个。</p>
<ul>
<li><strong>Lock/Unlock</strong>：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</li>
<li><strong>RLock/RUnlock</strong>：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</li>
<li><strong>RLocker</strong>：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</li>
</ul>
<p>RWMutex 的零值是未加锁的状态，所以，当你使用 RWMutex 的时候，无论是声明变量，还是嵌入到其它 struct 中，都不必显式地初始化。</p>
<p>以计数器为例，来说明一下，如何使用 RWMutex 保护共享资源。计数器的 count++操作是写操作，而获取 count 的值是读操作，这个场景非常适合读写锁，因为读操作可以并行执行，写操作时只允许一个线程执行，这正是 readers-writers 问题。</p>
<p>在这个例子中，使用 10 个 goroutine 进行读操作，每读取一次，sleep 1 毫秒，同时，还有一个 gorotine 进行写操作，每一秒写一次，这是一个 1 writer-n reader 的读写场景，而且写操作还不是很频繁（一秒一次）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> counter Counter<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123; <span class="hljs-comment">// 10个reader</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">for</span> &#123;<br>                counter.Count() <span class="hljs-comment">// 计数器读操作</span><br>                time.Sleep(time.Millisecond)<br>            &#125;<br>        &#125;()<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 一个writer</span><br>        counter.Incr() <span class="hljs-comment">// 计数器写操作</span><br>        time.Sleep(time.Second)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 一个线程安全的计数器</span><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mu    sync.RWMutex<br>    count <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 使用写锁保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Incr() &#123;<br>    c.mu.Lock()<br>    c.count++<br>    c.mu.Unlock()<br>&#125;<br><br><span class="hljs-comment">// 使用读锁保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Count() <span class="hljs-type">uint64</span> &#123;<br>    c.mu.RLock()<br>    <span class="hljs-keyword">defer</span> c.mu.RUnlock()<br>    <span class="hljs-keyword">return</span> c.count<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，Incr 方法会修改计数器的值，是一个写操作，我们使用 Lock/Unlock 进行保护。Count 方法会读取当前计数器的值，是一个读操作，我们使用 RLock/RUnlock 方法进行保护。</p>
<p>Incr 方法每秒才调用一次，所以，writer 竞争锁的频次是比较低的，而 10 个 goroutine 每毫秒都要执行一次查询，通过读写锁，可以极大提升计数器的性能，因为在读取的时候，可以并发进行。如果使用 Mutex，性能就不会像读写锁这么好。因为多个 reader 并发读的时候，使用互斥锁导致了 reader 要排队读的情况，没有 RWMutex 并发读的性能好。</p>
<p><strong>如果你遇到可以明确区分 reader 和 writer goroutine 的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁 RWMutex 替换 Mutex</strong>。</p>
<p>在实际使用 RWMutex 的时候，如果我们在 struct 中使用 RWMutex 保护某个字段，一般会把它和这个字段放在一起，用来指示两个字段是一组字段。除此之外，我们还可以采用匿名字段的方式嵌入 struct，这样，在使用这个 struct 时，我们就可以直接调用 Lock/Unlock、RLock/RUnlock 方法了，这和我们前面在 2.1小节 中介绍 Mutex 的使用方法很类似，可以回去复习一下。</p>
<br>
<p><strong>RWMutex 的实现原理</strong></p>
<p>RWMutex 是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。<strong>Go 标准库中的 RWMutex 是基于 Mutex 实现的</strong>。</p>
<p>readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。</p>
<ul>
<li><strong>Read-preferring</strong>：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</li>
<li><strong>Write-preferring</strong>：写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</li>
<li><strong>不指定优先级</strong>：这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</li>
</ul>
<p><strong>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁</strong>。</p>
<p>RWMutex 包含一个 Mutex，以及四个辅助字段 writerSem、readerSem、readerCount 和 readerWait：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>    w           Mutex   <span class="hljs-comment">// 互斥锁解决多个writer的竞争</span><br>    writerSem   <span class="hljs-type">uint32</span>  <span class="hljs-comment">// writer信号量</span><br>    readerSem   <span class="hljs-type">uint32</span>  <span class="hljs-comment">// reader信号量</span><br>    readerCount <span class="hljs-type">int32</span>   <span class="hljs-comment">// reader的数量</span><br>    readerWait  <span class="hljs-type">int32</span>   <span class="hljs-comment">// writer等待完成的reader的数量</span><br>&#125;<br><br><span class="hljs-keyword">const</span> rwmutexMaxReaders = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>
<p>简单解释一下这几个字段。</p>
<ul>
<li>字段 w：为 writer 的竞争锁而设计；</li>
<li>字段 readerCount：记录当前 reader 的数量（以及是否有 writer 竞争锁）；</li>
<li>readerWait：记录 writer 请求锁时需要等待 read 完成的 reader 的数量；</li>
<li>writerSem 和 readerSem：都是为了阻塞设计的信号量。</li>
</ul>
<p>这里的常量 rwmutexMaxReaders，定义了最大的 reader 数量。</p>
<p>好了，知道了 RWMutex 的设计方案和具体字段，下面解释一下具体的方法实现。</p>
<br>
<p><strong>RLock/RUnlock 的实现</strong></p>
<p>首先，我们看一下移除了 race 等无关紧要的代码后的 RLock 和 RUnlock 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span></span> RLock() &#123;<br>    <span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span><br>        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span></span> RUnlock() &#123;<br>    <span class="hljs-keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">-1</span>); r &lt; <span class="hljs-number">0</span> &#123;<br>        rw.rUnlockSlow(r) <span class="hljs-comment">// 有等待的writer</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="hljs-type">int32</span>) &#123;<br>    <span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 最后一个reader了，writer终于有机会获得锁了</span><br>        runtime_Semrelease(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 2 行是对 reader 计数加 1。你可能比较困惑的是，readerCount 怎么还可能为负数呢？其实，这是因为，readerCount 这个字段有双重含义：</p>
<ul>
<li>没有 writer 竞争或持有锁时，readerCount 和我们正常理解的 reader 的计数是一样的；</li>
<li>但是，如果有 writer 竞争锁或者持有锁时，那么，readerCount 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁，在这种情况下，请求锁的 reader 的处理进入第 4 行，阻塞等待锁的释放。</li>
</ul>
<p>调用 RUnlock 的时候，我们需要将 Reader 的计数减去 1（第 8 行），因为 reader 的数量减少了一个。但是，第 8 行的 AddInt32 的返回值还有另外一个含义。如果它是负值，就表示当前有 writer 竞争锁，在这种情况下，还会调用 rUnlockSlow 方法，检查是不是 reader 都释放读锁了，如果读锁都释放了，那么可以唤醒请求写锁的 writer 了。</p>
<p>当一个或者多个 reader 持有锁的时候，竞争锁的 writer 会等待这些 reader 释放完，才可能持有这把锁。打个比方，在房地产行业中有条规矩叫做“买卖不破租赁”，意思是说，就算房东把房子卖了，新业主也不能把当前的租户赶走，而是要等到租约结束后，才能接管房子。这和 RWMutex 的设计是一样的。当 writer 请求锁的时候，是无法改变既有的 reader 持有锁的现实的，也不会强制这些 reader 释放锁，它的优先权只是限定后来的 reader 不要和它抢。</p>
<p>所以，rUnlockSlow 将持有锁的 reader 计数减少 1 的时候，会检查既有的 reader 是不是都已经释放了锁，如果都释放了锁，就会唤醒 writer，让 writer 持有锁。</p>
<br>
<p><strong>Lock</strong></p>
<p>RWMutex 是一个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那么，为了避免 writer 之间的竞争，RWMutex 就会使用一个 Mutex 来保证 writer 的互斥。</p>
<p>一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。</p>
<p>我们来看下下面的代码。第 5 行，还会记录当前活跃的 reader 数量，所谓活跃的 reader，就是指持有读锁还没有释放的那些 reader。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// 首先解决其他writer竞争问题</span><br>    rw.w.Lock()<br>    <span class="hljs-comment">// 反转readerCount，告诉reader有writer竞争锁</span><br>    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<br>    <span class="hljs-comment">// 如果当前有reader持有锁，那么需要等待</span><br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="hljs-number">0</span> &#123;<br>        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 readerCount 不是 0，就说明当前有持有读锁的 reader，RWMutex 需要把这个当前 readerCount 赋值给 readerWait 字段保存下来（第 7 行）， 同时，这个 writer 进入阻塞等待状态（第 8 行）。</p>
<p>每当一个 reader 释放读锁的时候（调用 RUnlock 方法时），readerWait 字段就减 1，直到所有的活跃的 reader 都释放了读锁，才会唤醒这个 writer。</p>
<br>
<p><strong>Unlock</strong></p>
<p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。可以肯定的是，因为当前锁由 writer 持有，所以，readerCount 字段是反转过的，并且减去了 rwmutexMaxReaders 这个常数，变成了负数。所以，这里的反转方法就是给它增加 rwmutexMaxReaders 这个常数值。</p>
<p>既然 writer 要释放锁了，那么就需要唤醒之后新来的 reader，不必再阻塞它们了，让它们开开心心地继续执行就好了。</p>
<p>在 RWMutex 的 Unlock 返回之前，需要把内部的互斥锁释放。释放完毕后，其他的 writer 才可以继续竞争这把锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span></span> Unlock() &#123;<br>    <span class="hljs-comment">// 告诉reader没有活跃的writer了</span><br>    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)<br>    <br>    <span class="hljs-comment">// 唤醒阻塞的reader们</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(r); i++ &#123;<br>        runtime_Semrelease(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-comment">// 释放内部的互斥锁</span><br>    rw.w.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这段代码中，删除了 race 的处理和异常情况的检查，总体看来还是比较简单的。这里有几个重点，需要再提醒你一下。首先，你要理解 readerCount 这个字段的含义以及反转方式。其次，你还要注意字段的更改和内部互斥锁的顺序关系。在 Lock 方法中，是先获取内部互斥锁，才会修改的其他字段；而在 Unlock 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</p>
<p>好了，到这里我们就完整学习了 RWMutex 的概念和实现原理。RWMutex 的应用场景非常明确，就是解决 readers-writers 问题。学完了今天的内容，之后当你遇到这类问题时，要优先想到 RWMutex。另外，Go 并发原语代码实现的质量都很高，非常精炼和高效，所以，你可以通过看它们的实现原理，学习一些编程的技巧。当然，还有非常重要的一点就是要知道 reader 或者 writer 请求锁的时候，既有的 reader/writer 和后续请求锁的 reader/writer 之间的（释放锁 / 请求锁）顺序关系。</p>
<br>
<p>虽然 RWMutex 暴露的 API 也很简单，使用起来也没有复杂的逻辑，但是和 Mutex 一样，在实际使用的时候，也会很容易踩到一些坑。接下来，重点介绍 3 个常见的踩坑点。</p>
<p><strong>RWMutex 的 3 个踩坑点</strong></p>
<p><strong>坑点 1：不可复制</strong></p>
<p>前面刚刚说过，RWMutex 是由一个互斥锁和四个辅助字段组成的。我们很容易想到，互斥锁是不可复制的，再加上四个有状态的字段，RWMutex 就更加不能复制使用了。</p>
<p>不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。</p>
<p>那该怎么办呢？其实，解决方案也和互斥锁一样。你可以借助 vet 工具，在变量赋值、函数传参、函数返回值、遍历数据、struct 初始化等时，检查是否有读写锁隐式复制的情景。</p>
<p><strong>坑点 2：重入导致死锁</strong></p>
<p>读写锁因为重入（或递归调用）导致死锁的情况更多。 先介绍<strong>第一种</strong>情况。因为读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 Lock 的时候，就会出现死锁的现象，这个问题，我们在学习互斥锁的时候已经了解过了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(l *sync.RWMutex)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>    l.Lock()<br>    bar(l)<br>    l.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">(l *sync.RWMutex)</span></span> &#123;<br>    l.Lock()<br>    fmt.Println(<span class="hljs-string">&quot;in bar&quot;</span>)<br>    l.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    l := &amp;sync.RWMutex&#123;&#125;<br>    foo(l)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行这个程序，你就会得到死锁的错误输出，在 Go 运行的时候，很容易就能检测出来。</p>
<p><strong>第二种</strong>死锁的场景有点隐蔽。我们知道，有活跃 reader 的时候，writer 会等待，如果我们在 reader 的读操作时调用 writer 的写操作（它会调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态。Reader 想等待 writer 完成后再释放锁，而 writer 需要这个 reader 释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。</p>
<p><strong>第三种</strong>死锁的场景更加隐蔽。 当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer。</p>
<p>这个死锁相当隐蔽，原因在于它和 RWMutex 的设计和实现有关。啥意思呢？我们来看一个计算阶乘 (n!) 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.RWMutex<br><br>    <span class="hljs-comment">// writer,稍微等待，然后制造一个调用Lock的场景</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">200</span> * time.Millisecond)<br>        mu.Lock()<br>        fmt.Println(<span class="hljs-string">&quot;Lock&quot;</span>)<br>        time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>        mu.Unlock()<br>        fmt.Println(<span class="hljs-string">&quot;Unlock&quot;</span>)<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        factorial(&amp;mu, <span class="hljs-number">10</span>) <span class="hljs-comment">// 计算10的阶乘, 10!</span><br>    &#125;()<br>    <br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 递归调用计算阶乘</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">factorial</span><span class="hljs-params">(m *sync.RWMutex, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 阶乘退出条件 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;RLock&quot;</span>)<br>    m.RLock()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;RUnlock&quot;</span>)<br>        m.RUnlock()<br>    &#125;()<br>    time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>    <span class="hljs-keyword">return</span> factorial(m, n<span class="hljs-number">-1</span>) * n <span class="hljs-comment">// 递归调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>factoria 方法是一个递归计算阶乘的方法，我们用它来模拟 reader。为了更容易地制造出死锁场景，在这里加上了 sleep 的调用，延缓逻辑的执行。这个方法会调用读锁（第 27 行），在第 33 行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。</p>
<p>同时，我们使用另一个 goroutine 去调用 Lock 方法，来实现 writer，这个 writer 会等待 200 毫秒后才会调用 Lock，这样在调用 Lock 的时候，factoria 方法还在执行中不断调用 RLock。</p>
<p>这两个 goroutine 互相持有锁并等待，谁也不会退让一步，满足了“writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer”的死锁条件，所以就导致了死锁的产生。</p>
<p>所以，使用读写锁最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。</p>
<p><strong>坑点 3：释放未加锁的 RWMutex</strong></p>
<p>和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic。在生产环境中出现 panic 是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，不遗漏不多余。</p>
<br>
<p><strong>流行的 Go 开发项目中的坑</strong></p>
<p>Docker issue 36840</p>
<p><a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/36840/files">issue 36840</a>修复的是错误地把 writer 当成 reader 的 Bug。 这个地方本来需要修改数据，需要调用的是写锁，结果用的却是读锁。或许是被它紧挨着的 findNode 方法调用迷惑了，认为这只是一个读操作。可实际上，代码后面还会有 changeNodeState 方法的调用，这是一个写操作。修复办法也很简单，只需要改成 Lock/Unlock 即可。</p>
<p>Kubernetes issue 62464</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/62464">issue 62464</a>就是读写锁第二种死锁的场景，这是一个典型的 reader 导致的死锁的例子。知道墨菲定律吧？“凡是可能出错的事，必定会出错”。你可能觉得前面讲的 RWMutex 的坑绝对不会被人踩的，因为道理大家都懂，但是你看，Kubernetes 就踩了这个重入的坑。</p>
<p>这个 issue 在移除 pod 的时候可能会发生，原因就在于，GetCPUSetOrDefault 方法会请求读锁，同时，它还会调用 GetCPUSet 或 GetDefaultCPUSet 方法，这时又会请求读锁。如果期间有其它 goroutine 请求写锁的话，GetCPUSetOrDefault 方法调用 GetCPUSet 或 GetDefaultCPUSet 方法时就不会返回了，请求写锁的 goroutine 也不会返回，这就会形成死锁。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-6-WaitGroup：协同等待，任务编排利器">2.6 WaitGroup：协同等待，任务编排利器</h3>
<p>其实，WaitGroup 很简单，就是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题：现在有一个 goroutine A 在检查点（checkpoint）等待一组 goroutine 全部完成，如果在执行任务的这些 goroutine 还没全部完成，那么 goroutine A 就会阻塞在检查点，直到所有 goroutine 都完成后才能继续执行。</p>
<p>我们来看一个使用 WaitGroup 的场景。</p>
<p>比如，我们要完成一个大的任务，需要使用并行的 goroutine 执行三个小任务，只有这三个小任务都完成，我们才能去执行后面的任务。如果通过轮询的方式定时询问三个小任务是否完成，会存在两个问题：一是，性能比较低，因为三个小任务可能早就完成了，却要等很长时间才被轮询到；二是，会有很多无谓的轮询，空耗 CPU 资源。</p>
<p>那么，这个时候使用 WaitGroup 并发原语就比较有效了，它可以阻塞等待的 goroutine。等到三个小任务都完成了，再即时唤醒它们。</p>
<p>其实，很多操作系统和编程语言都提供了类似的并发原语。比如，Linux 中的 barrier、Pthread（POSIX 线程）中的 barrier、C++ 中的 std::barrier、Java 中的 CyclicBarrier 和 CountDownLatch 等。由此可见，这个并发原语还是一个非常基础的并发类型。所以，我们要认真掌握今天的内容，这样就可以举一反三，轻松应对其他场景下的需求了。<br>
我们还是从 WaitGroup 的基本用法学起吧。</p>
<br>
<p><strong>WaitGroup 的基本用法</strong></p>
<p>Go 标准库中的 WaitGroup 提供了三个方法，保持了 Go 简洁的风格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Add(delta <span class="hljs-type">int</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Done()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Wait()<br></code></pre></td></tr></table></figure>
<p>我们分别看下这三个方法：</p>
<ul>
<li><strong>Add</strong>，用来设置 WaitGroup 的计数值；</li>
<li><strong>Done</strong>，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li>
<li><strong>Wait</strong>，调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li>
</ul>
<p>接下来，我们通过一个使用 WaitGroup 的例子，来看下 Add、Done、Wait 方法的基本用法。</p>
<p>在这个例子中，我们使用了以前实现的计数器 struct。我们启动了 10 个 worker，分别对计数值加一，10 个 worker 都完成后，我们期望输出计数器的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 线程安全的计数器</span><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mu    sync.Mutex<br>    count <span class="hljs-type">uint64</span><br>&#125;<br><span class="hljs-comment">// 对计数值加一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Incr() &#123;<br>    c.mu.Lock()<br>    c.count++<br>    c.mu.Unlock()<br>&#125;<br><span class="hljs-comment">// 获取当前的计数值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Count() <span class="hljs-type">uint64</span> &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    <span class="hljs-keyword">return</span> c.count<br>&#125;<br><span class="hljs-comment">// sleep 1秒，然后计数值加1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(c *Counter, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br>    time.Sleep(time.Second)<br>    c.Incr()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> counter Counter<br>    <br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>) <span class="hljs-comment">// WaitGroup的值设置为10</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123; <span class="hljs-comment">// 启动10个goroutine执行加1任务</span><br>        <span class="hljs-keyword">go</span> worker(&amp;counter, &amp;wg)<br>    &#125;<br>    <span class="hljs-comment">// 检查点，等待goroutine都完成任务</span><br>    wg.Wait()<br>    <span class="hljs-comment">// 输出当前计数器的值</span><br>    fmt.Println(counter.Count())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们一起来分析下这段代码。</p>
<p>第 28 行，声明了一个 WaitGroup 变量，初始值为零。<br>
第 29 行，把 WaitGroup 变量的计数值设置为 10。因为我们需要编排 10 个 goroutine(worker) 去执行任务，并且等待 goroutine 完成。<br>
第 35 行，调用 Wait 方法阻塞等待。<br>
第 32 行，启动了 goroutine，并把我们定义的 WaitGroup 指针当作参数传递进去。goroutine 完成后，需要调用 Done 方法，把 WaitGroup 的计数值减 1。等 10 个 goroutine 都调用了 Done 方法后，WaitGroup 的计数值降为 0，这时，第 35 行的主 goroutine 就不再阻塞，会继续执行，在第 37 行输出计数值。</p>
<p>这就是我们使用 WaitGroup 编排这类任务的常用方式。而“这类任务”指的就是，需要启动多个 goroutine 执行任务，主 goroutine 需要等待子 goroutine 都完成后才继续执行。</p>
<p>这就是我们使用 WaitGroup 编排这类任务的常用方式。而“这类任务”指的就是，需要启动多个 goroutine 执行任务，主 goroutine 需要等待子 goroutine 都完成后才继续执行。</p>
<p>熟悉了 WaitGroup 的基本用法后，我们再看看它具体是如何实现的吧。</p>
<br>
<p><strong>WaitGroup 的实现</strong></p>
<p>首先，我们看看 WaitGroup 的数据结构。它包括了一个 noCopy 的辅助字段，一个 state1 记录 WaitGroup 状态的数组。</p>
<ul>
<li>noCopy 的辅助字段，主要就是辅助 vet 工具检查是否通过 copy 赋值这个 WaitGroup 实例。本文会在后面和你详细分析这个字段；</li>
<li>state1，一个具有复合意义的字段，包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。</li>
</ul>
<p>WaitGroup 的数据结构定义以及 state 信息的获取方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span><br>    noCopy noCopy<br>    <span class="hljs-comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span><br>    <span class="hljs-comment">// 另外32bit是用作信号量的</span><br>    <span class="hljs-comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span><br>    <span class="hljs-comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span><br>    state1 [<span class="hljs-number">3</span>]<span class="hljs-type">uint32</span><br>&#125;<br><br><br><span class="hljs-comment">// 得到state的地址和信号量的地址</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> state() (statep *<span class="hljs-type">uint64</span>, semap *<span class="hljs-type">uint32</span>) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="hljs-number">8</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span><br>        <span class="hljs-keyword">return</span> (*<span class="hljs-type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="hljs-number">2</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span><br>        <span class="hljs-keyword">return</span> (*<span class="hljs-type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="hljs-number">1</span>])), &amp;wg.state1[<span class="hljs-number">0</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的，所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</p>
<p>在 64 位环境下，state1 的第一个元素是 waiter 数，第二个元素是 WaitGroup 的计数值，第三个元素是信号量。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/71b5fyy6284140986d04c0b6f87aedea.webp" alt=""></p>
<p>在 32 位环境下，如果 state1 不是 64 位对齐的地址，那么 state1 的第一个元素是信号量，后两个元素分别是 waiter 数和计数值。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/22c40ac54cfeb53669a6ae39020c23ac.webp" alt=""></p>
<p>然后，我们继续深入源码，看一下 Add、Done 和 Wait 这三个方法的实现。</p>
<p>在查看这部分源码实现时，我们会发现，除了这些方法本身的实现外，还会有一些额外的代码，主要是 race 检查和异常检查的代码。其中，有几个检查非常关键，如果检查不通过，会出现 panic，这部分内容会在下一小节分析 WaitGroup 的错误使用场景时介绍。现在，我们先专注在 Add、Wait 和 Done 本身的实现代码上。</p>
<p>先梳理下 Add 方法的逻辑。Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值，内部通过原子操作把这个值加到计数值上。需要注意的是，这个 delta 也可以是个负数，相当于为计数值减去一个值，Done 方法内部其实就是通过 Add(-1) 实现的。</p>
<p>它的实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Add(delta <span class="hljs-type">int</span>) &#123;<br>    statep, semap := wg.state()<br>    <span class="hljs-comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span><br>    state := atomic.AddUint64(statep, <span class="hljs-type">uint64</span>(delta)&lt;&lt;<span class="hljs-number">32</span>)<br>    v := <span class="hljs-type">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>) <span class="hljs-comment">// 当前计数值</span><br>    w := <span class="hljs-type">uint32</span>(state) <span class="hljs-comment">// waiter count</span><br><br>    <span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> || w == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span><br>    <span class="hljs-comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span><br>    *statep = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; w != <span class="hljs-number">0</span>; w-- &#123;<br>        runtime_Semrelease(semap, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Done方法实际就是计数器减1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Done() &#123;<br>    wg.Add(<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Wait 方法的实现逻辑是：不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0，说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。</p>
<p>其主干实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Wait() &#123;<br>    statep, semap := wg.state()<br>    <br>    <span class="hljs-keyword">for</span> &#123;<br>        state := atomic.LoadUint64(statep)<br>        v := <span class="hljs-type">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>) <span class="hljs-comment">// 当前计数值</span><br>        w := <span class="hljs-type">uint32</span>(state) <span class="hljs-comment">// waiter的数量</span><br>        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 如果计数值为0, 调用这个方法的goroutine不必再等待，继续执行它后面的逻辑即可</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环</span><br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 阻塞休眠等待</span><br>            runtime_Semacquire(semap)<br>            <span class="hljs-comment">// 被唤醒，不再阻塞，返回</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>使用 WaitGroup 时的常见错误</strong></p>
<p>在分析 WaitGroup 的 Add、Done 和 Wait 方法的实现的时候，为避免干扰，删除了异常检查的代码。但是，这些异常检查非常有用。</p>
<p>我们在开发的时候，经常会遇见或看到误用 WaitGroup 的场景，究其原因就是没有弄明白这些检查的逻辑。所以接下来，我们就通过几个小例子，一起学习下在开发时绝对要避免的 3 个问题。</p>
<p><strong>常见问题一：计数器设置为负值</strong></p>
<p>WaitGroup 的计数器的值必须大于等于 0。我们在更改这个计数值的时候，WaitGroup 会先做检查，如果计数值被设置为负数，就会导致 panic。 一般情况下，有两种方法会导致计数器设置为负数。</p>
<p>第一种方法是：调用 Add 的时候传递一个负数。如果你能保证当前的计数器加上这个负数后还是大于等于 0 的话，也没有问题，否则就会导致 panic。</p>
<p>比如下面这段代码，计数器的初始值为 10，当第一次传入 -10 的时候，计数值被设置为 0，不会有啥问题。但是，再紧接着传入 -1 以后，计数值就被设置为负数了，程序就会出现 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">10</span>)<br><br>    wg.Add(<span class="hljs-number">-10</span>)<span class="hljs-comment">//将-10作为参数调用Add，计数值被设置为0</span><br><br>    wg.Add(<span class="hljs-number">-1</span>)<span class="hljs-comment">//将-1作为参数调用Add，如果加上-1计数值就会变为负数。这是不对的，所以会触发panic</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二个方法是：调用 Done 方法的次数过多，超过了 WaitGroup 的计数值。</p>
<p><strong>使用 WaitGroup 的正确姿势是，预先确定好 WaitGroup 的计数值，然后调用相同次数的 Done 完成相应的任务。</strong> 比如，在 WaitGroup 变量声明之后，就立即设置它的计数值，或者在 goroutine 启动之前增加 1，然后在 goroutine 中调用 Done。</p>
<p>如果你没有遵循这些规则，就很可能会导致 Done 方法调用的次数和计数值不一致，进而造成死锁（Done 调用次数比计数值少）或者 panic（Done 调用次数比计数值多）。</p>
<p>比如下面这个例子中，多调用了一次 Done 方法后，会导致计数值为负，所以程序运行到这一行会出现 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">1</span>)<br><br>    wg.Done()<br><br>    wg.Done()<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常见问题二：不期望的 Add 时机</strong></p>
<p>在使用 WaitGroup 的时候，你一定要遵循的原则就是，<strong>等所有的 Add 方法调用之后再调用 Wait</strong>，否则就可能导致 panic 或者不期望的结果。</p>
<p>我们构造这样一个场景：只有部分的 Add/Done 执行完后，Wait 就返回。我们看一个例子：启动四个 goroutine，每个 goroutine 内部调用 Add(1) 然后调用 Done()，主 goroutine 调用 Wait 等待任务完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">100</span>, &amp;wg) <span class="hljs-comment">// 启动第一个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">110</span>, &amp;wg) <span class="hljs-comment">// 启动第二个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">120</span>, &amp;wg) <span class="hljs-comment">// 启动第三个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">130</span>, &amp;wg) <span class="hljs-comment">// 启动第四个goroutine</span><br><br>    wg.Wait() <span class="hljs-comment">// 主goroutine等待完成</span><br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(millisecs time.Duration, wg *sync.WaitGroup)</span></span> &#123;<br>    duration := millisecs * time.Millisecond<br>    time.Sleep(duration) <span class="hljs-comment">// 故意sleep一段时间</span><br><br>    wg.Add(<span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;后台执行, duration:&quot;</span>, duration)<br>    wg.Done()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，我们原本设想的是，等四个 goroutine 都执行完毕后输出 Done 的信息，但是它的错误之处在于，将 WaitGroup.Add 方法的调用放在了子 gorotuine 中。等主 goorutine 调用 Wait 的时候，因为四个任务 goroutine 一开始都休眠，所以可能 WaitGroup 的 Add 方法还没有被调用，WaitGroup 的计数还是 0，所以它并没有等待四个子 goroutine 执行完毕才继续执行，而是立刻执行了下一步。</p>
<p>导致这个错误的原因是，没有遵循先完成所有的 Add 之后才 Wait。要解决这个问题，一个方法是，预先设置计数值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">4</span>) <span class="hljs-comment">// 预先设定WaitGroup的计数值</span><br><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">100</span>, &amp;wg) <span class="hljs-comment">// 启动第一个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">110</span>, &amp;wg) <span class="hljs-comment">// 启动第二个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">120</span>, &amp;wg) <span class="hljs-comment">// 启动第三个goroutine</span><br>    <span class="hljs-keyword">go</span> dosomething(<span class="hljs-number">130</span>, &amp;wg) <span class="hljs-comment">// 启动第四个goroutine</span><br><br>    wg.Wait() <span class="hljs-comment">// 主goroutine等待</span><br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(millisecs time.Duration, wg *sync.WaitGroup)</span></span> &#123;<br>    duration := millisecs * time.Millisecond<br>    time.Sleep(duration)<br><br>    fmt.Println(<span class="hljs-string">&quot;后台执行, duration:&quot;</span>, duration)<br>    wg.Done()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一种方法是在启动子 goroutine 之前才调用 Add：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    dosomething(<span class="hljs-number">100</span>, &amp;wg) <span class="hljs-comment">// 调用方法，把计数值加1，并启动任务goroutine</span><br>    dosomething(<span class="hljs-number">110</span>, &amp;wg) <span class="hljs-comment">// 调用方法，把计数值加1，并启动任务goroutine</span><br>    dosomething(<span class="hljs-number">120</span>, &amp;wg) <span class="hljs-comment">// 调用方法，把计数值加1，并启动任务goroutine</span><br>    dosomething(<span class="hljs-number">130</span>, &amp;wg) <span class="hljs-comment">// 调用方法，把计数值加1，并启动任务goroutine</span><br><br>    wg.Wait() <span class="hljs-comment">// 主goroutine等待，代码逻辑保证了四次Add(1)都已经执行完了</span><br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(millisecs time.Duration, wg *sync.WaitGroup)</span></span> &#123;<br>    wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 计数值加1，再启动goroutine</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        duration := millisecs * time.Millisecond<br>        time.Sleep(duration)<br>        fmt.Println(<span class="hljs-string">&quot;后台执行, duration:&quot;</span>, duration)<br>        wg.Done()<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见，无论是怎么修复，都要保证所有的 Add 方法是在 Wait 方法之前被调用的。</p>
<p><strong>常见问题三：前一个 Wait 还没结束就重用 WaitGroup</strong></p>
<p>“前一个 Wait 还没结束就重用 WaitGroup”这一点似乎不太好理解，现在借用田径比赛的例子和你解释下吧。在田径比赛的百米小组赛中，需要把选手分成几组，一组选手比赛完之后，就可以进行下一组了。为了确保两组比赛时间上没有冲突，我们在模型化这个场景的时候，可以使用 WaitGroup。</p>
<p>WaitGroup 等一组比赛的所有选手都跑完后 5 分钟，才开始下一组比赛。下一组比赛还可以使用这个 WaitGroup 来控制，因为 WaitGroup 是可以重用的。只要 WaitGroup 的计数值恢复到零值的状态，那么它就可以被看作是新创建的 WaitGroup，被重复使用。</p>
<p>但是，如果我们在 WaitGroup 的计数值还没有恢复到零值的时候就重用，就会导致程序 panic。我们看一个例子，初始设置 WaitGroup 的计数值为 1，启动一个 goroutine 先调用 Done 方法，接着就调用 Add 方法，Add 方法有可能和主 goroutine 并发执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(time.Millisecond)<br>        wg.Done() <span class="hljs-comment">// 计数器减1</span><br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 计数值加1</span><br>    &#125;()<br>    wg.Wait() <span class="hljs-comment">// 主goroutine等待，有可能和第7行并发执行</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，第 6 行虽然让 WaitGroup 的计数恢复到 0，但是因为第 9 行有个 waiter 在等待，如果等待 Wait 的 goroutine，刚被唤醒就和 Add 调用（第 7 行）有并发执行的冲突，所以就会出现 panic。</p>
<p>总结一下：WaitGroup 虽然可以重用，但是是有一个前提的，那就是必须等到上一轮的 Wait 完成之后，才能重用 WaitGroup 执行下一轮的 Add/Wait，如果你在 Wait 还没执行完的时候就调用下一轮 Add 方法，就有可能出现 panic。</p>
<br>
<p><strong>noCopy：辅助 vet 检查</strong></p>
<p>我们刚刚在学习 WaitGroup 的数据结构时，提到了里面有一个 noCopy 字段。你还记得它的作用吗？其实，它就是指示 vet 工具在做检查的时候，这个数据结构不能做值复制使用。更严谨地说，是不能在第一次使用之后复制使用 ( must not be copied after first use)。</p>
<p>你可能会说了，为什么要把 noCopy 字段单独拿出来讲呢？一方面，把 noCopy 字段穿插到 waitgroup 代码中讲解，容易干扰我们对 WaitGroup 整体的理解。另一方面，也是非常重要的原因，noCopy 是一个通用的计数技术，其他并发原语中也会用到，所以单独介绍有助于你以后在实践中使用这个技术。</p>
<p>我们在 2.3小节 学习 Mutex 的时候用到了 vet 工具。vet 会对实现 Locker 接口的数据类型做静态检查，一旦代码中有复制使用这种数据类型的情况，就会发出警告。但是，WaitGroup 同步原语不就是 Add、Done 和 Wait 方法吗？vet 能检查出来吗？</p>
<p>其实是可以的。通过给 WaitGroup 添加一个 noCopy 字段，我们就可以为 WaitGroup 实现 Locker 接口，这样 vet 工具就可以做复制检查了。而且因为 noCopy 字段是未输出类型，所以 WaitGroup 不会暴露 Lock/Unlock 方法。</p>
<p>noCopy 字段的类型是 noCopy，它只是一个辅助的、用来帮助 vet 检查用的类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> noCopy <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Lock is a no-op used by -copylocks checker from `go vet`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span></span> Lock()   &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span></span> Unlock() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>如果你想要自己定义的数据结构不被复制使用，或者说，不能通过 vet 工具检查出复制使用的报警，就可以通过嵌入 noCopy 这个数据类型来实现。</p>
<br>
<p><strong>流行的 Go 开发项目中的坑</strong></p>
<p>有网友在 Go 的<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/28123">issue 28123</a>中提了以下的例子，你能发现这段代码有什么问题吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestStruct <span class="hljs-keyword">struct</span> &#123;<br>  Wait sync.WaitGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  w := sync.WaitGroup&#123;&#125;<br>  w.Add(<span class="hljs-number">1</span>)<br>  t := &amp;TestStruct&#123;<br>    Wait: w,<br>  &#125;<br><br>  t.Wait.Done()<br>  fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码最大的一个问题，就是第 9 行 copy 了 WaitGroup 的实例 w。虽然这段代码能执行成功，但确实是违反了 WaitGroup 使用之后不要复制的规则。在项目中，我们可以通过 vet 工具检查出这样的错误。</p>
<p>Docker <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/28161">issue 28161</a> 和 <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/27011">issue 27011</a>  ，都是因为在重用 WaitGroup 的时候，没等前一次的 Wait 结束就 Add 导致的错误。Etcd <a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/issues/6534">issue 6534</a> 也是重用 WaitGroup 的 Bug，没有等前一个 Wait 结束就 Add。</p>
<p>Kubernetes <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/59574">issue 59574</a> 的 Bug 是忘记 Wait 之前增加计数了，这就属于我们通常认为几乎不可能出现的 Bug。</p>
<p>即使是开发 Go 语言的开发者自己，在使用 WaitGroup 的时候，也可能会犯错。比如 <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/12813">issue 12813</a>，因为 defer 的使用，Add 方法可能在 Done 之后才执行，导致计数负值的 panic。</p>
<br>
<p><strong>总结</strong></p>
<p>学完这一讲，我们知道了使用 WaitGroup 容易犯的错，是不是有些手脚被束缚的感觉呢？其实大可不必，只要我们不是特别复杂地使用 WaitGroup，就不用有啥心理负担。</p>
<p>而关于如何避免错误使用 WaitGroup 的情况，我们只需要尽量保证下面 5 点就可以了：</p>
<ul>
<li>不重用 WaitGroup。新建一个 WaitGroup 不会带来多大的资源开销，重用反而更容易出错。</li>
<li>保证所有的 Add 方法调用都在 Wait 之前。</li>
<li>不传递负数给 Add 方法，只通过 Done 来给计数值减 1。</li>
<li>不做多余的 Done 方法调用，保证 Add 的计数值和 Done 方法调用的数量是一样的。</li>
<li>不遗漏 Done 方法的调用，否则会导致 Wait hang 住无法返回。</li>
</ul>
<hr>
<p><br><br><br></p>
<h3 id="2-7-Cond：条件变量的实现机制及避坑指南">2.7 Cond：条件变量的实现机制及避坑指南</h3>
<p>在 Java 面试中，经常被问到的一个知识点就是等待 / 通知（wait/notify）机制。面试官经常会这样考察候选人：请实现一个限定容量的队列（queue），当队列满或者空的时候，利用等待 / 通知机制实现阻塞或者唤醒。</p>
<p>在 Go 中，也可以实现一个类似的限定容量的队列，而且实现起来也比较简单，只要用条件变量（Cond）并发原语就可以。Cond 并发原语相对来说不是那么常用，但是在特定的场景使用会事半功倍，比如你需要在唤醒一个或者所有的等待者做一些检查操作的时候。<br>
那么今天这一讲，我们就学习下 Cond 这个并发原语。</p>
<br>
<p><strong>Go 标准库的 Cond</strong></p>
<p>Go 标准库提供 Cond 原语的目的是，为等待 / 通知场景下的并发问题提供支持。Cond 通常应用于等待某个条件的一组 goroutine，等条件变为 true 的时候，其中一个 goroutine 或者所有的 goroutine 都会被唤醒执行。</p>
<p>顾名思义，Cond 是和某个条件相关，这个条件需要一组 goroutine 协作共同完成，在条件还没有满足的时候，所有等待这个条件的 goroutine 都会被阻塞住，只有这一组 goroutine 通过协作达到了这个条件，等待的 goroutine 才可能继续进行下去。</p>
<p>那这里等待的条件是什么呢？等待的条件，可以是某个变量达到了某个阈值或者某个时间点，也可以是一组变量分别都达到了某个阈值，还可以是某个对象的状态满足了特定的条件。总结来讲，等待的条件是一种可以用来计算结果是 true 还是 false 的条件。</p>
<p>从开发实践上，我们真正使用 Cond 的场景比较少，因为一旦遇到需要使用 Cond 的场景，我们更多地会使用 Channel 的方式（我们会在第 12 和第 13 讲展开 Channel 的用法）去实现，因为那才是更地道的 Go 语言的写法，甚至 Go 的开发者有个“把 Cond 从标准库移除”的提议（<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/21165">issue 21165</a>）。而有的开发者认为，Cond 是唯一难以掌握的 Go 并发原语。至于其中原因，先卖个关子，到这一讲的后半部分再解释。</p>
<p>今天，这一讲我们就带你仔细地学一学 Cond 这个并发原语吧。</p>
<br>
<p><strong>Cond 的基本用法</strong></p>
<p>标准库中的 Cond 并发原语初始化的时候，需要关联一个 Locker 接口的实例，一般我们使用 Mutex 或者 RWMutex。</p>
<p>我们看一下 Cond 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cond<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NeWCond</span><span class="hljs-params">(l Locker)</span></span> *Cond<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait()<br></code></pre></td></tr></table></figure>
<p>首先，Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着一个先入先出的等待队列。</p>
<p>然后，我们分别看下它的三个方法 Broadcast、Signal 和 Wait 方法。</p>
<p><strong>Signal</strong> 方法，允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中，比如 Java 语言中，Signal 方法也被叫做 notify 方法。</p>
<p>调用 Signal 方法时，不强求你一定要持有 c.L 的锁。</p>
<p><strong>Broadcast</strong> 方法，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。</p>
<p>同样地，调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。</p>
<p><strong>Wait</strong> 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。</p>
<p>调用 Wait 方法时必须要持有 c.L 的锁。</p>
<p>Go 实现的 sync.Cond 的方法名是 Wait、Signal 和 Broadcast，这是计算机科学中条件变量的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2">通用方法名</a>。比如，C 语言中对应的方法名是 pthread_cond_wait、pthread_cond_signal 和 pthread_cond_broadcast。</p>
<p>知道了 Cond 提供的三个方法后，我们再通过一个百米赛跑开始时的例子，来学习下 Cond 的使用方法。10 个运动员进入赛场之后需要先做拉伸活动活动筋骨，向观众和粉丝招手致敬，在自己的赛道上做好准备；等所有的运动员都准备好之后，裁判员才会打响发令枪。</p>
<p>每个运动员做好准备之后，将 ready 加一，表明自己做好准备了，同时调用 Broadcast 方法通知裁判员。因为裁判员只有一个，所以这里可以直接替换成 Signal 方法调用。调用 Broadcast 方法的时候，我们并没有请求 c.L 锁，只是在更改等待变量的时候才使用到了锁。</p>
<p>裁判员会等待运动员都准备好（第 22 行）。虽然每个运动员准备好之后都唤醒了裁判员，但是裁判员被唤醒之后需要检查等待条件是否满足（运动员都准备好了）。可以看到，裁判员被唤醒之后一定要检查等待条件，如果条件不满足还是要继续等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br>    <span class="hljs-keyword">var</span> ready <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            time.Sleep(time.Duration(rand.Int63n(<span class="hljs-number">10</span>)) * time.Second)<br><br>            <span class="hljs-comment">// 加锁更改等待条件</span><br>            c.L.Lock()<br>            ready++<br>            c.L.Unlock()<br><br>            log.Printf(<span class="hljs-string">&quot;运动员#%d 已准备就绪\n&quot;</span>, i)<br>            <span class="hljs-comment">// 广播唤醒所有的等待者</span><br>            c.Broadcast()<br>        &#125;(i)<br>    &#125;<br><br>    c.L.Lock()<br>    <span class="hljs-keyword">for</span> ready != <span class="hljs-number">10</span> &#123;<br>        c.Wait()<br>        log.Println(<span class="hljs-string">&quot;裁判员被唤醒一次&quot;</span>)<br>    &#125;<br>    c.L.Unlock()<br><br>    <span class="hljs-comment">//所有的运动员是否就绪</span><br>    log.Println(<span class="hljs-string">&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你看，Cond 的使用其实没那么简单。它的复杂在于：一，这段代码有时候需要加锁，有时候可以不加；二，Wait 唤醒后需要检查条件；三，条件变量的更改，其实是需要原子操作或者互斥锁保护的。所以，有的开发者会认为，Cond 是唯一难以掌握的 Go 并发原语。</p>
<br>
<p>Cond 的实现原理<br>
其实，Cond 的实现非常简单，或者说复杂的逻辑已经被 Locker 或者 runtime 的等待队列实现了。我们直接看看 Cond 的源码吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cond <span class="hljs-keyword">struct</span> &#123;<br>    noCopy noCopy<br><br>    <span class="hljs-comment">// 当观察或者修改等待条件的时候需要加锁</span><br>    L Locker<br><br>    <span class="hljs-comment">// 等待队列</span><br>    notify  notifyList<br>    checker copyChecker<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCond</span><span class="hljs-params">(l Locker)</span></span> *Cond &#123;<br>    <span class="hljs-keyword">return</span> &amp;Cond&#123;L: l&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait() &#123;<br>    c.checker.check()<br>    <span class="hljs-comment">// 增加到等待队列中</span><br>    t := runtime_notifyListAdd(&amp;c.notify)<br>    c.L.Unlock()<br>    <span class="hljs-comment">// 阻塞休眠直到被唤醒</span><br>    runtime_notifyListWait(&amp;c.notify, t)<br>    c.L.Lock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal() &#123;<br>    c.checker.check()<br>    runtime_notifyListNotifyOne(&amp;c.notify)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast() &#123;<br>    c.checker.check()<br>    runtime_notifyListNotifyAll(&amp;c.notify）<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这部分源码确实很简单，以下是其中比较关键的逻辑。</p>
<p>runtime_notifyListXXX 是运行时实现的方法，实现了一个等待 / 通知的队列。如果你想深入学习这部分，可以再去看看 runtime/sema.go 代码中。</p>
<p>copyChecker 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。</p>
<p>Signal 和 Broadcast 只涉及到 notifyList 数据结构，不涉及到锁。</p>
<p>Wait 把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他 goroutine 有机会检查或者更新等待变量。</p>
<p>我们继续看看使用 Cond 常见的两个错误，一个是调用 Wait 的时候没有加锁，另一个是没有检查条件是否满足程序就继续执行了。</p>
<br>
<p><strong>使用 Cond 的 2 个常见错误</strong></p>
<p>我们先看 <strong>Cond 最常见的使用错误，也就是调用 Wait 的时候没有加锁</strong>。</p>
<p>以前面百米赛跑的程序为例，在调用 cond.Wait 时，把前后的 Lock/Unlock 注释掉，如下面的代码中的第 20 行和第 25 行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br>    <span class="hljs-keyword">var</span> ready <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            time.Sleep(time.Duration(rand.Int63n(<span class="hljs-number">10</span>)) * time.Second)<br><br>            <span class="hljs-comment">// 加锁更改等待条件</span><br>            c.L.Lock()<br>            ready++<br>            c.L.Unlock()<br><br>            log.Printf(<span class="hljs-string">&quot;运动员#%d 已准备就绪\n&quot;</span>, i)<br>            <span class="hljs-comment">// 广播唤醒所有的等待者</span><br>            c.Broadcast()<br>        &#125;(i)<br>    &#125;<br><br>    <span class="hljs-comment">// c.L.Lock()</span><br>    <span class="hljs-keyword">for</span> ready != <span class="hljs-number">10</span> &#123;<br>        c.Wait()<br>        log.Println(<span class="hljs-string">&quot;裁判员被唤醒一次&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// c.L.Unlock()</span><br><br>    <span class="hljs-comment">//所有的运动员是否就绪</span><br>    log.Println(<span class="hljs-string">&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再运行程序，就会报释放未加锁的 panic：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/4780dca40087277be0d183674bc42c76.webp" alt=""></p>
<p>出现这个问题的原因在于，cond.Wait 方法的实现是，把当前调用者加入到 notify 队列之中后会释放锁（如果不释放锁，其他 Wait 的调用者就没有机会加入到 notify 队列中了），然后一直等待；等调用者被唤醒之后，又会去争抢这把锁。如果调用 Wait 之前不加锁的话，就有可能 Unlock 一个未加锁的 Locker。所以<strong>切记，调用 cond.Wait 方法之前一定要加锁</strong>。</p>
<p>使用 Cond 的另一个常见错误是，只调用了一次 Wait，没有检查等待条件是否满足，结果条件没满足，程序就继续执行了。出现这个问题的原因在于，误以为 Cond 的使用，就像 WaitGroup 那样调用一下 Wait 方法等待那么简单。比如下面的代码中，把第 21 行和第 24 行注释掉：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br>    <span class="hljs-keyword">var</span> ready <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            time.Sleep(time.Duration(rand.Int63n(<span class="hljs-number">10</span>)) * time.Second)<br><br>            <span class="hljs-comment">// 加锁更改等待条件</span><br>            c.L.Lock()<br>            ready++<br>            c.L.Unlock()<br><br>            log.Printf(<span class="hljs-string">&quot;运动员#%d 已准备就绪\n&quot;</span>, i)<br>            <span class="hljs-comment">// 广播唤醒所有的等待者</span><br>            c.Broadcast()<br>        &#125;(i)<br>    &#125;<br><br>    c.L.Lock()<br>    <span class="hljs-comment">// for ready != 10 &#123;</span><br>    c.Wait()<br>    log.Println(<span class="hljs-string">&quot;裁判员被唤醒一次&quot;</span>)<br>    <span class="hljs-comment">// &#125;</span><br>    c.L.Unlock()<br><br>    <span class="hljs-comment">//所有的运动员是否就绪</span><br>    log.Println(<span class="hljs-string">&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行这个程序，你会发现，可能只有几个运动员准备好之后程序就运行完了，而不是我们期望的所有运动员都准备好才进行下一步。原因在于，每一个运动员准备好之后都会唤醒所有的等待者，也就是这里的裁判员，比如第一个运动员准备好后就唤醒了裁判员，结果这个裁判员傻傻地没做任何检查，以为所有的运动员都准备好了，就继续执行了。</p>
<p>所以，我们一定要记住，waiter goroutine 被唤醒不等于等待条件被满足，只是有 goroutine 把它唤醒了而已，等待条件有可能已经满足了，也有可能不满足，我们需要进一步检查。你也可以理解为，等待者被唤醒，只是得到了一次检查的机会而已。</p>
<p>到这里，我们小结下。如果你想在使用 Cond 的时候避免犯错，只要时刻记住调用 cond.Wait 方法之前一定要加锁，以及 waiter goroutine 被唤醒不等于等待条件被满足这两个知识点。</p>
<br>
<p><strong>知名项目中 Cond 的使用</strong></p>
<p>Cond 在实际项目中被使用的机会比较少，原因总结起来有两个。</p>
<p>第一，同样的场景我们会使用其他的并发原语来替代。Go 特有的 Channel 类型，有一个应用很广泛的模式就是通知机制，这个模式使用起来也特别简单。所以很多情况下，我们会使用 Channel 而不是 Cond 实现 wait/notify 机制。</p>
<p>第二，对于简单的 wait/notify 场景，比如等待一组 goroutine 完成之后继续执行余下的代码，我们会使用 WaitGroup 来实现。因为 WaitGroup 的使用方法更简单，而且不容易出错。比如，上面百米赛跑的问题，就可以很方便地使用 WaitGroup 来实现。</p>
<p>所以，我在这一讲开头提到，Cond 的使用场景很少。先前的标准库内部有几个地方使用了 Cond，比如 io/pipe.go 等，后来都被其他的并发原语（比如 Channel）替换了，sync.Cond 的路越走越窄。但是，还是有一批忠实的“粉丝”坚持在使用 Cond，原因在于 Cond 有三点特性是 Channel 无法替代的：</p>
<ul>
<li>
<p>Cond 和一个 Locker 关联，可以利用这个 Locker 对相关的依赖条件更改提供保护。</p>
</li>
<li>
<p>Cond 可以同时支持 Signal 和 Broadcast 方法，而 Channel 只能同时支持其中一种。</p>
</li>
<li>
<p>Cond 的 Broadcast 方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用 Broadcast 再次唤醒等待的 goroutine。这也是</p>
<p>Channel 不能支持的，Channel 被 close 掉了之后不支持再 open。</p>
</li>
</ul>
<p>开源项目中使用 sync.Cond 的代码少之又少，包括标准库原先一些使用 Cond 的代码也改成使用 Channel 实现了，所以别说找 Cond 相关的使用 Bug 了，想找到的一个使用的例子都不容易，我找了 Kubernetes 中的一个例子，我们一起看看它是如何使用 Cond 的。</p>
<p>Kubernetes 项目中定义了优先级队列 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/internal/queue/scheduling_queue.go">PriorityQueue</a> 这样一个数据结构，用来实现 Pod 的调用。它内部有三个 Pod 的队列，即 activeQ、podBackoffQ 和 unschedulableQ，其中 activeQ 就是用来调度的活跃队列（heap）。</p>
<p>Pop 方法调用的时候，如果这个队列为空，并且这个队列没有 Close 的话，会调用 Cond 的 Wait 方法等待。</p>
<p>你可以看到，调用 Wait 方法的时候，调用者是持有锁的，并且被唤醒的时候检查等待条件（队列是否为空）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从队列中取出一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PriorityQueue)</span></span> Pop() (*framework.QueuedPodInfo, <span class="hljs-type">error</span>) &#123;<br>    p.lock.Lock()<br>    <span class="hljs-keyword">defer</span> p.lock.Unlock()<br>    <span class="hljs-keyword">for</span> p.activeQ.Len() == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果队列为空</span><br>        <span class="hljs-keyword">if</span> p.closed &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(queueClosed)<br>        &#125;<br>        p.cond.Wait() <span class="hljs-comment">// 等待，直到被唤醒</span><br>    &#125;<br>    ......<br>    <span class="hljs-keyword">return</span> pInfo, err<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当 activeQ 增加新的元素时，会调用条件变量的 Boradcast 方法，通知被 Pop 阻塞的调用者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 增加元素到队列中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PriorityQueue)</span></span> Add(pod *v1.Pod) <span class="hljs-type">error</span> &#123;<br>    p.lock.Lock()<br>    <span class="hljs-keyword">defer</span> p.lock.Unlock()<br>    pInfo := p.newQueuedPodInfo(pod)<br>    <span class="hljs-keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//增加元素到队列中</span><br>        klog.Errorf(<span class="hljs-string">&quot;Error adding pod %v to the scheduling queue: %v&quot;</span>, nsNameForPod(pod), err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    ......<br>    p.cond.Broadcast() <span class="hljs-comment">//通知其它等待的goroutine，队列中有元素了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个优先级队列被关闭的时候，也会调用 Broadcast 方法，避免被 Pop 阻塞的调用者永远 hang 住。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PriorityQueue)</span></span> Close() &#123;<br>    p.lock.Lock()<br>    <span class="hljs-keyword">defer</span> p.lock.Unlock()<br>    <span class="hljs-built_in">close</span>(p.stop)<br>    p.closed = <span class="hljs-literal">true</span><br>    p.cond.Broadcast() <span class="hljs-comment">//关闭时通知等待的goroutine，避免它们永远等待</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>你可以思考一下，这里为什么使用 Cond 这个并发原语，能不能换成 Channel 实现呢？</p>
<br>
<p><strong>总结</strong></p>
<p>好了，我们来做个总结。</p>
<p>Cond 是为等待 / 通知场景下的并发问题提供支持的。它提供了条件变量的三个基本方法 Signal、Broadcast 和 Wait，为并发的 goroutine 提供等待 / 通知机制。</p>
<p>在实践中，处理等待 / 通知的场景时，我们常常会使用 Channel 替换 Cond，因为 Channel 类型使用起来更简洁，而且不容易出错。但是对于需要重复调用 Broadcast 的场景，比如上面 Kubernetes 的例子，每次往队列中成功增加了元素后就需要调用 Broadcast 通知所有的等待者，使用 Cond 就再合适不过了。</p>
<p>使用 Cond 之所以容易出错，就是 Wait 调用需要加锁，以及被唤醒后一定要检查条件是否真的已经满足。你需要牢记这两点。</p>
<p>虽然我们讲到的百米赛跑的例子，也可以通过 WaitGroup 来实现，但是本质上 WaitGroup 和 Cond 是有区别的：WaitGroup 是主 goroutine 等待确定数量的子 goroutine 完成任务；而 Cond 是等待某个条件满足，这个条件的修改可以被任意多的 goroutine 更新，而且 Cond 的 Wait 不关心也不知道其他 goroutine 的数量，只关心等待条件。而且 Cond 还有单个通知的机制，也就是 Signal 方法。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-8-Once：一个简约而不简单的并发原语">2.8 Once：一个简约而不简单的并发原语</h3>
<p>本节来讲一个简单的并发原语：Once。为什么要学习 Once 呢？<strong>Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景</strong>。</p>
<p>那这节课，我们就从对单例对象进行初始化这件事儿说起。</p>
<p>初始化单例资源有很多方法，比如定义 package 级别的变量，这样程序在启动的时候就可以初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> abc<br><br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">var</span> startTime = time.Now()<br></code></pre></td></tr></table></figure>
<p>或者在 init 函数中进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> abc<br><br><span class="hljs-keyword">var</span> startTime time.Time<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    startTime = time.Now()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又或者在 main 函数开始执行的时候，执行一个初始化的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> abc<br><br><span class="hljs-keyword">var</span> startTime time.Tim<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initApp</span><span class="hljs-params">()</span></span> &#123;<br>    startTime = time.Now()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    initApp()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这三种方法都是线程安全的，并且后两种方法还可以根据传入的参数实现定制化的初始化操作。</p>
<p>但是很多时候我们是要延迟进行初始化的，所以有时候单例资源的初始化，我们会使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 使用互斥锁保证线程(goroutine)安全</span><br><span class="hljs-keyword">var</span> connMu sync.Mutex<br><span class="hljs-keyword">var</span> conn net.Conn<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getConn</span><span class="hljs-params">()</span></span> net.Conn &#123;<br>    connMu.Lock()<br>    <span class="hljs-keyword">defer</span> connMu.Unlock()<br><br>    <span class="hljs-comment">// 返回已创建好的连接</span><br>    <span class="hljs-keyword">if</span> conn != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> conn<br>    &#125;<br><br>    <span class="hljs-comment">// 创建连接</span><br>    conn, _ = net.DialTimeout(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;baidu.com:80&quot;</span>, <span class="hljs-number">10</span>*time.Second)<br>    <span class="hljs-keyword">return</span> conn<br>&#125;<br><br><span class="hljs-comment">// 使用连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    conn := getConn()<br>    <span class="hljs-keyword">if</span> conn == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;conn is nil&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方式虽然实现起来简单，但是有性能问题。一旦连接创建好，每次请求的时候还是得竞争锁才能读取到这个连接，这是比较浪费资源的，因为连接如果创建好之后，其实就不需要锁的保护了。怎么办呢？</p>
<p>这个时候就可以使用这一讲要介绍的 Once 并发原语了。接下来会详细介绍 Once 的使用、实现和易错场景。</p>
<br>
<p><strong>Once 的使用场景</strong></p>
<p><strong>sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)<br></code></pre></td></tr></table></figure>
<p>因为当且仅当第一次调用 Do 方法的时候参数 f 才会执行，即使第二次、第三次、第 n 次调用时 f 参数的值不一样，也不会被执行，比如下面的例子，虽然 f1 和 f2 是不同的函数，但是第二个函数 f2 就不会执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> once sync.Once<br><br>    <span class="hljs-comment">// 第一个初始化函数</span><br>    f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;in f1&quot;</span>)<br>    &#125;<br>    once.Do(f1) <span class="hljs-comment">// 打印出 in f1</span><br><br>    <span class="hljs-comment">// 第二个初始化函数</span><br>    f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;in f2&quot;</span>)<br>    &#125;<br>    once.Do(f2) <span class="hljs-comment">// 无输出</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为这里的 f 参数是一个无参数无返回的函数，所以你可能会通过闭包的方式引用外面的参数，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> addr = <span class="hljs-string">&quot;baidu.com&quot;</span><br><br><span class="hljs-keyword">var</span> conn net.Conn<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    conn, err = net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>而且在实际的使用中，绝大多数情况下，你会使用闭包的方式去初始化外部的一个资源。</p>
<p>你看，Once 的使用场景很明确，所以，在标准库内部实现中也常常能看到 Once 的身影。</p>
<p>比如标准库内部<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/f0e97546962736fe4aa73b7c7ed590f0134515e1/src/cmd/go/internal/cache/default.go">cache</a>的实现上，就使用了 Once 初始化 Cache 资源，包括 defaultDir 值的获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">()</span></span> *Cache &#123; <span class="hljs-comment">// 获取默认的Cache</span><br>    defaultOnce.Do(initDefaultCache) <span class="hljs-comment">// 初始化cache</span><br>    <span class="hljs-keyword">return</span> defaultCache<br>&#125;<br>  <br><span class="hljs-comment">// 定义一个全局的cache变量，使用Once初始化，所以也定义了一个Once变量</span><br><span class="hljs-keyword">var</span> (<br>    defaultOnce  sync.Once<br>    defaultCache *Cache<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDefaultCache</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//初始化cache,也就是Once.Do使用的f函数</span><br>    ......<br>    defaultCache = c<br>&#125;<br><br>    <span class="hljs-comment">// 其它一些Once初始化的变量，比如defaultDir</span><br><span class="hljs-keyword">var</span> (<br>    defaultDirOnce sync.Once<br>    defaultDir     <span class="hljs-type">string</span><br>    defaultDirErr  <span class="hljs-type">error</span><br>)<br></code></pre></td></tr></table></figure>
<p>还有一些测试的时候初始化测试的资源（<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/time/export_windows_test.go">export_windows_test</a>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 测试window系统调用时区相关函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForceAusFromTZIForTesting</span><span class="hljs-params">()</span></span> &#123;<br>    ResetLocalOnceForTest()<br>        <span class="hljs-comment">// 使用Once执行一次初始化</span><br>    localOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; initLocalFromTZI(&amp;aus) &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除此之外，还有保证只调用一次 copyenv 的 envOnce，strings 包下的 Replacer，time 包中的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/b71eafbcece175db33acfb205e9090ca99a8f984/src/time/export_test.go#L12">测试</a>，Go 拉取库时的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/8535008765b4fcd5c7dc3fb2b73a856af4d51f9b/src/cmd/go/internal/modfetch/proxy.go#L103">proxy</a>，net.pipe，crc64，Regexp，……，数不胜数。本小节重点介绍一下很值得我们学习的 math/big/sqrt.go 中实现的一个数据结构，它通过 Once 封装了一个只初始化一次的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 值是3.0或者0.0的一个数据结构</span><br><span class="hljs-keyword">var</span> threeOnce <span class="hljs-keyword">struct</span> &#123;<br>    sync.Once<br>    v *Float<br>&#125;<br>  <br><span class="hljs-comment">// 返回此数据结构的值，如果还没有初始化为3.0，则初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">three</span><span class="hljs-params">()</span></span> *Float &#123;<br>    threeOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 使用Once初始化</span><br>      threeOnce.v = NewFloat(<span class="hljs-number">3.0</span>)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> threeOnce.v<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它将 sync.Once 和 *Float 封装成一个对象，提供了只初始化一次的值 v。 你看它的 three 方法的实现，虽然每次都调用 <a target="_blank" rel="noopener" href="http://threeOnce.Do">threeOnce.Do</a> 方法，但是参数只会被调用一次。</p>
<p>当你使用 Once 的时候，你也可以尝试采用这种结构，将值和 Once 封装成一个新的数据结构，提供只初始化一次的值。</p>
<p>总结一下 Once 并发原语解决的问题和使用场景：<strong>Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源</strong>。</p>
<br>
<p><strong>如何实现一个 Once？</strong>。</p>
<p>很多人认为实现一个 Once 一样的并发原语很简单，只需使用一个 flag 标记是否初始化过即可，最多是用 atomic 原子操作这个 flag，比如下面的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    done <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> !atomic.CompareAndSwapUint32(&amp;o.done, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这确实是一种实现方式，但是，这个实现有一个很大的问题，就是如果参数 f 执行很慢的话，后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为 f 还没有执行完。</p>
<p>所以，<strong>一个正确的 Once 实现要使用一个互斥锁，这样初始化的时候如果有并发的 goroutine，就会进入 doSlow 方法</strong>。互斥锁的机制保证只有一个 goroutine 进行初始化，同时利用<strong>双检查的机制</strong>（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。</p>
<p>即使此时有多个 goroutine 同时进入了 doSlow 方法，因为双检查的机制，后续的 goroutine 会看到 o.done 的值为 1，也不会再次执行 f。</p>
<p>这样既保证了并发的 goroutine 会等待 f 完成，而且还不会多次执行 f。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    done <span class="hljs-type">uint32</span><br>    m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>        o.doSlow(f)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>    o.m.Lock()<br>    <span class="hljs-keyword">defer</span> o.m.Unlock()<br>    <span class="hljs-comment">// 双检查</span><br>    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>        f()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好了，到这里我们就了解了 Once 的使用场景，很明确，同时呢，也感受到 Once 的实现也是相对简单的。在实践中，其实很少会出现错误使用 Once 的情况，但是就像墨菲定律说的，凡是可能出错的事就一定会出错。使用 Once 也有可能出现两种错误场景，尽管非常罕见。这里提前讲给你，咱打个预防针。</p>
<br>
<p><strong>使用 Once 可能出现的 2 种错误</strong></p>
<p><strong>第一种错误：死锁</strong></p>
<p>你已经知道了 Do 方法会执行一次 f，但是如果 f 中再次调用这个 Once 的 Do 方法的话，就会导致死锁的情况出现。这还不是无限递归的情况，而是的的确确的 Lock 的递归调用导致的死锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> once sync.Once<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;初始化&quot;</span>)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，想要避免这种情况的出现，就不要在 f 参数中调用当前的这个 Once，不管是直接的还是间接的。</p>
<p><strong>第二种错误：未初始化</strong></p>
<p>如果 f 方法执行的时候 panic，或者 f 执行初始化资源的时候失败了，这个时候，Once 还是会认为初次执行已经成功了，即使再次调用 Do 方法，也不会再次执行 f。</p>
<p>比如下面的例子，由于一些防火墙的原因，googleConn 并没有被正确的初始化，后面如果想当然认为既然执行了 Do 方法 googleConn 就已经初始化的话，会抛出空指针的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> once sync.Once<br>    <span class="hljs-keyword">var</span> googleConn net.Conn <span class="hljs-comment">// 到Google网站的一个连接</span><br><br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 建立到google.com的连接，有可能因为网络的原因，googleConn并没有建立成功，此时它的值为nil</span><br>        googleConn, _ = net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;google.com:80&quot;</span>)<br>    &#125;)<br>    <span class="hljs-comment">// 发送http请求</span><br>    googleConn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;GET / HTTP/1.1\r\nHost: google.com\r\n Accept: */*\r\n\r\n&quot;</span>))<br>    io.Copy(os.Stdout, googleConn)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>既然执行过 <a target="_blank" rel="noopener" href="http://Once.Do">Once.Do</a> 方法也可能因为函数执行失败的原因未初始化资源，并且以后也没机会再次初始化资源，那么这种初始化未完成的问题该怎么解决呢？</p>
<p>这里来介绍一招独家秘笈，我们可以<strong>自己实现一个类似 Once 的并发原语</strong>，既可以返回当前调用 Do 方法是否正确完成，还可以在初始化失败后调用 Do 方法再次尝试初始化，直到初始化成功才不再初始化了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个功能更加强大的Once</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    m    sync.Mutex<br>    done <span class="hljs-type">uint32</span><br>&#125;<br><span class="hljs-comment">// 传入的函数f有返回值error，如果初始化失败，需要返回失败的error</span><br><span class="hljs-comment">// Do方法会把这个error返回给调用者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//fast path</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> o.slowDo(f)<br>&#125;<br><span class="hljs-comment">// 如果还没有初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> slowDo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    o.m.Lock()<br>    <span class="hljs-keyword">defer</span> o.m.Unlock()<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 双检查，还没有初始化</span><br>        err = f()<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 初始化成功才将标记置为已初始化</span><br>            atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们所做的改变就是 Do 方法和参数 f 函数都会返回 error，如果 f 执行失败，会把这个错误信息返回。</p>
<p>对 slowDo 方法也做了调整，如果 f 调用失败，我们不会更改 done 字段的值，这样后续的 goroutine 还会继续调用 f。如果 f 执行成功，才会修改 done 的值为 1。</p>
<p>可以说，真是一顿操作猛如虎，我们使用 Once 有点得心应手的感觉了。等等，还有个问题，我们怎么查询是否初始化过呢？</p>
<p>目前的 Once 实现可以保证你调用任意次数的 <a target="_blank" rel="noopener" href="http://once.Do">once.Do</a> 方法，它只会执行这个方法一次。但是，有时候我们需要打一个标记。如果初始化后我们就去执行其它的操作，标准库的 Once 并不会告诉你是否初始化完成了，只是让你放心大胆地去执行 Do 方法，所以，<strong>你还需要一个辅助变量，自己去检查是否初始化过了</strong>，比如通过下面的代码中的 inited 字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AnimalStore <span class="hljs-keyword">struct</span> &#123;once   sync.Once;inited <span class="hljs-type">uint32</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AnimalStore)</span></span> Init() <span class="hljs-comment">// 可以被并发调用</span><br>    a.once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        longOperationSetupDbOpenFilesQueuesEtc()<br>        atomic.StoreUint32(&amp;a.inited, <span class="hljs-number">1</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AnimalStore)</span></span> CountOfCats() (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 另外一个goroutine</span><br>    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;a.inited) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 初始化后才会执行真正的业务逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, NotYetInitedError<br>    &#125;<br>    <span class="hljs-comment">//Real operation</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，通过这段代码，我们可以解决这类问题，但是，如果官方的 Once 类型有 Done 这样一个方法的话，我们就可以直接使用了。这是有人在 Go 代码库中提出的一个 issue(<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/41690">#41690</a>)。对于这类问题，一般都会被建议采用其它类型，或者自己去扩展。我们可以尝试扩展这个并发原语：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Once 是一个扩展的sync.Once类型，提供了一个Done方法</span><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    sync.Once<br>&#125;<br><br><span class="hljs-comment">// Done 返回此Once是否执行过</span><br><span class="hljs-comment">// 如果执行过则返回true</span><br><span class="hljs-comment">// 如果没有执行过或者正在执行，返回false</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Done() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> atomic.LoadUint32((*<span class="hljs-type">uint32</span>)(unsafe.Pointer(&amp;o.Once))) == <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> flag Once<br>    fmt.Println(flag.Done()) <span class="hljs-comment">//false</span><br><br>    flag.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(time.Second)<br>    &#125;)<br><br>    fmt.Println(flag.Done()) <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p>好了，到这里关于并发原语 Once 的内容讲得就差不多了。最后呢，和你分享一个 Once 的踩坑案例。</p>
<p>其实啊，使用 Once 真的不容易犯错，想犯错都很困难，因为很少有人会傻傻地在初始化函数 f 中递归调用 f，这种死锁的现象几乎不会发生。另外如果函数初始化不成功，我们一般会 panic，或者在使用的时候做检查，会及早发现这个问题，在初始化函数中加强代码。</p>
<p>所以查看大部分的 Go 项目，几乎找不到 Once 的错误使用场景，不过原作者还是发现了一个。这个 issue 先从另外一个需求 (<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/25955">go#25955</a>) 谈起。</p>
<p><strong>Once 的踩坑案例</strong></p>
<p>go#25955 有网友提出一个需求，希望 Once 提供一个 Reset 方法，能够将 Once 重置为初始化的状态。比如下面的例子，St 通过两个 Once 控制它的 Open/Close 状态。但是在 Close 之后再调用 Open 的话，不会再执行 init 函数，因为 Once 只会执行一次初始化函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> St <span class="hljs-keyword">struct</span> &#123;<br>    openOnce *sync.Once<br>    closeOnce *sync.Once<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(st *St)</span></span> Open()&#123;<br>    st.openOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;) <span class="hljs-comment">// init</span><br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(st *St)</span></span> Close()&#123;<br>    st.closeOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;) <span class="hljs-comment">// deinit</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以提交这个 Issue 的开发者希望 Once 增加一个 Reset 方法，Reset 之后再调用 <a target="_blank" rel="noopener" href="http://once.Do">once.Do</a> 就又可以初始化了。</p>
<p>Go 的核心开发者 Ian Lance Taylor 给他了一个简单的解决方案。在这个例子中，只使用一个 ponce *sync.Once 做初始化，Reset 的时候给 ponce 这个变量赋值一个新的 Once 实例即可 (ponce = new(sync.Once))。Once 的本意就是执行一次，所以 Reset 破坏了这个并发原语的本意。</p>
<p>这个解决方案一点都没问题，可以很好地解决这位开发者的需求。Docker 较早的版本（1.11.2）中使用了它们的一个网络库 libnetwork，这个网络库在使用 Once 的时候就使用 Ian Lance Taylor 介绍的方法，但是不幸的是，它的 Reset 方法中又改变了 Once 指针的值，导致程序 panic 了。原始逻辑比较复杂，一个简化版可重现的<a target="_blank" rel="noopener" href="https://play.golang.org/p/xPULnrVKiY">代码</a>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;sync&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 一个组合的并发原语</span><br><span class="hljs-keyword">type</span> MuOnce <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    sync.Once<br>    mtime time.Time<br>    vals  []<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 相当于reset方法，会将m.Once重新复制一个Once</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MuOnce)</span></span> refresh() &#123;<br>    m.Lock()<br>    <span class="hljs-keyword">defer</span> m.Unlock()<br>    m.Once = sync.Once&#123;&#125;<br>    m.mtime = time.Now()<br>    m.vals = []<span class="hljs-type">string</span>&#123;m.mtime.String()&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取某个初始化的值，如果超过某个时间，会reset Once</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MuOnce)</span></span> strings() []<span class="hljs-type">string</span> &#123;<br>    now := time.Now()<br>    m.RLock()<br>    <span class="hljs-keyword">if</span> now.After(m.mtime) &#123;<br>        <span class="hljs-keyword">defer</span> m.Do(m.refresh) <span class="hljs-comment">// 使用refresh函数重新初始化</span><br>    &#125;<br>    vals := m.vals<br>    m.RUnlock()<br>    <span class="hljs-keyword">return</span> vals<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, playground&quot;</span>)<br>    m := <span class="hljs-built_in">new</span>(MuOnce)<br>    fmt.Println(m.strings())<br>    fmt.Println(m.strings())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你执行这段代码就会 panic:</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/f3401f75a86e1d0c3b257f52696228af.webp" alt=""></p>
<p>原因在于第 31 行执行 <a target="_blank" rel="noopener" href="http://m.Once.Do">m.Once.Do</a> 方法的时候，使用的是 m.Once 的指针，然后调用 m.refresh，在执行 m.refresh 的时候 Once 内部的 Mutex 首先会加锁（可以再翻看一下这一讲的 Once 的实现原理）， 但是，在 refresh 中更改了 Once 指针的值之后，结果在执行完 refresh 释放锁的时候，释放的是一个刚初始化未加锁的 Mutex，所以就 panic 了。</p>
<p>如果你还不太明白，再给你简化成一个更简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>    m sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow() &#123;<br>    o.m.Lock()<br>    <span class="hljs-keyword">defer</span> o.m.Unlock()<br><br>    <span class="hljs-comment">// 这里更新的o指针的值!!!!!!!, 会导致上一行Unlock出错</span><br>    *o = Once&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> once Once<br>    once.doSlow()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>doSlow 方法就演示了这个错误。Ian Lance Taylor 介绍的 Reset 方法没有错误，但是你在使用的时候千万别再初始化函数中 Reset 这个 Once，否则势必会导致 Unlock 一个未加锁的 Mutex 的错误。</p>
<p>总的来说，这还是对 Once 的实现机制不熟悉，又进行复杂使用导致的错误。不过最新版的 libnetwork 相关的地方已经去掉了 Once 的使用了。所以，我们一起来看这个案例，主要目的还是想巩固一下对 Once 的理解。</p>
<br>
<p><strong>总结</strong></p>
<p>今天我们一起学习了 Once，我们常常使用它来实现单例模式。</p>
<p>单例是 23 种设计模式之一，也是常常引起争议的设计模式之一，甚至有人把它归为反模式。为什么说它是反模式呢，我拿标准库中的单例模式给你介绍下。</p>
<p>因为 Go 没有 immutable 类型，导致我们声明的全局变量都是可变的，别的地方或者第三方库可以随意更改这些变量。比如 package io 中定义了几个全局变量，比如 io.EOF：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>) <br></code></pre></td></tr></table></figure>
<p>因为它是一个 package 级别的变量，我们可以在程序中偷偷把它改了，这会导致一些依赖 io.EOF 这个变量做判断的代码出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">io.EOF = errors.New(<span class="hljs-string">&quot;我们自己定义的EOF&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>从我个人的角度来说，一些单例（全局变量）的确很方便，比如 Buffer 池或者连接池，所以有时候我们也不要谈虎色变。虽然有人把单例模式称之为反模式，但毕竟只能代表一部分开发者的观点，否则也不会把它列在 23 种设计模式中了。</p>
<p>如果你真的担心这个 package 级别的变量被人修改，你可以不把它们暴露出来，而是提供一个只读的 GetXXX 的方法，这样别人就不会进行修改了。</p>
<p>而且，Once 不只应用于单例模式，一些变量在也需要在使用的时候做延迟初始化，所以也是可以使用 Once 处理这些场景的。</p>
<p>总而言之，Once 的应用场景还是很广泛的。<strong>一旦你遇到只需要初始化一次的场景，首先想到的就应该是 Once 并发原语</strong>。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-9-map：如何实现线程安全的map类型？">2.9 map：如何实现线程安全的map类型？</h3>
<p>哈希表（Hash Table）这个数据结构，我们已经非常熟悉了。它实现的就是 key-value 之间的映射关系，主要提供的方法包括 Add、Lookup、Delete 等。因为这种数据结构是一个基础的数据结构，每个 key 都会有一个唯一的索引值，通过索引可以很快地找到对应的值，所以使用哈希表进行数据的插入和读取都是很快的。Go 语言本身就内建了这样一个数据结构，也就是 <strong>map 数据类型</strong>。</p>
<p>今天呢，我们就先来学习 Go 语言内建的这个 map 类型，了解它的基本使用方法和使用陷阱，然后再学习如何实现线程安全的 map 类型，最后还会给你介绍 Go 标准库中线程安全的 sync.Map 类型。学完了这节课，你可以学会几种可以并发访问的 map 类型。</p>
<br>
<p><strong>map 的基本使用方法</strong></p>
<p>Go 内建的 map 类型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[K]V<br></code></pre></td></tr></table></figure>
<p>其中，<strong>key 类型的 K 必须是可比较的</strong>（comparable），也就是可以通过 == 和 != 操作符进行比较；value 的值和类型无所谓，可以是任意的类型，或者为 nil。</p>
<p>在 Go 语言中，bool、整数、浮点数、复数、字符串、指针、Channel、接口都是可比较的，包含可比较元素的 struct 和数组，这俩也是可比较的，而 slice、map、函数值都是不可比较的。</p>
<p>那么，上面这些可比较的数据类型都可以作为 map 的 key 吗？显然不是。通常情况下，我们会选择内建的基本类型，比如整数、字符串做 key 的类型，因为这样最方便。</p>
<p>这里有一点需要注意，如果使用 struct 类型做 key 其实是有坑的，因为如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mapKey <span class="hljs-keyword">struct</span> &#123;<br>    key <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[mapKey]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">var</span> key = mapKey&#123;<span class="hljs-number">10</span>&#125;<br><br><br>    m[key] = <span class="hljs-string">&quot;hello&quot;</span><br>    fmt.Printf(<span class="hljs-string">&quot;m[key]=%s\n&quot;</span>, m[key])<br><br><br>    <span class="hljs-comment">// 修改key的字段的值后再次查询map，无法获取刚才add进去的值</span><br>    key.key = <span class="hljs-number">100</span><br>    fmt.Printf(<span class="hljs-string">&quot;再次查询m[key]=%s\n&quot;</span>, m[key])<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那该怎么办呢？如果要使用 struct 作为 key，我们要保证 struct 对象在逻辑上是不可变的，这样才会保证 map 的逻辑没有问题。</p>
<p>以上就是选取 key 类型的注意点了。接下来，我们看一下使用 map[key]函数时需要注意的一个知识点。<strong>在 Go 中，map[key]函数返回结果可以是一个值，也可以是两个值</strong>，这是容易让人迷惑的地方。原因在于，如果获取一个不存在的 key 对应的值时，会返回零值。为了区分真正的零值和 key 不存在这两种情况，可以根据第二个返回值来区分，如下面的代码的第 6 行、第 7 行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">0</span><br>    fmt.Printf(<span class="hljs-string">&quot;a=%d; b=%d\n&quot;</span>, m[<span class="hljs-string">&quot;a&quot;</span>], m[<span class="hljs-string">&quot;b&quot;</span>])<br><br>    av, aexisted := m[<span class="hljs-string">&quot;a&quot;</span>]<br>    bv, bexisted := m[<span class="hljs-string">&quot;b&quot;</span>]<br>    fmt.Printf(<span class="hljs-string">&quot;a=%d, existed: %t; b=%d, existed: %t\n&quot;</span>, av, aexisted, bv, bexisted)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>map 是无序的，所以当遍历一个 map 对象的时候，迭代的元素的顺序是不确定的，无法保证两次遍历的顺序是一样的，也不能保证和插入的顺序一致。那怎么办呢？如果我们想要按照 key 的顺序获取 map 的值，需要先取出所有的 key 进行排序，然后按照这个排序的 key 依次获取对应的值。而如果我们想要保证元素有序，比如按照元素插入的顺序进行遍历，可以使用辅助的数据结构，比如<a target="_blank" rel="noopener" href="https://github.com/elliotchance/orderedmap">orderedmap</a>，来记录插入顺序。</p>
<p>好了，总结下关于 map 我们需要掌握的内容：map 的类型是 map[key]，key 类型的 K 必须是可比较的，通常情况下，我们会选择内建的基本类型，比如整数、字符串做 key 的类型。如果要使用 struct 作为 key，我们要保证 struct 对象在逻辑上是不可变的。在 Go 中，map[key]函数返回结果可以是一个值，也可以是两个值。map 是无序的，如果我们想要保证遍历 map 时元素有序，可以使用辅助的数据结构，比如<a target="_blank" rel="noopener" href="https://github.com/elliotchance/orderedmap">orderedmap</a>。</p>
<br>
<p><strong>使用 map 的 2 种常见错误</strong></p>
<p>那接下来，我们来看使用 map 最常犯的两个错误，就是未初始化和并发读写。</p>
<p><strong>常见错误一：未初始化</strong></p>
<p>和 slice 或者 Mutex、RWmutex 等 struct 类型不同，map 对象必须在使用之前初始化。如果不初始化就直接赋值的话，会出现 panic 异常，比如下面的例子，m 实例还没有初始化就直接进行操作会导致 panic（第 3 行）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>    m[<span class="hljs-number">100</span>] = <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>解决办法就是在第 2 行初始化这个实例（m := make(map[int]int)）。</p>
<p>从一个 nil 的 map 对象中获取值不会 panic，而是会得到零值，所以下面的代码不会报错:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>    fmt.Println(m[<span class="hljs-number">100</span>])<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子很简单，我们可以意识到 map 的初始化问题。但有时候 map 作为一个 struct 字段的时候，就很容易忘记初始化了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    Website      <span class="hljs-type">string</span><br>    Start        time.Time<br>    PageCounters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c Counter<br>    c.Website = <span class="hljs-string">&quot;baidu.com&quot;</span><br><br><br>    c.PageCounters[<span class="hljs-string">&quot;/&quot;</span>]++<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以，关于初始化这一点，再强调一下，目前还没有工具可以检查，我们只能记住“别忘记初始化”这一条规则。</p>
<p><strong>常见错误二：并发读写</strong></p>
<p>对于 map 类型，另一个很容易犯的错误就是并发访问问题。这个易错点，相当令人讨厌，如果没有注意到并发问题，程序在运行的时候就有可能出现并发读写导致的 panic。</p>
<p>Go 内建的 map 对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致 panic。</p>
<p>我们一起看一个并发访问 map 实例导致 panic 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">10</span>) <span class="hljs-comment">// 初始化一个map</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            m[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">//设置key</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            _ = m[<span class="hljs-number">2</span>] <span class="hljs-comment">//访问这个map</span><br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然这段代码看起来是读写 goroutine 各自操作不同的元素，貌似 map 也没有扩容的问题，但是运行时检测到同时对 map 对象有并发访问，就会直接 panic。panic 信息会告诉我们代码中哪一行有读写问题，根据这个错误信息你就能快速定位出来是哪一个 map 对象在哪里出的问题了。</p>
<p>这个错误非常常见，是几乎每个人都会踩到的坑。其实，不只是我们写代码时容易犯这个错，一些知名的项目中也是屡次出现这个问题，比如 Docker issue 40772，在删除 map 对象的元素时忘记了加锁.</p>
<p>Docker issue 40772，Docker issue 35588、34540、39643 等等，也都有并发读写 map 的问题。</p>
<p>除了 Docker 中，Kubernetes 的 issue 84431、72464、68647、64484、48045、45593、37560 等，以及 TiDB 的 issue 14960 和 17494 等，也出现了这个错误。</p>
<p>这么多人都会踩的坑，有啥解决方案吗？肯定有，那接下来，我们就继续来看如何解决内建 map 的并发读写问题。</p>
<br>
<p><strong>加读写锁：扩展 map，支持并发读写</strong></p>
<p>比较遗憾的是，目前 Go 还没有正式发布泛型特性，我们还不能实现一个通用的支持泛型的加锁 map。但是，将要发布的泛型方案已经可以验证测试了，离发布也不远了，也许发布之后 sync.Map 就支持泛型了。</p>
<p>当然了，如果没有泛型支持，我们也能解决这个问题。我们可以通过 interface{}来模拟泛型，但还是要涉及接口和具体类型的转换，比较复杂，还不如将要发布的泛型方案更直接、性能更好。</p>
<p>这里以一个具体的 map 类型为例，来演示利用读写锁实现线程安全的 map[int]int 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMap <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 一个读写锁保护的线程安全的map</span><br>    sync.RWMutex <span class="hljs-comment">// 读写锁保护下面的map字段</span><br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">// 新建一个RWMap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRWMap</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> *RWMap &#123;<br>    <span class="hljs-keyword">return</span> &amp;RWMap&#123;<br>        m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, n),<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMap)</span></span> Get(k <span class="hljs-type">int</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123; <span class="hljs-comment">//从map中读取一个值</span><br>    m.RLock()<br>    <span class="hljs-keyword">defer</span> m.RUnlock()<br>    v, existed := m.m[k] <span class="hljs-comment">// 在锁的保护下从map中读取</span><br>    <span class="hljs-keyword">return</span> v, existed<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMap)</span></span> Set(k <span class="hljs-type">int</span>, v <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 设置一个键值对</span><br>    m.Lock()              <span class="hljs-comment">// 锁保护</span><br>    <span class="hljs-keyword">defer</span> m.Unlock()<br>    m.m[k] = v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMap)</span></span> Delete(k <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//删除一个键</span><br>    m.Lock()                   <span class="hljs-comment">// 锁保护</span><br>    <span class="hljs-keyword">defer</span> m.Unlock()<br>    <span class="hljs-built_in">delete</span>(m.m, k)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// map的长度</span><br>    m.RLock()   <span class="hljs-comment">// 锁保护</span><br>    <span class="hljs-keyword">defer</span> m.RUnlock()<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMap)</span></span> Each(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) &#123; <span class="hljs-comment">// 遍历map</span><br>    m.RLock()             <span class="hljs-comment">//遍历期间一直持有读锁</span><br>    <span class="hljs-keyword">defer</span> m.RUnlock()<br><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m.m &#123;<br>        <span class="hljs-keyword">if</span> !f(k, v) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正如这段代码所示，对 map 对象的操作，无非就是增删改查和遍历等几种常见操作。我们可以把这些操作分为读和写两类，其中，查询和遍历可以看做读操作，增加、修改和删除可以看做写操作。如例子所示，我们可以通过读写锁对相应的操作进行保护。</p>
<br>
<p><strong>分片加锁：更高效的并发 map</strong></p>
<p>虽然使用读写锁可以提供线程安全的 map，但是在大量并发读写的情况下，锁的竞争会非常激烈。在第 4 讲中提到过，锁是性能下降的万恶之源之一。</p>
<p>在并发编程中，我们的一条原则就是尽量减少锁的使用。一些单线程单进程的应用（比如 Redis 等），基本上不需要使用锁去解决并发线程访问的问题，所以可以取得很高的性能。但是对于 Go 开发的应用程序来说，并发是常用的一个特性，在这种情况下，我们能做的就是，<strong>尽量减少锁的粒度和锁的持有时间</strong>。</p>
<p>你可以优化业务处理的代码，以此来减少锁的持有时间，比如将串行的操作变成并行的子任务执行。不过，这就是另外的故事了，今天我们还是主要讲对同步原语的优化，所以这里重点讲如何减少锁的粒度。</p>
<p>减少锁的粒度常用的方法就是分片（Shard），将一把锁分成几把锁，每个锁控制一个分片。Go 比较知名的分片并发 map 的实现是<a href="orcaman/concurrent-map">orcaman/concurrent-map</a>。</p>
<p>它默认采用 32 个分片，<strong>GetShard 是一个关键的方法，能够根据 key 计算出分片索引</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> SHARD_COUNT = <span class="hljs-number">32</span><br><br><span class="hljs-comment">// 分成SHARD_COUNT个分片的map</span><br><span class="hljs-keyword">type</span> ConcurrentMap []*ConcurrentMapShared<br><br><span class="hljs-comment">// 通过RWMutex保护的线程安全的分片，包含一个map</span><br><span class="hljs-keyword">type</span> ConcurrentMapShared <span class="hljs-keyword">struct</span> &#123;<br>    items        <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>    sync.RWMutex <span class="hljs-comment">// Read Write mutex, guards access to internal map.</span><br>&#125;<br><br><span class="hljs-comment">// 创建并发map</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> ConcurrentMap &#123;<br>    m := <span class="hljs-built_in">make</span>(ConcurrentMap, SHARD_COUNT)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; SHARD_COUNT; i++ &#123;<br>         m[i] = &amp;ConcurrentMapShared&#123;items: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m<br>&#125;<br><br><span class="hljs-comment">// 根据key计算分片索引</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m ConcurrentMap)</span></span> GetShard(key <span class="hljs-type">string</span>) *ConcurrentMapShared &#123;<br>  <span class="hljs-keyword">return</span> m[<span class="hljs-type">uint</span>(fnv32(key))%<span class="hljs-type">uint</span>(SHARD_COUNT)]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>增加或者查询的时候，首先根据分片索引得到分片对象，然后对分片对象加锁进行操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m ConcurrentMap)</span></span> Set(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-comment">// 根据key计算出对应的分片</span><br>    shard := m.GetShard(key)<br>    shard.Lock() <span class="hljs-comment">//对这个分片加锁，执行业务操作</span><br>    shard.items[key] = value<br>    shard.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m ConcurrentMap)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-comment">// 根据key计算出对应的分片</span><br>    shard := m.GetShard(key)<br>    shard.RLock()<br>    <span class="hljs-comment">// 从这个分片读取key的值</span><br>    val, ok := shard.items[key]<br>    shard.RUnlock()<br>    <span class="hljs-keyword">return</span> val, ok<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，除了 GetShard 方法，ConcurrentMap 还提供了很多其他的方法。这些方法都是通过计算相应的分片实现的，目的是保证把锁的粒度限制在分片上。</p>
<p>好了，到这里我们就学会了解决 map 并发 panic 的两个方法：加锁和分片。</p>
<p><strong>在原作者个人使用并发 map 的过程中，加锁和分片加锁这两种方案都比较常用，如果是追求更高的性能，显然是分片加锁更好，因为它可以降低锁的粒度，进而提高访问此 map 对象的吞吐。如果并发性能要求不是那么高的场景，简单加锁方式更简单</strong>。</p>
<p>接下来，继续介绍 sync.Map，这是 Go 官方线程安全 map 的标准实现。虽然是官方标准，反而是不常用的，为什么呢？一句话来说就是 map 要解决的场景很难描述，很多时候在做抉择时根本就不知道该不该用它。但是呢，确实有一些特定的场景，我们需要用到 sync.Map 来实现，所以还是很有必要学习这个知识点。具体什么场景呢，我慢慢给你道来。</p>
<br>
<p><strong>应对特殊场景的 sync.Map</strong></p>
<p>Go 内建的 map 类型不是线程安全的，所以 Go 1.9 中增加了一个线程安全的 map，也就是 sync.Map。但是，我们一定要记住，这个 sync.Map 并不是用来替换内建的 map 类型的，它只能被应用在一些特殊的场景里。</p>
<p>那这些特殊的场景是啥呢？<a target="_blank" rel="noopener" href="https://golang.org/pkg/sync/#Map">官方的文档</a>中指出，在以下两个场景中使用 sync.Map，会比使用 map+RWMutex 的方式，性能要好得多：</p>
<ul>
<li>只会增长的缓存系统中，一个 key 只写入一次而被读很多次；</li>
<li>多个 goroutine 为不相交的键集读、写和重写键值对。</li>
</ul>
<p>这两个场景说得都比较笼统，而且，这些场景中还包含了一些特殊的情况。所以，官方建议你针对自己的场景做性能评测，如果确实能够显著提高性能，再使用 sync.Map。</p>
<p>这么来看，我们能用到 sync.Map 的场景确实不多。即使是 sync.Map 的作者 Bryan C. Mills，也很少使用 sync.Map，即便是在使用 sync.Map 的时候，也是需要临时查询它的 API，才能清楚记住它的功能。所以，我们可以把 sync.Map 看成一个生产环境中很少使用的同步原语。</p>
<br>
<p><strong>sync.Map 的实现</strong></p>
<p>那 sync.Map 是怎么实现的呢？它是如何解决并发问题提升性能的呢？其实 sync.Map 的实现有几个优化点，这里先列出来，我们后面慢慢分析。</p>
<ul>
<li>空间换时间。通过冗余的两个数据结构（只读的 read 字段、可写的 dirty），来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</li>
<li>优先从 read 字段读取、更新、删除，因为对 read 字段的读取不需要锁。</li>
<li>动态调整。miss 次数多了之后，将 dirty 数据提升为 read，避免总是从 dirty 中加锁读取。 double-checking。加锁之后先还要再检查 read 字段，确定真的不存在才操作 dirty 字段。</li>
<li>延迟删除。删除一个键值只是打标记，只有在提升 dirty 字段为 read 字段的时候才清理删除的数据。</li>
</ul>
<p>要理解 sync.Map 这些优化点，我们还是得深入到它的设计和实现上，去学习它的处理方式。</p>
<p>我们先看一下 map 的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123;<br>    mu Mutex<br>    <span class="hljs-comment">// 基本上你可以把它看成一个安全的只读的map</span><br>    <span class="hljs-comment">// 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了</span><br>    read atomic.Value <span class="hljs-comment">// readOnly</span><br><br>    <span class="hljs-comment">// 包含需要加锁才能访问的元素</span><br>    <span class="hljs-comment">// 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素</span><br>    dirty <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry<br><br>    <span class="hljs-comment">// 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空</span><br>    misses <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> readOnly <span class="hljs-keyword">struct</span> &#123;<br>    m       <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry<br>    amended <span class="hljs-type">bool</span> <span class="hljs-comment">// 当dirty中包含read没有的数据时为true，比如新增一条数据</span><br>&#125;<br><br><span class="hljs-comment">// expunged是用来标识此项已经删掉的指针</span><br><span class="hljs-comment">// 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项</span><br><span class="hljs-keyword">var</span> expunged = unsafe.Pointer(<span class="hljs-built_in">new</span>(<span class="hljs-keyword">interface</span>&#123;&#125;))<br><br><span class="hljs-comment">// entry代表一个值</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>    p unsafe.Pointer <span class="hljs-comment">// *interface&#123;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 dirty 字段非 nil 的话，map 的 read 字段和 dirty 字段会包含相同的非 expunged 的项，所以如果通过 read 字段更改了这个项的值，从 dirty 字段中也会读取到这个项的新值，因为本来它们指向的就是同一个地址。</p>
<p>dirty 包含重复项目的好处就是，一旦 miss 数达到阈值需要将 dirty 提升为 read 的话，只需简单地把 dirty 设置为 read 对象即可。不好的一点就是，当创建新的 dirty 对象的时候，需要逐条遍历 read，把非 expunged 的项复制到 dirty 对象中。</p>
<p>接下来，我们就深入到源码去看看 sync.map 的实现。在看这部分源码的过程中，我们只要重点关注 Store、Load 和 Delete 这 3 个核心的方法就可以了。</p>
<p>Store、Load 和 Delete 这三个核心函数的操作都是先从 read 字段中处理的，因为读取 read 字段的时候不用加锁。</p>
<p><strong>Store 方法</strong></p>
<p>我们先来看 Store 方法，它是用来设置一个键值对，或者更新一个键值对的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Store(key, value <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    read, _ := m.read.Load().(readOnly)<br>    <span class="hljs-comment">// 如果read字段包含这个项，说明是更新，cas更新项目的值即可</span><br>    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// read中不存在，或者cas更新失败，就需要加锁访问dirty了</span><br>    m.mu.Lock()<br>    read, _ = m.read.Load().(readOnly)<br>    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="hljs-comment">// 双检查，看看read是否已经存在了</span><br>        <span class="hljs-keyword">if</span> e.unexpungeLocked() &#123;<br>            <span class="hljs-comment">// 此项目先前已经被删除了，通过将它的值设置为nil，标记为unexpunged</span><br>            m.dirty[key] = e<br>        &#125;<br>        e.storeLocked(&amp;value) <span class="hljs-comment">// 更新</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="hljs-comment">// 如果dirty中有此项</span><br>        e.storeLocked(&amp;value) <span class="hljs-comment">// 直接更新</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则就是一个新的key</span><br>        <span class="hljs-keyword">if</span> !read.amended &#123; <span class="hljs-comment">//如果dirty为nil</span><br>            <span class="hljs-comment">// 需要创建dirty对象，并且标记read的amended为true,</span><br>            <span class="hljs-comment">// 说明有元素它不包含而dirty包含</span><br>            m.dirtyLocked()<br>            m.read.Store(readOnly&#123;m: read.m, amended: <span class="hljs-literal">true</span>&#125;)<br>        &#125;<br>        m.dirty[key] = newEntry(value) <span class="hljs-comment">//将新值增加到dirty对象中</span><br>    &#125;<br>    m.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，Store 既可以是新增元素，也可以是更新元素。如果运气好的话，更新的是已存在的未被删除的元素，直接更新即可，不会用到锁。如果运气不好，需要更新（重用）删除的对象、更新还未提升的 dirty 中的对象，或者新增加元素的时候就会使用到了锁，这个时候，性能就会下降。</p>
<p>所以从这一点来看，sync.Map 适合那些只会增长的缓存系统，可以进行更新，但是不要删除，并且不要频繁地增加新元素。</p>
<p>新加的元素需要放入到 dirty 中，如果 dirty 为 nil，那么需要从 read 字段中复制出来一个 dirty 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> dirtyLocked() &#123;<br>    <span class="hljs-keyword">if</span> m.dirty != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果dirty字段已经存在，不需要创建了</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    read, _ := m.read.Load().(readOnly) <span class="hljs-comment">// 获取read字段</span><br>    m.dirty = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry, <span class="hljs-built_in">len</span>(read.m))<br>    <span class="hljs-keyword">for</span> k, e := <span class="hljs-keyword">range</span> read.m &#123; <span class="hljs-comment">// 遍历read字段</span><br>        <span class="hljs-keyword">if</span> !e.tryExpungeLocked() &#123; <span class="hljs-comment">// 把非punged的键值对复制到dirty中</span><br>            m.dirty[k] = e<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Load 方法</strong></p>
<p>Load 方法用来读取一个 key 对应的值。它也是从 read 开始处理，一开始并不需要锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Load(key <span class="hljs-keyword">interface</span>&#123;&#125;) (value <span class="hljs-keyword">interface</span>&#123;&#125;, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-comment">// 首先从read处理</span><br>    read, _ := m.read.Load().(readOnly)<br>    e, ok := read.m[key]<br>    <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="hljs-comment">// 如果不存在并且dirty不为nil(有新的元素)</span><br>        m.mu.Lock()<br>        <span class="hljs-comment">// 双检查，看看read中现在是否存在此key</span><br>        read, _ = m.read.Load().(readOnly)<br>        e, ok = read.m[key]<br>        <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="hljs-comment">//依然不存在，并且dirty不为nil</span><br>            e, ok = m.dirty[key]<span class="hljs-comment">// 从dirty中读取</span><br>            <span class="hljs-comment">// 不管dirty中存不存在，miss数都加1</span><br>            m.missLocked()<br>        &#125;<br>        m.mu.Unlock()<br>    &#125;<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> e.load() <span class="hljs-comment">//返回读取的对象，e既可能是从read中获得的，也可能是从dirty中获得的</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果幸运的话，我们从 read 中读取到了这个 key 对应的值，那么就不需要加锁了，性能会非常好。但是，如果请求的 key 不存在或者是新加的，就需要加锁从 dirty 中读取。所以，读取不存在的 key 会因为加锁而导致性能下降，读取还没有提升的新值的情况下也会因为加锁性能下降。</p>
<p>其中，missLocked 增加 miss 的时候，如果 miss 数等于 dirty 长度，会将 dirty 提升为 read，并将 dirty 置空。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> missLocked() &#123;<br>    m.misses++ <span class="hljs-comment">// misses计数加一</span><br>    <span class="hljs-keyword">if</span> m.misses &lt; <span class="hljs-built_in">len</span>(m.dirty) &#123; <span class="hljs-comment">// 如果没达到阈值(dirty字段的长度),返回</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    m.read.Store(readOnly&#123;m: m.dirty&#125;) <span class="hljs-comment">//把dirty字段的内存提升为read字段</span><br>    m.dirty = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 清空dirty</span><br>    m.misses = <span class="hljs-number">0</span>  <span class="hljs-comment">// misses数重置为0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Delete 方法</strong></p>
<p>sync.map 的第 3 个核心方法是 Delete 方法。在 Go 1.15 中欧长坤提供了一个 LoadAndDelete 的实现（go#issue 33762），所以 Delete 方法的核心改在了对 LoadAndDelete 中实现了。</p>
<p>同样地，Delete 方法是先从 read 操作开始，原因我们已经知道了，因为不需要锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> LoadAndDelete(key <span class="hljs-keyword">interface</span>&#123;&#125;) (value <span class="hljs-keyword">interface</span>&#123;&#125;, loaded <span class="hljs-type">bool</span>) &#123;<br>    read, _ := m.read.Load().(readOnly)<br>    e, ok := read.m[key]<br>    <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended &#123;<br>        m.mu.Lock()<br>        <span class="hljs-comment">// 双检查</span><br>        read, _ = m.read.Load().(readOnly)<br>        e, ok = read.m[key]<br>        <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended &#123;<br>            e, ok = m.dirty[key]<br>            <span class="hljs-comment">// 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收</span><br>            <span class="hljs-built_in">delete</span>(m.dirty, key)<br>            <span class="hljs-comment">// miss数加1</span><br>            m.missLocked()<br>        &#125;<br>        m.mu.Unlock()<br>    &#125;<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">delete</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Delete(key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.LoadAndDelete(key)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> <span class="hljs-built_in">delete</span>() (value <span class="hljs-keyword">interface</span>&#123;&#125;, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        p := atomic.LoadPointer(&amp;e.p)<br>        <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || p == expunged &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="hljs-literal">nil</span>) &#123;<br>            <span class="hljs-keyword">return</span> *(*<span class="hljs-keyword">interface</span>&#123;&#125;)(p), <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 read 中不存在，那么就需要从 dirty 中寻找这个项目。最终，如果项目存在就删除（将它的值标记为 nil）。如果项目不为 nil 或者没有被标记为 expunged，那么还可以把它的值返回。</p>
<p>最后，我补充一点，sync.map 还有一些 LoadAndDelete、LoadOrStore、Range 等辅助方法，但是没有 Len 这样查询 sync.Map 的包含项目数量的方法，并且官方也不准备提供。如果你想得到 sync.Map 的项目数量的话，你可能不得不通过 Range 逐个计数。</p>
<br>
<p><strong>总结</strong></p>
<p>Go 内置的 map 类型使用起来很方便，但是它有一个非常致命的缺陷，那就是它存在着并发问题，所以如果有多个 goroutine 同时并发访问这个 map，就会导致程序崩溃。所以 Go 官方 Blog 很早就提供了一种加锁的<a target="_blank" rel="noopener" href="https://blog.golang.org/maps#TOC_6.">方法</a>，还有后来提供了适用特定场景的线程安全的 sync.Map，还有第三方实现的分片式的 map，这些方法都可以应用于并发访问的场景。</p>
<p>这里的建议，也是 Go 开发者给的建议，就是通过性能测试，看看某种线程安全的 map 实现是否满足你的需求。</p>
<p>当然还有一些扩展其它功能的 map 实现，比如带有过期功能的<a target="_blank" rel="noopener" href="https://github.com/zekroTJA/timedmap">timedmap</a>、使用红黑树实现的 key 有序的<a target="_blank" rel="noopener" href="https://godoc.org/github.com/emirpasic/gods/maps/treemap">treemap</a>等，因为和并发问题没有关系，就不详细介绍了。这里我给你提供了链接，你可以自己探索。</p>
<hr>
<p><br><br><br></p>
<h3 id="2-10-Pool：性能提升大杀器">2.10 Pool：性能提升大杀器</h3>
<p>Go 是一个自动垃圾回收的编程语言，采用<a target="_blank" rel="noopener" href="https://go.dev/blog/ismmkeynote">三色并发标记算法</a>标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。</p>
<p>但是，<strong>如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</strong>，毕竟，Go 的自动垃圾回收机制还是有一个 STW（stop-the-world，程序暂停）的时间，而且，大量地创建在堆上的对象，也会影响垃圾回收标记的时间。</p>
<p>所以，一般我们做性能优化的时候，会采用对象池的方式，把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必在堆上重新创建了。</p>
<p>不止如此，像数据库连接、TCP 的长连接，这些连接在创建的时候是一个非常耗时的操作。如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上。</p>
<p>所以，如果我们能把这些连接保存下来，避免每次使用的时候都重新创建，不仅可以大大减少业务的耗时，还能提高应用程序的整体性能。</p>
<p>Go 标准库中提供了一个通用的 Pool 数据结构，也就是 sync.Pool，我们使用它可以创建池化的对象。这节课我会详细给你介绍一下 sync.Pool 的使用方法、实现原理以及常见的坑，帮助你全方位地掌握标准库的 Pool。</p>
<p>不过，这个类型也有一些使用起来不太方便的地方，就是<strong>它池化的对象可能会被垃圾回收掉</strong>，这对于数据库长连接等场景是不合适的。所以在这一讲中，我会专门介绍其它的一些 Pool，包括 TCP 连接池、数据库连接池等等。</p>
<p>除此之外，我还会专门介绍一个池的应用场景： Worker Pool，或者叫做 goroutine pool，这也是常用的一种并发模式，可以使用有限的 goroutine 资源去处理大量的业务数据。</p>
<br>
<p><strong>sync.Pool</strong></p>
<p>首先，我们来学习下标准库提供的 sync.Pool 数据类型。</p>
<p>sync.Pool 数据类型用来保存一组可独立访问的<strong>临时</strong>对象。请注意这里加粗的“临时”这两个字，它说明了 sync.Pool 这个数据类型的特点，也就是说，它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且，如果没有别的对象引用这个被移除的对象的话，这个被移除的对象就会被垃圾回收掉。</p>
<p>因为 Pool 可以有效地减少新对象的申请，从而提高程序性能，所以 Go 内部库也用到了 sync.Pool，比如 fmt 包，它会使用一个动态大小的 buffer 池做输出缓存，当大量的 goroutine 并发输出的时候，就会创建比较多的 buffer，并且在不需要的时候回收掉。</p>
<p>有两个知识点你需要记住：</p>
<ol>
<li>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；</li>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
<br>
<p><strong>sync.Pool 的使用方法</strong></p>
<p>知道了 sync.Pool 这个数据类型的特点，接下来，我们来学习下它的使用方法。其实，这个数据类型不难，它只提供了三个对外的方法：New、Get 和 Put。</p>
<ol>
<li>
<p><strong>New</strong></p>
<p>Pool struct 包含一个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</p>
<p>有趣的是，New 是可变的字段。这就意味着，你可以在程序运行的时候改变创建元素的方法。当然，很少有人会这么做，因为一般我们创建元素的逻辑都是一致的，要创建的也是同一类的元素，所以你在使用 Pool 的时候也没必要玩一些“花活”，在程序运行时更改 New 的值。</p>
</li>
<li>
<p><strong>Get</strong></p>
<p>如果调用这个方法，就会从 Pool 取走一个元素，这也就意味着，这个元素会从 Pool 中移除，返回给调用者。不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil（Pool.New 字段没有设置，又没有空闲元素可以返回），所以你在使用的时候，可能需要判断。</p>
</li>
<li>
<p><strong>Put</strong></p>
<p>这个方法用于将一个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但如果 Put 一个 nil 值，Pool 就会忽略这个值。</p>
</li>
</ol>
<br>
<p>好了，了解了这几个方法，下面我们看看 sync.Pool 最常用的一个场景：buffer 池（缓冲池）。</p>
<p>因为 byte slice 是经常被创建销毁的一类对象，使用 buffer 池可以缓存已经创建的 byte slice，比如，著名的静态网站生成工具 Hugo 中，就包含这样的实现<a target="_blank" rel="noopener" href="https://github.com/gohugoio/hugo/blob/master/bufferpool/bufpool.go">bufpool</a>，你可以看一下下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffers = sync.Pool&#123;<br>    New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(bytes.Buffer)<br>    &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetBuffer</span><span class="hljs-params">()</span></span> *bytes.Buffer &#123;<br>    <span class="hljs-keyword">return</span> buffers.Get().(*bytes.Buffer)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PutBuffer</span><span class="hljs-params">(buf *bytes.Buffer)</span></span> &#123;<br>    buf.Reset()<br>    buffers.Put(buf)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了 Hugo，这段 buffer 池的代码非常常用。很可能你在阅读其它项目的代码的时候就碰到过，或者是你自己实现 buffer 池的时候也会这么去实现，但是请你注意了，这段代码是有问题的，你一定不要将上面的代码应用到实际的产品中。它可能会有内存泄漏的问题，下面我会重点讲这个问题。</p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">bytes.Buffer </summary><div class="toggle-content"><p><code>bytes.Buffer</code> 是 Go 标准库 <code>bytes</code> 包中的一个结构体，提供了一个可变大小的字节缓冲区，用于高效地操作字节切片。它在处理字符串构建、数据流操作以及实现 <code>io.Reader</code> 和 <code>io.Writer</code> 接口时非常有用。</p>
<p><strong>主要特性</strong></p>
<ol>
<li>
<p><strong>动态扩展</strong>：</p>
<ul>
<li><code>bytes.Buffer</code> 可以根据需要动态扩展其容量，避免频繁分配内存，提高性能。</li>
</ul>
</li>
<li>
<p><strong>实现接口</strong>：</p>
<ul>
<li>实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，使其可以方便地用于各种 I/O 操作中，如文件读写、网络通信等。</li>
</ul>
</li>
<li>
<p><strong>高效的字符串构建</strong>：</p>
<ul>
<li>相比于使用字符串拼接（<code>+</code> 操作符），使用 <code>bytes.Buffer</code> 构建字符串更高效，特别是在需要进行大量拼接时。</li>
</ul>
</li>
<li>
<p><strong>内存复用</strong>：</p>
<ul>
<li>通过复用内部缓冲区，减少了内存分配和垃圾回收的开销。</li>
</ul>
</li>
</ol>
<br>
<p><strong>常见用途</strong></p>
<ol>
<li>
<p><strong>字符串和字节切片的构建</strong>：</p>
<ul>
<li>适用于需要逐步构建复杂字符串或字节数据的场景。</li>
</ul>
</li>
<li>
<p><strong>数据流操作</strong>：</p>
<ul>
<li>作为临时存储，聚合来自不同来源的数据，然后一次性处理或传输。</li>
</ul>
</li>
<li>
<p><strong>实现 <code>io.Reader</code> 和 <code>io.Writer</code></strong>：</p>
<ul>
<li>在需要读取或写入数据的自定义函数或方法中，作为中间缓冲区使用。</li>
</ul>
</li>
<li>
<p><strong>网络编程</strong>：</p>
<ul>
<li>构建需要发送的消息或解析接收到的消息，尤其是在处理协议数据时。</li>
</ul>
</li>
</ol>
<br>
<p><strong>常用方法</strong></p>
<ul>
<li>
<p><code>Write(p []byte) (n int, err error)</code>：<br>
向缓冲区写入字节切片 <code>p</code>。</p>
</li>
<li>
<p><code>WriteString(s string) (n int, err error)</code>：<br>
向缓冲区写入字符串 <code>s</code>。</p>
</li>
<li>
<p><code>Read(p []byte) (n int, err error)</code>：<br>
从缓冲区读取数据到 <code>p</code>。</p>
</li>
<li>
<p><code>Bytes() []byte</code>：<br>
返回缓冲区的内容作为字节切片。</p>
</li>
<li>
<p><code>String() string</code>：<br>
返回缓冲区的内容作为字符串。</p>
</li>
<li>
<p><code>Reset()</code>：<br>
重置缓冲区，清空所有内容。</p>
</li>
<li>
<p><code>Len() int</code>：<br>
返回缓冲区当前的长度。</p>
</li>
<li>
<p><code>Cap() int</code>：<br>
返回缓冲区的容量。</p>
</li>
</ul>
<br>
<p><strong>示例代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bytes&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Buffer</span><br>    <span class="hljs-keyword">var</span> buffer bytes.Buffer<br><br>    <span class="hljs-comment">// 向 Buffer 写入字符串</span><br>    buffer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello &quot;</span>))<br>    buffer.WriteString(<span class="hljs-string">&quot;World!&quot;</span>)<br><br>    <span class="hljs-comment">// 将 Buffer 的内容作为字符串输出</span><br>    fmt.Println(buffer.String()) <span class="hljs-comment">// 输出: Hello World!</span><br><br>    <span class="hljs-comment">// 将 Buffer 的内容写入标准输出</span><br>    buffer.WriteTo(os.Stdout) <span class="hljs-comment">// 输出: Hello World!</span><br><br>    <span class="hljs-comment">// 从 Buffer 读取数据</span><br>    data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">5</span>)<br>    buffer.Read(data)<br>    fmt.Println(<span class="hljs-type">string</span>(data)) <span class="hljs-comment">// 输出: Hello</span><br><br>    <span class="hljs-comment">// 重置 Buffer</span><br>    buffer.Reset()<br>    fmt.Println(<span class="hljs-string">&quot;Buffer reset, length:&quot;</span>, buffer.Len()) <span class="hljs-comment">// 输出: Buffer reset, length: 0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>注意事项</strong></p>
<ol>
<li>
<p><strong>并发安全性</strong>：</p>
<ul>
<li><code>bytes.Buffer</code> 不是并发安全的。如果需要在多个 goroutine 中同时访问同一个 <code>Buffer</code> 实例，需使用外部同步机制（如 <code>sync.Mutex</code>）。</li>
</ul>
</li>
<li>
<p><strong>性能优化</strong>：</p>
<ul>
<li>在只需要构建字符串的场景下，可以考虑使用 <code>strings.Builder</code>，它在某些情况下比 <code>bytes.Buffer</code> 更高效。</li>
</ul>
</li>
<li>
<p><strong>内存管理</strong>：</p>
<ul>
<li>虽然 <code>bytes.Buffer</code> 会自动管理缓冲区大小，但在处理非常大的数据时，仍需注意内存的使用情况，避免过度分配。</li>
</ul>
</li>
</ol>
<br>
<p><strong>总结</strong></p>
<p><code>bytes.Buffer</code> 是 Go 语言中一个强大且灵活的工具，适用于多种需要高效字节和字符串操作的场景。通过其实现的接口和丰富的方法，开发者可以轻松地进行数据的读写、构建和转换操作。在实际开发中，合理选择和使用 <code>bytes.Buffer</code> 能显著提升代码的性能和可维护性。</p>
</div></details>
<br>
<p><strong>实现原理</strong></p>
<p>了解了 sync.Pool 的基本使用方法，下面我们就来重点学习下它的实现。</p>
<p>Go 1.13 之前的 sync.Pool 的实现有 2 大问题：</p>
<ol>
<li>
<p>每次 GC 都会回收创建的对象。</p>
<p>如果缓存元素数量太多，就会导致 STW 耗时变长；缓存元素都被回收后，会导致 Get 命中率下降，Get 方法不得不新创建很多对象</p>
</li>
<li>
<p>底层实现使用了 Mutex，对这个锁并发请求竞争激烈的时候，会导致性能的下降。</p>
</li>
</ol>
<p>在 Go 1.13 中，sync.Pool 做了大量的优化。前几讲中我提到过，提高并发程序性能的优化点是尽量不要使用锁，如果不得已使用了锁，就把锁 Go 的粒度降到最低。<strong>Go 对 Pool 的优化就是避免使用锁，同时将加锁的 queue 改成 lock-free 的 queue 的实现，给即将移除的元素再多一次“复活”的机会</strong>。</p>
<p>当前，sync.Pool 的数据结构如下图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/f4003704663ea081230760098f8af696.webp" alt=""></p>
<p>Pool 最重要的两个字段是 local 和 victim，因为它们两个主要用来存储空闲的元素。弄清楚这两个字段的处理逻辑，你就能完全掌握 sync.Pool 的实现了。下面我们来看看这两个字段的关系。</p>
<p>每次垃圾回收的时候，Pool 会把 victim 中的对象移除，然后把 local 的数据给 victim，这样的话，local 就会被清空，而 victim 就像一个垃圾分拣站，里面的东西可能会被当做垃圾丢弃了，但是里面有用的东西也可能被捡回来重新使用。</p>
<p>victim 中的元素如果被 Get 取走，那么这个元素就很幸运，因为它又“活”过来了。但是，如果这个时候 Get 的并发不是很大，元素没有被 Get 取走，那么就会被移除掉，因为没有别人引用它的话，就会被垃圾回收掉。</p>
<p>下面的代码是垃圾回收时 sync.Pool 的处理逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poolCleanup</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 丢弃当前victim, STW所以不用加锁</span><br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> oldPools &#123;<br>        p.victim = <span class="hljs-literal">nil</span><br>        p.victimSize = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将local复制给victim, 并将原local置为nil</span><br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> allPools &#123;<br>        p.victim = p.local<br>        p.victimSize = p.localSize<br>        p.local = <span class="hljs-literal">nil</span><br>        p.localSize = <span class="hljs-number">0</span><br>    &#125;<br><br>    oldPools, allPools = allPools, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这段代码中，你需要关注一下 local 字段，因为所有当前主要的空闲可用的元素都存放在 local 字段中，请求元素时也是优先从 local 字段中查找可用的元素。local 字段包含一个 poolLocalInternal 字段，并提供 CPU 缓存对齐，从而避免 false sharing。</p>
<p>而 poolLocalInternal 也包含两个字段：private 和 shared。</p>
<ul>
<li>private，代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。</li>
<li>shared，可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。</li>
</ul>
<p><strong>Get 方法</strong></p>
<p>我们来看看 Get 方法的具体实现原理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Get() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-comment">// 把当前goroutine固定在当前的P上</span><br>    l, pid := p.pin()<br>    x := l.private <span class="hljs-comment">// 优先从local的private字段取，快速</span><br>    l.private = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 从当前的local.shared弹出一个，注意是从head读取并移除</span><br>        x, _ = l.shared.popHead()<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果没有，则去偷一个</span><br>            x = p.getSlow(pid) <br>        &#125;<br>    &#125;<br>    runtime_procUnpin()<br>    <span class="hljs-comment">// 如果没有获取到，尝试使用New函数生成一个新的</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &amp;&amp; p.New != <span class="hljs-literal">nil</span> &#123;<br>        x = p.New()<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我来给你解释下这段代码。首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快，如果没有获取到，就尝试从本地的 shared 获取一个，如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个。最后，如果没有获取到，就尝试使用 New 函数创建一个新的。</p>
<p>这里的重点是 getSlow 方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的 local，尝试从它们的 shared 弹出一个元素。如果还没找到一个，那么，就开始对 victim 下手了。</p>
<p>在 vintim 中查询可用元素的逻辑还是一样的，先从对应的 victim 的 private 查找，如果查不到，就再从其它 victim 的 shared 中查找。<br>
下面的代码是 getSlow 方法的主要逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> getSlow(pid <span class="hljs-type">int</span>) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><br>    size := atomic.LoadUintptr(&amp;p.localSize)<br>    locals := p.local                       <br>    <span class="hljs-comment">// 从其它proc中尝试偷取一个元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(size); i++ &#123;<br>        l := indexLocal(locals, (pid+i+<span class="hljs-number">1</span>)%<span class="hljs-type">int</span>(size))<br>        <span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> x<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果其它proc也没有可用元素，那么尝试从vintim中获取</span><br>    size = atomic.LoadUintptr(&amp;p.victimSize)<br>    <span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(pid) &gt;= size &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    locals = p.victim<br>    l := indexLocal(locals, pid)<br>    <span class="hljs-keyword">if</span> x := l.private; x != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 同样的逻辑，先从vintim中的local private获取</span><br>        l.private = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(size); i++ &#123; <span class="hljs-comment">// 从vintim其它proc尝试偷取</span><br>        l := indexLocal(locals, (pid+i)%<span class="hljs-type">int</span>(size))<br>        <span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> x<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了</span><br>    atomic.StoreUintptr(&amp;p.victimSize, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我没列出 pin 代码的实现，你只需要知道，pin 方法会将此 goroutine 固定在当前的 P 上，避免查找元素期间被其它的 P 执行。固定的好处就是查找元素期间直接得到跟这个 P 相关的 local。有一点需要注意的是，pin 方法在执行的时候，如果跟这个 P 相关的 local 还没有创建，或者运行时 P 的数量被修改了的话，就会新创建 local。</p>
<p><strong>Put 方法</strong></p>
<p>我们来看看 Put 方法的具体实现原理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Put(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// nil值直接丢弃</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    l, _ := p.pin()<br>    <span class="hljs-keyword">if</span> l.private == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果本地private没有值，直接设置这个值即可</span><br>        l.private = x<br>        x = <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 否则加入到本地队列中</span><br>        l.shared.pushHead(x)<br>    &#125;<br>    runtime_procUnpin()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Put 的逻辑相对简单，优先设置本地 private，如果 private 字段已经有值了，那么就把此元素 push 到本地队列中。</p>
<p><strong>sync.Pool 的坑</strong></p>
<p>到这里，我们就掌握了 sync.Pool 的使用方法和实现原理，接下来，我要再和你聊聊容易踩的两个坑，分别是内存泄漏和内存浪费。</p>
<p><strong>内存泄漏</strong></p>
<p>这节课刚开始的时候，我讲到，可以使用 sync.Pool 做 buffer 池，但是，如果用刚刚的那种方式做 buffer 池的话，可能会有内存泄漏的风险。为啥这么说呢？我们来分析一下。</p>
<p>取出来的 bytes.Buffer 在使用的时候，我们可以往这个元素中增加大量的 byte 数据，这会导致底层的 byte slice 的容量可能会变得很大。这个时候，即使 Reset 再放回到池子中，这些 byte slice 的容量不会改变，所占的空间依然很大。而且，因为 Pool 回收的机制，这些大的 Buffer 可能不被回收，而是会一直占用很大的空间，这属于内存泄漏的问题。</p>
<p>即使是 Go 的标准库，在内存泄漏这个问题上也栽了几次坑，比如 <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/23199">issue 23199</a>、<a target="_blank" rel="noopener" href="https://github.com/dsnet">@dsnet</a>提供了一个简单的可重现的例子，演示了内存泄漏的问题。再比如 encoding、json 中类似的问题：将容量已经变得很大的 Buffer 再放回 Pool 中，导致内存泄漏。后来在元素放回时，增加了检查逻辑，改成放回的超过一定大小的 buffer，就直接丢弃掉，不再放到池子中，如下所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/e3e23d2f2ab55b64741e14856a58389f.webp" alt=""></p>
<p>package fmt 中也有这个问题，修改方法是一样的，超过一定大小的 buffer，就直接丢弃了：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/06c68476cac13a860c470b006718c462.webp" alt=""></p>
<p>在使用 sync.Pool 回收 buffer 的时候，一定要检查回收的对象的大小。如果 buffer 太大，就不要回收了，否则就太浪费了。</p>
<br>
<p><strong>内存浪费</strong></p>
<p>除了内存泄漏以外，还有一种浪费的情况，就是池子中的 buffer 都比较大，但在实际使用的时候，很多时候只需要一个小的 buffer，这也是一种浪费现象。接下来，我就讲解一下这种情况的处理方法。</p>
<p>要做到物尽其用，尽可能不浪费的话，我们可以将 buffer 池分成几层。首先，小于 512 byte 的元素的 buffer 占一个池子；其次，小于 1K byte 大小的元素占一个池子；再次，小于 4K byte 大小的元素占一个池子。这样分成几个池子以后，就可以根据需要，到所需大小的池子中获取 buffer 了。</p>
<p>在标准库 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/617f2c3e35cdc8483b950aa3ef18d92965d63197/src/net/http/server.go">net/http/server.go</a>中的代码中，就提供了 2K 和 4K 两个 writer 的池子。你可以看看下面这段代码：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/55086ccba91975a0f65bd35d1192e335.webp" alt=""></p>
<p>YouTube 开源的知名项目 vitess 中提供了<a target="_blank" rel="noopener" href="https://github.com/vitessio/vitess/blob/master/go/bucketpool/bucketpool.go">bucketpool</a>的实现，它提供了更加通用的多层 buffer 池。你在使用的时候，只需要指定池子的最大和最小尺寸，vitess 就会自动计算出合适的池子数。而且，当你调用 Get 方法的时候，只需要传入你要获取的 buffer 的大小，就可以了。下面这段代码就描述了这个过程，你可以看看：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/c5cd474aa53fe57e0722d840a6c7f308.webp" alt=""></p>
<br>
<p><strong>第三方库</strong></p>
<p>除了这种分层的为了节省空间的 buffer 设计外，还有其它的一些第三方的库也会提供 buffer 池的功能。接下来我带你熟悉几个常用的第三方的库。</p>
<p>1.<a target="_blank" rel="noopener" href="https://github.com/valyala/bytebufferpool">bytebufferpool</a></p>
<p>这是 fasthttp 作者 valyala 提供的一个 buffer 池，基本功能和 sync.Pool 相同。它的底层也是使用 sync.Pool 实现的，包括会检测最大的 buffer，超过最大尺寸的 buffer，就会被丢弃。</p>
<p>valyala 一向很擅长挖掘系统的性能，这个库也不例外。它提供了校准（calibrate，用来动态调整创建元素的权重）的机制，可以“智能”地调整 Pool 的 defaultSize 和 maxSize。一般来说，我们使用 buffer size 的场景比较固定，所用 buffer 的大小会集中在某个范围里。有了校准的特性，bytebufferpool 就能够偏重于创建这个范围大小的 buffer，从而节省空间。</p>
<p>2.<a target="_blank" rel="noopener" href="https://github.com/oxtoacart/bpool">oxtoacart/bpool</a></p>
<p>这也是比较常用的 buffer 池，它提供了以下几种类型的 buffer。</p>
<ul>
<li>
<p>bpool.BufferPool： 提供一个固定元素数量的 buffer 池，元素类型是 bytes.Buffer，如果超过这个数量，Put 的时候就丢弃，如果池中的元素都被取光了，会新建一个返回。Put 回去的时候，不会检测 buffer 的大小。</p>
</li>
<li>
<p>bpool.BytesPool：提供一个固定元素数量的 byte slice 池，元素类型是 byte slice。Put 回去的时候不检测 slice 的大小。</p>
</li>
<li>
<p>bpool.SizedBufferPool： 提供一个固定元素数量的 buffer 池，如果超过这个数量，Put 的时候就丢弃，如果池中的元素都被取光了，会新建一个返回。Put 回去的时候，会检测 buffer 的大小，超过指定的大小的话，就会创建一个新的满足条件的 buffer 放回去。</p>
</li>
</ul>
<p>bpool 最大的特色就是能够保持池子中元素的数量，一旦 Put 的数量多于它的阈值，就会自动丢弃，而 sync.Pool 是一个没有限制的池子，只要 Put 就会收进去。</p>
<p>bpool 是基于 Channel 实现的，不像 sync.Pool 为了提高性能而做了很多优化，所以，在性能上比不过 sync.Pool。不过，它提供了限制 Pool 容量的功能，所以，如果你想控制 Pool 的容量的话，可以考虑这个库。</p>
<br>
<p><strong>连接池</strong></p>
<p>Pool 的另一个很常用的一个场景就是保持 TCP 的连接。一个 TCP 的连接创建，需要三次握手等过程，如果是 TLS 的，还会需要更多的步骤，如果加上身份认证等逻辑的话，耗时会更长。所以，为了避免每次通讯的时候都新创建连接，我们一般会建立一个连接的池子，预先把连接创建好，或者是逐步把连接放在池子中，减少连接创建的耗时，从而提高系统的性能。</p>
<p>事实上，我们很少会使用 sync.Pool 去池化连接对象，原因就在于，sync.Pool 会无通知地在某个时候就把连接移除垃圾回收掉了，而我们的场景是需要长久保持这个连接，所以，我们一般会使用其它方法来池化连接，比如接下来我要讲到的几种需要保持长连接的 Pool。</p>
<p><strong>标准库中的 http client 池</strong></p>
<p>标准库的 http.Client 是一个 http client 的库，可以用它来访问 web 服务器。为了提高性能，这个 Client 的实现也是通过池的方法来缓存一定数量的连接，以便后续重用这些连接。</p>
<p>http.Client 实现连接池的代码是在 Transport 类型中，它使用 idleConn 保存持久化的可重用的长连接：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/141ced98a81466b793b0f90b9652afec.webp" alt=""></p>
<p><strong>TCP 连接池</strong></p>
<p>最常用的一个 TCP 连接池是 fatih 开发的fatih/pool，虽然这个项目已经被 fatih 归档（Archived），不再维护了，但是因为它相当稳定了，我们可以开箱即用。即使你有一些特殊的需求，也可以 fork 它，然后自己再做修改。</p>
<p>它的使用套路如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 工厂模式，提供创建连接的工厂方法</span><br>factory := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (net.Conn, <span class="hljs-type">error</span>) &#123; <span class="hljs-keyword">return</span> net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:4000&quot;</span>) &#125;<br><br><span class="hljs-comment">// 创建一个tcp池，提供初始容量和最大容量以及工厂方法</span><br>p, err := pool.NewChannelPool(<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, factory)<br><br><span class="hljs-comment">// 获取一个连接</span><br>conn, err := p.Get()<br><br><span class="hljs-comment">// Close并不会真正关闭这个连接，而是把它放回池子，所以你不必显式地Put这个对象到池子中</span><br>conn.Close()<br><br><span class="hljs-comment">// 通过调用MarkUnusable, Close的时候就会真正关闭底层的tcp的连接了</span><br><span class="hljs-keyword">if</span> pc, ok := conn.(*pool.PoolConn); ok &#123;<br>  pc.MarkUnusable()<br>  pc.Close()<br>&#125;<br><br><span class="hljs-comment">// 关闭池子就会关闭=池子中的所有的tcp连接</span><br>p.Close()<br><br><span class="hljs-comment">// 当前池子中的连接的数量</span><br>current := p.Len()<br></code></pre></td></tr></table></figure>
<p>虽然一直在说 TCP，但是它管理的是更通用的 net.Conn，不局限于 TCP 连接。</p>
<p>它通过把 net.Conn 包装成 PoolConn，实现了拦截 net.Conn 的 Close 方法，避免了真正地关闭底层连接，而是把这个连接放回到池中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PoolConn <span class="hljs-keyword">struct</span> &#123;<br>    net.Conn<br>    mu       sync.RWMutex<br>    c        *channelPool<br>    unusable <span class="hljs-type">bool</span><br>&#125;<br>  <br>    <span class="hljs-comment">//拦截Close</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PoolConn)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    p.mu.RLock()<br>    <span class="hljs-keyword">defer</span> p.mu.RUnlock()<br>  <br>    <span class="hljs-keyword">if</span> p.unusable &#123;<br>        <span class="hljs-keyword">if</span> p.Conn != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> p.Conn.Close()<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p.c.put(p.Conn)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的 Pool 是通过 Channel 实现的，空闲的连接放入到 Channel 中，这也是 Channel 的一个应用场景：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> channelPool <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 存储连接池的channel</span><br>    mu    sync.RWMutex<br>    conns <span class="hljs-keyword">chan</span> net.Conn<br>  <br><br>    <span class="hljs-comment">// net.Conn 的产生器</span><br>    factory Factory<br>&#125;	<br></code></pre></td></tr></table></figure>
<p><strong>数据库连接池</strong></p>
<p>标准库 sql.DB 还提供了一个通用的数据库的连接池，通过 MaxOpenConns 和 MaxIdleConns 控制最大的连接数和最大的 idle 的连接数。默认的 MaxIdleConns 是 2，这个数对于数据库相关的应用来说太小了，我们一般都会调整它。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/49c14b5bccb6d6ac7a159eece17a2215.webp" alt=""></p>
<p>DB 的 freeConn 保存了 idle 的连接，这样，当我们获取数据库连接的时候，它就会优先尝试从 freeConn 获取已有的连接（<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/4fc3896e7933e31822caa50e024d4e139befc75f/src/database/sql/sql.go#L1196">conn</a>）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/d043yyd649a216fe37885yy4e03af3b5.webp" alt=""></p>
<p><strong>Memcached Client 连接池</strong></p>
<p>Brad Fitzpatrick 是知名缓存库 Memcached 的原作者，前 Go 团队成员。<a target="_blank" rel="noopener" href="https://github.com/bradfitz/gomemcache">gomemcache</a>是他使用 Go 开发的 Memchaced 的客户端，其中也用了连接池的方式池化 Memcached 的连接。接下来让我们看看它的连接池的实现。</p>
<p>gomemcache Client 有一个 freeconn 的字段，用来保存空闲的连接。当一个请求使用完之后，它会调用 putFreeConn 放回到池子中，请求的时候，调用 getFreeConn 优先查询 freeConn 中是否有可用的连接。它采用 Mutex+Slice 实现 Pool：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 放回一个待重用的连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> putFreeConn(addr net.Addr, cn *conn) &#123;<br>    c.lk.Lock()<br>    <span class="hljs-keyword">defer</span> c.lk.Unlock()<br>    <span class="hljs-keyword">if</span> c.freeconn == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果对象为空，创建一个map对象</span><br>        c.freeconn = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*conn)<br>    &#125;<br>    freelist := c.freeconn[addr.String()] <span class="hljs-comment">//得到此地址的连接列表</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(freelist) &gt;= c.maxIdleConns() &#123;<span class="hljs-comment">//如果连接已满,关闭，不再放入</span><br>        cn.nc.Close()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    c.freeconn[addr.String()] = <span class="hljs-built_in">append</span>(freelist, cn) <span class="hljs-comment">// 加入到空闲列表中</span><br>&#125;<br><br><span class="hljs-comment">// 得到一个空闲连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> getFreeConn(addr net.Addr) (cn *conn, ok <span class="hljs-type">bool</span>) &#123;<br>    c.lk.Lock()<br>    <span class="hljs-keyword">defer</span> c.lk.Unlock()<br>    <span class="hljs-keyword">if</span> c.freeconn == <span class="hljs-literal">nil</span> &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    freelist, ok := c.freeconn[addr.String()]<br>    <span class="hljs-keyword">if</span> !ok || <span class="hljs-built_in">len</span>(freelist) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有此地址的空闲列表，或者列表为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    cn = freelist[<span class="hljs-built_in">len</span>(freelist)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 取出尾部的空闲连接</span><br>    c.freeconn[addr.String()] = freelist[:<span class="hljs-built_in">len</span>(freelist)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> cn, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Worker Pool</strong></p>
<p>最后，我再讲一个 Pool 应用得非常广泛的场景。</p>
<p>你已经知道，goroutine 是一个很轻量级的“纤程”，在一个服务器上可以创建十几万甚至几十万的 goroutine。但是“可以”和“合适”之间还是有区别的，你会在应用中让几十万的 goroutine 一直跑吗？基本上是不会的。</p>
<p>一个 goroutine 初始的栈大小是 2048 个字节，并且在需要的时候可以扩展到 1GB（具体的内容你可以课下看看代码中的配置：<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L120">不同的架构最大数会不同</a>），所以，大量的 goroutine 还是很耗资源的。同时，大量的 goroutine 对于调度和垃圾回收的耗时还是会有影响的，因此，goroutine 并不是越多越好。</p>
<p>有的时候，我们就会创建一个 Worker Pool 来减少 goroutine 的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的 goroutine 去处理的话，在大量连接的情况下，就会创建大量的 goroutine，这个时候，我们就可以创建一个固定数量的 goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp 中的<a target="_blank" rel="noopener" href="https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16">Worker Pool</a>。</p>
<p>Worker 的实现也是五花八门的：</p>
<ul>
<li>有些是在后台默默执行的，不需要等待返回结果；</li>
<li>有些需要等待一批任务执行完；</li>
<li>有些 Worker Pool 的生命周期和程序一样长；</li>
<li>有些只是临时使用，执行完毕后，Pool 就销毁了。</li>
</ul>
<p>大部分的 Worker Pool 都是通过 Channel 来缓存任务的，因为 Channel 能够比较方便地实现并发的保护，有的是多个 Worker 共享同一个任务 Channel，有些是每个 Worker 都有一个独立的 Channel。</p>
<p>综合下来，精挑细选，我给你推荐三款易用的 Worker Pool，这三个 Worker Pool 的 API 设计简单，也比较相似，易于和项目集成，而且提供的功能也是我们常用的功能。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://godoc.org/github.com/gammazero/workerpool">gammazero/workerpool</a>：gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</li>
<li><a target="_blank" rel="noopener" href="https://godoc.org/github.com/ivpusic/grpool">ivpusic/grpool</a>：grpool 创建 Pool 的时候需要提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。</li>
<li><a target="_blank" rel="noopener" href="https://godoc.org/github.com/dpaks/goworkers">dpaks/goworkers</a>：dpaks/goworkers 提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。它的任务的执行结果需要在 ResultChan 和 ErrChan 中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker 的数量和任务数。</li>
</ul>
<p>类似的 Worker Pool 的实现非常多，比如还有<a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">panjf2000/ants</a>、<a target="_blank" rel="noopener" href="https://github.com/Jeffail/tunny">Jeffail/tunny</a> 、<a target="_blank" rel="noopener" href="https://github.com/benmanns/goworker">benmanns/goworker</a>、<a target="_blank" rel="noopener" href="https://github.com/go-playground/pool">go-playground/pool</a>、<a target="_blank" rel="noopener" href="https://github.com/Sherifabdlnaby/gpool">Sherifabdlnaby/gpool</a>等第三方库。<a target="_blank" rel="noopener" href="https://github.com/alitto/pond">pond</a>也是一个非常不错的 Worker Pool，关注度目前不是很高，但是功能非常齐全。</p>
<p>其实，你也可以自己去开发自己的 Worker Pool，但是，对于我这种“懒惰”的人来说，只要满足我的实际需求，我还是倾向于从这个几个常用的库中选择一个来使用。所以，我建议你也从常用的库中进行选择。</p>
<br>
<p><strong>总结</strong></p>
<p>Pool 是一个通用的概念，也是解决对象重用和预先分配的一个常用的优化手段。即使你自己没在项目中直接使用过，但肯定在使用其它库的时候，就享受到应用 Pool 的好处了，比如数据库的访问、http API 的请求等等。</p>
<p>我们一般不会在程序一开始的时候就开始考虑优化，而是等项目开发到一个阶段，或者快结束的时候，才全面地考虑程序中的优化点，而 Pool 就是常用的一个优化手段。如果你发现程序中有一种 GC 耗时特别高，有大量的相同类型的临时对象，不断地被创建销毁，这时，你就可以考虑看看，是不是可以通过池化的手段重用这些对象。</p>
<p>另外，在分布式系统或者微服务框架中，可能会有大量的并发 Client 请求，如果 Client 的耗时占比很大，你也可以考虑池化 Client，以便重用。 如果你发现系统中的 goroutine 数量非常多，程序的内存资源占用比较大，而且整体系统的耗时和 GC 也比较高，我建议你看看，是否能够通过 Worker Pool 解决大量 goroutine 的问题，从而降低这些指标。</p>
<p>如果你发现系统中的 goroutine 数量非常多，程序的内存资源占用比较大，而且整体系统的耗时和 GC 也比较高，我建议你看看，是否能够通过 Worker Pool 解决大量 goroutine 的问题，从而降低这些指标。</p>
<p><img src="/static/imgs/loading.gif" data-original="http://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go%2F58358f16bcee0281b55299f0386e17aa.webp" alt=""></p>
<hr>
<p><br><br><br></p>
<h3 id="2-11-Context：信息穿透上下文">2.11 Context：信息穿透上下文</h3>
<p>假设有一天你进入办公室，突然同事们都围住你，然后大喊“小王小王你最帅”，此时你可能一头雾水，只能尴尬地笑笑。为啥呢？因为你缺少上下文的信息，不知道之前发生了什么。</p>
<p>但是，如果同事告诉你，由于你业绩突出，一天之内就把云服务化的主要架构写好了，因此被评为 9 月份的工作之星，总经理还特意给你发 1 万元的奖金，那么，你心里就很清楚了，原来同事恭喜你，是因为你的工作被表扬了，还获得了奖金。同事告诉你的这些前因后果，就是上下文信息，他把上下文传递给你，你接收后，就可以获取之前不了解的信息。</p>
<p>你看，上下文（Context）就是这么重要。在我们的开发场景中，上下文也是不可或缺的，缺少了它，我们就不能获取完整的程序信息。那到底啥是上下文呢？其实，这就是指，在 API 之间或者方法调用之间，所传递的除了业务参数之外的额外信息。</p>
<p>比如，服务端接收到客户端的 HTTP 请求之后，可以把客户端的 IP 地址和端口、客户端的身份信息、请求接收的时间、Trace ID 等信息放入到上下文中，这个上下文可以在后端的方法调用中传递，后端的业务方法除了利用正常的参数做一些业务处理（如订单处理）之外，还可以从上下文读取到消息请求的时间、Trace  ID 等信息，把服务处理的时间推送到 Trace 服务中。Trace 服务可以把同一 Trace ID 的不同方法的调用顺序和调用时间展示成流程图，方便跟踪。</p>
<p>不过，Go 标准库中的 Context 功能还不止于此，它还提供了超时（Timeout）和取消（Cancel）的机制，下面就让我一一道来。</p>
<br>
<p><strong>Context 的来历</strong></p>
<p>在学习 Context 的功能之前呢，我先带你了解下它的来历。毕竟，知道了它的来龙去脉，我们才能应用得更加得心应手一些。</p>
<p>Go 在 1.7 的版本中才正式把 Context 加入到标准库中。在这之前，很多 Web 框架在定义自己的 handler 时，都会传递一个自定义的 Context，把客户端的信息和客户端的请求信息放入到 Context 中。Go 最初提供了 <a target="_blank" rel="noopener" href="http://golang.org/x/net/context">golang.org/x/net/context</a> 库用来提供上下文信息，最终还是在 Go1.7 中把此库提升到标准库 context 包中。</p>
<p>为啥呢？这是因为，在 Go1.7 之前，有很多库都依赖 <a target="_blank" rel="noopener" href="http://golang.org/x/net/context">golang.org/x/net/context</a> 中的 Context 实现，这就导致 Go 1.7 发布之后，出现了标准库 Context 和 <a target="_blank" rel="noopener" href="http://golang.org/x/net/context">golang.org/x/net/context</a> 并存的状况。新的代码使用标准库 Context 的时候，没有办法使用这个标准库的 Context 去调用旧有的使用 x/net/context 实现的方法。</p>
<p>所以，在 Go1.9 中，还专门实现了一个叫做 type alias 的新特性，然后把 x/net/context 中的 Context 定义成标准库 Context 的别名，以解决新旧 Context 类型冲突问题，你可以看一下下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build go1.9</span><br><span class="hljs-keyword">package</span> context<br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;context&quot;</span><br>  <br><span class="hljs-keyword">type</span> Context = context.Context<br><span class="hljs-keyword">type</span> CancelFunc = context.CancelFunc<br></code></pre></td></tr></table></figure>
<p>Go 标准库的 Context 不仅提供了上下文传递的信息，还提供了 cancel、timeout 等其它信息，这些信息貌似和 context 这个包名没关系，但是还是得到了广泛的应用。所以，你看，context 包中的 Context 不仅仅传递上下文信息，还有 timeout 等其它功能，是不是“名不副实”呢？</p>
<p>其实啊，这也是这个 Context 的一个问题，比较容易误导人，Go 布道师 Dave Cheney 还专门写了一篇文章讲述这个问题：<a target="_blank" rel="noopener" href="https://dave.cheney.net/2017/08/20/context-isnt-for-cancellation">Context isn’t for cancellation</a>。</p>
<p>同时，也有一些批评者针对 Context 提出了批评：<a target="_blank" rel="noopener" href="https://faiface.github.io/post/context-should-go-away-go2/">Context should go away for Go 2</a>，这篇文章把 Context 比作病毒，病毒会传染，结果把所有的方法都传染上了病毒（加上 Context 参数），绝对是视觉污染。</p>
<p>Go 的开发者也注意到了“关于 Context，存在一些争议”这件事儿，所以，Go 核心开发者 Ian Lance Taylor 专门开了一个issue 28342，用来记录当前的 Context 的问题：</p>
<ul>
<li>Context 包名导致使用的时候重复 ctx context.Context；</li>
<li>Context.WithValue 可以接受任何类型的值，非类型安全；</li>
<li>Context 包名容易误导人，实际上，Context 最主要的功能是取消 goroutine 的执行；</li>
<li>Context 漫天飞，函数污染。</li>
</ul>
<p>尽管有很多的争议，但是，在很多场景下，使用 Context 其实会很方便，所以现在它已经在 Go 生态圈中传播开来了，包括很多的 Web 应用框架，都切换成了标准库的 Context。标准库中的 database/sql、os/exec、net、net/http 等包中都使用到了 Context。而且，如果我们遇到了下面的一些场景，也可以考虑使用 Context：</p>
<ul>
<li>上下文信息传递 （request-scoped），比如处理 http 请求、在请求处理链路上传递信息；</li>
<li>控制子 goroutine 的运行；</li>
<li>超时控制的方法调用；</li>
<li>可以取消的方法调用。</li>
</ul>
<p>所以，我们需要掌握 Context 的具体用法，这样才能在不影响主要业务流程实现的时候，实现一些通用的信息传递，或者是能够和其它 goroutine 协同工作，提供 timeout、cancel 等机制。</p>
<br>
<p><strong>Context 基本使用方法</strong></p>
<p>首先，我们来学习一下 Context 接口包含哪些方法，这些方法都是干什么用的。</p>
<p>包 context 定义了 Context 接口，Context 的具体实现包括 4 个方法，分别是 Deadline、Done、Err 和 Value，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>    Err() <span class="hljs-type">error</span><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我来具体解释下这 4 个方法。</p>
<ul>
<li>
<p><code>Deadline</code> 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期，ok 的值是 false。后续每次调用这个对象的 Deadline 方法时，都会返回和第一次调用相同的结果。</p>
</li>
<li>
<p><code>Done</code> 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时候，你可以通过 ctx.Err 获取错误信息。Done 这个方法名其实起得并不好，因为名字太过笼统，不能明确反映 Done 被 close 的原因，因为 cancel、timeout、deadline 都可能导致 Done 被 close，不过，目前还没有一个更合适的方法名称。</p>
<p>关于 Done 方法，你必须要记住的知识点就是：如果 Done 没有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法会返回 Done 被 close 的原因。</p>
</li>
<li>
<p><code>Value</code> 返回此 ctx 中和指定的 key 相关联的 value。</p>
<p>Context 中实现了 2 个常用的生成顶层 Context 的方法。</p>
<ul>
<li><code>context.Background()</code>：返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。</li>
<li><code>context.TODO()</code>：返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。当你不清楚是否该用 Context，或者目前还不知道要传递一些什么上下文信息的时候，就可以使用这个方法。</li>
</ul>
</li>
</ul>
<p>官方文档是这么讲的，你可能会觉得像没说一样，因为界限并不是很明显。其实，你根本不用费脑子去考虑，可以直接使用 context.Background。事实上，它们两个底层的实现是一模一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    background = <span class="hljs-built_in">new</span>(emptyCtx)<br>    todo       = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<br>    <span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在使用 Context 的时候，有一些约定俗成的规则。</p>
<ol>
<li>
<p>一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。</p>
</li>
<li>
<p>从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一个空的上下文对象，也不要使用 nil。</p>
</li>
<li>
<p>Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。把 Context 持久化到数据库、本地文件或者全局变量、缓存中都是错误的用法。</p>
</li>
<li>
<p>key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是自己定义的类型。</p>
 <details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">why? </summary><div class="toggle-content"><ol>
<li><strong>避免键名冲突</strong></li>
</ol>
<p>当使用像字符串或其他内建类型（如 <code>int</code>、<code>string</code>）作为键时，可能会在不同的包或应用组件之间产生冲突。例如，如果两个不同的包都使用字符串 <code>&quot;userID&quot;</code> 作为键来存储在 <code>Context</code> 中的值，它们可能会无意中覆盖对方的数据，导致难以调试的错误和不可预见的行为。</p>
<ol start="2">
<li><strong>类型安全</strong></li>
</ol>
<p>使用自定义类型（通常是不可导出的类型）作为键可以增加类型安全性。这意味着，只有创建该键的包才能访问相应的值，其他包即使尝试使用相同的名字也无法访问这些值。这样可以避免误用键值对，保护数据不被其他包意外修改或读取。</p>
<ol start="3">
<li><strong>封装</strong></li>
</ol>
<p>自定义类型作为键还可以增强封装性，有助于定义清晰的接口，并减少包之间的依赖。通过限制键的类型和范围，可以更好地控制谁可以访问或修改 <code>Context</code> 中的数据。</p>
<ol start="4">
<li><strong>实现细节的隐藏</strong></li>
</ol>
<p>使用不可导出的类型（通过定义一个私有的结构体或其他类型）作为 <code>Context</code> 的键，可以隐藏实现细节，使得键的创建和管理完全由原始包控制，外部代码无法构造相同的键，这样就保证了数据的独立性和安全性。</p>
</div></details> 
</li>
<li>
<p>常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。</p>
</li>
</ol>
<p>其实官方的文档也是比较搞笑的，文档中强调 key 的类型不要使用 string，结果接下来的例子中就是用 string 类型作为 key 的类型。你自己把握住这个要点就好，如果你能保证别人使用你的 Context 时不会和你定义的 key 冲突，那么 key 的类型就比较随意，因为你自己保证了不同包的 key 不会冲突，否则建议你尽量采用保守的 unexported 的类型。</p>
<br>
<p><strong>创建特殊用途 Context 的方法</strong></p>
<p>接下来，我会介绍标准库中几种创建特殊用途 Context 的方法：WithValue、WithCancel、WithTimeout 和 WithDeadline，包括它们的功能以及实现方式。</p>
<p><strong>WithValue</strong></p>
<p>WithValue 基于 parent Context 生成一个新的 Context，保存了一个 key-value 键值对。它常常用来传递上下文。</p>
<p>WithValue 方法其实是创建了一个类型为 valueCtx 的 Context，它的类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context<br>    key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它持有一个 key-value 键值对，还持有 parent 的 Context。它覆盖了 Value 方法，优先从自己的存储中检查这个 key，不存在的话会从 parent 中继续检查。</p>
<p>Go 标准库实现的 Context 还实现了链式查找。如果不存在，还会向 parent Context 去查找，如果 parent 还是 valueCtx 的话，还是遵循相同的原则：valueCtx 会嵌入 parent，所以还是会查找 parent 的 Value 方法的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx = context.TODO()<br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>)<br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>)<br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>)<br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;0004&quot;</span>)<br><br>fmt.Println(ctx.Value(<span class="hljs-string">&quot;key1&quot;</span>))<br></code></pre></td></tr></table></figure>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/035a1b8e090184c1feba1ef194ec53fe.webp" alt=""></p>
<p><strong>WithCancel</strong></p>
<p>WithCancel 方法返回 parent 的副本，只是副本中的 Done Channel 是新建的对象，它的类型是 cancelCtx。</p>
<p>我们常常在一些需要主动取消长时间的任务时，创建这种类型的 Context，然后把这个 Context 传给长时间执行任务的 goroutine。当需要中止任务时，我们就可以 cancel 这个 Context，这样长时间执行任务的 goroutine，就可以通过检查这个 Context，知道 Context 已经被取消了。</p>
<p>WithCancel 返回值中的第二个值是一个 cancel 函数。其实，这个返回值的名称（cancel）和类型（Cancel）也非常迷惑人。</p>
<p>记住，不是只有你想中途放弃，才去调用 cancel，只要你的任务正常完成了，就需要调用 cancel，这样，这个 Context 才能释放它的资源（通知它的 children 处理 cancel，从它的 parent 中把自己移除，甚至释放相关的 goroutine）。很多同学在使用这个方法的时候，都会忘记调用 cancel，切记切记，而且一定尽早释放。</p>
<p>我们来看下 WithCancel 方法的实现代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;<br>    c := newCancelCtx(parent)<br>    propagateCancel(parent, &amp;c)<span class="hljs-comment">// 把c朝上传播</span><br>    <span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br><br><span class="hljs-comment">// newCancelCtx returns an initialized cancelCtx.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCancelCtx</span><span class="hljs-params">(parent Context)</span></span> cancelCtx &#123;<br>    <span class="hljs-keyword">return</span> cancelCtx&#123;Context: parent&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码中调用的 propagateCancel 方法会顺着 parent 路径往上找，直到找到一个 cancelCtx，或者为 nil。如果不为空，就把自己加入到这个 cancelCtx 的 child，以便这个 cancelCtx 被取消的时候通知自己。如果为空，会新起一个 goroutine，由它来监听 parent 的 Done 是否已关闭。</p>
<p>当这个 cancelCtx 的 cancel 函数被调用的时候，或者 parent 的 Done 被 close 的时候，这个 cancelCtx 的 Done 才会被 close。</p>
<p>cancel 是向下传递的，如果一个 WithCancel 生成的 Context 被 cancel 时，如果它的子 Context（也有可能是孙，或者更低，依赖子的类型）也是 cancelCtx 类型的，就会被 cancel，但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。</p>
<p>cancelCtx 被取消时，它的 Err 字段就是下面这个 Canceled 错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Canceled = errors.New(<span class="hljs-string">&quot;context canceled&quot;</span>)<br></code></pre></td></tr></table></figure>
<p><strong>WithTimeout</strong></p>
<p>WithTimeout 其实是和 WithDeadline 一样，只不过一个参数是超时时间，一个参数是截止时间。超时时间加上当前时间，其实就是截止时间，因此，WithTimeout 的实现是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-comment">// 当前时间+timeout就是deadline</span><br>    <span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>WithDeadline</strong></p>
<p>WithDeadline 会返回一个 parent 的副本，并且设置了一个不晚于参数 d 的截止时间，类型为 timerCtx（或者是 cancelCtx）。</p>
<p>如果它的截止时间晚于 parent 的截止时间，那么就以 parent 的截止时间为准，并返回一个类型为 cancelCtx 的 Context，因为 parent 的截止时间到了，就会取消这个 cancelCtx。</p>
<p>如果当前时间已经超过了截止时间，就直接返回一个已经被 cancel 的 timerCtx。否则就会启动一个定时器，到截止时间取消这个 timerCtx。</p>
<p>综合起来，timerCtx 的 Done 被 Close 掉，主要是由下面的某个事件触发的：</p>
<ul>
<li>截止时间到了；</li>
<li>cancel 函数被调用；</li>
<li>parent 的 Done 被 close。</li>
<li>下面的代码是 WithDeadline 方法的实现：</li>
</ul>
<p>下面的代码是 WithDeadline 方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br>    <span class="hljs-comment">// 如果parent的截止时间更早，直接返回一个cancelCtx即可</span><br>    <span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br>        <span class="hljs-keyword">return</span> WithCancel(parent)<br>    &#125;<br>    c := &amp;timerCtx&#123;<br>        cancelCtx: newCancelCtx(parent),<br>        deadline:  d,<br>    &#125;<br>    propagateCancel(parent, c) <span class="hljs-comment">// 同cancelCtx的处理逻辑</span><br>    dur := time.Until(d)<br>    <span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//当前时间已经超过了截止时间，直接cancel</span><br>        c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>        <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>    &#125;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br>    <span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 设置一个定时器，到截止时间后取消</span><br>        c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>和 cancelCtx 一样，WithDeadline（WithTimeout）返回的 cancel 一定要调用，并且要尽可能早地被调用，这样才能尽早释放资源，不要单纯地依赖截止时间被动取消。正确的使用姿势是啥呢？我们来看一个例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slowOperationWithTimeout</span><span class="hljs-params">(ctx context.Context)</span></span> (Result, <span class="hljs-type">error</span>) &#123;<br>  ctx, cancel := context.WithTimeout(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br>  <span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// 一旦慢操作完成就立马调用cancel</span><br>  <span class="hljs-keyword">return</span> slowOperation(ctx)<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>总结</strong></p>
<p>我们经常使用 Context 来取消一个 goroutine 的运行，这是 Context 最常用的场景之一，Context 也被称为 goroutine 生命周期范围（goroutine-scoped）的 Context，把 Context 传递给 goroutine。但是，goroutine 需要尝试检查 Context 的 Done 是否关闭了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ctx, cancel := context.WithCancel(context.Background())<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;goroutine exit&quot;</span>)<br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">default</span>:<br>                time.Sleep(time.Second)<br>            &#125;<br>        &#125;<br>    &#125;()<br><br>    time.Sleep(time.Second)<br>    cancel()<br>    time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你要为 Context 实现一个带超时功能的调用，比如访问远程的一个微服务，超时并不意味着你会通知远程微服务已经取消了这次调用，大概率的实现只是避免客户端的长时间等待，远程的服务器依然还执行着你的请求。</p>
<p>所以，有时候，Context 并不会减少对服务器的请求负担。如果在 Context 被 cancel 的时候，你能关闭和服务器的连接，中断和数据库服务器的通讯、停止对本地文件的读写，那么，这样的超时处理，同时能减少对服务调用的压力，但是这依赖于你对超时的底层处理机制。</p>
<hr>
<br>
<h2 id="三、原子操作">三、原子操作</h2>
<h3 id="3-1-atomic：要保证原子操作，一定要使用这几种方法">3.1 atomic：要保证原子操作，一定要使用这几种方法</h3>
<p>前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，并没有展开介绍这些原子操作是干什么用的。</p>
<p>你可能会说，这些并发原语已经可以应对大多数的并发场景了，为啥还要学习原子操作呢？其实，这是因为，在很多场景中，使用并发原语实现起来比较复杂，而原子操作可以帮助我们更轻松地实现底层的优化。</p>
<p>所以，现在，会专门用一节课，带你仔细地了解一下什么是原子操作，atomic 包都提供了哪些实现原子操作的方法。另外，还会带你实现一个基于原子操作的数据结构。好了，接下来我们先来学习下什么是原子操作。</p>
<br>
<p><strong>原子操作的基础知识</strong></p>
<p>Package sync/atomic 实现了同步算法底层的原子的内存操作原语，我们把它叫做原子操作原语，它提供了一些实现原子操作的方法。</p>
<p>之所以叫原子操作，是因为一个原子在执行的时候，其它线程不会看到执行一半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像一个最小的粒子 - 原子一样，不可分割。</p>
<p>CPU 提供了基础的原子操作，不过，不同架构的系统的原子操作是不一样的。</p>
<p>对于单处理器单核系统来说，如果一个操作是由一个 CPU 指令来实现的，那么它就是原子操作，比如它的 XCHG 和 INC 等指令。如果操作是基于多条指令来实现的，那么，执行的过程中可能会被中断，并执行上下文切换，这样的话，原子性的保证就被打破了，因为这个时候，操作可能只执行了一半。</p>
<p>在多处理器多核系统中，原子操作的实现就比较复杂了。</p>
<p>由于 cache 的存在，单个核上的单个指令进行原子操作的时候，你要确保其它处理器或者核不访问此原子操作的地址，或者是确保其它处理器或者核总是访问原子操作之后的最新的值。x86 架构中提供了指令前缀 LOCK，LOCK 保证了指令（比如 LOCK CMPXCHG op1、op2）不会受其它处理器或 CPU 核的影响，有些指令（比如 XCHG）本身就提供 Lock 的机制。不同的 CPU 架构提供的原子操作指令的方式也是不同的，比如对于多核的 MIPS 和 ARM，提供了 LL/SC（Load Link/Store Conditional）指令，可以帮助实现原子操作（ARMLL/SC 指令 LDREX 和 STREX）。</p>
<p><strong>因为不同的 CPU 架构甚至不同的版本提供的原子操作的指令是不同的，所以，要用一种编程语言实现支持不同架构的原子操作是相当有难度的</strong>。不过，还好这些都不需要你操心，因为 Go 提供了一个通用的原子操作的 API，将更底层的不同的架构下的实现封装成 atomic 包，提供了修改类型的原子操作（<a target="_blank" rel="noopener" href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/">atomic read-modify-write，RMW</a>）和加载存储类型的原子操作（<a target="_blank" rel="noopener" href="https://preshing.com/20130618/atomic-vs-non-atomic-operations/">Load 和 Store</a>）的 API，稍后我会一一介绍。</p>
<p>有的代码也会因为架构的不同而不同。有时看起来貌似一个操作是原子操作，但实际上，对于不同的架构来说，情况是不一样的。比如下面的代码的第 4 行，是将一个 64 位的值赋值给变量 i：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> x <span class="hljs-type">int64</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">33</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i = x<br>    _ = i<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你使用 GOARCH=386 的架构去编译这段代码，那么，第 5 行其实是被拆成了两个指令，分别操作低 32 位和高 32 位（使用 GOARCH=386 go tool compile -N -l test.go；GOARCH=386 go tool objdump -gnu test.o 反编译试试）：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/4563ac42f379d1500d191377db16a162.webp" alt=""></p>
<p>如果 GOARCH=amd64 的架构去编译这段代码，那么，第 5 行其中的赋值操作其实是一条指令：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/6e20a0f44d95d78c1bca4303f1a32966.webp" alt=""></p>
<p>所以，如果要想保证原子操作，切记一定要使用 atomic 提供的方法。</p>
<br>
<p>好了，了解了什么是原子操作以及不同系统的不同原子操作，接下来，我来介绍下 atomic 原子操作的应用场景。</p>
<p><strong>atomic 原子操作的应用场景</strong></p>
<p>开篇我说过，使用 atomic 的一些方法，我们可以实现更底层的一些优化。如果使用 Mutex 等并发原语进行这些优化，虽然可以解决问题，但是这些并发原语的实现逻辑比较复杂，对性能还是有一定的影响的。</p>
<p>举个例子：假设你想在程序中使用一个标志（flag，比如一个 bool 类型的变量），来标识一个定时任务是否已经启动执行了，你会怎么做呢？<br>
我们先来看看加锁的方法。如果使用 Mutex 和 RWMutex，在读取和设置这个标志的时候加锁，是可以做到互斥的、保证同一时刻只有一个定时任务在执行的，所以使用 Mutex 或者 RWMutex 是一种解决方案。</p>
<p>其实，这个场景中的问题不涉及到对资源复杂的竞争逻辑，只是会并发地读写这个标志，这类场景就适合使用 atomic 的原子操作。具体怎么做呢？你可以使用一个 uint32 类型的变量，如果这个变量的值是 0，就标识没有任务在执行，如果它的值是 1，就标识已经有任务在完成了。你看，是不是很简单呢？</p>
<p>再来看一个例子。假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉取一份新的配置并更新。你的程序中可能有多个 goroutine 都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护。在大部分情况下，你也可以利用 atomic 实现配置对象的更新和加载。</p>
<p>分析到这里，可以看到，这两个例子都可以使用基本并发原语来实现的，只不过，我们不需要这些基本并发原语里面的复杂逻辑，而是只需要其中的简单原子操作，所以，这些场景可以直接使用 atomic 包中的方法去实现。</p>
<p><strong>有时候，你也可以使用 atomic 实现自己定义的基本并发原语</strong>，比如 Go issue 有人提议的 CondMutex、Mutex.LockContext、WaitGroup.Go 等，我们可以使用 atomic 或者基于它的更高一级的并发原语去实现。我先前讲的几种基本并发原语的底层（比如 Mutex），就是基于通过 atomic 的方法实现的。</p>
<p>除此之外，atomic 原子操作还是实现 lock-free 数据结构的基石。</p>
<p>在实现 lock-free 的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁而阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free 的数据结构还可以提供并发的性能。</p>
<p>不过，lock-free 的数据结构实现起来比较复杂，需要考虑的东西很多，有兴趣的同学可以看一位微软专家写的一篇经验分享：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/dxtecharts/lockless-programming">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</a>，这里我们不细谈了。不过，这节课的最后我会带你开发一个 lock-free 的 queue，来学习下使用 atomic 操作实现 lock-free 数据结构的方法，你可以拿它和使用互斥锁实现的 queue 做性能对比，看看在性能上是否有所提升。</p>
<p>看到这里，你是不是觉得 atomic 非常重要呢？不过，要想能够灵活地应用 atomic，我们首先得知道 atomic 提供的所有方法。</p>
<br>
<p><strong>atomic 提供的方法</strong></p>
<p>目前的 Go 的泛型的特性还没有发布，Go 的标准库中的很多实现会显得非常啰嗦，多个类型会实现很多类似的方法，尤其是 atomic 包，最为明显。相信泛型支持之后，atomic 的 API 会清爽很多。</p>
<p>atomic 为了支持 int32、int64、uint32、uint64、uintptr、Pointer（Add 方法不支持）类型，分别提供了 AddXXX、CompareAndSwapXXX、SwapXXX、LoadXXX、StoreXXX 等方法。不过，你也不要担心，你只要记住了一种数据类型的方法的意义，其它数据类型的方法也是一样的。</p>
<p>关于 atomic，还有一个地方你一定要记住，<strong>atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</strong>。</p>
<p>好了，下面我就来给你介绍一下 atomic 提供的方法。掌握了这些，你就可以说完全掌握了 atomic 包。</p>
<p><strong>Add</strong></p>
<p>首先，我们来看 Add 方法的签名：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/95dcf8742593b1191e87beaca16f59de.webp" alt=""></p>
<p>其实，Add 方法就是给第一个参数地址中的值增加一个 delta 值。</p>
<p>对于有符号的整数来说，delta 可以是一个负数，相当于减去一个值。对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？毕竟，atomic 并没有提供单独的减法操作。</p>
<p>我来跟你说一种方法。你可以利用计算机补码的规则，把减法变成加法。以 uint32 类型为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">AddUint32(&amp;x, ^<span class="hljs-type">uint32</span>(c<span class="hljs-number">-1</span>))<br></code></pre></td></tr></table></figure>
<p>如果是对 uint64 的值进行操作，那么，就把上面的代码中的 uint32 替换成 uint64。<br>
尤其是减 1 这种特殊的操作，我们可以简化为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">AddUint32(&amp;x, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure>
<br>
<p>好了，我们再来看看 CAS 方法。</p>
<p><strong>CAS （CompareAndSwap）</strong></p>
<p>以 int32 为例，我们学习一下 CAS 提供的功能。在 CAS 的方法签名中，需要提供要操作的地址、原数据值、新值，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure>
<p>我们来看下这个方法的功能。</p>
<p>这个方法会比较当前 addr 地址里的值是不是 old，如果不等于 old，就返回 false；如果等于 old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。</p>
<p>如果使用伪代码来表示这个原子操作，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *addr == old &#123;<br>    *addr = <span class="hljs-built_in">new</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>它支持的类型和方法如图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/1b0ffac37d8f952ca485ff58daf27177.webp" alt=""></p>
<br>
<p><strong>Swap</strong></p>
<p>如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用 Swap 方法，它替换后还可以返回旧值，伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">old = *addr<br>*addr = <span class="hljs-built_in">new</span><br><span class="hljs-keyword">return</span> old<br></code></pre></td></tr></table></figure>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/c02e210607aa45734bb1812c97f77c0a.webp" alt=""></p>
<br>
<p><strong>Load</strong></p>
<p>Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。</p>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/3faba284bda2a666caa5727d0f0c275d.webp" alt=""></p>
<br>
<p><strong>Store</strong></p>
<p>Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。</p>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/8b77dc0e1ede98394aa21cf10fecc9a0.webp" alt=""></p>
<br>
<p><strong>Value 类型</strong></p>
<p>刚刚说的都是一些比较常见的类型，其实，atomic 还提供了一个特殊的类型：Value。它可以原子地存取对象类型，但也只能存取，不能 CAS 和 Swap，常常用在配置变更等场景中。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/478b665391766de77043ffeb0d6fff76.webp" alt=""></p>
<p>接下来，我以一个配置变更的例子，来演示 Value 类型的使用。这里定义了一个 Value 类型的变量 config， 用来存储配置信息。</p>
<p>首先，我们启动一个 goroutine，然后让它随机 sleep 一段时间，之后就变更一下配置，并通过我们前面学到的 Cond 并发原语，通知其它的 reader 去加载新的配置。</p>
<p>接下来，我们启动一个 goroutine 等待配置变更的信号，一旦有变更，它就会加载最新的配置。</p>
<p>通过这个例子，你可以了解到 Value 的 Store/Load 方法的使用，因为它只有这两个方法，只要掌握了它们的使用，你就完全掌握了 Value 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>    NodeName <span class="hljs-type">string</span><br>    Addr     <span class="hljs-type">string</span><br>    Count    <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadNewConfig</span><span class="hljs-params">()</span></span> Config &#123;<br>    <span class="hljs-keyword">return</span> Config&#123;<br>        NodeName: <span class="hljs-string">&quot;北京&quot;</span>,<br>        Addr:     <span class="hljs-string">&quot;10.77.95.27&quot;</span>,<br>        Count:    rand.Int31(),<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> config atomic.Value<br>    config.Store(loadNewConfig())<br>    <span class="hljs-keyword">var</span> cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br><br>    <span class="hljs-comment">// 设置新的config</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(<span class="hljs-number">5</span>+rand.Int63n(<span class="hljs-number">5</span>)) * time.Second)<br>            config.Store(loadNewConfig())<br>            cond.Broadcast() <span class="hljs-comment">// 通知等待着配置已变更</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            cond.L.Lock()<br>            cond.Wait()                 <span class="hljs-comment">// 等待变更信号</span><br>            c := config.Load().(Config) <span class="hljs-comment">// 读取新的配置</span><br>            fmt.Printf(<span class="hljs-string">&quot;new config: %+v\n&quot;</span>, c)<br>            cond.L.Unlock()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好了，关于标准库的 atomic 提供的方法，到这里我们就学完了。事实上，atomic 包提供了非常好的支持各种平台的一致性的 API，绝大部分项目都是直接使用它。接下来，我再给你介绍一下第三方库，帮助你稍微开拓一下思维。</p>
<br>
<p><strong>第三方库的扩展</strong></p>
<p>其实，atomic 的 API 已经算是很简单的了，它提供了包一级的函数，可以对几种类型的数据执行原子操作。</p>
<p>不过有一点让人觉得不爽的是，或者是让熟悉面向对象编程的程序员不爽的是，函数调用有一点点麻烦。所以，有些人就对这些函数做了进一步的包装，跟 atomic 中的 Value 类型类似，这些类型也提供了面向对象的使用方式，比如关注度比较高的<a target="_blank" rel="noopener" href="https://github.com/uber-go/atomic">uber-go/atomic</a>，它定义和封装了几种与常见类型相对应的原子操作类型，这些类型提供了原子操作的方法。这些类型包括 Bool、Duration、Error、Float64、Int32、Int64、String、Uint32、Uint64 等。</p>
<p>比如 Bool 类型，提供了 CAS、Store、Swap、Toggle 等原子方法，还提供 String、MarshalJSON、UnmarshalJSON 等辅助方法，确实是一个精心设计的 atomic 扩展库。关于这些方法，你一看名字就能猜出来它们的功能，我就不多说了。</p>
<p>其它的数据类型也和 Bool 类型相似，使用起来就像面向对象的编程一样，你可以看下下面的这段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> running atomic.Bool<br>running.Store(<span class="hljs-literal">true</span>)<br>running.Toggle()<br>fmt.Println(running.Load()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<br>
<p><strong>使用 atomic 实现 Lock-Free queue</strong></p>
<p>atomic 常常用来实现 Lock-Free 的数据结构，这次我会给你展示一个 Lock-Free queue 的实现。</p>
<p>Lock-Free queue 最出名的就是 Maged M. Michael 和 Michael L. Scott 1996 年发表的<a target="_blank" rel="noopener" href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">论文</a>中的算法，算法比较简单，容易实现，伪代码的每一行都提供了注释，我就不在这里贴出伪代码了，因为我们使用 Go 实现这个数据结构的代码几乎和伪代码一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> queue<br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;sync/atomic&quot;</span><br>  <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><span class="hljs-comment">// lock-free的queue</span><br><span class="hljs-keyword">type</span> LKQueue <span class="hljs-keyword">struct</span> &#123;<br>    head unsafe.Pointer<br>    tail unsafe.Pointer<br>&#125;<br><span class="hljs-comment">// 通过链表实现，这个数据结构代表链表中的节点</span><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>    value <span class="hljs-keyword">interface</span>&#123;&#125;<br>    next  unsafe.Pointer<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLKQueue</span><span class="hljs-params">()</span></span> *LKQueue &#123;<br>    n := unsafe.Pointer(&amp;node&#123;&#125;)<br>    <span class="hljs-keyword">return</span> &amp;LKQueue&#123;head: n, tail: n&#125;<br>&#125;<br><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *LKQueue)</span></span> Enqueue(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    n := &amp;node&#123;value: v&#125;<br>    <span class="hljs-keyword">for</span> &#123;<br>        tail := load(&amp;q.tail)<br>        next := load(&amp;tail.next)<br>        <span class="hljs-keyword">if</span> tail == load(&amp;q.tail) &#123; <span class="hljs-comment">// 尾还是尾</span><br>            <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 还没有新数据入队</span><br>                <span class="hljs-keyword">if</span> cas(&amp;tail.next, next, n) &#123; <span class="hljs-comment">//增加到队尾</span><br>                    cas(&amp;q.tail, tail, n) <span class="hljs-comment">//入队成功，移动尾巴指针</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 已有新数据加到队列后面，需要移动尾指针</span><br>                cas(&amp;q.tail, tail, next)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 出队，没有元素则返回nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *LKQueue)</span></span> Dequeue() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        head := load(&amp;q.head)<br>        tail := load(&amp;q.tail)<br>        next := load(&amp;head.next)<br>        <span class="hljs-keyword">if</span> head == load(&amp;q.head) &#123; <span class="hljs-comment">// head还是那个head</span><br>            <span class="hljs-keyword">if</span> head == tail &#123; <span class="hljs-comment">// head和tail一样</span><br>                <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 说明是空队列</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>                &#125;<br>                <span class="hljs-comment">// 只是尾指针还没有调整，尝试调整它指向下一个</span><br>                cas(&amp;q.tail, tail, next)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 读取出队的数据</span><br>                v := next.value<br>                <span class="hljs-comment">// 既然要出队了，头指针移动到下一个</span><br>                <span class="hljs-keyword">if</span> cas(&amp;q.head, head, next) &#123;<br>                    <span class="hljs-keyword">return</span> v <span class="hljs-comment">// Dequeue is done.  return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将unsafe.Pointer原子加载转换成node</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">(p *unsafe.Pointer)</span></span> (n *node) &#123;<br>    <span class="hljs-keyword">return</span> (*node)(atomic.LoadPointer(p))<br>&#125;<br><br><span class="hljs-comment">// 封装CAS,避免直接将*node转换成unsafe.Pointer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cas</span><span class="hljs-params">(p *unsafe.Pointer, old, <span class="hljs-built_in">new</span> *node)</span></span> (ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">return</span> atomic.CompareAndSwapPointer(<br>        p, unsafe.Pointer(old), unsafe.Pointer(<span class="hljs-built_in">new</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>我来给你介绍下这里的主要逻辑。</p>
<p>这个 lock-free 的实现使用了一个辅助头指针（head），头指针不包含有意义的数据，只是一个辅助的节点，这样的话，出队入队中的节点会更简单。<br>
入队的时候，通过 CAS 操作将一个元素添加到队尾，并且移动尾指针。</p>
<p>出队的时候移除一个节点，并通过 CAS 操作移动 head 指针，同时在必要的时候移动尾指针。</p>
<br>
<p><strong>总结</strong></p>
<p>好了，我们来小结一下。这节课，我们学习了 atomic 的基本使用方法，以及它提供的几种方法，包括 Add、CAS、Swap、Load、Store、Value 类型。除此之外，我还介绍了一些第三方库，并且带你实现了 Lock-free queue。到这里，相信你已经掌握了 atomic 提供的各种方法，并且能够应用到实践中了。</p>
<p>最后，我还想和你讨论一个额外的问题：<strong>对一个地址的赋值是原子操作吗</strong>？</p>
<p>这是一个很有趣的问题，如果是原子操作，还要 atomic 包干什么？官方的文档中并没有特意的介绍，不过，在一些 issue 或者论坛中，每当有人谈到这个问题时，总是会被建议用 atomic 包。</p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">Dave Cheney</a>就谈到过这个问题，讲得非常好。我来给你总结一下他讲的知识点，这样你就比较容易理解使用 atomic 和直接内存操作的区别了。</p>
<p>在现在的系统中，write 的地址基本上都是对齐的（aligned）。 比如，32 位的操作系统、CPU 以及编译器，write 的地址总是 4 的倍数，64 位的系统总是 8 的倍数（还记得 WaitGroup 针对 64 位系统和 32 位系统对 state1 的字段不同的处理吗）。对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话，那么，处理器就需要分成两个指令去处理，如果执行了一个指令，其它人就会看到更新了一半的错误的数据，这被称做撕裂写（torn write） 。所以，你可以认为赋值操作是一个原子操作，这个“原子操作”可以认为是保证数据的完整性。</p>
<p>但是，对于现代的多处理多核的系统来说，由于 cache、指令重排，可见性等问题，我们对原子操作的意义有了更多的追求。在多核系统中，一个核对地址的值的更改，在更新到主内存中之前，是在多级缓存中存放的。这时，多个核看到的数据可能是不一样的，其它的核可能还没有看到更新的数据，还在使用旧的数据。</p>
<p>多处理器多核心系统为了处理这类问题，使用了一种叫做内存屏障（memory fence 或 memory barrier）的方式。一个写内存屏障会告诉处理器，必须要等到它管道中的未完成的操作（特别是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的 CPU 缓存失效，以便让它们从主存中拉取最新的值。</p>
<p>atomic 包提供的方法会提供内存屏障的功能，所以，atomic 不仅仅可以保证赋值的数据完整性，还能保证数据的可见性，一旦一个核更新了该地址的值，其它处理器总是能读取到它的最新值。但是，需要注意的是，因为需要处理器之间保证数据的一致性，atomic 的操作也是会降低性能的。</p>
<hr>
<p><br><br><br></p>
<h2 id="四、channel">四、channel</h2>
<h3 id="4-1-channel：另辟蹊径，解决并发问题">4.1 channel：另辟蹊径，解决并发问题</h3>
<p>Channel 是 Go 语言内建的 first-class 类型，也是 Go 语言与众不同的特性之一。Go 语言的 Channel 设计精巧简单，以至于也有人用其它语言编写了类似 Go 风格的 Channel 库，比如<a href="docker/libchan">docker/libchan</a>、<a href="tylertreat/chan">tylertreat/chan</a>，但是并不像 Go 语言一样把 Channel 内置到了语言规范中。从这一点，你也可以看出来，Channel 的地位在编程语言中的地位之高，比较罕见。</p>
<p>所以，这节课，我们就来学习下 Channel。</p>
<br>
<p><strong>Channel 的发展</strong></p>
<p>要想了解 Channel 这种 Go 编程语言中的特有的数据结构，我们要追溯到 CSP 模型，学习一下它的历史，以及它对 Go 创始人设计 Channel 类型的影响。</p>
<p>CSP 是 Communicating Sequential Process 的简称，中文直译为通信顺序进程，或者叫做交换信息的循序进程，是用来描述并发系统中进行交互的一种模式。</p>
<p>CSP 最早出现于计算机科学家 Tony Hoare 在 1978 年发表的<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">论文</a>中（你可能不熟悉 Tony Hoare 这个名字，但是你一定很熟悉排序算法中的 Quicksort 算法，他就是 Quicksort 算法的作者，图灵奖的获得者）。最初，论文中提出的 CSP 版本在本质上不是一种进程演算，而是一种并发编程语言，但之后又经过了一系列的改进，最终发展并精炼出 CSP 的理论。<strong>CSP 允许使用进程组件来描述系统，它们独立运行，并且只通过消息传递的方式通信</strong>。</p>
<p>就像 Go 的创始人之一 Rob Pike 所说的：“每一个计算机程序员都应该读一读 Tony Hoare 1978 年的关于 CSP 的论文。”他和 Ken Thompson 在设计 Go 语言的时候也深受此论文的影响，并将 CSP 理论真正应用于语言本身（Russ Cox 专门写了一篇文章记录这个<a target="_blank" rel="noopener" href="https://swtch.com/~rsc/thread/">历史</a>），通过引入 Channel 这个新的类型，来实现 CSP 的思想。</p>
<p><strong>Channel 类型是 Go 语言内置的类型，你无需引入某个包，就能使用它</strong>。虽然 Go 也提供了传统的并发原语，但是它们都是通过库的方式提供的，你必须要引入 sync 包或者 atomic 包才能使用它们，而 Channel 就不一样了，它是内置类型，使用起来非常方便。</p>
<p>Channel 和 Go 的另一个独特的特性 goroutine 一起为并发编程提供了优雅的、便利的、与传统并发控制不同的方案，并演化出很多并发模式。接下来，我们就来看一看 Channel 的应用场景。</p>
<br>
<p><strong>Channel 的应用场景</strong></p>
<p>先看一条 Go 语言中流传很广的谚语：</p>
<blockquote>
<p>Don’t communicate by sharing memory, share memory by communicating.</p>
</blockquote>
<blockquote>
<p>Go Proverbs by Rob Pike</p>
</blockquote>
<p>这是 Rob Pike 在 2015 年的一次 Gopher 会议中提到的一句话，虽然有一点绕，但也指出了使用 Go 语言的哲学，我尝试着来翻译一下：“<strong>执行业务处理的 goroutine 不要通过共享内存的方式通信，而是要通过 Channel 通信的方式分享数据</strong>。”</p>
<p>“communicate by sharing memory”和“share memory by communicating”是两种不同的并发处理模式。“communicate by sharing memory”是传统的并发编程处理方式，就是指，共享的数据需要用锁进行保护，goroutine 需要获取到锁，才能并发访问数据。</p>
<p>“share memory by communicating”则是类似于 CSP 模型的方式，通过通信的方式，一个 goroutine 可以把数据的“所有权”交给另外一个 goroutine（虽然 Go 中没有“所有权”的概念，但是从逻辑上说，你可以把它理解为是所有权的转移）。</p>
<p>从 Channel 的历史和设计哲学上，我们就可以了解到，Channel 类型和基本并发原语是有竞争关系的，它应用于并发场景，涉及到 goroutine 之间的通讯，可以提供并发的保护，等等。</p>
<p>综合起来，我把 Channel 的应用场景分为五种类型。这里你先有个印象，这样你可以有目的地去学习 Channel 的基本原理。下节课我会借助具体的例子，来带你掌握这几种类型。</p>
<ul>
<li><strong>数据交流</strong>：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li>
<li><strong>数据传递</strong>：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。</li>
<li><strong>信号通知</strong>：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。</li>
<li><strong>任务编排</strong>：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。</li>
<li><strong>锁</strong>：利用 Channel 也可以实现互斥锁的机制。</li>
</ul>
<p>下面，我们来具体学习下 Channel 的基本用法。</p>
<br>
<p><strong>Channel 基本用法</strong></p>
<p>你可以往 Channel 中发送数据，也可以从 Channel 中接收数据，所以，Channel 类型（为了说起来方便，我们下面都把 Channel 叫做 chan）分为<strong>只能接收、只能发送、既可以接收又可以发送</strong>三种类型。下面是它的语法定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ChannelType = ( <span class="hljs-string">&quot;chan&quot;</span> | <span class="hljs-string">&quot;chan&quot;</span> <span class="hljs-string">&quot;&lt;-&quot;</span> | <span class="hljs-string">&quot;&lt;-&quot;</span> <span class="hljs-string">&quot;chan&quot;</span> ) ElementType .<br></code></pre></td></tr></table></figure>
<p>相应地，Channel 的正确语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>          <span class="hljs-comment">// 可以发送接收string</span><br><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;      <span class="hljs-comment">// 只能发送struct&#123;&#125;</span><br>&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>           <span class="hljs-comment">// 只能从chan接收int</span><br></code></pre></td></tr></table></figure>
<p>我们把既能接收又能发送的 chan 叫做双向的 chan，把只能发送和只能接收的 chan 叫做单向的 chan。其中，“&lt;-”表示单向的 chan，如果你记不住，我告诉你一个简便的方法：<strong>这个箭头总是射向左边的，元素类型总在最右边。如果箭头指向 chan，就表示可以往 chan 中塞数据；如果箭头远离 chan，就表示 chan 会往外吐数据。</strong></p>
<p>chan 中的元素是任意的类型，所以也可能是 chan 类型，我来举个例子，比如下面的 chan 类型也是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>   <br><span class="hljs-keyword">chan</span>&lt;- &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>  <br>&lt;-<span class="hljs-keyword">chan</span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br><span class="hljs-keyword">chan</span> (&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure>
<p>可是，怎么判定箭头符号属于哪个 chan 呢？其实，“&lt;-”有个规则，<strong>总是尽量和左边的 chan 结合</strong>（The <code>&lt;-</code> operator associates with the leftmost <code>chan</code> possible:），因此，上面的定义和下面的使用括号的划分是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span>&lt;- （<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>） <span class="hljs-comment">// &lt;- 和第一个chan结合</span><br><span class="hljs-keyword">chan</span>&lt;- （&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>） <span class="hljs-comment">// 第一个&lt;-和最左边的chan结合，第二个&lt;-和左边第二个chan结合</span><br>&lt;-<span class="hljs-keyword">chan</span> （&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>） <span class="hljs-comment">// 第一个&lt;-和最左边的chan结合，第二个&lt;-和左边第二个chan结合 </span><br><span class="hljs-keyword">chan</span> (&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 因为括号的原因，&lt;-和括号内第一个chan结合</span><br></code></pre></td></tr></table></figure>
<p>通过 make，我们可以初始化一个 chan，未初始化的 chan 的零值是 nil。你可以设置它的容量，比如下面的 chan 的容量是 9527，我们把这样的 chan 叫做 buffered chan；如果没有设置，它的容量是 0，我们把这样的 chan 叫做 <strong>unbuffered chan</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">9527</span>)<br></code></pre></td></tr></table></figure>
<p>如果 chan 中还有数据，那么，从这个 chan 接收数据的时候就不会阻塞，如果 chan 还未满（“满”指达到其容量），给它发送数据也不会阻塞，否则就会阻塞。unbuffered chan 只有读写都准备好之后才不会阻塞，这也是很多使用 unbuffered chan 时的常见 Bug。</p>
<p>还有一个知识点需要你记住：<strong>nil 是 chan 的零值，是一种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞</strong>。</p>
<br>
<p>下面，我来具体给你介绍几种基本操作，分别是发送数据、接收数据，以及一些其它操作。学会了这几种操作，你就能真正地掌握 Channel 的用法了。</p>
<ol>
<li><strong>发送数据</strong></li>
</ol>
<p>往 chan 中发送一个数据使用“ch&lt;-”，发送数据是一条语句:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>
<p>这里的 ch 是 chan int 类型或者是 chan &lt;-int。</p>
<ol start="2">
<li><strong>接收数据</strong></li>
</ol>
<p>从 chan 中接收一条数据使用“&lt;-ch”，接收数据也是一条语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x := &lt;-ch <span class="hljs-comment">// 把接收的一条数据赋值给变量x</span><br>foo(&lt;-ch) <span class="hljs-comment">// 把接收的一个的数据作为参数传给函数</span><br>&lt;-ch <span class="hljs-comment">// 丢弃接收的一条数据</span><br></code></pre></td></tr></table></figure>
<p>这里的 ch 类型是 chan T 或者 &lt;-chan T。</p>
<p>接收数据时，还可以返回两个值。第一个值是返回的 chan 中的元素，很多人不太熟悉的是第二个值。第二个值是 bool 类型，代表是否成功地从 chan 中读取到一个值，如果第二个参数是 false，chan 已经被 close 而且 chan 中没有缓存的数据，这个时候，第一个值是零值。所以，如果从 chan 读取到一个零值，可能是 sender 真正发送的零值，也可能是 closed 的并且没有缓存元素产生的零值。</p>
<ol start="3">
<li><strong>其它操作</strong></li>
</ol>
<p>Go 内建的函数 close、cap、len 都可以操作 chan 类型：close 会把 chan 关闭掉，cap 返回 chan 的容量，len 返回 chan 中缓存的还未被取走的元素数量。</p>
<p>send 和 recv 都可以作为 select 语句的 case clause，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> ch &lt;- i:<br>        <span class="hljs-keyword">case</span> v := &lt;-ch:<br>            fmt.Println(v)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>chan 还可以应用于 for-range 语句中，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者是忽略读取的值，只是清空 chan：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> ch &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好了，到这里，Channel 的基本用法，我们就学完了。下面从代码实现的角度分析 chan 类型的实现。毕竟，只有掌握了原理，你才能真正地用好它。</p>
<br>
<p><strong>Channel 的实现原理</strong></p>
<p>接下来，我会给你介绍 chan 的数据结构、初始化的方法以及三个重要的操作方法，分别是 send、recv 和 close。通过学习 Channel 的底层实现，你会对 Channel 的功能和异常情况有更深的理解。</p>
<p><strong>chan 数据结构</strong></p>
<p>chan 类型的数据结构如下图所示，它的数据类型是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/chan.go#L32">runtime.hchan</a>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/81304c1f1845d21c66195798b6ba48dd.webp" alt=""></p>
<p>下面来具体解释各个字段的意义。</p>
<ul>
<li>qcount：代表 chan 中已经接收但还没被取走的元素的个数。内建函数 len 可以返回这个字段的值。</li>
<li>dataqsiz：队列的大小。chan 使用一个循环队列来存放元素，循环队列很适合这种生产者 - 消费者的场景（我很好奇为什么这个字段省略 size 中的 e）。</li>
<li>buf：存放元素的循环队列的 buffer。</li>
<li>elemtype 和 elemsize：chan 中元素的类型和 size。因为 chan 一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的。</li>
<li>sendx：处理发送数据的指针在 buf 中的位置。一旦接收了新的数据，指针就会加上 elemsize，移向下一个位置。buf 的总大小是 elemsize 的整数倍，而且 buf 是一个循环列表。</li>
<li>recvx：处理接收请求时的指针在 buf 中的位置。一旦取出数据，此指针会移动到下一个位置。</li>
<li>recvq：chan 是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到 recvq 队列中。</li>
</ul>
<p><strong>初始化</strong></p>
<p>Go 在编译的时候，会根据容量的大小选择调用 makechan64，还是 makechan。</p>
<p>下面的代码是处理 make chan 的逻辑，它会决定是使用 makechan 还是 makechan64 来实现 chan 的初始化：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/e96f2fee0633c8157a88b8b725f702d7.webp" alt=""></p>
<p>我们只关注 makechan 就好了，因为 makechan64 只是做了 size 检查，底层还是调用 makechan 实现的。makechan 的目标就是生成 hchan 对象。<br>
那么，接下来，就让我们来看一下 makechan 的主要逻辑。主要的逻辑我都加上了注释，它会根据 chan 的容量的大小和元素的类型不同，初始化不同的存储空间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>    elem := t.elem<br>  <br>    <span class="hljs-comment">// 略去检查代码</span><br>    mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br>        <br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">var</span> c *hchan<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br>      <span class="hljs-comment">// chan的size或者元素的size是0，不必创建buf</span><br>      c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>      c.buf = c.raceaddr()<br>    <span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br>      <span class="hljs-comment">// 元素不是指针，分配一块连续的内存给hchan数据结构和buf</span><br>      c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>            <span class="hljs-comment">// hchan数据结构后面紧接着就是buf</span><br>      c.buf = add(unsafe.Pointer(c), hchanSize)<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">// 元素包含指针，那么单独分配buf</span><br>      c = <span class="hljs-built_in">new</span>(hchan)<br>      c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>    &#125;<br>  <br>        <span class="hljs-comment">// 元素大小、类型、容量都记录下来</span><br>    c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br>    c.elemtype = elem<br>    c.dataqsiz = <span class="hljs-type">uint</span>(size)<br>    lockInit(&amp;c.lock, lockRankHchan)<br><br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终，针对不同的容量和元素类型，这段代码分配了不同的对象来初始化 hchan 对象的字段，返回 hchan 对象。</p>
<p><strong>send</strong></p>
<p>Go 在编译发送数据给 chan 的时候，会把 send 语句转换成 chansend1 函数，chansend1 函数会调用 chansend，我们分段学习它的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 第一部分</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> !block &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最开始，第一部分是进行判断：如果 chan 是 nil 的话，就把调用者 goroutine park（阻塞休眠）， 调用者就永远被阻塞住了，所以，第 11 行是不可能执行到的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第二部分，如果chan没有被close,并且chan满了，直接返回</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第二部分的逻辑是当你往一个已经满了的 chan 实例发送数据时，并且想不阻塞当前调用，那么这里的逻辑是直接返回。chansend1 方法在调用 chansend 的时候设置了阻塞参数，所以不会执行到第二部分的分支里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第三部分，chan已经被close的情景</span><br>lock(&amp;c.lock) <span class="hljs-comment">// 开始加锁</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>    unlock(&amp;c.lock)<br>    <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第三部分显示的是，如果 chan 已经被 close 了，再往里面发送数据的话会 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第四部分，从接收队列中出队一个等待的receiver</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// </span><br>    send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第四部分，如果等待队列中有等待的 receiver，那么这段代码就把它从队列中弹出，然后直接把数据交给它（通过 memmove(dst, src, t.size)），而不需要放入到 buf 中，速度可以更快一些。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第五部分，buf还没满</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br>    qp := chanbuf(c, c.sendx)<br>    <span class="hljs-keyword">if</span> raceenabled &#123;<br>        raceacquire(qp)<br>        racerelease(qp)<br>    &#125;<br>    typedmemmove(c.elemtype, qp, ep)<br>    c.sendx++<br>    <span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>        c.sendx = <span class="hljs-number">0</span><br>    &#125;<br>    c.qcount++<br>    unlock(&amp;c.lock)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第五部分说明当前没有 receiver，需要把数据放入到 buf 中，放入之后，就成功返回了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第六部分，buf满。</span><br><span class="hljs-comment">// chansend1不会进入if块里，因为chansend1的block=true</span><br><span class="hljs-keyword">if</span> !block &#123;<br>    unlock(&amp;c.lock)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第六部分是处理 buf 满的情况。如果 buf 满了，发送者的 goroutine 就会加入到发送者的等待队列中，直到被唤醒。这个时候，数据或者被取走了，或者 chan 被 close 了。</p>
<p><strong>recv</strong></p>
<p>在处理从 chan 中接收数据时，Go 会把代码转换成 chanrecv1 函数，如果要返回两个返回值，会转换成 chanrecv2，chanrecv1 函数和 chanrecv2 会调用 chanrecv。我们分段学习它的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="hljs-type">bool</span>) &#123;<br>    _, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-comment">// 第一部分，chan为nil</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> !block &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br>    ......<br></code></pre></td></tr></table></figure>
<p>chanrecv1 和 chanrecv2 传入的 block 参数的值是 true，都是阻塞方式，所以我们分析 chanrecv 的实现的时候，不考虑 block=false 的情况。</p>
<p>第一部分是 chan 为 nil 的情况。和 send 一样，从 nil chan 中接收（读取、获取）数据时，调用者会被永远阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第二部分, block=false且c为空</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br>    ......<br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第二部分你可以直接忽略，因为不是我们这次要分析的场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 加锁，返回时释放锁</span><br>lock(&amp;c.lock)<br><span class="hljs-comment">// 第三部分，c已经被close,且chan为空empty</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br>    unlock(&amp;c.lock)<br>    <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>        typedmemclr(c.elemtype, ep)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第三部分是 chan 已经被 close 的情况。如果 chan 已经被 close 了，并且队列中没有缓存的元素，那么返回 true、false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第四部分，如果sendq队列中有等待发送的sender</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>    recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br>......<br></code></pre></td></tr></table></figure>
<p>第四部分是处理 buf 满的情况。这个时候，如果是 unbuffer 的 chan，就直接将 sender 的数据复制给 receiver，否则就从队列头部读取一个值，并把这个 sender 的值加入到队列尾部。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第五部分, 没有等待的sender, buf中有数据</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br>    qp := chanbuf(c, c.recvx)<br>    <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>        typedmemmove(c.elemtype, ep, qp)<br>    &#125;<br>    typedmemclr(c.elemtype, qp)<br>    c.recvx++<br>    <span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>        c.recvx = <span class="hljs-number">0</span><br>    &#125;<br>    c.qcount--<br>    unlock(&amp;c.lock)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123;<br>    unlock(&amp;c.lock)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 第六部分， buf中没有元素，阻塞</span><br>......<br><br></code></pre></td></tr></table></figure>
<p>第五部分是处理没有等待的 sender 的情况。这个是和 chansend 共用一把大锁，所以不会有并发的问题。如果 buf 有元素，就取出一个元素给 receiver。</p>
<p>第六部分是处理 buf 中没有元素的情况。如果没有元素，那么当前的 receiver 就会被阻塞，直到它从 sender 中接收了数据，或者是 chan 被 close，才返回。</p>
<p><strong>close</strong></p>
<p>通过 close 函数，可以把 chan 关闭，编译器会替换成 closechan 方法的调用。</p>
<p>下面的代码是 close chan 的主要逻辑。如果 chan 为 nil，close 会 panic；如果 chan 已经 closed，再次 close 也会 panic。否则的话，如果 chan 不为 nil，chan 也没有 closed，就把等待队列中的 sender（writer）和 receiver（reader）从队列中全部移除并唤醒。</p>
<p>下面的代码就是 close chan 的逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// chan为nil, panic</span><br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>    &#125;<br>  <br>    lock(&amp;c.lock)<br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// chan已经closed, panic</span><br>        unlock(&amp;c.lock)<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>    &#125;<br><br>    c.closed = <span class="hljs-number">1</span>  <br><br>    <span class="hljs-keyword">var</span> glist gList<br><br>    <span class="hljs-comment">// 释放所有的reader</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.recvq.dequeue()<br>        ......<br>        gp := sg.g<br>        ......<br>        glist.push(gp)<br>    &#125;<br>  <br>    <span class="hljs-comment">// 释放所有的writer (它们会panic)</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.sendq.dequeue()<br>        ......<br>        gp := sg.g<br>        ......<br>        glist.push(gp)<br>    &#125;<br>    unlock(&amp;c.lock)<br>  <br>    <span class="hljs-keyword">for</span> !glist.empty() &#123;<br>        gp := glist.pop()<br>        gp.schedlink = <span class="hljs-number">0</span><br>        goready(gp, <span class="hljs-number">3</span>)<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure>
<p>掌握了 Channel 的基本用法和实现原理，下面再来给你讲一讲容易犯的错误。你一定要认真看，毕竟，这些可都是帮助你避坑的。</p>
<p><strong>使用 Channel 容易犯的错误</strong></p>
<p>根据 2019 年第一篇全面分析 Go 并发 Bug 的<a target="_blank" rel="noopener" href="https://songlh.github.io/paper/go-study.pdf">论文</a>，那些知名的 Go 项目中使用 Channel 所犯的 Bug 反而比传统的并发原语的 Bug 还要多。主要有两个原因：一个是，Channel 的概念还比较新，程序员还不能很好地掌握相应的使用方法和最佳实践；第二个是，Channel 有时候比传统的并发原语更复杂，使用起来很容易顾此失彼。</p>
<p>使用 Channel 最常见的错误是 panic 和 goroutine 泄漏。<br>
首先，我们来总结下会 panic 的情况，总共有 3 种：</p>
<ol>
<li>close 为 nil 的 chan；</li>
<li>send 已经 close 的 chan；</li>
<li>close 已经 close 的 chan。</li>
</ol>
<p>goroutine 泄漏的问题也很常见，下面的代码也是一个实际项目中的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(timeout time.Duration)</span></span> <span class="hljs-type">bool</span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 模拟处理耗时的业务</span><br>        time.Sleep((timeout + time.Second))<br>        ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// block</span><br>        fmt.Println(<span class="hljs-string">&quot;exit goroutine&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> result := &lt;-ch:<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，process 函数会启动一个 goroutine，去处理需要长时间处理的业务，处理完之后，会发送 true 到 chan 中，目的是通知其它等待的 goroutine，可以继续处理了。</p>
<p>我们来看一下第 10 行到第 15 行，主 goroutine 接收到任务处理完成的通知，或者超时后就返回了。这段代码有问题吗？</p>
<p>如果发生超时，process 函数就返回了，这就会导致 unbuffered 的 chan 从来就没有被读取。我们知道，unbuffered chan 必须等 reader 和 writer 都准备好了才能交流，否则就会阻塞。超时导致未读，结果就是子 goroutine 就阻塞在第 7 行永远结束不了，进而导致 goroutine 泄漏。</p>
<p>解决这个 Bug 的办法很简单，就是将 unbuffered chan 改成容量为 1 的 chan，这样第 7 行就不会被阻塞了。</p>
<p>Go 的开发者极力推荐使用 Channel，不过，这两年，大家意识到，Channel 并不是处理并发问题的“银弹”，有时候使用并发原语更简单，而且不容易出错。所以，我给你提供一套选择的方法:</p>
<ol>
<li>共享资源的并发访问使用传统并发原语；</li>
<li>复杂的任务编排和消息传递使用 Channel；</li>
<li>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；</li>
<li>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</li>
<li>需要和 Select 语句结合，使用 Channel；</li>
<li>需要和超时配合时，使用 Channel 和 Context。</li>
</ol>
<br>
<p><strong>它们踩过的坑</strong></p>
<p>接下来，我带你围观下知名 Go 项目的 Channel 相关的 Bug。<br>
<a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/pull/6857">etcd issue 6857</a>是一个程序 hang 住的问题：在异常情况下，没有往 chan 实例中填充所需的元素，导致等待者永远等待。具体来说，Status 方法的逻辑是生成一个 chan Status，然后把这个 chan 交给其它的 goroutine 去处理和写入数据，最后，Status 返回获取的状态信息。</p>
<p>不幸的是，如果正好节点停止了，没有 goroutine 去填充这个 chan，会导致方法 hang 在返回的那一行上（下面的截图中的第 466 行）。解决办法就是，在等待 status chan 返回元素的同时，也检查节点是不是已经停止了（done 这个 chan 是不是 close 了）。</p>
<p>其实，感觉这个修改还是有问题的。问题就在于，如果程序执行了 466 行，成功地把 c 写入到 Status 待处理队列后，执行到第 467 行时，如果停止了这个节点，那么，这个 Status 方法还是会阻塞在第 467 行。你可以自己研究研究，看看是不是这样。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/issues/5505">etcd issue 5505</a> 虽然没有任何的 Bug 描述，但是从修复内容上看，它是一个往已经 close 的 chan 写数据导致 panic 的问题。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/issues/11256">etcd issue 11256</a>  是因为 unbuffered chan goroutine 泄漏的问题。TestNodeProposeAddLearnerNode 方法中一开始定义了一个 unbuffered 的 chan，也就是 applyConfChan，然后启动一个子 goroutine，这个子 goroutine 会在循环中执行业务逻辑，并且不断地往这个 chan 中添加一个元素。TestNodeProposeAddLearnerNode 方法的末尾处会从这个 chan 中读取一个元素。</p>
<p>这段代码在 for 循环中就往此 chan 中写入了一个元素，结果导致 TestNodeProposeAddLearnerNode 从这个 chan 中读取到元素就返回了。悲剧的是，子 goroutine 的 for 循环还在执行，阻塞在下图中红色的第 851 行，并且一直 hang 在那里。</p>
<p>这个 Bug 的修复也很简单，只要改动一下 applyConfChan 的处理逻辑就可以了：只有子 goroutine 的 for 循环中的主要逻辑完成之后，才往 applyConfChan 发送一个元素，这样，TestNodeProposeAddLearnerNode 收到通知继续执行，子 goroutine 也不会被阻塞住了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/issues/9956">etcd issue 9956</a> 是往一个已 close 的 chan 发送数据，其实它是 grpc 的一个 bug（<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/pull/2695">grpc issue 2695</a>），修复办法就是不 close 这个 chan 就好了</p>
<br>
<p><strong>总结</strong></p>
<p>chan 的值和状态有多种情况，而不同的操作（send、recv、close）又可能得到不同的结果，这是使用 chan 类型时经常让人困惑的地方。</p>
<p>为了帮助你快速地了解不同状态下各种操作的结果，以下总结了一个表格，你一定要特别关注下那些 panic 的情况，另外还要掌握那些会 block 的场景，它们是导致死锁或者 goroutine 泄露的罪魁祸首。</p>
<p>还有一个值得注意的点是，<strong>只要一个 chan 还有未读的数据，即使把它 close 掉，你还是可以继续把这些未读的数据消费完，之后才是读取零值数据</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/5108954ea36559860e5e5aaa42b2f998.webp" alt=""></p>
<hr>
<p><br><br><br></p>
<h3 id="4-2-Channel：透过代码看典型的应用模式">4.2 Channel：透过代码看典型的应用模式</h3>
<p>你好，我是鸟窝。</p>
<p>前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。</p>
<p>在开始上课之前，我先补充一个知识点：通过反射的方式执行 select 语句，在处理很多的 case clause，尤其是不定长的 case clause 的时候，非常有用。而且，在后面介绍任务编排的实现时，我也会采用这种方法，所以，我先带你具体学习下 Channel 的反射用法。</p>
<p><strong>使用反射操作 Channel</strong></p>
<p>select 语句可以处理 chan 的 send 和 recv，send 和 recv 都可以作为 case clause。如果我们同时处理两个 chan，就可以写成下面的样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> v := &lt;-ch1:<br>    fmt.Println(v)<br>    <span class="hljs-keyword">case</span> v := &lt;-ch2:<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果需要处理三个 chan，你就可以再添加一个 case clause，用它来处理第三个 chan。可是，如果要处理 100 个 chan 呢？一万个 chan 呢？</p>
<p>或者是，chan 的数量在编译的时候是不定的，在运行的时候需要处理一个 slice of chan，这个时候，也没有办法在编译前写成字面意义的 select。那该怎么办？</p>
<p>这个时候，就要“祭”出我们的反射大法了。</p>
<p>通过 reflect.Select 函数，你可以将一组运行时的 case clause 传入，当作参数执行。Go 的 select 是伪随机的，它可以在执行的 case 中随机选择一个 case，并把选择的这个 case 的索引（chosen）返回，如果没有可用的 case 返回，会返回一个 bool 类型的返回值，这个返回值用来表示是否有 case 成功被选择。如果是 recv case，还会返回接收的元素。Select 的方法签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">(cases []SelectCase)</span></span> (chosen <span class="hljs-type">int</span>, recv Value, recvOK <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure>
<p>下面，我来借助一个例子，来演示一下，动态处理两个 chan 的情形。因为这样的方式可以动态处理 case 数据，所以，你可以传入几百几千几万的 chan，这就解决了不能动态处理 n 个 chan 的问题。</p>
<p>首先，createCases 函数分别为每个 chan 生成了 recv case 和 send case，并返回一个 reflect.SelectCase 数组。</p>
<p>然后，通过一个循环 10 次的 for 循环执行 reflect.Select，这个方法会从 cases 中选择一个 case 执行。第一次肯定是 send case，因为此时 chan 还没有元素，recv 还不可用。等 chan 中有了数据以后，recv case 就可以被选择了。这样，你就可以处理不定数量的 chan 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">var</span> ch2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">// 创建SelectCase</span><br>    <span class="hljs-keyword">var</span> cases = createCases(ch1, ch2)<br><br>    <span class="hljs-comment">// 执行10次select</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        chosen, recv, ok := reflect.Select(cases)<br>        <span class="hljs-keyword">if</span> recv.IsValid() &#123; <span class="hljs-comment">// recv case</span><br>            fmt.Println(<span class="hljs-string">&quot;recv:&quot;</span>, cases[chosen].Dir, recv, ok)<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// send case</span><br>            fmt.Println(<span class="hljs-string">&quot;send:&quot;</span>, cases[chosen].Dir, ok)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createCases</span><span class="hljs-params">(chs ...<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> []reflect.SelectCase &#123;<br>    <span class="hljs-keyword">var</span> cases []reflect.SelectCase<br><br><br>    <span class="hljs-comment">// 创建recv case</span><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs &#123;<br>        cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>            Dir:  reflect.SelectRecv,<br>            Chan: reflect.ValueOf(ch),<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 创建send case</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> chs &#123;<br>        v := reflect.ValueOf(i)<br>        cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>            Dir:  reflect.SelectSend,<br>            Chan: reflect.ValueOf(ch),<br>            Send: v,<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cases<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>典型的应用场景</strong></p>
<p>了解刚刚的反射用法，我们就解决了今天的基础知识问题，接下来，我就带你具体学习下 Channel 的应用场景。</p>
<p>首先来看消息交流。</p>
<p><strong>消息交流</strong></p>
<p>从 chan 的内部实现看，它是以一个循环队列的方式存放数据，所以，它有时候也会被当成线程安全的队列和 buffer 使用。一个 goroutine 可以安全地往 Channel 中塞数据，另外一个 goroutine 可以安全地从 Channel 中读取数据，goroutine 就可以安全地实现信息交流了。</p>
<p>我们来看几个例子。</p>
<p>第一个例子是 worker 池的例子。Marcio Castilho 在 <a target="_blank" rel="noopener" href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">使用 Go 每分钟处理百万请求</a>  这篇文章中，就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中，这个 chan Job 就相当于一个待处理任务队列。除此之外，还有一个 chan chan Job 队列，用来存放可以处理任务的 worker 的缓存队列。</p>
<p>dispatcher 会把待处理任务队列中的任务放到一个可用的缓存队列中，worker 会一直处理它的缓存队列。通过使用 Channel，实现了一个 worker 池的任务处理中心，并且解耦了前端 HTTP 请求处理和后端任务处理的逻辑。</p>
<p>我在讲 Pool 的时候，提到了一些第三方实现的 worker 池，它们全部都是通过 Channel 实现的，这是 Channel 的一个常见的应用场景。worker 池的生产者和消费者的消息交流都是通过 Channel 实现的。</p>
<p>第二个例子是 etcd 中的 node 节点的实现，包含大量的 chan 字段，比如 recvc 是消息处理的 chan，待处理的 protobuf 消息都扔到这个 chan 中，node 有一个专门的 run goroutine 负责处理这些消息。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/0643503a1yy135b476d41345d71766a4.webp" alt=""></p>
<br>
<p><strong>数据传递</strong></p>
<p>“击鼓传花”的游戏很多人都玩过，花从一个人手中传给另外一个人，就有点类似流水线的操作。这个花就是数据，花在游戏者之间流转，这就类似编程中的数据传递。</p>
<p>为了实现顺序的数据传递，我们可以定义一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌传递给下一个 goroutine，我们尝试使用 chan 来实现，可以看下下面的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Token <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newWorker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, ch <span class="hljs-keyword">chan</span> Token, nextCh <span class="hljs-keyword">chan</span> Token)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        token := &lt;-ch         <span class="hljs-comment">// 取得令牌</span><br>        fmt.Println((id + <span class="hljs-number">1</span>)) <span class="hljs-comment">// id从1开始</span><br>        time.Sleep(time.Second)<br>        nextCh &lt;- token<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    chs := []<span class="hljs-keyword">chan</span> Token&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Token), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Token), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Token), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Token)&#125;<br><br>    <span class="hljs-comment">// 创建4个worker</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> newWorker(i, chs[i], chs[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>])<br>    &#125;<br><br>    <span class="hljs-comment">//首先把令牌交给第一个worker</span><br>    chs[<span class="hljs-number">0</span>] &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我来给你具体解释下这个实现方式。</p>
<p>首先，我们定义一个令牌类型（Token），接着定义一个创建 worker 的方法，这个方法会从它自己的 chan 中读取令牌。哪个 goroutine 取得了令牌，就可以打印出自己编号，因为需要每秒打印一次数据，所以，我们让它休眠 1 秒后，再把令牌交给它的下家。</p>
<p>接着，在第 16 行启动每个 worker 的 goroutine，并在第 20 行将令牌先交给第一个 worker。</p>
<p>如果你运行这个程序，就会在命令行中看到每一秒就会输出一个编号，而且编号是以 1、2、3、4 这样的顺序输出的。</p>
<p>这类场景有一个特点，就是当前持有数据的 goroutine 都有一个信箱，信箱使用 chan 实现，goroutine 只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中。</p>
<br>
<p><strong>信号通知</strong></p>
<p>chan 类型有这样一个特点：chan 如果为空，那么，receiver 接收数据的时候就会阻塞等待，直到 chan 被关闭或者有新的数据到来。利用这个机制，我们可以实现 wait/notify 的设计模式。</p>
<p>传统的并发原语 Cond 也能实现这个功能。但是，Cond 使用起来比较复杂，容易出错，而使用 chan 实现 wait/notify 模式，就方便多了。<br>
除了正常的业务处理时的 wait/notify，我们经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理（doCleanup 方法）的动作。这个时候，我们经常要使用 chan。</p>
<p>比如，使用 chan 实现程序的 graceful shutdown，在退出之前执行一些连接关闭、文件 close、缓存落盘等一些动作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ...... <span class="hljs-comment">// 执行业务处理</span><br>    &#125;()<br><br>    <span class="hljs-comment">// 处理CTRL+C等中断信号</span><br>    termChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)<br>    &lt;-termChan <br><br>    <span class="hljs-comment">// 执行退出之前的清理动作</span><br>    doCleanup()<br><br>    fmt.Println(<span class="hljs-string">&quot;优雅退出&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有时候，doCleanup 可能是一个很耗时的操作，比如十几分钟才能完成，如果程序退出需要等待这么长时间，用户是不能接受的，所以，在实践中，我们需要设置一个最长的等待时间。只要超过了这个时间，程序就不再等待，可以直接退出。所以，退出的时候分为两个阶段：</p>
<ol>
<li>closing，代表程序退出，但是清理工作还没做；</li>
<li>closed，代表清理工作已经做完。</li>
</ol>
<p>所以，上面的例子可以改写如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> closing = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">var</span> closed = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 模拟业务处理</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-closing:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// ....... 业务计算</span><br>                time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>            &#125;<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 处理CTRL+C等中断信号</span><br>    termChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)<br>    &lt;-termChan<br><br>    <span class="hljs-built_in">close</span>(closing)<br>    <span class="hljs-comment">// 执行退出之前的清理动作</span><br>    <span class="hljs-keyword">go</span> doCleanup(closed)<br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-closed:<br>    <span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>        fmt.Println(<span class="hljs-string">&quot;清理超时，不等了&quot;</span>)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;优雅退出&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doCleanup</span><span class="hljs-params">(closed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    time.Sleep((time.Minute))<br>    <span class="hljs-built_in">close</span>(closed)<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>锁</strong></p>
<p>使用 chan 也可以实现互斥锁。</p>
<p>在 chan 的内部实现中，就有一把互斥锁保护着它的所有字段。从外在表现上，chan 的发送和接收之间也存在着 happens-before 的关系，保证元素放进去之后，receiver 才能读取到（关于 happends-before 的关系，是指事件发生的先后顺序关系，我会在下一讲详细介绍，这里你只需要知道它是一种描述事件先后顺序的方法）。</p>
<p>要想使用 chan 实现互斥锁，至少有两种方式。一种方式是先初始化一个 capacity 等于 1 的 Channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。另一种方式是，先初始化一个 capacity 等于 1 的 Channel，它的“空槽”代表锁，谁能成功地把元素发送到这个 Channel，谁就获取了这把锁。</p>
<p>这是使用 Channel 实现锁的两种不同实现方式，我重点介绍下第一种。理解了这种实现方式，第二种方式也就很容易掌握了，我就不多说了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用chan实现互斥锁</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用锁需要初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMutex</span><span class="hljs-params">()</span></span> *Mutex &#123;<br>    mu := &amp;Mutex&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br>    mu.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">return</span> mu<br>&#125;<br><br><span class="hljs-comment">// 请求锁，直到获取到</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    &lt;-m.ch<br>&#125;<br><br><span class="hljs-comment">// 解锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> m.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 尝试获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> TryLock() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">default</span>:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 加入一个超时的设置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> LockTimeout(timeout time.Duration) <span class="hljs-type">bool</span> &#123;<br>    timer := time.NewTimer(timeout)<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-m.ch:<br>        timer.Stop()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> &lt;-timer.C:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 锁是否已被持有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> IsLocked() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.ch) == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := NewMutex()<br>    ok := m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked v %v\n&quot;</span>, ok)<br>    ok = m.TryLock()<br>    fmt.Printf(<span class="hljs-string">&quot;locked %v\n&quot;</span>, ok)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你可以用 buffer 等于 1 的 chan 实现互斥锁，在初始化这个锁的时候往 Channel 中先塞入一个元素，谁把这个元素取走，谁就获取了这把锁，把元素放回去，就是释放了锁。元素在放回到 chan 之前，不会有 goroutine 能从 chan 中取出元素的，这就保证了互斥性。</p>
<p>在这段代码中，还有一点需要我们注意下：利用 select+chan 的方式，很容易实现 TryLock、Timeout 的功能。具体来说就是，在 select 语句中，我们可以使用 default 实现 TryLock，使用一个 Timer 来实现 Timeout 的功能。</p>
<br>
<p><strong>任务编排</strong></p>
<p>前面所说的消息交流的场景是一个特殊的任务编排的场景，这个“击鼓传花”的模式也被称为流水线模式。</p>
<p>在2.6中，我们学习了 WaitGroup，我们可以利用它实现等待模式：启动一组 goroutine 执行任务，然后等待这些任务都完成。其实，我们也可以使用 chan 实现 WaitGroup 的功能。这个比较简单，我就不举例子了，接下来我介绍几种更复杂的编排模式。</p>
<p>这里的编排既指安排 goroutine 按照指定的顺序执行，也指多个 chan 按照指定的方式组合处理的方式。goroutine 的编排类似“击鼓传花”的例子，我们通过编排数据在 chan 之间的流转，就可以控制 goroutine 的执行。接下来，我来重点介绍下多个 chan 的编排方式，总共 5 种，分别是 Or-Done 模式、扇入模式、扇出模式、Stream 和 map-reduce。</p>
<p><strong>Or-Done 模式</strong></p>
<details class="toggle" style="border: 1px solid  #edf4ee"><summary class="toggle-button" style="background-color:  #edf4ee;color:  #17181a">Or-Done </summary><div class="toggle-content"><p><strong>“Or-Done 模式”</strong> 这个名字源自于 <strong>“Or”</strong> 和 <strong>“Done”</strong> 这两个词的结合，含义可以通过分析这两个词来理解：</p>
<ul>
<li><strong>“Or”</strong> 表示<strong>选择</strong>或<strong>任选其一</strong>，在这里，指的是多个并发任务中，只关心 <strong>任意一个任务完成</strong> 即可。</li>
<li><strong>“Done”</strong> 表示任务完成，也就是在这个模式中，任务一旦完成就通知主程序，主程序不需要等待其他任务的完成。</li>
</ul>
<p>因此，<strong>Or-Done 模式</strong> 的意思就是：多个任务并发执行时，一旦有 <strong>任意一个任务完成</strong>，主程序或调用者就能接收到信号，进行后续操作，而无需等待所有任务完成。</p>
<br>
<p><strong>为什么会有这个模式？</strong></p>
<p>在实际的工程开发中，某些场景下确实只需要等待 <strong>一个任务成功</strong> 即可，不需要等待所有并发任务都完成。这种需求源自于以下几个原因：</p>
<ol>
<li><strong>并发任务的效率优化</strong></li>
</ol>
<p>当发起多个任务时，通常并不是所有任务都必须完全成功才能达到目标，尤其是当任务的目标是查询、读取数据、请求外部服务等操作时，<strong>第一个成功的结果就能满足要求</strong>。例如：</p>
<ul>
<li>
<p><strong>微服务调用</strong>：假设你在多个微服务节点上并行请求数据，只要任意一个节点返回数据就满足业务需求，其他节点的响应可以忽略。这样一来，你就不需要等待所有节点的响应，而是可以减少延迟并提高响应速度。</p>
</li>
<li>
<p><strong>支付网关</strong>：如果你请求多个支付网关服务，只要一个支付网关响应成功，就可以认为交易成功，而不需要等待所有支付网关的响应。</p>
</li>
<li>
<p><strong>数据源查询</strong>：你可能会从多个数据源查询相同的信息，只要其中一个数据源返回数据，你就可以继续处理，而不必等待其他数据源的查询结果。</p>
</li>
</ul>
<ol start="2">
<li><strong>容错和降级</strong></li>
</ol>
<p>在一些高并发的系统中，可能会涉及到多个后端服务的请求。某些服务可能因为网络问题或超时无法响应，<strong>Or-Done 模式</strong> 提供了一种容错和降级的策略：</p>
<ul>
<li>
<p>如果你发起了多个任务，每个任务可能代表不同的服务或后端资源，只要其中一个任务成功，就意味着业务操作成功。这样，即使其他任务失败或超时，你的系统也不会完全阻塞或崩溃。</p>
</li>
<li>
<p>例如，在负载均衡和多节点的情况中，某个节点的请求可能失败，但是其他节点成功时，你可以用其他节点的响应结果来继续执行，不会因此而完全丧失整个操作的成功机会。</p>
</li>
</ul>
<ol start="3">
<li><strong>减少等待时间</strong></li>
</ol>
<p>等待所有任务完成可能会导致不必要的延迟，特别是在<strong>高延迟</strong>的网络请求或数据库查询中。如果你只关心第一个完成的任务，那么你可以更快地获得结果，从而提高系统的响应速度。</p>
<ol start="4">
<li><strong>简化并发控制</strong></li>
</ol>
<p>有时并发任务不一定是所有任务都必须成功，而是只需要尽早完成其中一个任务。使用 <strong>Or-Done 模式</strong> 可以简化并发控制，因为你只需要处理一个任务完成的信号，避免了等待和管理多个任务状态的复杂性。</p>
<br>
<p><strong>为什么建立这个多个任务却只关心一个成功就行？</strong></p>
<ol>
<li><strong>效率和响应速度</strong>：在很多场景下，任务之间是独立的，某个任务的完成不依赖于其他任务的完成。例如，从多个节点请求数据时，任意一个节点返回数据即可以算作请求成功。这样可以减少等待时间和加快响应速度。</li>
<li><strong>简化业务逻辑</strong>：在很多业务场景下，任务的执行是异步的且互不依赖，某一个任务的完成就可以触发某些动作，而不需要关心其他任务的结果。例如，在发起多个 API 请求时，只要有一个请求成功，就可以认为任务已经完成，避免了复杂的状态管理。</li>
<li><strong>适应不稳定环境</strong>：在分布式系统或者微服务架构中，某些服务可能由于网络或资源问题不稳定。通过使用 <strong>Or-Done 模式</strong>，可以确保即使某些服务或任务出现问题，其他服务或任务也可以正常完成，不会导致系统阻塞或过度依赖某个服务。</li>
<li><strong>提高容错性</strong>：在多个任务中只关心一个成功的场景能够提高系统的容错性。例如，假设你请求多个支付网关，只要一个支付网关成功支付就可以认为交易完成。如果某个支付网关挂掉或超时，其他支付网关的成功就足以确保系统不受影响。</li>
</ol>
<br>
<p><strong>现实生活中的例子</strong></p>
<ul>
<li><strong>订票系统</strong>：你可能在多个网站上并行搜索票务信息，只要其中一个网站返回了有票的结果，整个查询就算成功了，其他网站的查询可以忽略。</li>
<li><strong>大数据采集</strong>：你在多个数据源中并发查询数据，只要某个数据源返回了所需数据，整个查询就算完成，无需再等待其他源。</li>
<li><strong>内容聚合</strong>：在聚合多家新闻网站的内容时，只要其中一个网站返回了最新的新闻，你就可以更新页面显示，而不需要等待所有网站的响应。</li>
</ul>
<br>
<p><strong>总结</strong></p>
<p><strong>Or-Done 模式</strong> 是为了解决某些场景中 <strong>只关心任意一个任务完成就好</strong> 的需求，特别是在并发任务中，一旦其中某个任务完成，就能通知主程序继续执行。这种模式可以提高系统效率、降低延迟、增强容错性并简化并发控制。在 Go 中，它通常通过 <code>select</code> 语句和 <code>chan struct{}</code> 来实现，非常适合用于处理微服务、分布式系统、数据采集等需要并行处理但又不需要等待所有任务完成的场景。</p>
</div></details>
<p>首先来看 Or-Done 模式。Or-Done 模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”，我先来解释一下。</p>
<p>我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为 chan struct{}类型的 done 变量，等任务结束后，我们就可以 close 这个变量，然后，其它 receiver 就会收到这个通知。</p>
<p>这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是 Or-Done 模式。</p>
<p>比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，这个时候，就可以参考下面的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-comment">// 特殊情况，只有零个或者1个chan</span><br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br><br>        <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 2个也是一种特殊情况</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">case</span> &lt;-channels[<span class="hljs-number">1</span>]:<br>            &#125;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">//超过两个，二分法递归处理</span><br>            m := <span class="hljs-built_in">len</span>(channels) / <span class="hljs-number">2</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[:m]...):<br>            <span class="hljs-keyword">case</span> &lt;-or(channels[m:]...):<br>            &#125;<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以写一个测试程序测试它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sig</span><span class="hljs-params">(after time.Duration)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>        time.Sleep(after)<br>    &#125;() <br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br><br>    &lt;-or(<br>        sig(<span class="hljs-number">10</span>*time.Second),<br>        sig(<span class="hljs-number">20</span>*time.Second),<br>        sig(<span class="hljs-number">30</span>*time.Second),<br>        sig(<span class="hljs-number">40</span>*time.Second),<br>        sig(<span class="hljs-number">50</span>*time.Second),<br>        sig(<span class="hljs-number">01</span>*time.Minute),<br>    )<br><br>    fmt.Printf(<span class="hljs-string">&quot;done after %v&quot;</span>, time.Since(start))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的实现使用了一个巧妙的方式，当 chan 的数量大于 2 时，使用递归的方式等待信号。</p>
<p>在 chan 数量比较多的情况下，递归并不是一个很好的解决方式，根据这一讲最开始介绍的反射的方法，我们也可以实现 Or-Done 模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">or</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-comment">//特殊情况，只有0个或者1个</span><br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(channels) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> channels[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    orDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(orDone)<br>        <span class="hljs-comment">// 利用反射构建SelectCase</span><br>        <span class="hljs-keyword">var</span> cases []reflect.SelectCase<br>        <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> channels &#123;<br>            cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>                Dir:  reflect.SelectRecv,<br>                Chan: reflect.ValueOf(c),<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">// 随机选择一个可用的case</span><br>        reflect.Select(cases)<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> orDone<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是递归和反射两种方法实现 Or-Done 模式的代码。反射方式避免了深层递归的情况，可以处理有大量 chan 的情况。其实最笨的一种方法就是为每一个 Channel 启动一个 goroutine，不过这会启动非常多的 goroutine，太多的 goroutine 会影响性能，所以不太常用。你只要知道这种用法就行了，不用重点掌握。</p>
<p><strong>扇入模式</strong></p>
<p>扇入借鉴了数字电路的概念，它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入，一个输出。</p>
<p>在软件工程中，模块的扇入是指有多少个上级模块调用它。而对于我们这里的 Channel 扇入模式来说，就是指有多个源 Channel 输入、一个目的 Channel 输出的情况。扇入比就是源 Channel 数量比 1。</p>
<p>每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要监听目标 Channel，就可以接收所有发送给源 Channel 的数据。</p>
<p>扇入模式也可以使用反射、递归，或者是用最笨的每个 goroutine 处理一个 Channel 的方式来实现。</p>
<p>这里我列举下递归和反射的方式，帮你加深一下对这个技巧的理解。</p>
<p>反射的代码比较简短，易于理解，主要就是构造出 SelectCase slice，然后传递给 reflect.Select 语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInReflect</span><span class="hljs-params">(chans ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-comment">// 构造SelectCase slice</span><br>        <span class="hljs-keyword">var</span> cases []reflect.SelectCase<br>        <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> chans &#123;<br>            cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>                Dir:  reflect.SelectRecv,<br>                Chan: reflect.ValueOf(c),<br>            &#125;)<br>        &#125;<br>        <br>        <span class="hljs-comment">// 循环，从cases中选择一个可用的</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(cases) &gt; <span class="hljs-number">0</span> &#123;<br>            i, v, ok := reflect.Select(cases)<br>            <span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-comment">// 此channel已经close</span><br>                cases = <span class="hljs-built_in">append</span>(cases[:i], cases[i+<span class="hljs-number">1</span>:]...)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            out &lt;- v.Interface()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归模式也是在 Channel 大于 2 时，采用二分法递归 merge。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInRec</span><span class="hljs-params">(chans ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(chans) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>        <span class="hljs-built_in">close</span>(c)<br>        <span class="hljs-keyword">return</span> c<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> chans[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> mergeTwo(chans[<span class="hljs-number">0</span>], chans[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">default</span>:<br>        m := <span class="hljs-built_in">len</span>(chans) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> mergeTwo(<br>            fanInRec(chans[:m]...),<br>            fanInRec(chans[m:]...))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里有一个 mergeTwo 的方法，是将两个 Channel 合并成一个 Channel，是扇入形式的一种特例（只处理两个 Channel）。 下面我来借助一段代码帮你理解下这个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInRec</span><span class="hljs-params">(chans ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> <span class="hljs-built_in">len</span>(chans) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>        <span class="hljs-built_in">close</span>(c)<br>        <span class="hljs-keyword">return</span> c<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> chans[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> mergeTwo(chans[<span class="hljs-number">0</span>], chans[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">default</span>:<br>        m := <span class="hljs-built_in">len</span>(chans) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> mergeTwo(<br>            fanInRec(chans[:m]...),<br>            fanInRec(chans[m:]...))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里有一个 mergeTwo 的方法，是将两个 Channel 合并成一个 Channel，是扇入形式的一种特例（只处理两个 Channel）。 下面我来借助一段代码帮你理解下这个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwo</span><span class="hljs-params">(a, b &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>        <span class="hljs-keyword">for</span> a != <span class="hljs-literal">nil</span> || b != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//只要还有可读的chan</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> v, ok := &lt;-a:<br>                <span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-comment">// a 已关闭，设置为nil</span><br>                    a = <span class="hljs-literal">nil</span><br>                    <span class="hljs-keyword">continue</span><br>                &#125;<br>                c &lt;- v<br>            <span class="hljs-keyword">case</span> v, ok := &lt;-b:<br>                <span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-comment">// b 已关闭，设置为nil</span><br>                    b = <span class="hljs-literal">nil</span><br>                    <span class="hljs-keyword">continue</span><br>                &#125;<br>                c &lt;- v<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>扇出模式</strong></p>
<p>有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。</p>
<p>扇出模式只有一个输入源 Channel，有多个目标 Channel，扇出比就是 1 比目标 Channel 数的值，经常用在设计模式中的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/5881786?fr=aladdin">观察者模式</a>中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p>
<p>下面是一个扇出模式的实现。从源 Channel 取出一个数据后，依次发送给目标 Channel。在发送给目标 Channel 的时候，可以同步发送，也可以异步发送：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanOut</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, out []<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, async <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//退出时关闭所有的输出chan</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                <span class="hljs-built_in">close</span>(out[i])<br>            &#125;<br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123; <span class="hljs-comment">// 从输入chan中读取数据</span><br>            v := v<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(out); i++ &#123;<br>                i := i<br>                <span class="hljs-keyword">if</span> async &#123; <span class="hljs-comment">//异步</span><br>                    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                        out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中,异步方式</span><br>                    &#125;()<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    out[i] &lt;- v <span class="hljs-comment">// 放入到输出chan中，同步方式</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你也可以尝试使用反射的方式来实现，我就不列相关代码了，希望你课后可以自己思考下。</p>
<p><strong>Stream</strong></p>
<p>这里我来介绍一种把 Channel 当作流式管道使用的方式，也就是把 Channel 看作流（Stream），提供跳过几个元素，或者是只取其中的几个元素等方法。</p>
<p>首先，我们提供创建流的方法。这个方法把一个数据 slice 转换成流：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个unbuffered的channel</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine，往s中塞数据</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s) <span class="hljs-comment">// 退出时关闭chan</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v: <span class="hljs-comment">// 将数组元素塞入到chan中</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure>
<p>流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。</p>
<ol>
<li>takeN：只取流中的前 n 个数据；</li>
<li>takeFn：筛选流中的数据，只保留满足条件的数据；</li>
<li>takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取；</li>
<li>skipN：跳过流中前几个数据；</li>
<li>skipFn：跳过满足条件的数据；</li>
<li>skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。</li>
</ol>
<p>这些方法的实现很类似，我们以 takeN 为例来具体解释一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">takeN</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, valueStream &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, num <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    takeStream := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 创建输出流</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(takeStream)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123; <span class="hljs-comment">// 只读取前num个元素</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> takeStream &lt;- &lt;-valueStream: <span class="hljs-comment">//从输入流中读取元素</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> takeStream<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>map-reduce</strong></p>
<p>map-reduce 是一种处理数据的方式，最早是由 Google 公司研究提出的一种面向大规模数据处理的并行计算模型和方法，开源的版本是 hadoop，前几年比较火。</p>
<p>不过，我要讲的并不是分布式的 map-reduce，而是单机单进程的 map-reduce 方法。</p>
<p>map-reduce 分为两个步骤，第一步是映射（map），处理队列中的数据，第二步是规约（reduce），把列表中的每一个元素按照一定的处理方式处理成结果，放入到结果队列中。</p>
<p>就像做汉堡一样，map 就是单独处理每一种食材，reduce 就是从每一份食材中取一部分，做成一个汉堡。</p>
<p>我们先来看下 map 函数的处理逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapChan</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, fn <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125;) &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">//创建一个输出chan</span><br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">return</span> out<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 启动一个goroutine,实现map的主要逻辑</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 从输入chan读取数据，执行业务操作，也就是map操作</span><br>            out &lt;- fn(v)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure>
<p>reduce 函数的处理逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reduce</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, fn <span class="hljs-keyword">func</span>(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">if</span> in == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 异常检查</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    out := &lt;-in <span class="hljs-comment">// 先读取第一个元素</span><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; <span class="hljs-comment">// 实现reduce的主要逻辑</span><br>        out = fn(out, v)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以写一个程序，这个程序使用 map-reduce 模式处理一组整数，map 函数就是为每个整数乘以 10，reduce 函数就是把 map 处理的结果累加起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 生成一个数据流</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asStream</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(s)<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123; <span class="hljs-comment">// 从数组生成</span><br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">case</span> s &lt;- v:<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    in := asStream(<span class="hljs-literal">nil</span>)<br><br>    <span class="hljs-comment">// map操作: 乘以10</span><br>    mapFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> v.(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-comment">// reduce操作: 对map的结果进行累加</span><br>    reduceFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> r.(<span class="hljs-type">int</span>) + v.(<span class="hljs-type">int</span>)<br>    &#125;<br><br>    sum := reduce(mapChan(in, mapFn), reduceFn) <span class="hljs-comment">//返回累加结果</span><br>    fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>总结</strong></p>
<p>这节课，我借助代码示例，带你学习了 Channel 的应用场景和应用模式。这几种模式不是我们学习的终点，而是学习的起点。掌握了这几种模式之后，我们可以延伸出更多的模式。</p>
<p>虽然 Channel 最初是基于 CSP 设计的用于 goroutine 之间的消息传递的一种数据类型，但是，除了消息传递这个功能之外，大家居然还演化出了各式各样的应用模式。我不确定 Go 的创始人在设计这个类型的时候，有没有想到这一点，但是，我确实被各位大牛利用 Channel 的各种点子折服了，比如有人实现了一个基于 TCP 网络的分布式的 Channel。</p>
<p>在使用 Go 开发程序的时候，你也不妨多考虑考虑是否能够使用 chan 类型，看看你是不是也能创造出别具一格的应用模式。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/4140728d1f331beaf92e712cd34681c9.webp" alt=""></p>
<hr>
<p><br><br><br></p>
<h3 id="4-3-内存模型：Go如何保证并发读写的顺序？">4.3 内存模型：Go如何保证并发读写的顺序？</h3>
<p>你好，我是鸟窝。</p>
<p>Go 官方文档里专门介绍了 Go 的<a target="_blank" rel="noopener" href="https://golang.org/ref/mem">内存模型</a>，你不要误解这里的内存模型的含义，它并不是指 Go 对象的内存分配、内存回收和内存整理的规范，它描述的是并发环境中多 goroutine 读相同变量的时候，变量的可见性条件。具体点说，就是指，在什么条件下，goroutine 在读取一个变量的值的时候，能够看到其它 goroutine 对这个变量进行的写的结果。</p>
<p>由于 CPU 指令重排和多级 Cache 的存在，保证多核访问同一个变量这件事儿变得非常复杂。毕竟，不同 CPU 架构（x86/amd64、ARM、Power 等）的处理方式也不一样，再加上编译器的优化也可能对指令进行重排，所以编程语言需要一个规范，来明确多线程同时访问同一个变量的可见性和顺序（ Russ Cox 在麻省理工学院 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/">6.824 分布式系统 Distributed Systems 课程</a> 的一课，专门介绍了相关的<a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf">知识</a>）。在编程语言中，这个规范被叫做内存模型。</p>
<p>除了 Go，Java、C++、C、C#、Rust 等编程语言也有内存模型。为什么这些编程语言都要定义内存模型呢？在我看来，主要是两个目的。</p>
<ul>
<li>向广大的程序员提供一种保证，以便他们在做设计和开发程序时，面对同一个数据同时被多个 goroutine 访问的情况，可以做一些串行化访问的控制，比如使用 Channel 或者 sync 包和 sync/atomic 包中的并发原语。</li>
<li>允许编译器和硬件对程序做一些优化。这一点其实主要是为编译器开发者提供的保证，这样可以方便他们对 Go 的编译器做优化。</li>
</ul>
<p>既然内存模型这么重要，今天，我们就来花一节课的时间学习一下。</p>
<br>
<p>首先，我们要先弄明白重排和可见性的问题，因为它们影响着程序实际执行的顺序关系。</p>
<p><strong>重排和可见性的问题</strong></p>
<p>由于指令重排，代码并不一定会按照你写的顺序执行。</p>
<p>举个例子，当两个 goroutine 同时对一个数据进行读写时，假设 goroutine g1 对这个变量进行写操作 w，goroutine g2 同时对这个变量进行读操作 r，那么，如果 g2 在执行读操作 r 的时候，已经看到了 g1 写操作 w 的结果，那么，也不意味着 g2 能看到在 w 之前的其它的写操作。这是一个反直观的结果，不过的确可能会存在。</p>
<p>接下来，我再举几个具体的例子，带你来感受一下，重排以及多核 CPU 并发执行导致程序的运行和代码的书写顺序不一样的情况。</p>
<p>先看第一个例子，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    a = <span class="hljs-number">1</span> <span class="hljs-comment">// w之前的写操作</span><br>    b = <span class="hljs-number">2</span> <span class="hljs-comment">// 写操作w</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">print</span>(b) <span class="hljs-comment">// 读操作r</span><br>    <span class="hljs-built_in">print</span>(a) <span class="hljs-comment">// ???</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> f() <span class="hljs-comment">//g1</span><br>    g() <span class="hljs-comment">//g2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，第 9 行是要打印 b 的值。需要注意的是，即使这里打印出的值是 2，但是依然可能在打印 a 的值时，打印出初始值 0，而不是 1。这是因为，程序运行的时候，不能保证 g2 看到的 a 和 b 的赋值有先后关系。</p>
<p>再来看一个类似的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> done <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br>    a = <span class="hljs-string">&quot;hello, world&quot;</span><br>    done = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> setup()<br>    <span class="hljs-keyword">for</span> !done &#123;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这段代码中，主 goroutine main 即使观察到 done 变成 true 了，最后读取到的 a 的值仍然可能为空。</p>
<p>更糟糕的情况是，main 根本就观察不到另一个 goroutine 对 done 的写操作，这就会导致 main 程序一直被 hang 住。甚至可能还会出现半初始化的情况，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    msg <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> g *T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br>    t := <span class="hljs-built_in">new</span>(T)<br>    t.msg = <span class="hljs-string">&quot;hello, world&quot;</span><br>    g = t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> setup()<br>    <span class="hljs-keyword">for</span> g == <span class="hljs-literal">nil</span> &#123;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(g.msg)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即使 main goroutine 观察到 g 不为 nil，也可能打印出空的 msg（第 17 行）。</p>
<p>看到这里，你可能要说了，我都运行这个程序几百万次了，怎么也没有观察到这种现象？我可以这么告诉你，能不能观察到和提供保证（guarantee）是两码事儿。由于 CPU 架构和 Go 编译器的不同，即使你运行程序时没有遇到这些现象，也不代表 Go 可以 100% 保证不会出现这些问题。</p>
<p>刚刚说了，程序在运行的时候，两个操作的顺序可能不会得到保证，那该怎么办呢？接下来，我要带你了解一下 Go 内存模型中很重要的一个概念：happens-before，这是用来描述两个时间的顺序关系的。如果某些操作能提供 happens-before 关系，那么，我们就可以 100% 保证它们之间的顺序。</p>
<br>
<p><strong>happens-before</strong></p>
<p>在一个 goroutine 内部，程序的执行顺序和它们的代码指定的顺序是一样的，即使编译器或者 CPU 重排了读写顺序，从行为上来看，也和代码指定的顺序一样。</p>
<p>这是一个非常重要的保证，我们一定要记住。</p>
<p>我们来看一个例子。在下面的代码中，即使编译器或者 CPU 对 a、b、c 的初始化进行了重排，但是打印结果依然能保证是 1、2、3，而不会出现 1、0、0 或 1、0、1 等情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span><br><br>    <span class="hljs-built_in">println</span>(a)<br>    <span class="hljs-built_in">println</span>(b)<br>    <span class="hljs-built_in">println</span>(c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是，对于另一个 goroutine 来说，重排却会产生非常大的影响。因为 Go 只保证 goroutine 内部重排对读写的顺序没有影响，比如刚刚我们在讲“可见性”问题时提到的三个例子，那该怎么办呢？这就要用到 happens-before 关系了。</p>
<p>如果两个 action（read 或者 write）有明确的 happens-before 关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序）。</p>
<p>Go 内存模型通过 happens-before 定义两个事件（读、写 action）的顺序：如果事件 e1 happens before 事件 e2，那么，我们就可以说事件 e2 在事件 e1 之后发生（happens after）。如果 e1 不是 happens before e2， 同时也不 happens after e2，那么，我们就可以说事件 e1 和 e2 是同时发生的。</p>
<p>如果要保证对“变量 v 的读操作 r”能够观察到一个对“变量 v 的写操作 w”，并且 r 只能观察到 w 对变量 v 的写，没有其它对 v 的写操作，也就是说，我们要保证 r 绝对能观察到 w 操作的结果，那么就需要同时满足两个条件：</p>
<ol>
<li>w happens before r；</li>
<li>其它对 v 的写操作（w2、w3、w4, …） 要么 happens before w，要么 happens after r，绝对不会和 w、r 同时发生，或者是在它们之间发生。</li>
</ol>
<p>你可能会说，这是很显然的事情啊，但我要和你说的是，这是一个非常严格、严谨的数学定义。</p>
<p>对于单个的 goroutine 来说，它有一个特殊的 happens-before 关系，Go 内存模型中是这么讲的：</p>
<blockquote>
<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>
</blockquote>
<p>我来解释下这句话。它的意思是，在单个的 goroutine 内部， happens-before 的关系和代码编写的顺序是一致的。</p>
<p>其实，在这一章的开头我已经用橙色把这句话标注出来了。我再具体解释下。</p>
<p>在 goroutine 内部对一个局部变量 v 的读，一定能观察到最近一次对这个局部变量 v 的写。如果要保证多个 goroutine 之间对一个共享变量的读写顺序，在 Go 语言中，可以使用并发原语为读写操作建立 happens-before 关系，这样就可以保证顺序了。</p>
<p>说到这儿，我想先给你补充三个 Go 语言中和内存模型有关的小知识，掌握了这些，你就能更好地理解下面的内容。</p>
<ol>
<li>在 Go 语言中，对变量进行零值的初始化就是一个写操作。</li>
<li>如果对超过机器 word（64bit、32bit 或者其它）大小的值进行读写，那么，就可以看作是对拆成 word 大小的几个读写无序进行。</li>
<li>Go 并不提供直接的 CPU 屏障（CPU fence）来提示编译器或者 CPU 保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语。</li>
</ol>
<br>
<p>接下来，我就带你学习下 Go 语言中提供的 happens-before 关系保证。</p>
<p><strong>Go 语言中保证的 happens-before 关系</strong></p>
<p>除了单个 goroutine 内部提供的 happens-before 保证，Go 语言中还提供了一些其它的 happens-before 关系的保证，下面我来一个一个介绍下。</p>
<p><strong>init 函数</strong><br>
应用程序的初始化是在单一的 goroutine 执行的。如果包 p 导入了包 q，那么，q 的 init 函数的执行一定 happens before  p 的任何初始化代码。</p>
<p>这里有一个特殊情况需要你记住：main 函数一定在导入的包的 init 函数之后执行。</p>
<p>包级别的变量在同一个文件中是按照声明顺序逐个初始化的，除非初始化它的时候依赖其它的变量。同一个包下的多个文件，会按照文件名的排列顺序进行初始化。这个顺序被定义在Go 语言规范中，而不是 Go 的内存模型规范中。你可以看看下面的例子中各个变量的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>  a = c + b  <span class="hljs-comment">// == 9</span><br>  b = f()    <span class="hljs-comment">// == 4</span><br>  c = f()    <span class="hljs-comment">// == 5</span><br>  d = <span class="hljs-number">3</span>      <span class="hljs-comment">// == 5 全部初始化完成后</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>  d++<br>  <span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure>
<p>具体怎么对这些变量进行初始化呢？</p>
<p>Go 采用的是依赖分析技术。不过，依赖分析技术保证的顺序只是针对同一包下的变量，而且，只有引用关系是本包变量、函数和非接口的方法，才能保证它们的顺序性。</p>
<p>同一个包下可以有多个 init 函数，甚至一个文件中也可以包含多个相同签名的 init 函数。</p>
<p>刚刚讲的这些都是不同包的 init 函数执行顺序，下面我举一个具体的例子，把这些内容串起来，你一看就明白了。</p>
<p>这个例子是一个 main 程序，它依赖包 p1，包 p1 依赖包 p2，包 p2 依赖 p3。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/d5059fab1977602934339e18f9eddb2a.webp" alt=""></p>
<p>为了追踪初始化过程，并输出有意义的日志，我定义了一个辅助方法，打印出日志并返回一个用来初始化的整数值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Trace</span><span class="hljs-params">(t <span class="hljs-type">string</span>, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    fmt.Println(t, <span class="hljs-string">&quot;:&quot;</span>, v)<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们来分别看下包 p3 的这两个文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lib1.go in p3</span><br><br><span class="hljs-keyword">var</span> V1_p3 = trace.Trace(<span class="hljs-string">&quot;init v1_p3&quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">var</span> V2_p3 = trace.Trace(<span class="hljs-string">&quot;init v2_p3&quot;</span>, <span class="hljs-number">3</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init func in p3&quot;</span>)<br>    V1_p3 = <span class="hljs-number">300</span><br>    V2_p3 = <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lib2.go in p3</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;another init func in p3&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面再来看看包 p2。包 p2 定义了变量和 init 函数。第一个变量初始化为 2，并在 init 函数中更改为 200。第二个变量是复制的 p3.V2_p3。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> V1_p2 = trace.Trace(<span class="hljs-string">&quot;init v1_p2&quot;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> V2_p2 = trace.Trace(<span class="hljs-string">&quot;init v2_p2&quot;</span>, p3.V2_p3)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init func in p2&quot;</span>)<br>    V1_p2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>包 p1 定义了变量和 init 函数。它的两个变量的值是复制的 p2 对应的两个变量值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> V1_p1 = trace.Trace(<span class="hljs-string">&quot;init v1_p1&quot;</span>, p2.V1_p2)<br><span class="hljs-keyword">var</span> V2_p1 = trace.Trace(<span class="hljs-string">&quot;init v2_p1&quot;</span>, p2.V2_p2)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init func in p1&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>main 定义了 init 函数和 main 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init func in main&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;V1_p1:&quot;</span>, p1.V1_p1)<br>    fmt.Println(<span class="hljs-string">&quot;V2_p1:&quot;</span>, p1.V2_p1)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 main 函数会依次输出 p3、p2、p1、main 的初始化变量时的日志（变量初始化时的日志和 init 函数调用时的日志）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 包p3的变量初始化<br>init v1_p3 : 3<br>init v2_p3 : 3<br>// p3的init函数<br>init func in p3<br>// p3的另一个init函数 <br>another init func in p3<br><br>// 包p2的变量初始化<br>init v1_p2 : 2<br>init v2_p2 : 300<br>// 包p2的init函数<br>init func in p2<br><br>// 包p1的变量初始化<br>init v1_p1 : 200<br>init v2_p1 : 300<br>// 包p1的init函数<br>init func in p1<br><br>// 包main的init函数<br>init func in main<br>// main函数<br>V1_p1: 200<br>V2_p1: 300<br></code></pre></td></tr></table></figure>
<br>
<p>下面，我们再来看看 goroutine 对 happens-before 关系的保证情况。</p>
<p><strong>goroutine</strong></p>
<p>首先，我们需要明确一个规则：<strong>启动 goroutine 的 go 语句的执行，一定 happens before 此 goroutine 内的代码执行</strong>。</p>
<p>根据这个规则，我们就可以知道，如果 go 语句传入的参数是一个函数执行的结果，那么，这个函数一定先于 goroutine 内部的代码被执行。</p>
<p>我们来看一个例子。在下面的代码中，第 8 行 a 的赋值和第 9 行的 go 语句是在同一个 goroutine 中执行的，所以，在主 goroutine 看来，第 8 行肯定 happens before 第 9 行，又由于刚才的保证，第 9 行子 goroutine 的启动 happens before 第 4 行的变量输出，那么，我们就可以推断出，第 8 行 happens before 第 4 行。也就是说，在第 4 行打印 a 的值的时候，肯定会打印出“hello world”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">print</span>(a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    a = <span class="hljs-string">&quot;hello, world&quot;</span><br>    <span class="hljs-keyword">go</span> f()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>刚刚说的是启动 goroutine 的情况，goroutine 退出的时候，是没有任何 happens-before 保证的。所以，如果你想观察某个 goroutine 的执行效果，你需要使用同步机制建立 happens-before 关系，比如 Mutex 或者 Channel。接下来，我会讲 Channel 的 happens-before 的关系保证。</p>
<br>
<p><strong>Channel</strong></p>
<p>Channel 是 goroutine 同步交流的主要方法。往一个 Channel 中发送一条数据，通常对应着另一个 goroutine 从这个 Channel 中接收一条数据。<br>
通用的 Channel happens-before 关系保证有 4 条规则，我分别来介绍下。</p>
<p>第 1 条规则是，往 Channel 中的发送操作，happens before 从该 Channel 接收相应数据的动作完成之前，即第 n 个 send 一定 happens before 第 n 个 receive 的完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">10</span>) <span class="hljs-comment">// buffered或者unbuffered</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    s = <span class="hljs-string">&quot;hello, world&quot;</span><br>    ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> f()<br>    &lt;-ch<br>    <span class="hljs-built_in">print</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，s 的初始化（第 5 行）happens before 往 ch 中发送数据， 往 ch 发送数据 happens before 从 ch 中读取出一条数据（第 11 行），第 12 行打印 s 的值 happens after 第 11 行，所以，打印的结果肯定是初始化后的 s 的值“hello world”。</p>
<p>第 2 条规则是，close 一个 Channel 的调用，肯定 happens before 从关闭的 Channel 中读取出一个零值。</p>
<p>还是拿刚刚的这个例子来说，如果你把第 6 行替换成 close(ch)，也能保证同样的执行顺序。因为第 11 行从关闭的 ch 中读取出零值后，第 6 行肯定被调用了。</p>
<p>第 3 条规则是，对于 unbuffered 的 Channel，也就是容量是 0 的 Channel，从此 Channel 中读取数据的调用一定 happens before 往此 Channel 发送数据的<u>调用完成</u>。</p>
<p>所以，在上面的这个例子中呢，如果想保持同样的执行顺序，也可以写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    s = <span class="hljs-string">&quot;hello, world&quot;</span><br>    &lt;-ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> f()<br>    ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-built_in">print</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 4 条规则是，如果 Channel 的容量是 m（m&gt;0），那么，第 n 个 receive 一定 happens before 第 n+m 个 send 的完成。</p>
<p>前一条规则是针对 unbuffered channel 的，这里给出了更广泛的针对 buffered channel 的保证。利用这个规则，我们可以实现信号量（Semaphore）的并发原语。Channel 的容量相当于可用的资源，发送一条数据相当于请求信号量，接收一条数据相当于释放信号。关于信号量这个并发原语，我会在下一讲专门给你介绍一下，这里你只需要知道它可以控制多个资源的并发访问，就可以了。</p>
<br>
<p><strong>Mutex/RWMutex</strong></p>
<p>对于互斥锁 Mutex m 或者读写锁 RWMutex m，有 3 条 happens-before 关系的保证。</p>
<ol>
<li>第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回；</li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.Lock 方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。</li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.RLock 方法的调用已返回，那么它的第 k （k&lt;=n）个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用，只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。</li>
</ol>
<p>读写锁的保证有点绕，我再带你看看官方的描述：</p>
<blockquote>
<p>对于读写锁 l 的 l.RLock 方法调用，如果存在一个 n，这次的 l.RLock 调用 happens after 第 n 次的 l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是，读写锁的 Lock 必须等待既有的读锁释放后才能获取到。</p>
</blockquote>
<p>我再举个例子。在下面的代码中，第 6 行第一次的 Unlock 一定 happens before 第二次的 Lock（第 12 行），所以这也能保证正确地打印出“hello world”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    s = <span class="hljs-string">&quot;hello, world&quot;</span><br>    mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">go</span> foo()<br>    mu.Lock()<br>    <span class="hljs-built_in">print</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>WaitGroup</strong></p>
<p>接下来是 WaitGroup 的保证。</p>
<p>对于一个 WaitGroup 实例 wg，在某个时刻 t0 时，它的计数值已经不是零了，假如 t0 时刻之后调用了一系列的 wg.Add(n) 或者 wg.Done()，并且只有最后一次调用 wg 的计数值变为了 0，那么，可以保证这些 wg.Add 或者 wg.Done() 一定 happens before t0 时刻之后调用的 wg.Wait 方法的返回。<br>
这个保证的通俗说法，就是 Wait 方法等到计数值归零之后才返回。</p>
<br>
<p><strong>Once</strong></p>
<p>我们在 <u>2.8 Once：一个简约而不简单的并发原语</u> 学过 Once 了，相信你已经很熟悉它的功能了。它提供的保证是：对于 <a target="_blank" rel="noopener" href="http://once.Do">once.Do</a>(f) 调用，f 函数的那个单次调用一定 happens before 任何 <a target="_blank" rel="noopener" href="http://once.Do">once.Do</a>(f) 调用的返回。换句话说，就是函数 f 一定会在 Do 方法返回之前执行。</p>
<p>还是以 hello world 的例子为例，这次我们使用 Once 并发原语实现，可以看下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    s = <span class="hljs-string">&quot;hello, world&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoprint</span><span class="hljs-params">()</span></span> &#123;<br>    once.Do(foo)<br>    <span class="hljs-built_in">print</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 5 行的执行一定 happens before 第 9 行的返回，所以执行到第 10 行的时候，sd 已经初始化了，所以会正确地打印“hello world”。</p>
<br>
<p>最后，我再来说说 atomic 的保证。</p>
<p><strong>atomic</strong></p>
<p>其实，Go 内存模型的官方文档并没有明确给出 atomic 的保证，有一个相关的 issue go<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/5045"># 5045</a>记录了相关的讨论。光看 issue 号，就知道这个讨论由来已久了。Russ Cox 想让 atomic 有一个弱保证，这样可以为以后留下充足的可扩展空间，所以，Go 内存模型规范上并没有严格的定义。</p>
<p>对于 Go 1.15 的官方实现来说，可以保证使用 atomic 的 Load/Store 的变量之间的顺序性。</p>
<p>在下面的例子中，打印出的 a 的结果总是 1，但是官方并没有做任何文档上的说明和保证。</p>
<p>依照 Ian Lance Taylor 的说法，Go 核心开发组的成员几乎没有关注这个方向上的研究，因为这个问题太复杂，有很多问题需要去研究，所以，现阶段还是不要使用 atomic 来保证顺序性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int32</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        atomic.StoreInt32(&amp;a, <span class="hljs-number">1</span>)<br>        atomic.StoreInt32(&amp;b, <span class="hljs-number">1</span>)<br>    &#125;()<br><br>    <span class="hljs-keyword">for</span> atomic.LoadInt32(&amp;b) == <span class="hljs-number">0</span>&#123;<br>        runtime.Gosched()<br>    &#125;<br>    fmt.Println(atomic.LoadInt32(&amp;a))<br>&#125;<br></code></pre></td></tr></table></figure>
<br>
<p><strong>总结</strong></p>
<p>Go 的内存模型规范中，一开始有这么一段话：</p>
<blockquote>
<p>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</p>
</blockquote>
<blockquote>
<p>Don’t be clever.</p>
</blockquote>
<p>我来说说我对这句话的理解：你通过学习这节课来理解你的程序的行为是聪明的，但是，不要自作聪明。</p>
<p>谨慎地使用这些保证，能够让你的程序按照设想的 happens-before 关系执行，但是不要以为完全理解这些概念和保证，就可以随意地制造所谓的各种技巧，否则就很容易掉进“坑”里，而且会给代码埋下了很多的“定时炸弹”。</p>
<p>比如，Go 里面已经有值得信赖的互斥锁了，如果没有额外的需求，就不要使用 Channel 创造出自己的互斥锁。</p>
<p>当然，我也不希望你畏手畏脚地把思想局限住，我还是建议你去做一些有意义的尝试，比如使用 Channel 实现信号量等扩展并发原语。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/dc68fc5f93a4af96c8f4d45d6282104d.webp" alt=""></p>
<hr>
<p><br><br><br></p>
<h2 id="五、扩展并发原语">五、扩展并发原语</h2>
<hr>
<p><br><br><br></p>
<h2 id="六、分布式并发原语">六、分布式并发原语</h2>
<hr>
<p><br><br><br></p>
<h2 id="七、结束语">七、结束语</h2>
<hr>
<p>怎么解决配置中心这种，写很少，但是读特别多的问题？</p>
<p>Rwmutexs</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">go vet ./...<br></code></pre></td></tr></table></figure>
<p><code>sync.Map</code> 和普通的 <code>map</code> 在 Go 中的主要区别确实在于 <strong>线程安全</strong>，但除此之外，它们在实现方式、性能特点和使用场景上也有一些显著的差异。</p>
<ol>
<li>
<p><strong>线程安全性</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：<code>sync.Map</code> 是线程安全的，可以在并发环境下直接使用而不需要额外的锁。因此，在需要频繁并发读写的场景中，<code>sync.Map</code> 能够避免手动加锁操作，提供较好的安全性和便捷性。</li>
<li><strong>普通 <code>map</code></strong>：普通的 <code>map</code> 在并发读写时并不是线程安全的，必须使用 <code>sync.RWMutex</code> 等机制进行同步保护，否则会引发并发读写错误（如 <code>fatal error: concurrent map read and map write</code>）。</li>
</ul>
</li>
<li>
<p><strong>性能和使用场景</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：适用于读多写少的场景，尤其是在数据量较大时，频繁读写可能导致性能下降。<code>sync.Map</code> 采用了内部分段锁和延迟删除机制（不立即删除而是标记删除），在高并发、读多写少的情况表现更好。</li>
<li><strong>普通 <code>map</code></strong>：对于写多读少或非并发的场景，普通 <code>map</code> 加上 <code>sync.RWMutex</code> 可能会有更好的性能，因为 <code>sync.Map</code> 复杂的内部逻辑（如分段锁、延迟删除等）在写多的情况下反而可能会增加额外的开销。</li>
</ul>
</li>
<li>
<p><strong>API 不同</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：
<ul>
<li>使用的是 <code>Load</code>、<code>Store</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code> 等方法，没有直接的索引操作（如 <code>m[key]</code>）。</li>
<li><code>LoadOrStore</code> 方法特别适合在高并发时使用，可以实现“检查并存储”的操作，相比普通 <code>map</code> 更加简洁高效。</li>
</ul>
</li>
<li><strong>普通 <code>map</code></strong>：
<ul>
<li>可以通过索引操作 <code>m[key]</code> 来直接读取或写入数据，使用方式更加简洁。</li>
<li>普通 <code>map</code> 直接支持的操作方式更加灵活，比如通过直接的迭代、元素删除等操作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>内存管理和清理</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：使用了延迟删除机制，标记删除的元素不会立即被移除，而是在后续操作或 <code>Range</code> 时被逐步清理。这种机制在频繁删除和读写的情况下可能会占用更多内存。</li>
<li><strong>普通 <code>map</code></strong>：删除元素时直接释放内存，更加简单直接，不会有延迟删除的问题。</li>
</ul>
</li>
<li>
<p><strong>遍历顺序</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：<code>sync.Map</code> 中元素的遍历顺序是不确定的，因为其内部实现可能会对元素存储进行重新分配、优化等操作。</li>
<li><strong>普通 <code>map</code></strong>：虽然遍历顺序也不保证一致，但在一次遍历过程中元素的顺序是固定的，且通常不会因为 <code>Range</code> 而改变（除非手动插入或删除元素）。</li>
</ul>
</li>
<li>
<p><strong>实现原理的不同</strong></p>
<ul>
<li><strong><code>sync.Map</code></strong>：<code>sync.Map</code> 并不是简单地加锁来实现线程安全的，它采用了一种更复杂的数据结构，基于读多写少场景设计。其内部结构大致由两部分组成：只读部分（read-only）和脏部分（dirty）。
<ul>
<li><strong>只读部分</strong>：存储稳定的数据，用于快速读取，没有锁，因此读性能很高。</li>
<li><strong>脏部分</strong>：用于存储最近的写入数据，并在适当时机合并到只读部分。</li>
<li>当写入操作发生时，会优先尝试在脏部分写入，写入次数增多时，会将脏部分的数据合并到只读部分中。这种设计提高了并发访问的性能。</li>
</ul>
</li>
<li><strong>普通 <code>map</code></strong>：普通的 <code>map</code> 是基于哈希表实现的，不具备并发安全特性。</li>
</ul>
</li>
</ol>
<p>总结</p>
<ul>
<li><strong>线程安全</strong>：<code>sync.Map</code> 的最大优势是线程安全，适合并发读写场景，普通 <code>map</code> 在并发下需要手动加锁。</li>
<li><strong>使用场景</strong>：<code>sync.Map</code> 适用于读多写少的高并发场景，而普通 <code>map</code> 更适合非并发场景或写多读少的场景。</li>
<li><strong>实现细节</strong>：<code>sync.Map</code> 采用分段锁和延迟删除，牺牲了部分写性能来换取读性能和线程安全，而普通 <code>map</code> 是一个简单的哈希表。</li>
</ul>
<p>因此，如果你的应用场景是并发读多写少，<code>sync.Map</code> 会更合适；如果是非并发或写多读少场景，则可以使用普通的 <code>map</code>，配合 <code>sync.RWMutex</code> 达到更好的性能。</p>
<hr>
<p><strong>并发编程中避免数据竞争的总结笔记</strong></p>
<p>在实际生产环境中，<strong>数据竞争（Data Race）<strong>是并发编程中常见的问题。我们应尽量在设计阶段就</strong>避免数据竞争</strong>，而不是依赖加锁等手段在问题发生后再去解决，因为加锁会导致并发性能的下降。</p>
<p>一、避免共享可变状态</p>
<ol>
<li>
<p><strong>无共享设计（No Shared State Design）</strong></p>
<ul>
<li><strong>消除共享数据</strong>：通过设计，使得线程或协程之间不共享数据，从根本上避免数据竞争。</li>
<li><strong>函数式编程理念</strong>：使用不可变数据结构，避免状态变化。</li>
</ul>
</li>
<li>
<p><strong>消息传递（Message Passing）</strong></p>
<ul>
<li><strong>使用通信机制</strong>：如 Go 语言的 <strong>channel</strong>，线程或协程之间通过消息传递数据，而不是共享内存。</li>
</ul>
</li>
</ol>
<p>二、使用不可变数据和值传递</p>
<ol>
<li>
<p><strong>不可变数据（Immutable Data）</strong></p>
<ul>
<li><strong>创建后不修改</strong>：不可变数据在并发环境下是安全的，因为它们不会被修改。</li>
</ul>
</li>
<li>
<p><strong>值传递</strong></p>
<ul>
<li><strong>传递数据副本</strong>：将数据的副本传递给线程或协程，避免对原始数据的并发修改。</li>
</ul>
</li>
</ol>
<p>三、数据局部化</p>
<ol>
<li>
<p><strong>线程/协程本地存储（Thread/Coroutine Local Storage）</strong></p>
<ul>
<li><strong>数据局部化</strong>：将数据限制在单个线程或协程内部，防止跨线程的数据竞争。</li>
</ul>
</li>
<li>
<p><strong>写时复制（Copy-on-Write, COW）</strong></p>
<ul>
<li><strong>延迟复制</strong>：在需要修改数据时才复制，减少不必要的复制开销。</li>
</ul>
</li>
</ol>
<p>四、使用无锁数据结构</p>
<ul>
<li><strong>无锁（Lock-free）和无等待（Wait-free）数据结构</strong>
<ul>
<li><strong>原子操作</strong>：利用原子操作（如 CAS）实现线程安全，而不需要锁。</li>
</ul>
</li>
</ul>
<p>五、使用原子操作和内存屏障</p>
<ol>
<li>
<p><strong>原子操作（Atomic Operations）</strong></p>
<ul>
<li><strong>线程安全的基本操作</strong>：如原子加减，可以保证对单个变量的线程安全访问。</li>
</ul>
</li>
<li>
<p><strong>内存屏障（Memory Barrier）</strong></p>
<ul>
<li><strong>防止指令重排</strong>：确保内存操作的执行顺序，避免因编译器优化导致的意外行为。</li>
</ul>
</li>
</ol>
<p>六、使用并发安全的数据结构</p>
<ul>
<li><strong>并发安全容器</strong>
<ul>
<li><strong>如</strong>：Java 的 <code>ConcurrentHashMap</code>、Go 的 <code>sync.Map</code>。</li>
<li><strong>特性</strong>：内部实现了必要的同步机制，适合在并发环境下使用。</li>
</ul>
</li>
</ul>
<p>七、合理使用同步机制</p>
<ol>
<li>
<p><strong>最小化锁的粒度</strong></p>
<ul>
<li><strong>减少锁的持有时间</strong>：仅在必要的代码块加锁，避免影响其他并发操作。</li>
</ul>
</li>
<li>
<p><strong>读写锁（Read-Write Lock）</strong></p>
<ul>
<li><strong>读多写少场景</strong>：允许多个读操作并发进行，写操作仍需独占。</li>
</ul>
</li>
</ol>
<p>八、Go 语言中的实践</p>
<ol>
<li>
<p><strong>优先使用值传递或不可变数据传递给 goroutine</strong></p>
<ul>
<li><strong>避免数据竞争</strong>：传递数据副本或不可变数据，防止 goroutine 修改共享数据。</li>
</ul>
</li>
<li>
<p><strong>使用 channel 传递数据</strong></p>
<ul>
<li><strong>通信共享内存</strong>：通过 channel 传递数据，而不是共享内存，符合 Go 的并发哲学。</li>
</ul>
</li>
<li>
<p><strong>避免共享可变数据</strong></p>
<ul>
<li><strong>慎用指针和引用类型</strong>：除非有明确的同步机制，否则应避免在 goroutine 间共享可变数据。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<p>在并发编程中，<strong>预防胜于治疗</strong>。通过设计无共享的数据结构、使用不可变数据、值传递和并发安全的通信机制，可以有效避免数据竞争问题，提升程序的并发性能和可靠性。依赖加锁虽然能解决数据竞争，但会带来性能开销和死锁风险，应尽量避免。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gxblogs.com">ggw &amp; xpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gxblogs.com/posts/1808/">https://gxblogs.com/posts/1808/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gxblogs.com" target="_blank">GXBLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-09-30_16-11-15.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/49872/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-12-20_17-08-48.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">linux日常笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/57494/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-09-18_17-13-03.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">golang注意事项</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/19502/" title="connection pool"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-08_10-26-59.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="title">connection pool</div></div></a></div><div><a href="/posts/45078/" title="go代码模块记录"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-03-20_10-54-38.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-22</div><div class="title">go代码模块记录</div></div></a></div><div><a href="/posts/47375/" title="go包目录"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-06-03_14-06-04.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="title">go包目录</div></div></a></div><div><a href="/posts/14787/" title="Go‘s 数据结构"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2024-08-05_14-52-01.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="title">Go‘s 数据结构</div></div></a></div><div><a href="/posts/47995/" title="go编程规范"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/general/Snipaste_2025-04-02_10-51-17.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-06</div><div class="title">go编程规范</div></div></a></div><div><a href="/posts/47697/" title="设计模式（golang）"><img class="cover" src="/static/imgs/loading.gif" data-original="https://ggwimgs-1313043536.cos.ap-guangzhou.myqcloud.com/go/Snipaste_2025-01-03_16-16-49.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="title">设计模式（golang）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%80%E7%AF%87%E8%AF%8D"><span class="toc-text">一、开篇词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-text">二、基本并发原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Mutex-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98"><span class="toc-text">2.1 Mutex: 如何解决资源并发访问问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1.1 互斥锁的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Mutex-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.1.2 Mutex 的基本使用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Mutex%EF%BC%9A%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9B%E7%9C%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 Mutex：庖丁解牛看实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%88%9D%E7%89%88%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">2.2.1 初版的互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%BB%99%E6%96%B0%E4%BA%BA%E6%9C%BA%E4%BC%9A"><span class="toc-text">2.2.2 给新人机会</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%A4%9A%E7%BB%99%E4%BA%9B%E6%9C%BA%E4%BC%9A"><span class="toc-text">2.2.3 多给些机会</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E8%A7%A3%E5%86%B3%E9%A5%A5%E9%A5%BF"><span class="toc-text">2.2.4 解决饥饿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Mutex%EF%BC%9A4%E7%A7%8D%E6%98%93%E9%94%99%E5%9C%BA%E6%99%AF%E5%A4%A7%E7%9B%98%E7%82%B9"><span class="toc-text">2.3 Mutex：4种易错场景大盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Lock-Unlock-%E4%B8%8D%E6%98%AF%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><span class="toc-text">2.3.1 Lock&#x2F;Unlock 不是成对出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Copy-%E5%B7%B2%E4%BD%BF%E7%94%A8%E7%9A%84-Mutex"><span class="toc-text">2.3.2 Copy 已使用的 Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E9%87%8D%E5%85%A5"><span class="toc-text">2.3.3 重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E6%AD%BB%E9%94%81"><span class="toc-text">2.3.4 死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E6%B5%81%E8%A1%8C%E7%9A%84-Go-%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0"><span class="toc-text">2.3.5 流行的 Go 开发项目踩坑记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Mutex%EF%BC%9A%E9%AA%87%E5%AE%A2%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8B%93%E5%B1%95%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">2.4 Mutex：骇客编程，如何拓展额外功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-RWMutex%EF%BC%9A%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="toc-text">2.5 RWMutex：读写锁的实现原理及避坑指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-WaitGroup%EF%BC%9A%E5%8D%8F%E5%90%8C%E7%AD%89%E5%BE%85%EF%BC%8C%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8"><span class="toc-text">2.6 WaitGroup：协同等待，任务编排利器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Cond%EF%BC%9A%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="toc-text">2.7 Cond：条件变量的实现机制及避坑指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-Once%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E7%BA%A6%E8%80%8C%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-text">2.8 Once：一个简约而不简单的并发原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-map%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84map%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">2.9 map：如何实现线程安全的map类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-Pool%EF%BC%9A%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%A4%A7%E6%9D%80%E5%99%A8"><span class="toc-text">2.10 Pool：性能提升大杀器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-Context%EF%BC%9A%E4%BF%A1%E6%81%AF%E7%A9%BF%E9%80%8F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.11 Context：信息穿透上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">三、原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-atomic%EF%BC%9A%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%99%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81channel"><span class="toc-text">四、channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-channel%EF%BC%9A%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">4.1 channel：另辟蹊径，解决并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Channel%EF%BC%9A%E9%80%8F%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2 Channel：透过代码看典型的应用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9AGo%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">4.3 内存模型：Go如何保证并发读写的顺序？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-text">五、扩展并发原语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-text">六、分布式并发原语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-text">七、结束语</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By ggw & xpl</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/pluginsSrc/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/ggwsettings.js"></script><script>(function(d, w, c) {
    w.ChatraID = 'dKkRxvMac7f9AeKhu';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>