<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王道操作系统 | ggw和xpl的博客</title><meta name="author" content="ggw"><meta name="copyright" content="ggw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:type" content="article">
<meta property="og:title" content="王道操作系统">
<meta property="og:url" content="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ggw和xpl的博客">
<meta property="og:description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg">
<meta property="article:published_time" content="2023-05-03T11:13:08.565Z">
<meta property="article:modified_time" content="2023-05-07T15:39:22.577Z">
<meta property="article:author" content="ggw">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: ggw","link":"链接: ","source":"来源: ggw和xpl的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-07 23:39:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/C5EAC1F2A55D115DB1654F59F20A9934.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggw和xpl的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-03T11:13:08.565Z" title="发表于 2023-05-03 19:13:08">2023-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-07T15:39:22.577Z" title="更新于 2023-05-07 23:39:22">2023-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">51.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>158分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王道操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?t=3.0&amp;p=2">【王道考研操作系统】</a></p>
<p>微博大号–@王道咸鱼老师-计算机考研<br>
微博小号–@王道楼楼老师-计算机考研</p>
<h1>第一章 计算机系统概述</h1>
<h2 id="1-1-1-操作系统的概念、功能">1.1.1 操作系统的概念、功能</h2>
<ul>
<li><strong><u>大家都熟悉的操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_18-59-48.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的概念（定义）</strong></u></li>
</ul>
<p>一台电脑的诞生~<br>
Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机）<br>
Step 2：出售前安装操作系统<br>
Step 3：用户安装应用程序（eg：QQ）<br>
Step 4：使用 QQ 聊天</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-16-00.jpg" alt=""></p>
<p><strong>操作系统</strong>（Operating System， OS）</p>
<ul>
<li>是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>（<u>①操作系统是系统资源的管理者</u>）资源，并合理地组织调度计算机的工作和资源的分配；</li>
<li>以<strong>提供给用户和其他软件方便的接口和环境</strong>（<u>②向上层提供方便易用的服务</u>）；</li>
<li>它是计算机系统中最基本的<strong>系统软件</strong>（<u>③是最接近硬件的一层软件</u>）。</li>
</ul>
<p>直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-25-08.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为系统资源的管理者</strong></u>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>补充知识：执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p>
<p>用QQ和朋友视频聊天的过程：<br>
Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）【逐层打开文件夹，找到QQ.exe 这个程序（可执行文件）的存放位置】<br>
Step 2：双击打开 QQ.exe 【需要把该程序相关数据放入内存】<br>
Step 3：QQ 程序正常运行 【对应的进程被处理机（CPU）处理】<br>
Step 4：开始和朋友视频聊天 【需要将摄像头设备分配给进程】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——向上层提供方便易用的服务</strong></u></li>
</ul>
<p><strong>封装思想</strong>：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-35-16.jpg" alt=""></p>
<p><strong>GUI</strong>：图形化用户接口（Graphical User Interface） 【很多现代操作系统都提供GUI】<br>
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>
例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
<p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口<br>
Step 1：win键+R<br>
Step 2：输入cmd，按回车，打开命令解释器<br>
Step 3：尝试使用 time 命令<br>
【特点：用户说一句， 系统跟着做一句】</p>
<p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口<br>
使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。<br>
【特点：用户说一堆， 系统跟着做一堆】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-40-45.jpg" alt=""></p>
<p>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。<br>
如：写C语言“Hello world”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-45-43.jpg" alt=""><br>
系统调用类似于函数调用，是应用程 序请求操作系统服务的唯一方式。<strong>在有的教材中： 系统调用=广义指令</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-50-22.jpg" alt=""><br>
【有的教材中把命令接口和程序接口统称为“用户接口”，意思就是说狭义的用户接口不包括GUI。】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为最接近硬件的层次</strong></u></li>
</ul>
<p>需要实现<strong>对硬件机器的拓展</strong>；<br>
没有任何软件支持的计算机成为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器；<br>
通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>
<p>类比汽车： 发动机——只会转；轮胎——只会滚；<br>
在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展</p>
<p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</p>
<hr>
<h2 id="1-1-2-操作系统的特征">1.1.2 操作系统的特征</h2>
<blockquote>
<ul>
<li>并发</li>
<li>共享</li>
</ul>
<p>并发和共享是两个最基本的特征，二者互为存在条件。</p>
<ul>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>重要考点：<br>
理解并发和并行的区别<br>
并发和共享互为存在条件<br>
没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</p>
</blockquote>
<ul>
<li><u><strong>操作系统的特征——并发</strong></u></li>
</ul>
<p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。<br>
常考易混概念——<strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p>
<p>并发 VS 并行：<br>
eg：假设小渣和老渣每人有两个女朋友。任务1：和一号约会；任务2：和二号约会…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_20-10-44.jpg" alt=""></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。<br>
操作系统就是伴随着“多道程序技术”（后面介绍）而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p>
<p>注意（<strong>重要考点</strong>）：<br>
<strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行<br>
<strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行<br>
比如Intel 的第八代 i3 处理器就是 <strong>4 核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>；【即使是对于4核CPU来说，只要有4个以 上的程序需要“同时”运行，那么并发性依然是必不可少的，因此<strong>并发性是操作系统一个最基本的特性</strong>】</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——共享</strong></u></li>
</ul>
<p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：<br>
互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br>
同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——并发和共享的关系</strong></u></li>
</ul>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。<br>
<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>通过上述例子来看并发与共享的关系：<br>
使用QQ发送文件A，同时使用微信发送文件B。<br>
1.两个进程正在并发执行（并发性） 【如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义】<br>
2.需要共享地访问硬盘资源（共享性）【如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发】</p>
<p><strong>二者互为存在条件。</strong></p>
<hr>
<ul>
<li><strong><u>操作系统的特征——虚拟</u></strong></li>
</ul>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>Yo~用一个例子来理解<br>
背景知识：一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p>
<p>GTA5需要4GB的运行内存，<br>
QQ 需要256MB的内存，<br>
迅雷需要256MB的内存，<br>
网易云音乐需要256MB的内存……<br>
我的电脑：4GB内存<br>
问题：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？<br>
答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>空分复用技术</strong>” 。</p>
<p>某单核CPU的计算机中，用户打开了以下软件。。。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-18-58.jpg" alt=""><br>
问题：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>时分复用技术</strong>” 。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p>
<ul>
<li><strong>虚拟技术</strong>
<ul>
<li><strong>空分复用技术</strong>（如虚拟存储技术）</li>
<li><strong>时分复用技术</strong>（如虚拟处理器）</li>
</ul>
</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——异步</strong></u></li>
</ul>
<p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""><br>
与一、二号的约会 = 两道并发执行的程序 老渣的心 = 有限的系统资源</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p>
<hr>
<h2 id="1-2-操作系统的发展与分类">1.2 操作系统的发展与分类</h2>
<ul>
<li><strong><u>手工操作阶段</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-40-24.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>批处理阶段——单道批处理系统</u></strong></li>
</ul>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-43-53.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-48-41.jpg" alt=""></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br>
主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
<hr>
<ul>
<li><strong><u>批处理阶段——多道批处理系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-04.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-54.jpg" alt=""></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br>
主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）</p>
<hr>
<ul>
<li><strong><u>分时操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-14-13.jpg" alt=""></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。<br>
主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br>
主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
<hr>
<ul>
<li><strong><u>实时操作系统</u></strong>
<ul>
<li>硬实时系统<br>
必须在绝对严格的规定时间内完成处理<br>
如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统<br>
能接受偶尔违反时间规定<br>
如：12306火车订票系统</li>
</ul>
</li>
</ul>
<p>实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<hr>
<ul>
<li><strong><u>其他几种操作系统</u></strong></li>
</ul>
<p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
<p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
<p>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</p>
<hr>
<h2 id="1-3-1-操作系统的运行机制">1.3.1 操作系统的运行机制</h2>
<blockquote>
<p>Tips：</p>
<ol>
<li>都是高频考点，很重要</li>
<li>初学者不完全理解没关系， 放心大胆地往后学，随着后面章节的学习，理解会逐渐加深</li>
</ol>
</blockquote>
<ul>
<li><strong><u>预备知识：程序是如何运行的？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-19-00.jpg" alt=""></p>
<p>程序运行的过程其实就 是CPU执行一条一条的机器指令的过程</p>
<p>“指令”就是处理器（CPU）能识别、执行的最基本命令</p>
<p>注：很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也 称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别 开。本节中的“指令”指二进制机器指令</p>
<hr>
<ul>
<li><strong><u>内核程序 v.s. 应用程序</u></strong></li>
</ul>
<p>我们普通程序员写的程序就是“<strong>应用程序</strong>”</p>
<p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”<br>
由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong> ” 内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核） 操作系统的功能未必都在内核中，如图形化用户界面 GUI</p>
<hr>
<ul>
<li><strong><u>特权指令 v.s. 非特权指令</u></strong></li>
</ul>
<p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU 执行一条指令前就能判断出其类型</p>
<p>应用程序只能使用“非特权指令”，如： 加法指令、减法指令等</p>
<p>操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</p>
<hr>
<ul>
<li><strong><u>内核态 v.s. 用户态</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-25-21.jpg" alt=""></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 问题：如何实现CPU状态的切换？</p>
<p>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<br>
处于<strong>内核态时</strong>，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong><br>
处于<strong>用户态时</strong>，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p>
<p>拓展：CPU 中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong> ，其中有个二进制位，1表示 “内核态”，0表示“用户态”</p>
<p><strong>别名</strong>：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></p>
<hr>
<ul>
<li><strong><u>内核态、用户态 的切换</u></strong></li>
</ul>
<table>
    <tr>
        <td>
            一个故事：</br>
    ① 刚开机时，CPU 为“<b>内核态</b>”，操作系统内核程序先上CPU运行</br>
② 开机完成后，用户可以启动某个应用程序</br> 
③ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行</br>
【操作系统内核在让出CPU之前，会<b>用一条特权指令把 PSW 的标志位设置为“用户态”</b>】</br>
④ 应用程序运行在“用户态”</br> 
⑤ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…</br> 
⑥ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”</br> 
⑦ 这个非法事件会引发一个<b>中断信号</b></br>
【<b>CPU检测到中断信号后</b>，会立即<b>变为“核心态”</b>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序】</br> 
⑧ “中断”使操作系统再次夺回CPU的控制权</br> ⑨ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</br>
        </td>
    </tr>    
</table>
**内核态** $\to$ **用户态**：**执行一条特权指令**——**修改PSW**的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权 
**用户态** $\to$ **内核态**：由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权
【除了非法使用特权指令之外，还有很多事件 会触发中断信号。一个共性是，**但凡需要操作系统介入的地方，都会触发中断信号**】
<hr>
<h2 id="1-3-2-中断和异常">1.3.2 中断和异常</h2>
<ul>
<li><strong><u>中断的作用</u></strong><br>
“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
</ul>
<p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>（是整个系统的管理者），一种是<strong>应用程序</strong></p>
<p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）</p>
<p>“中断”是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径</p>
<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序<br>
没有中断机制，就不可能实现操作系统，不可能实现程序并发</p>
<hr>
<ul>
<li><strong><u>中断的类型</u></strong>
<ul>
<li><strong>内中断</strong><br>
与当前执行的指令有关， 中断信号来源于CPU内部</li>
<li><strong>外中断</strong><br>
与当前执行的指令无关， 中断信号来源于CPU外部</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><u><strong>内中断的例子</strong></u></li>
</ul>
<p>例子 1：试图在用户态下执行特权指令<br>
例子 2：执行除法指令时发现除数为 0<br>
【若当前执行的指令是非法的，则会引发一个中断信号】</p>
<p>例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<br>
【执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “<strong>系统调用”就是通过陷入指令完成的</strong>】</p>
<hr>
<ul>
<li><strong><u>外中断的例子</u></strong></li>
</ul>
<p>例子1：时钟中断——由时钟部件发来的中断信号</p>
<p>例子2：I/O中断——由输入/输出设备发来的中断信号</p>
<hr>
<ul>
<li><strong><u>中断的分类</u></strong>【广义的中断】
<ul>
<li>内中断（也称<strong>异常</strong>、例外）
<ul>
<li>陷阱、陷入（trap）【由陷入指令引发，是应用程序故意引发的】</li>
<li>故障（fault）【由错误条件引起的，可能被 内核程序修复。内核程序修 复故障后会把 CPU使用权还 给应用程序，让它继续执行 下去。如：缺页故障。】</li>
<li>终止（abort）【由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序。如： 整数除0、非法使用特权指令】</li>
</ul>
</li>
<li>外中断（也称中断）【狭义的中断】
<ul>
<li>时钟中断</li>
<li>I/O中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常“</p>
<hr>
<ul>
<li><u><strong>中断机制的基本原理</strong></u></li>
</ul>
<p>检测中断信号：</p>
<ul>
<li>内中断：CPU在<strong>执行指令时</strong>会检查是否有异常发生</li>
<li>外中断：<strong>每个指令周期末尾</strong>，CPU都会检查是否有外中断信号需要处理</li>
</ul>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-07-58.jpg" alt=""><br>
显然，中断处理程序一定是内核程序，需要运行在“内核态”</p>
<hr>
<h2 id="1-3-3-系统调用">1.3.3 系统调用</h2>
<ul>
<li><strong><u>什么是系统调用，有何作用？</u></strong></li>
</ul>
<p>知识点回顾：<br>
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
<hr>
<ul>
<li><strong><u>系统调用与库函数的区别</u></strong></li>
</ul>
<table>
    <tr>
        <td>普通应用程序</td>
        <td>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
    </tr>
    <tr>
        <td>编程语言</td>
        <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>
    </tr>
    <tr>
        <td>操作系统</td>
        <td>向上提供系统调用，使得上层程序能请求内核的服务</td>
    </tr>
    <tr>
        <td>裸机</td>
        <td></td>
    </tr>
</table>
<p>不涉及系统调用的库函数：如的“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-21-42.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>小例子：为什么系统调用是必须的？</u></strong></li>
</ul>
<p>生活场景：去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开 始工作。<br>
你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p>
<hr>
<ul>
<li><strong><u>什么功能要用到系统调用？</u></strong></li>
</ul>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<ul>
<li><strong>系统调用（按功能分类）</strong>
<ul>
<li><strong>设备管理</strong>：完成设备的 <strong>请求/释放/启动</strong> 等功能</li>
<li><strong>文件管理</strong>：完成文件的 <strong>读/写/创建/删除</strong> 等功能</li>
<li><strong>进程管理</strong>：完成进程的 <strong>创建/撤销/阻塞/唤醒</strong> 等功能</li>
<li><strong>进程通信</strong>：完成进程之间的 <strong>消息传递/信号传递</strong> 等功能</li>
<li><strong>内存管理</strong>：完成内存的 <strong>分配/回收</strong> 等功能</li>
</ul>
</li>
</ul>
<p>拓展：感兴趣的同学可以搜索“Linux 系统调用”，了解 Linux 操作系统提供了哪些系统调用</p>
<hr>
<ul>
<li><strong><u>系统调用的过程</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-36-59.png" alt=""></p>
<p>传递系统调用参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 执行陷入指令（<strong>用户态</strong>，陷入指令是非特权指令） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>  执行相应的内请求核程序处理系统调用（<strong>核心态</strong>） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 返回 应用程序<br>
注意：<br>
1.陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态<br>
2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</p>
<p>注意别名： 陷入指令 = trap 指令 = 访管指令</p>
<hr>
<h2 id="1-4-1-操作系统的体系结构（上）">1.4.1 操作系统的体系结构（上）</h2>
<ul>
<li><strong><u>操作系统的内核</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-43-27.png" alt="">·</p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分。<br>
实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-45-33.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-46-56.png" alt=""></p>
<p>注意：<br>
操作系统<strong>内核</strong>需要运行在<strong>内核态</strong><br>
操作系统的<strong>非内核</strong>功能运行在<strong>用户态</strong></p>
<p>一个故事：现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-58-30.png" alt=""></p>
<p>注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能<br>
【注意：“变态”在这里是口头表述，考试应该正规表述，例如“状态改变”】</p>
<hr>
<ul>
<li><strong><u>操作系统的体系结构</u></strong>
<ul>
<li>大内核
<ul>
<li>将操作系统的主要功能模块作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核
<ul>
<li>只把最基本功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>典型的大内核/宏内核/单内核 操作系统： Linux、UNIX<br>
典型的 微内核 操作系统： Windows NT</p>
<p>类比：<br>
操作系统的体系结构问题与企业的管理问题很相似。<br>
<strong>内核</strong>就是企业的<strong>管理层</strong>，负责一些重要的工作。只有管理层才能执行<strong>特权指令</strong>，普通员工只能执行<strong>非特权指令</strong>。<strong>用户态</strong>、<strong>核心态</strong>之间的切换相当于普通员工和管理层之间的工作交接<br>
<strong>大内核</strong>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。<br>
<strong>微内核</strong>：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p>
<hr>
<h2 id="1-4-2-操作系统的体系结构（下）">1.4.2 操作系统的体系结构（下）</h2>
<blockquote>
<ul>
<li>大内核（又名：宏内核/单内核）</li>
<li>微内核</li>
<li>分层结构（新增）</li>
<li>模块化（新增）</li>
<li>外核（新增）</li>
</ul>
<p>Tips: 一定是<strong>考简单的选择题</strong>，了解各种体系结构的<strong>特性</strong>，了解各自的<strong>优缺点</strong></p>
</blockquote>
<ul>
<li><strong><u>操作系统结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_15-55-43.png" alt=""></p>
<p>【注：加星号是作者认为更容易考的，红色星号是全新的内容，黄色星号的是老内容（大内核、微内核）】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——分层结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-00-31.png" alt=""></p>
<p>最底层是硬件，最高层是用户接口<br>
每层可调用更低一层【不能跨层调用】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——模块化</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-04-57.png" alt=""></p>
<p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，上图所示为由模块、子模块等组成的模块化操作系统结构。</p>
<hr>
<ul>
<li><strong><u>操作系统结构——外核（exokernel）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-11-27.png" alt=""></p>
<hr>
<h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2>
<blockquote>
<p>操作系统引导(boot)–开机的时候怎么让操作系统运行起来?</p>
</blockquote>
<ul>
<li><strong><u>一个刚买来的磁盘（硬盘）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-25-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>安装操作系统后，操作系统引导（开机过程）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-33-54.png" alt=""></p>
<p>【注释】<br>
根目录：顾名思义，双击C盘看到的那些东西<br>
分区表：实际上是一个数据结构，记录每个盘每个分区多大、地址范围这些信息<br>
BIOS：Basic Input/Output System<br>
ROM引导程序：ROM boot 程序</p>
<p><strong>操作系统引导</strong>:<br>
① CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序 (先进行硬件自检，再开机)<br>
② 将磁盘的第一块–主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>
③ 从活动分区 (又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序<br>
④ 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作</p>
<hr>
<ul>
<li><strong><u>例: windows 操作系统的初始化程序</u></strong></li>
</ul>
<p>注：完整的操作系统初始化程序 (即 启动管理器) 可在根目录下找到<br>
Eg：windows操作系统完整的开机初始化程序在“根目录/Windows/Boot”下</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-38-37.png" alt=""></p>
<hr>
<h2 id="1-6-虚拟机">1.6 虚拟机</h2>
<ul>
<li><strong><u>传统计算机</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-42-34.png" alt=""></p>
<hr>
<ul>
<li><strong><u>虚拟机</u></strong></li>
</ul>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统</p>
<p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-53-47.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_17-02-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>两类虚拟机管理程序（VMM）的对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对物理资源的控制权</td>
<td>直接运行在硬件上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖Host OS为其分配物理资源</td>
</tr>
<tr>
<td style="text-align:left">资源分配方式</td>
<td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td>
<td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td>性能更好</td>
<td>性能更差，需要Host OS作为“中介”</td>
</tr>
<tr>
<td style="text-align:left">可支持虚拟机的数量</td>
<td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，Host OS本身也需要使用物力资源，Host OS上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td style="text-align:left">虚拟机的可迁移性</td>
<td>更差</td>
<td>更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛</td>
</tr>
<tr>
<td style="text-align:left">运行模式</td>
<td>第一类VMM运行在最高权限级（Ring 0），可以执行最高权限指令</td>
<td>第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用</td>
</tr>
</tbody>
</table>
<hr>
<h1>第二章 进程与线程</h1>
<h2 id="2-1-1-进程的概念、组成、特征">2.1.1 进程的概念、组成、特征</h2>
<ul>
<li><strong><u>进程的概念</u></strong></li>
</ul>
<p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的 可执行文件，就是一系列的指令集合。<br>
进程（Process）：是<strong>动态的</strong>，是程序的一 次执行过程 同一个程序多 次执行会对应 多个进程</p>
<hr>
<ul>
<li><strong><u>进程的组成——PCB</u></strong></li>
</ul>
<p>思考：操作系统是这些进程的管理者，它要怎么区分各个进程？<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <strong>PID</strong>（Process ID，进程ID）</p>
<ol>
<li>操作系统要记录PID、进程所属用户ID（UID）<br>
【基本的进程描述信息，可以让操作系统区分各个进程】</li>
<li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<br>
【可用于实现操作系统对资源的管理】</li>
<li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）<br>
【可用于实现操作系统对进程的控制、调度】</li>
<li>这些信息都被保存在一个数据结构<strong>PCB</strong> （Process Control Block）中，即<strong>进程控制块</strong><br>
操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong></li>
</ol>
<p>【总结】：</p>
<ul>
<li><strong>进程控制块（PCB）</strong> ：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
<ul>
<li><strong>进程描述信息</strong>
<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><strong>进程控制和管理信息</strong>
<ul>
<li>CPU、磁盘、网络流量使用情况统计…</li>
<li>进程当前状态：就绪态 / 阻塞态 / 运行态…</li>
</ul>
</li>
<li><strong>资源分配清单</strong>
<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I/O设备</li>
</ul>
</li>
<li><strong>处理机相关信息</strong>
<ul>
<li>如PSW，PC等等各种寄存器的值（用于实现进程切换）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统对进程进行管理工作所需的信息都存在PCB中</p>
<hr>
<ul>
<li><u><strong>进程的组成——程序段、数据段</strong></u>
<ul>
<li><strong>PCB</strong>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PCB</strong> 是<strong>给操作系统用的</strong>。<br>
<strong>程序段、数据段</strong>是<strong>给进程自己用的</strong>。</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>一条高级语言的代码翻译过来可能会对应多条机器指令<br>
程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-07-33.png" alt=""></p>
<p>一个<strong>进程实体（进程映像）</strong> 由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。 <strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong> 是<strong>静态</strong>的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）</p>
<hr>
<ul>
<li><u><strong>进程的组成</strong></u>【更确切的说，应该 是“进程实体(进程 映像)的组成”】
<ul>
<li><strong>PCB</strong>【PCB 是给操作系统用的】
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【程序段、数据段是给进程自己用的， 与进程自身的运行逻辑有关】<br>
【同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）】</p>
<p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong> 引入进程实体的概念后，<br>
可把<strong>进程定义为</strong>： 进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。<br>
【一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行】</p>
<p>注意：PCB是进程存在的唯一标志！</p>
<hr>
<ul>
<li><strong><u>进程的特征</u></strong></li>
</ul>
<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<ol>
<li><strong>动态性</strong>【动态性是进程最基本的特征】<br>
进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性</strong><br>
内存中有多个实体进程，各进程可并发执行</li>
<li><strong>独立性</strong><br>
进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li><strong>异步性</strong><br>
各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li><strong>结构性</strong><br>
每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<hr>
<h2 id="2-1-2-进程的状态与转换、进程的组织">2.1.2 进程的状态与转换、进程的组织</h2>
<ul>
<li><u><strong>进程的状态——创建态、就绪态</strong></u></li>
</ul>
<p>进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<p>当进程创建完成后，便进入“<strong>就绪态</strong>”， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行</p>
<hr>
<ul>
<li><strong><u>进程的状态——运行态</u></strong></li>
</ul>
<p>系统中可能会有很多个进程都处于就绪态；</p>
<p>当CPU空闲时，操作系统就会选择一个就绪进程， 让它上处理机运行；</p>
<p>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。 CPU会执行该进程对应的程序（执行指令序列）</p>
<hr>
<ul>
<li><strong><u>进程的状态——阻塞态</u></strong></li>
</ul>
<p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p>
<p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</p>
<p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p>
<hr>
<ul>
<li><u><strong>进程的状态——终止态</strong></u></li>
</ul>
<p>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。</p>
<p>此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。</p>
<p>当终止进程的工作完成之后，这个进程就彻底消失了。</p>
<hr>
<ul>
<li><strong><u>进程状态的转换</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-37-42.png" alt=""></p>
<p><strong>注意：不能由阻塞态直接转换为运行态， 也不能由就绪态直接转换为阻塞态</strong>（因为 进入阻塞态是进程主动请求的，必然需要 进程在运行时才能发出这种请求）</p>
<hr>
<ul>
<li><strong><u>进程的状态</u></strong>
<ul>
<li><strong>三种基本状态</strong>【进程的整个生命周期 中，大部分时间都处 于三种基本状态】
<ul>
<li>运行态（Running）【单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态】<br>
占有CPU，并在CPU上运行</li>
<li>就绪态（Ready）<br>
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>
<li>阻塞态（Waiting / Blocked，又称：等待态）<br>
因等待某一事件而暂时不能运行</li>
</ul>
</li>
<li>另外两种状态
<ul>
<li>创建态（New，又称：新建态）<br>
进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（Terminated，又称：结束态）<br>
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程PCB中，会有一个变量 state 来表示进程的当前状态</strong>。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<hr>
<ul>
<li><strong><u>进程的组织——链接方式</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-03-39.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-04-35.png" alt=""></p>
<hr>
<ul>
<li><u><strong>进程的组织——索引方式</strong></u></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-05-33.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程的组织</u></strong>
<ul>
<li><strong>链接方式</strong>
<ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><strong>索引方式</strong>
<ul>
<li>根据进程状态不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数操作系统使用链接方式【</p>
<hr>
<h2 id="2-1-3-进程控制">2.1.3 进程控制</h2>
<ul>
<li><strong><u>什么是进程控制？</u></strong></li>
</ul>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<p>简化理解：反正进程控制就是要实现进程状态转换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-15-07.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现进程控制？</u></strong></li>
</ul>
<p>用“原语”实现【第一章提到了】</p>
<p>原语的执行具有“原子性”，一气呵成</p>
<p>思考：为何进程控制（状态转 换）的过程要“一气呵成”？<br>
如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</p>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…<br>
假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>
①将PCB2的 state 设为 1<br>
②将PCB2从阻塞队列放到就绪队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-22-47.png" alt=""></p>
<p>但是完成了第一步后收到中断信号，CPU处理中断去了，那么这个时候PCB2 的state=1，但是它却还在阻塞队列里。</p>
<hr>
<ul>
<li><strong><u>如何实现原语的“原子性”？</u></strong></li>
</ul>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。<br>
可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现<strong>原子性</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-28-05.png" alt=""></p>
<p>如上图：<br>
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</p>
<p>这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子 性”</p>
<p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？<br>
假设用户直接在程序开头设置关中断，在程序尾设置开中断，那么这个程序执行时将不能被打断，一直霸占资源，这是不合理的。</p>
<hr>
<ul>
<li><strong><u>进程控制相关的原语</u></strong></li>
</ul>
<ol>
<li><strong>进程的创建</strong>
<ul>
<li><strong>创建原语</strong>【操作系统创建一个进程时使用的原语】
<ul>
<li>申请空白PCB</li>
<li>为新的进程分配资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列【创建态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录<br>
分时系统中，用户登录成功，系统会为其创建一个新的进程</li>
<li>作业调度<br>
多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务<br>
用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求<br>
由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的终止</strong>
<ul>
<li><strong>撤销原语</strong>【就绪态/阻塞态/运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 终止态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 无】
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程【进程间的关系是树形结构】</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束【进程自己请求终止（exit系统调用）】</li>
<li>异常结束【整数除以0、非法使用特权指令， 然后被操作系统强行杀掉】</li>
<li>外界干预【Ctrl+Alt+delete，用户选择杀掉进程】</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>3.阻塞原语、4.唤醒原语必须成对使用</p>
<ol start="3">
<li><strong>进程的阻塞</strong>
<ul>
<li><strong>阻塞原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 阻塞态】
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li><strong>保护进程运行现场</strong>，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的唤醒</strong>
<ul>
<li><strong>唤醒原语</strong>【阻塞态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】
<ul>
<li>在事件等待队列找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生【因何事阻塞，就应由何事唤醒】</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的切换</strong>
<ul>
<li><strong>切换原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态、就绪态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 运行态】
<ul>
<li>将<strong>运行环境信息</strong>【进程上下文（Context ）】存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>新进程所需的运行环境</strong></li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>【上接：2.1.1 进程的概念、组成、特征 中的知识滚雪球】</p>
<p>CPU中会设置很多 “寄存器”，用来存放程序运行过程中所需的某些数据。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSW</td>
<td>程序状态字寄存器</td>
</tr>
<tr>
<td>PC</td>
<td>程序计数器，存放下一条指令的地址</td>
</tr>
<tr>
<td>IR</td>
<td>指令寄存器，存放当前正在执行的指令</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>其他一些必 要信息</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<table>
 <tr>
     <td>
         int x = 1;</br>
x++;</br>
…… </br></br>
         指令1: 往内存中某个地方写入变量x的值</br>
指令2: 把变量x的值放到某个寄存器中</br>
指令3: 寄存器中的数值+1</br>
指令4: 把寄存器的值写回变量x的存放位置</br>
……</br>
     </td>
    </tr>  
</table>
<p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p>
<p>思考：执行完指令3后， 另一个进程开始上CPU运行。<br>
注意：另一个进程在运行过程中也会使用各个寄存器<br>
灵魂拷问：之后还怎么切换回之前的进程？？？？</p>
<p>解决办法：在进程切换时<strong>先在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<br>
当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong></p>
<hr>
<ul>
<li><strong><u>学习技巧</u></strong></li>
</ul>
<p>进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息
<ul>
<li>a. 所有的进程控制原语一定都会修改进程状态标志</li>
<li>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>c. 某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<hr>
<h2 id="2-1-4-进程通信">2.1.4 进程通信</h2>
<ul>
<li><strong><u>什么是进程通信？</u></strong><br>
进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-27-27.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong><u>为什么进程通信需要操作系统支持？</u></strong></li>
</ul>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-30-11.png" alt=""></p>
<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<p>下面将介绍三种进程通信方式：<strong>1. 共享存储、2. 消息传递、3. 管道通信</strong></p>
<hr>
<ul>
<li><strong><u>进程通信——共享存储</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-36-25.png" alt=""></p>
<p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。<br>
各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作【后面介绍】)</p>
<p>linux中，如何实现共享内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(...)</span>	<span class="comment">// 通过 shm_open 系统调用，申请一片共享内存区</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(...)</span>	<span class="comment">// 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中(第三章内容)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>共享存储</strong>：</p>
<ul>
<li><strong>基于数据结构</strong>的共享：<br>
比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种<strong>低级通信</strong>方式</li>
<li><strong>基于存储区</strong>的共享：<br>
在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递</u></strong></li>
</ul>
<p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-44-02.png" alt=""></p>
<p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<p><strong>消息传递</strong>：</p>
<ul>
<li><strong>直接通信方式</strong><br>
消息直接挂到接收进程的消息缓冲队列上</li>
<li><strong>间接通信方式</strong><br>
消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（直接通信方式）</u></strong></li>
</ul>
<p>点名道姓的消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-55-43.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（间接通信方式）</u></strong></li>
</ul>
<p>以“信箱”作为中间实体进行消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-01-46.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——管道通信</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-47-19.png" alt=""></p>
<p>那么管道通信和进程通信又有什么区别呢？<br>
管道通信读写要求先进先出（循环队列）；而共享存储存取没有要求，都行</p>
<ol>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。 （由操作系统实现）</li>
<li>当<strong>管道写满</strong>时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当<strong>管道读空</strong>时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：1、<strong>一个管道允许多个写进程，一个读进程</strong> (2014年408真题高教社官方答案)；2、允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)。</li>
</ol>
<hr>
<ul>
<li><strong><u>王道书修正</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-58-27.png" alt=""></p>
<hr>
<h2 id="2-1-5-线程概念-多线程模型">2.1.5 线程概念 多线程模型</h2>
<ul>
<li><strong><u>什么是线程，为什么要引入线程？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_14-48-55.png" alt=""></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p>传统的进程是程序执行流的最小单位。<br>
引入线程后，线程成为了程序执行流的最小单位</p>
<p>可以把线程理解为“轻量级进程”。</p>
<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>， 也是<strong>程序执行流的最小单位</strong>。<br>
引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内 也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）</p>
<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br>
<strong>线程</strong>则作为<strong>处理机的分配单元</strong>。</p>
<hr>
<ul>
<li><strong><u>引入线程机制后，有什么变化？</u></strong></li>
</ul>
<ol>
<li><strong>资源分配、调度</strong>
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>
</ul>
</li>
<li><strong>并发性</strong>
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
</li>
<li><strong>系统开销</strong>
<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>引入线程后，并发所带来的系统开销减小</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的属性</u></strong></li>
</ul>
<ol>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块 (TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ol>
<hr>
<h2 id="2-1-6-线程的实现方式-多线程模型">2.1.6 线程的实现方式 多线程模型</h2>
<ul>
<li><strong><u>线程的实现方式——用户级线程（User-Level Thread, ULT）</u></strong></li>
</ul>
<p>历史背景：早期的操作系统（如：早期Unix）只支持进程， 不支持线程。当时的“线程”是由线程库实现的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-01-10.png" alt=""></p>
<p>eg：将下面进程描述成如下代码</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-02-37.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;	</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>	<span class="comment">// i = 0, 1, 2, 0, 1, 2...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码的角度看，线程其实就是一段代码逻辑。 上述三段代码逻辑上可以看作三个“线程”。 while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。</p>
<p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“<strong>用户级线程</strong>”就是“<strong>从用户视角看能看到的线程</strong>”</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的实现方式——内核级线程（Kernel-Level Thread, KLT”）</u></strong><br>
又称“<strong>内核支持的线程</strong>“</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p>由操作系统支持的线程，<strong>内核级线程才是处理机分配的单位</strong></p>
<p>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块）， 通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看能看到的线程</strong>”</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>
缺点：一个用户进程会占用多个内核级线程，内核级线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ol>
<hr>
<ul>
<li><strong><u>多线程模型</u></strong><br>
在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关 系，可以划分为几种多线程模型</li>
</ul>
<p><strong>重点重点重点</strong>： 操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</p>
<p><strong>一对一</strong>模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p><strong>多对一</strong>模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-06.png" alt=""></p>
<p>多对多模型：n 用户及线程映射到 m 个内核级 线程（n &gt;= m）。每个用户进程对应 m 个内核 级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-11.png" alt=""></p>
<p>可以这么理解：<br>
用户级线程是“代码逻辑”的载体<br>
内核级线程是“运行机会”的载体<br>
【<strong>内核级线程才是处理机分配的单位</strong>。例如：多核 CPU环境下，上图这个进程最多能被分配两个核。】</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU执行<br>
【内核级线程中可以运行任意一个有映射关系的用户级线程代码，如上图，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞】</p>
<hr>
<h2 id="2-1-7-线程的状态与转换">2.1.7 线程的状态与转换</h2>
<ul>
<li><strong><u>线程的状态与转换</u></strong></li>
</ul>
<p>下面与进程完全一致</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<hr>
<ul>
<li><strong><u>线程的组织与控制</u></strong></li>
</ul>
<p>类似于进程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-40-03.png" alt=""></p>
<p>组织：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-41-19.png" alt=""></p>
<hr>
<h2 id="2-2-1-调度的概念、层次">2.2.1 调度的概念、层次</h2>
<ul>
<li><strong><u>调度的概念</u></strong></li>
</ul>
<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——高级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-49-48.png" alt=""></p>
<p>作业：一个具体的任务<br>
用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>内存空间有限，有时无法将用户提交的作业全部放入内存</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。<br>
【简化理解：好几个程序需要启动，到底先启动哪个】</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——低级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-50-23.png" alt=""></p>
<p><strong>低级调度（进程调度/处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——中级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-53-15.png" alt=""></p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p>
<p><strong>中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。<br>
一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p>
<hr>
<ul>
<li><strong><u>补充知识：进程的挂起态与七状态模型</u></strong></li>
</ul>
<p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p>
<p>五状态模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>七状态模型：【看学校怎么考】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<p>注意“挂起”和“阻塞”的区别，两种 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。<br>
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<hr>
<ul>
<li><strong><u>三层调度的联系、对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>要做什么</th>
<th style="text-align:center">调度发生在…</th>
<th style="text-align:center">发生频率</th>
<th style="text-align:center">对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高级调度<br />（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向作业）</td>
<td style="text-align:center">最低</td>
<td style="text-align:center">无<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>创建态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态</td>
</tr>
<tr>
<td style="text-align:center">中级调度<br />（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向进程）</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">挂起态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态 <br />（阻塞挂起<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态）</td>
</tr>
<tr>
<td style="text-align:center">低级调度<br />（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td style="text-align:center">内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">就绪态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>运行态</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-2-2-进程调度的时机、切换与过程调度方式">2.2.2 进程调度的时机、切换与过程调度方式</h2>
<ul>
<li><strong><u>进程调度的时机</u></strong></li>
</ul>
<p><strong>进程调度</strong>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p><strong>需要进行</strong>进程调度与切换的情况：</p>
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如 等待I/O）</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p><strong>不能进行</strong>进程调度与切 换的情况：</p>
<ol>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中。<br>
【但是进程在普通临界区中是可以进行调度和切换的】</li>
<li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<p>【考题：】<br>
【对】进程在操作系统内核程序临界区中不能进行调度与切换<br>
【错】（2012年联考真题）进程处于临界区时不能进行处理机调度<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
首先要知道：<br>
临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>
临界区：访问临界资源的那段代码。<br>
<strong>内核程序临界区</strong>一般是用来<strong>访问某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成)</p>
<p>【eg:】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-24-53.png" alt=""></p>
<p>如果还没退出临界区 (还没解锁 )就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-25-07.png" alt=""></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<hr>
<ul>
<li><strong><u>进程调度的方式</u></strong></li>
</ul>
<p>有的系统中，只允许进程主动放弃处理机<br>
有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br>
【实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统】</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>
【可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统】</li>
</ul>
<hr>
<ul>
<li><strong><u>进程的切换与过程</u></strong></li>
</ul>
<p>“狭义的进程调度”与“进程切换”的区别：<br>
<strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程， 也可能是另一个进程，后一种情况就需要进程切换）<br>
<strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<hr>
<h2 id="2-2-3-调度器和闲逛程序">2.2.3 调度器和闲逛程序</h2>
<ul>
<li><strong><u>调度器/调度程序（scheduler）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<p>上图中，2和3由调度程序引起，调度程序决定:</p>
<p>让谁运行?——调度算法<br>
运行多长时间?——时间片大小</p>
<p>调度时机——什么事件会触发“调度程序” ?</p>
<ul>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li>运行<strong>进程阻塞</strong></li>
<li><strong>l/O中断</strong>发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个<strong>时钟中断</strong>或k个时钟中断会触发调度程序工作</li>
</ul>
<p>不支持内核级线程的操作系统，调度程序的处理对象是进程<br>
支持内核级线程的操作系统，调度程序的处理对象是内核线程</p>
<hr>
<ul>
<li><strong><u>闲逛进程</u></strong></li>
</ul>
<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程(idle)</p>
<p>闲逛进程的<strong>特性</strong>:</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<hr>
<h2 id="2-2-4-调度算法的评价指标">2.2.4 调度算法的评价指标</h2>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>等待时间</mtext><mo>=</mo><mtext>周转时间</mtext><mo>−</mo><mtext>运行时间</mtext></mrow><annotation encoding="application/x-tex">等待时间=周转时间-运行时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">周转时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">运行时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均等待时间</mtext><mo>=</mo><mfrac><mtext>各作业等待时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均等待时间=\frac{各作业等待时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业等待时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</blockquote>
<ul>
<li><strong><u>CPU利用率</u></strong></li>
</ul>
<p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong></p>
<p><strong>CPU利用率</strong>：指CPU “忙碌”的时间占总时间的比例。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【有的题目还会要求计 算某种设备的利用率】</p>
<p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒， 再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中， CPU利用率、打印机利用率分别是多少？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>打印机利用率</mtext><mo>=</mo><mfrac><mn>5</mn><mn>15</mn></mfrac><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">打印机利用率=\frac{5}{15}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">打印机利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span><br>
【通常会考察多道程序并发 执行的情况，可以用“甘 特图”来辅助计算】</p>
<hr>
<ul>
<li><u><strong>系统吞吐量</strong></u></li>
</ul>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<br>
<strong>系统吞吐量</strong>：单位时间内完成作业的数量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<br>
10/100 = 0.1 道/秒</p>
<hr>
<ul>
<li><strong><u>周转时间</u></strong></li>
</ul>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br>
<strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。<br>
它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>
【对于用户来说，更关心自 己的单个作业的周转时间】</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值】</p>
<p>【思考】有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<br>
eg：等待1分钟，执行10分钟；等待10分钟，运行1分钟。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<hr>
<ul>
<li><strong><u>等待时间</u></strong></li>
</ul>
<p>计算机的用户希望自己的作业尽可能少的等待处理机<br>
<strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业在后备队列等待被服务（调度）<br>
作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候</p>
<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>
对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p>
<hr>
<ul>
<li><strong><u>响应时间</u></strong></li>
</ul>
<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>
<hr>
<h2 id="2-2-5-调度算法1：先来先服务-最短作业优先-最高响应比优先">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</h2>
<blockquote>
<p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于 作业调度 还是 进程调度？</li>
<li>抢占式？非抢占式？</li>
<li>优点和缺点</li>
<li>是否会导致<strong>饥饿</strong>【某进程/作业长期得不到服务】</li>
</ol>
</blockquote>
<ul>
<li><strong><u>先来先服务（FCFS, First Come First Serve）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li>
<li><strong>算法规则</strong><br>
按照作业/进程到达的先后顺序进行服务</li>
<li><strong>用于作业/进程调度</strong><br>
用于作业调度时，考虑的是哪个作业先到达后备队列；<br>
用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
<li><strong>是否可抢占？</strong><br>
非抢占式的算法</li>
<li><strong>优缺点</strong><br>
优点：公平、算法实现简单<br>
缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶，前面某个人要买100杯…）</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>先来先服务调度算法：按照到达的先后顺序调度，事实上就 是等待时间越久的越优先得到服务。 因此，调度顺序为：P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-52-11.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间     P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7</p>
<p>平均周转时间 = (7+9+8+11)/4 = 8.75</p>
<p>平均带权周转时间 = (1+2.25+8+2.75)/4 = 3.5</p>
<p>平均等待时间 = (0+5+7+7)/4 = 4.75</p>
<hr>
<ul>
<li><strong><u>短作业优先（SJF, Shortest Job First）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li><strong>算法规则</strong><br>
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li>
<li><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</li>
<li><strong>是否可抢占？</strong><br>
SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本</strong>——<strong>最短剩余时间优先算法</strong>（<strong>SRTN</strong>, Shortest Remaining Time Next）</li>
<li><strong>优缺点</strong><br>
优点：“最短的”平均等待时间、平均周转时间<br>
缺点：不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的， 并不一定真实，不一定能做到真正的短作业优先</li>
<li>是否会导致<strong>饥饿</strong><br>
会。如果源源不断地有短作业/进程到来，可能使长作业/进 程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不 到服务，则称为“<strong>饿死</strong>”</li>
</ol>
<p>【<strong>例题1</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>非抢占式</strong>的<strong>短作业优先</strong>调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周 转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业/进程。 因此，<strong>调度顺序</strong>为：P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<p>【对比FCFS算法的结果的平均周转时间8.75、平均带权周转时间3.5、平均等待时间4.75，显然SPF算法的 平均等待/周转/带权周转时间都要更低】</p>
<p>【<strong>例题2</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>抢占式</strong>的<strong>短作业优先</strong>调度算法， 计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时 间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>最短剩余时间优先</strong>算法：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个<strong>进程完成时也需要调度</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-10-34.png" alt=""></p>
<p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_n(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表 示当前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进程剩余时间为 m。各个时刻的情况如下：<br>
0时刻（P1到达） ： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(7)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">7</span><span class="mclose">)</span></span></span></span></span><br>
2时刻（P2到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
4时刻（P3到达）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">3</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、P_2(2)、\mathbf{P_3(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span></span></span></span></span><br>
5时刻（P3完成且P4刚好到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">2</mn><mo stretchy="false">)</mo></mrow><mtext>、</mtext><msub><mi>P</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(2)}、P_4(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">2</span><span class="mclose">)</span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span><br>
7时刻（P2完成）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">4</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_4(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
11时刻（P4完成） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(5)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">5</span><span class="mclose">)</span></span></span></span></span></p>
<p>周转时间 = 完成时间 - 到达时间    P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6</p>
<p>带权周转时间 = 周转时间/运行时间    P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5</p>
<p>等待时间 = 周转时间 – 运行时间    P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2</p>
<p>平均周转时间 = (16+5+1+6)/4 = 7</p>
<p>平均带权周转时间 = (2.28+1.25+1+1.5)/4 = 1.50</p>
<p>平均等待时间 = (9+1+0+2)/4 = 3</p>
<p>【对比非抢占式的短作业优先算法的平均周转时间8、平均带权周转时间2.56、平均等待时间4，显 然抢占式的这几个指标又要更低】</p>
<ul>
<li><strong>注意</strong>几个小细节：</li>
</ul>
<ol>
<li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</li>
<li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”
<ul>
<li>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待 时间、平均周转时间还要更少</li>
<li>应该加上一个条件“在<strong>所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最 少”；</li>
<li>或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</li>
<li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算 法）的平均等待时间、平均周转时间最少”</li>
</ul>
</li>
<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS）， SJF依然可以获得较少的平均等待时间、平均周转时间</li>
<li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li>
</ol>
<hr>
<ul>
<li><strong><u>对FCFS和SJF两种算法的思考…</u></strong></li>
</ul>
<p>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>
<p>SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p>
<p>能不能设计一个算法，即考虑到各个作业 的等待时间，也能兼顾运行时间呢？<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高响应比优先算法</strong></p>
<hr>
<ul>
<li><strong><u>高响应比优先（HRRN, Highest Response Ratio Next）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
要综合考虑作业/进程的等待时间和要求服务的时间</li>
<li><strong>算法规则</strong><br>
在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间 + 要求服务时间}{要求服务时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">等待时间</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度</li>
<li><strong>是否可抢占？</strong><br>
<strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
<li><strong>优缺点</strong><br>
综合考虑了等待时间和运行时间（要求服务时间）<br>
等待时间相同时，要求服务时间短的优先（SJF 的优点）<br>
要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br>
对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算 各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>高响应比优先</strong>算法：<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进 行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的</strong>进程上处理机。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>0时刻：只有 P1到达就绪队列，<strong>P1</strong>上处理机<br>
7时刻（P1主动放弃CPU）： 就绪队列中有 P2 (响应比=(5+4)/4=2.25)、 <strong>P3</strong>((3+1)/1=4)、 P4((2+4)/4=1.5)，<br>
8时刻（P3完成）： <strong>P2</strong>(2.5)、 P4(1.75)<br>
12时刻（P2完成）：就绪队列中只剩下 <strong>P4</strong></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">考虑到等待时间&amp;运行时间？</th>
<th style="text-align:center">导致饥饿？</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FCFS</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">公平；实现简单</td>
<td style="text-align:center">对短作业不利</td>
<td style="text-align:center">等待时间√ <br />运行时间×</td>
<td style="text-align:center">不会</td>
</tr>
<tr>
<td style="text-align:center">SJF/SPF</td>
<td style="text-align:center">默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN）</td>
<td style="text-align:center">“最短的”平均等待/周转时间；</td>
<td style="text-align:center">对长作业不利，可能导致饥饿；难以做到真正的短作业优先</td>
<td style="text-align:center">等待时间× <br />运行时间√</td>
<td style="text-align:center">会</td>
</tr>
<tr>
<td style="text-align:center">HRRN</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">上述两种算法的权衡 折中，综合考虑的等 待时间和运行时间</td>
<td style="text-align:center"></td>
<td style="text-align:center">等待时间√ <br />运行时间√</td>
<td style="text-align:center">不会</td>
</tr>
</tbody>
</table>
<p>注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但 是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算 法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的 角色。而适合用于<strong>交互式系统</strong>的调度算法将在下个小节介绍…</p>
<p><strong>提示：一定要动手做课后习题</strong>！这些算法特性容易考小题，算法的使用常结合调度算法的评价指标在大题 中考察。</p>
<hr>
<h2 id="2-2-6-调度算法2：时间片轮转-优先级调度-多级反馈队列">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</h2>
<ul>
<li><strong><u>时间片轮转（RR, Round-Robin）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li><strong>算法规则</strong><br>
按照各进程到达<strong>就绪队列</strong>的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度（只有作业放入内存建立了相应的进程后， 才能被分配处理机时间片）</li>
<li><strong>是否可抢占？</strong><br>
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</li>
<li><strong>优缺点</strong><br>
优点：公平；响应快，适用于<strong>分时操作系统</strong>；<br>
缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
<li>补充<br>
时间片太大或太小分别有什么影响？【下面例题中介绍】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>时间片轮转</strong>调度算法，分析时间片大小分别是2、5时的进程运行情况。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-02-10.png" alt=""></p>
<p>时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>
<p>时间片大小为 2 （注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p>
<p>0时刻（<strong>P1(5)</strong> ）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片<br>
2时刻（<strong>P2(4)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(3)）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。 此时P2排在队头，因此让P2上处理机。（<strong>注意</strong>： 2时刻，P1<strong>下处理机</strong>，同一时刻新进程P2到达，如果在 题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>）<br>
4时刻（<strong>P1(3)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾<br>
5时刻（<strong>P3(1)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此 暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）<br>
6时刻（<strong>P3(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发 生调度<br>
7时刻（<strong>P2(2)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行 完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>
9时刻（<strong>P4(6)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机<br>
11时刻（<strong>P1(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机<br>
12时刻（<strong>P4(4)</strong> ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机<br>
14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>
16时刻：所有进程运行结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-10-53.png" alt=""></p>
<p>时间片大小为 5</p>
<p>0时刻（<strong>P1(5)</strong> ）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2(4)</strong> ）：P2到达，但P1时间片尚未结束，因此暂不调度<br>
4时刻（<strong>P2(4)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1)）：P3到达，但P1时间片尚未结束，因此暂不调度<br>
5时刻（<strong>P2(4)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) ）：P4到达，同时，P1运行结束。发生调度，P2上处理机。<br>
9时刻（<strong>P3(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) ）：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
10时刻（<strong>P4(6)</strong> ）：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
15时刻（ ）：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。<br>
16时刻（ ）：P4运行完，主动放弃处理机。所有进程运行完。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>若按照先来先服务调度算法…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且会<strong>增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。<br>
【比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应 可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调 试命令，可能需要等待9秒才能被系统响应】</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理%进程切换，从而导致实际用于进程执行的时间比例减小。可见<strong>时间片也不能太小</strong>。<br>
【一般来说，设计 时间片时要让切换进程的开销占比不超过1%】</p>
<hr>
<ul>
<li><strong><u>优先级调度算法</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
<li><strong>算法规则</strong><br>
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li><strong>用于作业/进程调度</strong><br>
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
<li><strong>是否可抢占？</strong><br>
抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>
<li><strong>优缺点</strong><br>
优点：用优先级区分紧急程度、重要程度，适用于<strong>实时操作系统</strong>。可灵活地调整对各种作业/进程的偏好程度。<br>
缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>是否会导致<strong>饥饿</strong><br>
会</li>
<li>补充：<br>
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置<br>
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。<br>
<strong>静态优先级</strong>：创建进程时确定，之后一直不变。<br>
<strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ol>
<p>【<strong>思考</strong>】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
如何合理地设置各类进程的优先级？<br>
通常：<br>
系统进程优先级 <strong>高于</strong> 用户进程<br>
前台进程优先级 <strong>高于</strong> 后台进程<br>
操作系统更<strong>偏好 I/O型进程（或称 I/O繁忙型进程）</strong><br>
注：与I/O型进程相对的是<strong>计算型进程（或称 CPU繁忙型进程)</strong><br>
【I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话， 则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p>
<p>如果采用的是动态优先级，什么时候应该调整？<br>
可以从追求公平、提升资源利用率等角度考虑<br>
如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级<br>
如果某进程占用处理机运行了很长时间，则可适当降低其优先级<br>
如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p>
<p>【<strong>例题1</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>非抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
7时刻（P2、<strong>P3</strong>、P4）：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。<br>
8时刻（ <strong>P2</strong>、P4 ）：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机<br>
12时刻（ <strong>P4</strong> ）：P2完成，就绪队列只剩P4，P4上处理机。<br>
16时刻（ ）：P4完成，所有进程都结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-23-54.png" alt=""></p>
<p>【<strong>例题2</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机</strong>时发生调度。另 外，当<strong>就绪队列发生改变时</strong>也需要检查是会发生抢占。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2</strong>）：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。<br>
4时刻（P1、<strong>P3</strong>）：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。<br>
5时刻（P1、<strong>P2</strong>、P4）：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列， 因此选择P2上处理机<br>
7时刻（P1、<strong>P4</strong>）：P2完成，就绪队列只剩P1、P4，P4上处理机。<br>
11时刻（<strong>P1</strong> ）：P4完成，P1上处理机<br>
16时刻（）：P1完成，所有进程均完成</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-26-59.png" alt=""></p>
<hr>
<ul>
<li><strong><u>思考</u></strong></li>
</ul>
<p>FCFS算法的优点是公平</p>
<p>SJF 算法的优点是能尽快处理完短作业， 平均等待/周转时间等参数很优秀</p>
<p>时间片轮转调度算法可以让各个进程得 到及时的响应</p>
<p>优先级调度算法可以灵活地调整各种进 程被服务的机会</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？</p>
<p><strong>多级反馈队列调度算法</strong></p>
<hr>
<ul>
<li><u><strong>多级反馈队列调度算法</strong></u></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
对其他调度算法的折中权衡</li>
<li><strong>算法规则</strong>
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
</ol>
</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度</li>
<li><strong>是否可抢占？</strong><br>
<strong>抢占式</strong>的算法。在 k 级队列的进程运行过程中，若更上级的队列 （1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的 队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列 队尾。</li>
<li><strong>优缺点</strong><br>
对各类型进程相对公平（FCFS的优点）；<br>
每个新到达的进程都可以 很快就得到响应（RR的优点）；<br>
短进程只用较少的时间就可完成 （SPF的优点）；<br>
不必实现估计进程的运行时间（避免用户作假）；<br>
可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密 集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级）</li>
<li>是否会导致<strong>饥饿</strong><br>
会【一直来短进程的话，有可能一直在高优先级队列处理，被降级的会饥饿】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>多级反馈队列调度算法</strong>，分析进程运行的过程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-47-19.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-55-40.png" alt=""></p>
<p>P1(1) —&gt; P2(1) —&gt; P1(2) —&gt; P2(1)—&gt; P3(1)—&gt; P2(2) —&gt; P1(4) —&gt; P1(1)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-05_22-22-51.gif" alt=""></p>
<p>设置多级就绪队列，各级队列<strong>优先级</strong>从<strong>高到低</strong>，<strong>时间片</strong>从<strong>小到大新进程</strong>到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程<strong>还未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>已经在最下级</strong>的队列，则<strong>重新放回最下级</strong>队列队尾<br>
只有第 <strong>k 级队列为空</strong>时，才会<strong>为 k+1 级</strong>队头的进程<strong>分配时间片</strong><br>
<strong>被抢占处理机</strong>的进程<strong>重新放回原队列</strong>队尾</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">导致饥饿？</th>
<th style="text-align:center">补充</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">时间片轮转</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">公平，适用于分时系统</td>
<td style="text-align:center">频繁切换有开销，不区分优先级</td>
<td style="text-align:center">不会</td>
<td style="text-align:center">时间片太大或太小有何 影响？</td>
</tr>
<tr>
<td style="text-align:center">优先级调度</td>
<td style="text-align:center">有抢占式的，也有非抢占式的。注意做题时的区</td>
<td style="text-align:center">区分优先级， 适用于实时系统</td>
<td style="text-align:center">可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center">动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？</td>
</tr>
<tr>
<td style="text-align:center">多级反馈队列</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">平衡优秀 666</td>
<td style="text-align:center">一般不说它有缺点，不过可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括 分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也 能较好地满足交互式系统的需求。因此这三种算法适合用于<strong>交互式系统</strong>。（比如UNIX使用的就是多级反馈 队列调度算法）</p>
<p><strong>提示：一定要动手做课后习题</strong></p>
<hr>
<h2 id="2-2-5-调度算法3：多级队列">2.2.5 调度算法3：多级队列</h2>
<ul>
<li><strong><u>多级队列调度算法</u></strong></li>
</ul>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_08-38-34.png" alt=""></p>
<p>队列之间可采取固定优先级，或时间片划分<br>
固定优先级: 高优先级空时低优先级进程才能被调度<br>
时间片划分:如三个队列分配时间50%、40%、10%</p>
<p>各队列可采用不同的调度策略，如：<br>
系统进程队列采用 优先级调度<br>
交互式队列采用 RR<br>
批处理队列采用 FCFS</p>
<hr>
<h2 id="2-3-1-进程同步-进程互斥">2.3.1 进程同步 进程互斥</h2>
<ul>
<li><strong><u>什么是进程同步</u></strong></li>
</ul>
<p>知识点回顾：进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<p>【<strong>例1</strong>】老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p>
<p>但是这个时候：<br>
女一号只想做老渣的初恋<br>
女二号只想交一个有恋爱经验的渣男</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>那么，老渣在并发执行这两个约会进程的时候，<br>
就必须保证“一号的指令2” 一定要在“二号的指令1”之前执行。</p>
<p>操作系统要提供“<strong>进程同步</strong>机制”来实现上述需求。</p>
<p>【<strong>例2</strong>】进程通信——管道通信</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_22-46-57.png" alt=""></p>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读数据</strong>”的顺序来执行的。 如何解决这种异步问题，就是 “<strong>进程同步</strong>”所讨论的内容。</p>
<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<hr>
<ul>
<li><strong><u>什么是进程互斥</u></strong></li>
</ul>
<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
<p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。</p>
<ul>
<li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;		<span class="comment">// 进入区</span></span><br><span class="line">    critical section;	<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;		<span class="comment">// 退出区</span></span><br><span class="line">    remainder section; 	<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">区</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入区</td>
<td>负责检查是否可进入临界区，若可进入，则应<br />设置<strong>正在访问临界资源的标志</strong>（可理解为“上锁”），<br />以阻止其他进程同时进入临界区</td>
</tr>
<tr>
<td style="text-align:center">临界区</td>
<td><strong>访问临界资源</strong>的那段代码</td>
</tr>
<tr>
<td style="text-align:center">退出区</td>
<td>负责解除<strong>正在访问临界资源的标志</strong>（可理解为“解锁”）</td>
</tr>
<tr>
<td style="text-align:center">剩余区</td>
<td>做其他处理</td>
</tr>
</tbody>
</table>
<p>注意：<br>
<strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。<br>
<strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。<br>
临界区也可称为“临界段”。</p>
<ul>
<li>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下<strong>原则</strong>：</li>
</ul>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<hr>
<h2 id="2-3-2-进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2>
<blockquote>
<p>学习提示：</p>
<ol>
<li>理解各个算法的思想、原理</li>
<li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li>
<li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li>
</ol>
</blockquote>
<ul>
<li><strong><u>如果没有注意进程互斥？</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程A、进程B在系统中并发地运行</span></span><br><span class="line">进程A： </span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程B：</span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调度A上处理机运行<br>
当A在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度B让它上处理机运行<br>
进程B也在使用打印机</p>
<p>结局：A、B 的打印内容混在一起了【错误的，不希望看到的】</p>
<p>如何实现进程互斥？</p>
<hr>
<ul>
<li><strong><u>单标志法</u></strong></li>
</ul>
<p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);	<span class="comment">// 1 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">// 3 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 4 剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);	<span class="comment">// 5 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">// 7 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 8 剩余区</span></span><br></pre></td></tr></table></figure>
<p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。<br>
若 P1 先上处理机运行，则会一直卡在5。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。<br>
代码1不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在5。<br>
只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</p>
<p>因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>只能按 P0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。<br>
因此，<strong>单标志法</strong>存在的<strong>主要问题</strong>是：<strong>违背“空闲让进”原则</strong>。</p>
<hr>
<ul>
<li><u><strong>双标志先检查法</strong></u></li>
</ul>
<p>算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如 “flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 1 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 2 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 5 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6 3 7….的顺序执行，P0 和 P1 将会同时访问临界区。 因此，<strong>双标志先检查法</strong>的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。<br>
原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<hr>
<ul>
<li><strong><u>双标志后检查法</u></strong></li>
</ul>
<p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查” 的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 2 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 5 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 6 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6….的顺序执行，P0 和 P1 将都无法进入临界区<br>
因此，双标志后检查法虽然<strong>解决了“忙则等待”的问题</strong>，但是<strong>又违背了“空闲让进”和“有限等待” 原则</strong>，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。<br>
两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<hr>
<ul>
<li><strong><u>Peterson 算法</u></strong></li>
</ul>
<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">// 2 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);	<span class="comment">// 3 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;	<span class="comment">// 4 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 5 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">// 7 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);	<span class="comment">// 8 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;	<span class="comment">// 9 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 10 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>动手推导： 按不同的顺序穿插 执行会发生什么？<br>
1 2 3  6 7 8…    1 6 2 3…   1 3 6 7 8…   1 6 2 7 8…</p>
<p>Peterson 算法用软件方法解决了进 程互斥问题，<strong>遵循了空闲让进、忙 则等待、有限等待 三个原则</strong>，但是 依然<strong>未遵循让权等待</strong>的原则。</p>
<p>Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<hr>
<h2 id="2-3-3-进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2>
<ul>
<li><strong><u>中断屏蔽方法</u></strong></li>
</ul>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为 止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断； <span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断； <span class="comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>优点：简单、高效<br>
缺点：不适用于多处理机【多个处理机同时访问临界区】；<br>
只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令</u></strong></li>
</ul>
<p>简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令<br>
TSL 指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true 表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line">	<span class="type">bool</span> old;		</span><br><span class="line">	old = *lock; 	<span class="comment">// old用来存放Lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; 	<span class="comment">// 无论之前是否已加锁，都将Lock设为true</span></span><br><span class="line">	<span class="keyword">return</span> old;		<span class="comment">// 返回Lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用 TSL 指今实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// &quot;上锁“并检查临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;	<span class="comment">// “解锁”</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。<br>
优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br>
缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>Swap指令</u></strong></li>
</ul>
<p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。<br>
Swap 指令是<strong>用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap 指令的作用是交换两个变量的值</span></span><br><span class="line">Swap (<span class="type">bool</span> *a，<span class="type">bool</span> *b) &#123;</span><br><span class="line">	<span class="type">bool</span> temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// Lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">    Swap (&amp;lock，&amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令和Swap指令的逻辑</u></strong></li>
</ul>
<ol>
<li>old记录是否已被上锁;</li>
<li>再将lock设为 true;</li>
<li>检查临界区是否已被上锁(若已上锁，则循环重复前几步)</li>
</ol>
<p>总之就是为了：<strong>检查并上锁</strong></p>
<hr>
<h2 id="2-3-4-互斥锁">2.3.4 互斥锁</h2>
<ul>
<li><strong><u>进程互斥：锁</u></strong></li>
</ul>
<p>解决临界区最简单的工具就是<strong>互斥锁 (mutex lock)</strong> 。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 <code>acquire()</code> 获得锁，而函数 <code>release()</code> 释放锁。</p>
<p>每个互斥锁有一个布尔变量 <code>available</code>，表示锁是否可用。如果锁是可用的，调用 acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻寒，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);	<span class="comment">// 忙等待</span></span><br><span class="line">	available = <span class="literal">false</span>;	<span class="comment">// 获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">	available = <span class="literal">true</span>;	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire()或release()的执行必须是<strong>原子</strong>操作，因此互斥锁通常<strong>采用硬件</strong>机制来实现。</p>
<p>互斥锁的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必约连续循环调用 acquire()。当多个进程共享同一 CPU 时，就浪费了CPU 周期。因此，互斥锁通用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong> ，如TSL指令、swap指令、单标志法</p>
<p>【<strong>特性</strong>】:</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<hr>
<h2 id="2-3-5-信号量机制">2.3.5 信号量机制</h2>
<ul>
<li><strong><u>复习回顾</u></strong></li>
</ul>
<p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题?</p>
<p>进程互斥的四种软件实现方式 (单标志法、双标志先检查、双标志后检查、Peterson算法)</p>
<p>进程互斥的三种硬件实现方式 (中断屏蔽方法、TS/TSL指令、Swap/XCHG指令)</p>
<ol>
<li>在双标志先检查法中，<strong>进入区的“检查”、“上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题:</li>
<li>所有的解决方案<strong>都无法实现“让权等待“</strong></li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法–<strong>信号量机制</strong></p>
<hr>
<ul>
<li><strong><u>信号量机制</u></strong></li>
</ul>
<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p><strong>信号量</strong>其实就是一个变量 (<strong>可以是一个整数，也可以是更复杂的记录型变量</strong>)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如: 系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p><strong>一对原语</strong>: <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p>
<p>wait、signal 原语常<strong>简称为 P、V操作</strong> (来自荷兰语 proberen 和 verhogen)。因此，做题的时候<strong>常</strong>把wait(S)、signal(S) 两个操作<strong>分别写为 <code>P(S)</code>、<code>V(S)</code></strong></p>
<hr>
<ul>
<li><strong><u>信号量机制——整型信号量</u></strong></li>
</ul>
<p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。<br>
【与普通整数变量的区别： 对信号量的操作只有三种， 即 初始化、P操作、V操作】</p>
<p>Eg ：某计算机系统中有一台打印机…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整型信号量s，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --“检查”和“上锁”一气呵成，避免了并发、异步导致的问题--</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;	<span class="comment">// wait 原语，相当于“进入区”</span></span><br><span class="line">    <span class="comment">// --存在的问题：不满足“让权等待”原则，会发生“忙等”--</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);	<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S=S<span class="number">-1</span>;			<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> s)</span> &#123;	<span class="comment">// signal 原语，相当于“退出区&quot;</span></span><br><span class="line">    S=S+<span class="number">1</span>;				<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">进程P0:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程P1:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程Pn:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>
<p><strong><u>信号量机制——记录型信号量</u></strong></p>
<p><strong>大题、小题超高频出题点</strong></p>
</li>
</ul>
<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表 示的信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;			<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>	<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过 wait 原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【如果剩余资源数不够，使用block原语使进程从</span></span><br><span class="line"><span class="comment">// 运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过 signal 原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【释放资源后，若还有别的进程在等待这种资源，则使用</span></span><br><span class="line"><span class="comment">// wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态】</span></span><br></pre></td></tr></table></figure>
<p>Eg：某计算机系统中有2台打印机…，<br>
则可在初始化信号量 S 时将 S.value 的值设为 2，队列 S.L 设置为空</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_9-44-38.gif" alt=""></p>
<p>在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S)， 这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong> 。</p>
<p><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p>
<p>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>（当前运行的进程从<strong>运行态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待”原则&quot;</strong> ， 不会出现“忙等”现象。</p>
<p>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加1， 若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类 资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态</strong>）。</p>
<p>注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量。</p>
<hr>
<h2 id="2-3-6-用信号量机制实现：进程互斥、同步、前驱关系">2.3.6 用信号量机制实现：进程互斥、同步、前驱关系</h2>
<blockquote>
<p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p>
<p>信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<p>P( S ) —— 申请一个资源S，如果<strong>资源不够就阻塞等待</strong></p>
<p>V( S ) —— 释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong></p>
</blockquote>
<ul>
<li><strong><u>信号量机制实现进程互斥</u></strong></li>
</ul>
<ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>
<li>设置<strong>互斥信号量</strong> mutex，<strong>初值为 1</strong> 【互斥访问临界资源】<br>
【理解：信号量 mutex 表示 “进入临界区的名额”】</li>
<li>在进入区 P(mutex)——<strong>申请资源</strong></li>
<li>在退出区 V(mutex)——<strong>释放资源</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;			<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>	<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">// 这是上一小节信号量的定义，但是如果题目没有特别说明，用下面方式定义即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【要会自己定义记录型信号量，但如果题目中没特别说明，可以把信号量的声明简写成这种形式】</span></span><br><span class="line">semphore muutex = <span class="number">1</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">    . . .</span><br><span class="line">	P(mutex);	<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);	<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">    . . .</span><br><span class="line">	P(mutex);	</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);	</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-07-06.png" alt=""></p>
<p><strong>P、V操作必须成对出现</strong>。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</p>
<hr>
<ul>
<li><strong><u>信号量机制实现进程同步</u></strong></li>
</ul>
<p>进程同步：要让各并发进程按要求有序地推进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">	代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">	代码<span class="number">4</span>;</span><br><span class="line">	代码<span class="number">5</span>;</span><br><span class="line">	代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p>
<p>若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。</p>
<p>用信号量实现进程同步：</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li>
<li>设置<strong>同步信号量</strong> S, <strong>初始为 0</strong></li>
<li><strong>在“前操作”之后执行 V(S)</strong></li>
<li><strong>在“后操作”之前执行 P(S)</strong></li>
</ol>
<p>【<strong>技巧口诀：前V后P</strong>】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 信号量机制实现进程同步 */</span><br><span class="line">semaphore S = 0; // 初始化同步信号量，初值为0</span><br><span class="line">// 【理解：信号量S代表“某种资源”，刚开始是没有这种资源的。</span><br><span class="line">// P2需要使用这种资源，而又只能由P1产生这种资源】</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	代码1;</span><br><span class="line">    代码2;</span><br><span class="line">    V(S);	// 释放资源</span><br><span class="line">    代码3;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">	P(S)	// 保证了 代码4 一定是在 代码2 之后执行</span><br><span class="line">	代码4;</span><br><span class="line">	代码5;</span><br><span class="line">	代码6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作 时，由于 S=1，表示有可用资源，会执行 S–，S 的值变回 0， P2 进程不会执行 block 原语，而是继续往下执行代码4。</p>
<p>若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。 之后当执行完代码2，继而执行 V(S) 操作， S++，使 S 变回 0， 由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续 执行 代码4 了</p>
<hr>
<ul>
<li><strong><u>信号量机制实现前驱关系</u></strong></li>
</ul>
<p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求 按如下前驱图所示的顺序来执行：</p>
<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作） 因此，</p>
<ol>
<li>要<strong>为每一对前驱关系各设置一个同步信号量</strong></li>
<li><strong>在“前操作”之后对相应的同步信号量执行 V 操作</strong></li>
<li><strong>在“后操作”之前对相应的同步信号量执行 P 操作</strong></li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-22-13.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	...</span><br><span class="line">	s1;</span><br><span class="line">	V(a);</span><br><span class="line">	V(b);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	...</span><br><span class="line">    P(a);</span><br><span class="line">	s2;</span><br><span class="line">    V(c);</span><br><span class="line">    V(d);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3() &#123;</span><br><span class="line">	...</span><br><span class="line">    P(b);</span><br><span class="line">	s3;</span><br><span class="line">    V(g);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4() &#123;</span><br><span class="line">	...</span><br><span class="line">    P(c);</span><br><span class="line">	s4;</span><br><span class="line">    V(e);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5() &#123;</span><br><span class="line">	...</span><br><span class="line">	P(d);</span><br><span class="line">    s5;</span><br><span class="line">    V(f);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	...</span><br><span class="line">    P(e);</span><br><span class="line">    P(f);</span><br><span class="line">    P(g);</span><br><span class="line">	s6;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点和考点</u></strong></li>
</ul>
<p>除了互斥、同步问题外， 还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行 V 操作即可</p>
<p>互斥问题，信 号量初值为1<br>
同步问题，信 号量初值为0</p>
<p>前驱关系问题， 本质上就是多级同步问题</p>
<hr>
<h2 id="2-3-7-生产者消费者问题">2.3.7 生产者消费者问题</h2>
<ul>
<li>
<p><strong><u>问题描述</u></strong></p>
</li>
<li>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者 进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>
</li>
<li>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
</li>
<li>
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 【缓冲区没满<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>生产者生产】</p>
</li>
<li>
<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 【缓冲区没空<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>消费者消费】</p>
</li>
<li>
<p>缓冲区是临界资源，各进程必须互斥地访问。【互斥关系】</p>
</li>
<li>
<p>缓冲区满时，生产者必须等待。</p>
</li>
<li>
<p>缓冲区空时，消费者必须等待。</p>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_21-54-04.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<p>PV操作题目分析步骤：</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>
<li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n; <span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		生产一个产品;</span><br><span class="line">		P(empty);	<span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        <span class="comment">// --实现互斥是在同一进程中进行一对PV操作--</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		把产品放入缓冲区;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);	<span class="comment">// 增加一个产品</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V--</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(full);	<span class="comment">// 消耗一个产品（非空缓冲区）</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		从缓冲区取出一个产品;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);	<span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">		使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【分析双方执行后，增加了什么，申请了什么资源<br>
生产者增加了产品 V(full），消费者增加了缓冲区空白 V(empty）<br>
生产者申请了空白 P(empty)，消费者申请了产品 P(full)】</p>
<hr>
<ul>
<li><strong><u>思考：能否改变相邻P、V操作的顺序？</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		生产一个产品;	</span><br><span class="line">		P(mutex);	<span class="comment">// ①</span></span><br><span class="line">		P(empty);	<span class="comment">// ②</span></span><br><span class="line">		把产品放入缓冲区;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;	</span><br><span class="line">		P(mutex);	<span class="comment">// ③</span></span><br><span class="line">		P(full);	<span class="comment">// ④</span></span><br><span class="line">		从缓冲区取出一个产品;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);	</span><br><span class="line">		使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时缓冲区内已经放满产品，则 empty=0，full=n。<br>
则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。<br>
由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。<br>
这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“<strong>死锁</strong>”。</p>
<p>同样的，若缓冲区中没有产品，即full=0，empty=n。按③④① 的顺序执行就会发生死锁。</p>
<p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。<br>
V操作不会导致进程阻塞，因此<strong>两个V操作顺序可以交换</strong>。</p>
<p>【思考】能否将“生产一个产品;”和“使用产品;”放到PV操作之间呢？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>可以；但是不这么做，这样会使上锁和解锁之间的时间变长，实际应该让这个时间尽可能短。</p>
<hr>
<ul>
<li><strong><u>知识点和考点</u></strong></li>
</ul>
<p>生产者消费者问题是一个互斥、同步的综合问题。<br>
对于初学者来说最难的是发现题目中隐含的两对同步关系。<br>
有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_21-59-22.png" alt=""></p>
<hr>
<h2 id="2-3-8-多生产者-多消费者">2.3.8 多生产者-多消费者</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_23-13-01.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>
【互斥：临界区前后加P、V；同步：前V后P】</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>互斥关系：mutex = 1<br>
对缓冲区（盘子）的访问要互斥地进行</p>
<p>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果<br>
【“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果】</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-21-38.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>; <span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个苹果;</span><br><span class="line">		P(plate);</span><br><span class="line">		P(mutex);</span><br><span class="line">		把苹果放入盘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个橘子;</span><br><span class="line">		P(plate);</span><br><span class="line">		P(mutex);</span><br><span class="line">		把橘子放入盘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(orange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(apple);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从盘中取出苹果;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉苹果;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(orange);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从盘中取出橘子;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉橘子;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：<strong>可不可以不用互斥信号量</strong>？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore apple = <span class="number">0</span>; <span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个苹果;</span><br><span class="line">		P(plate);</span><br><span class="line">		把苹果放入盘子;</span><br><span class="line">		V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		准备一个橘子;</span><br><span class="line">		P(plate);</span><br><span class="line">		把橘子放入盘子;</span><br><span class="line">		V(orange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(apple);</span><br><span class="line">		从盘中取出苹果;</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉苹果;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(orange);</span><br><span class="line">		从盘中取出橘子;</span><br><span class="line">		V(plate);</span><br><span class="line">		吃掉橘子;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程即使上处理机运行也会被阻塞。如果刚开始是父亲进程先上处理机运行，则： 父亲 P(plate)，可以访问盘子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>母亲 P(plate)，阻塞等待盘子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>父亲放入苹果 V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>女儿 P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>母亲进程访问盘子（其他进程暂时都无法进入临界区）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>……</p>
<p><strong>结论</strong>：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。</p>
<p><strong>原因</strong>在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻， 最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p><strong>如果盘子容量为2的话</strong>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate = <span class="number">2</span>; <span class="comment">// 盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure>
<p>父亲 P(plate)，可以访问盘子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>母亲 P(plate)，可以访问盘子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>父亲在往盘子里放苹果，同时母亲也可以往盘子里 放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现 互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p>
<p>建议：在考试中如果来不及仔细分析，最好是可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。 但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p>
<p>PV 操作题目的<strong>解题思路</strong>：</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>
【互斥：临界区前后加P、V；同步：前V后P】</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。 在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生 的事看做是两种“事件”的前后关系。<br>
比如，如果<strong>从单个进程行为的角度来考虑</strong>的话，我们会有以下结论：<br>
<strong>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</strong><br>
<strong>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</strong><br>
这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-40-36.png" alt=""></p>
<p>正确的分析方法应该从“事件”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”【<strong>我认为：关注点应该在资源上（请求盘子，释放盘子）</strong> 】<br>
盘子变空事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件” 既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-44-39.png" alt=""></p>
<hr>
<h2 id="2-3-9-吸烟者问题">2.3.9 吸烟者问题</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、 第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它</strong>，并<strong>给供应者进程一个信号告诉完成了</strong>，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-49-18.png" alt=""></p>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>组合一：纸+胶水<br>
组合二：烟草+胶水<br>
组合三：烟草+纸</p>
<p>互斥关系：桌子可以抽象为容量为1的缓冲区，要互斥访问</p>
<p>同步关系（从事件的角度来分析）：<br>
桌上有组合一 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 第一个抽烟者取走东西<br>
桌上有组合二 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 第二个抽烟者取走东西<br>
桌上有组合三 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 第三个抽烟者取走东西<br>
发出完成信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 供应者将下一个组合放到桌上</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_23-54-13.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>; <span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure>
<p>【思考】是否需要设置 一个专门的互斥信号量？<br>
缓冲区大小为1，同一时 刻，四个同步信号量中至多有一个的值为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">provider() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			将组合一放桌上;</span><br><span class="line">			V(offer1);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">			将组合二放桌上;</span><br><span class="line">			V(offer2);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">			将组合三放桌上;</span><br><span class="line">			V(offer3);</span><br><span class="line">		&#125;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">		P(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">		从桌上拿走组合</span><br><span class="line">		一；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer2);</span><br><span class="line">		从桌上拿走组合</span><br><span class="line">		二；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(offer3);</span><br><span class="line">		从桌上拿走组合</span><br><span class="line">		三；卷烟；抽掉；</span><br><span class="line">		V(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。<br>
值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注 意体会我们是如何用一个整型变量 i 实现这个“轮流”过程的。</p>
<p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = rand() % <span class="number">3</span>;	<span class="comment">// 随机产生0/1/2</span></span><br></pre></td></tr></table></figure>
<p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的 “事件”发生之后的位置。</p>
<hr>
<h2 id="2-3-10-读者-写者问题">2.3.10 读者-写者问题</h2>
<ul>
<li><strong><u>问题描述</u></strong></li>
</ul>
<p>有读者和写者两组并发进程，共享<strong>一个文件</strong>【不要被下面的图误导了，本问题只有一个已存在的文件】，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<strong>因此要求</strong>：<br>
① 允许多个读者可以同时对文件执行读操作；<br>
② 只允许一个写者往文件中写信息；<br>
③ 任一写者在完成写操作之前不允许其他读者或写者工作；<br>
④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_00-15-28.png" alt=""></p>
<ul>
<li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。 因此多个读者可同时访问共享数据</li>
<li>两个写进程同时共享数据，可能导致数据错误覆盖的问题</li>
<li>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题</li>
</ul>
<hr>
<ul>
<li><strong><u>问题分析</u></strong></li>
</ul>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<p>两类进程：写进程、读进程<br>
互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p>
<hr>
<ul>
<li><strong><u>如何实现</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">			P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		读文件…</span><br><span class="line">		count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">			V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【思考】：若两个读进程并发执行，则 count=0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况。 如何解决：出现上述问题的<strong>原因在于对 count 变量的检查和赋值无法一气呵成</strong>，因此可以设置另一个互斥信号量来保证各读进 程对count 的访问是互斥的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">			P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		读文件…</span><br><span class="line">		P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">			V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>潜在的问题</strong>：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。 因此，这种算法中，读进程是优先的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于保证对count变量的互斥访问</span></span><br><span class="line">semaphore w = <span class="number">1</span>; <span class="comment">// 用于实现“写优先”【其实不是写优先，是“读写公平法”】</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(rw); <span class="comment">// 写之前“加锁”</span></span><br><span class="line">		写文件…</span><br><span class="line">		V(rw); <span class="comment">// 写完了“解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由第一个读进程负责</span></span><br><span class="line">			P(rw); <span class="comment">// 读之前“加锁”</span></span><br><span class="line">		count++; <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		读文件…</span><br><span class="line">		P(mutex); <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">		count--; <span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count==<span class="number">0</span>) <span class="comment">// 由最后一个读进程负责</span></span><br><span class="line">			V(rw); <span class="comment">// 读完了“解锁”</span></span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析以下并发执行 P(w) 的情况：<br>
（1）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>
（2）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2<br>
（3）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<br>
（4）读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者2<br>
（5）写者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读者1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>写者2</p>
<p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并<strong>不是真正的“写优先”</strong> ，而是相对公平的先来先服务原则。 有的书上把这种算法称为“<strong>读写公平法</strong>”。</p>
<p>【其实是通过w实现了一个<strong>等待w的队列</strong>】<br>
对上面各情况来说，当第一个事件占用了“w资源”，等待队列如下：<br>
（1）[w] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [读者2]<br>
（2）[w] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [写者2]<br>
（3）[w] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [读者1]<br>
（4）[w] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [写者1] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [读者2]<br>
（5）[w] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [读者1] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> [写者2]<br>
所以其实是先来先服务原则，不会导致写操作饿死，但也不是“写优先”，而是”读写公平法“</p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>读者-写者问题为我们解决复杂的互斥问题ᨀ供了一个参考思路。</p>
<p>其<strong>核心思想</strong>在于设置了一个<strong>计数器 count</strong> 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p>
<p>另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量</strong>。</p>
<p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p>
<p>【例题：南北桥】没写完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore west = <span class="number">0</span>;	</span><br><span class="line">semaphore east = <span class="number">0</span>;</span><br><span class="line">semaphore ableForPerson = n;</span><br><span class="line">semaphore full = <span class="number">1</span>;	<span class="comment">// 满人了</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 避免死锁</span></span><br><span class="line">    </span><br><span class="line">westPerson() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(west);</span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == <span class="number">0</span>)</span><br><span class="line">            P(full);</span><br><span class="line">        ableForPerson--;</span><br><span class="line">        V(west);</span><br><span class="line">        过河...</span><br><span class="line">        P(mutex);</span><br><span class="line">        ableForPerson++;  </span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == n) <span class="comment">// 我是桥上最后一个人</span></span><br><span class="line">            V(east);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eastPerson() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(east);</span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == <span class="number">0</span>)</span><br><span class="line">            P(full);</span><br><span class="line">        ableForPerson--;</span><br><span class="line">        V(east);</span><br><span class="line">        过河...</span><br><span class="line">        P(mutex);</span><br><span class="line">        ableForPerson++;  </span><br><span class="line">        <span class="keyword">if</span> (ableForPerson == n) <span class="comment">// 我是桥上最后一个人</span></span><br><span class="line">            V(west);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-3-11-哲学家进餐问题">2.3.11 哲学家进餐问题</h2>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_09-27-55.png" alt=""></p>
<ol>
<li>关系分析。系统中有5个哲学家进程，5位哲学 家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li>
<li>信号量设置。定义互斥信号量数组 <code>chopstick[5]=&#123;1,1,1,1,1&#125;</code> 用于实现对5个筷子的互 斥访问。并对哲学家按<code>0~4</code>编号，哲学家 <code>i</code> 左边 的筷子编号为 <code>i</code>，右边的筷子编号为 <code>(i+1)%5</code>。</li>
</ol>
<ul>
<li><strong>每个哲学家吃饭前依次拿起左、 右两支筷子</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果5个哲学家并发地拿起了自己左手边的筷子…<br>
每位哲学家循环等待右边 的人放下筷子（阻塞）。 发生“死锁”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p>
<ul>
<li><strong>如何防止死锁的发生呢</strong>？</li>
</ul>
<p>① 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore able2eat = <span class="number">4</span>;	<span class="comment">// 最多有4个人能吃饭</span></span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p(able2eat);	<span class="comment">// 申请吃饭</span></span><br><span class="line">		P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        v(able2eat);	<span class="comment">// 吃完了，别人可以吃</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就 避免占有一支后再等待另一只的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;	<span class="comment">// 奇数号哲学家</span></span><br><span class="line">            P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">			P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;				<span class="comment">// 偶数号哲学家</span></span><br><span class="line">			P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">            P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">        &#125;</span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。【下面的实现其实并不是这样】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123; <span class="comment">// i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(chopstick[i]); <span class="comment">// 拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">		V(mutex);</span><br><span class="line">		吃饭…</span><br><span class="line">		V(chopstick[i]); <span class="comment">// 放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">		思考…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码分析下面的情况：<br>
【哲学家0拿起来左边的筷子，然后进程切换到哲学家2】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-58-44.gif" alt=""></p>
<p>【哲学家0吃饭，这个时候哲学家1想吃饭，然后哲学家2想吃饭】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-02-32.gif" alt=""></p>
<p>【哲学家0吃饭，这个时候哲学家4想吃饭】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_10-04-15.gif" alt=""></p>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>哲学家进餐问题的关键在于解决进程死锁。<br>
这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p>
<p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。<br>
可以参考哲学家就餐问题解决死锁的三种思路。</p>
<hr>
<h2 id="2-3-12-管程">2.3.12 管程</h2>
<ul>
<li><strong><u>为什么要引入管程</u></strong></li>
</ul>
<p>信号量机制存在的问题：编写程序困难、易出错</p>
<p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p>
<p>1973年，Brinch Hansen 首次在程序设计语言 (Pascal) 中引入了“管程”成分——一种高级同步机制</p>
<hr>
<ul>
<li><strong><u>管程的定义和基本特征</u></strong></li>
</ul>
<p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程需要一个名字。</li>
</ol>
<p>跨考Tips: “过程”其实就是“函数”</p>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></li>
</ol>
<hr>
<ul>
<li><strong><u>拓展1：用管程解决生产者消费者问题</u></strong></li>
</ul>
<p>以下当做伪代码来理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下当做伪代码来理解</span></span><br><span class="line">monitor ProcedureConsumer   <span class="comment">// 定义一个管程</span></span><br><span class="line">    管程内容...</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line">monitor ProcedureConsumer</span><br><span class="line">    condition full, empty;  <span class="comment">// 条件变量用来实现同步</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 缓冲区中的产品</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span> <span class="params">(Item item)</span> &#123;   <span class="comment">// 把产品放入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (count == N)     <span class="comment">// 是否满</span></span><br><span class="line">            wait(empty);    <span class="comment">// 相当于P操作</span></span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);  <span class="comment">// 放入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)     <span class="comment">// 我是第一个，空-&gt;非空，那么我会唤醒等待队列的进程</span></span><br><span class="line">            signal(full);   <span class="comment">// 相当于V操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// 从缓冲区取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)     <span class="comment">// 是否空</span></span><br><span class="line">            wait(full);     <span class="comment">// 相当于P操作</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>) <span class="comment">// 我是最后一个，满-&gt;不满，那么我会唤醒等待队列的进程</span></span><br><span class="line">            signal(empty);  <span class="comment">// 相当于V操作</span></span><br><span class="line">        <span class="keyword">return</span> remove_item();   <span class="comment">// 取出一个产品</span></span><br><span class="line">        &#125;</span><br><span class="line">end monitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProcedureConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = ProcedureConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由编译器负责实现 各进程互斥地进入管程中的过程</p>
<p>每次仅允许一个进程在管程内执行某个内部过程。<br>
例1：两个生产者进程并发执行，依次调用了 insert 过程…<br>
例2：两个消费者进程先执行，生产者进程后执行…</p>
<p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者 问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li>
<li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li>
<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong> ，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一 个时间段内最多只会有一个进程在访问缓冲区。<strong>注意：这种互斥特性是由编译器负责实现的， 程序员不用关心</strong>）</li>
<li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒</strong>操作以解决同步问题。可以让一个进程或线程在条件变量上等待（<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong> ）；可以通过唤醒操作将 等待在条件变量上的进程或线程唤醒。</li>
</ol>
<p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;）， 之后其他程序员就可以使用这个管程提供的特定“入口”【“封装”思想】很方便地使用实现进程同步/互斥了。</p>
<hr>
<ul>
<li><strong><u>拓展2：Java 中类似于管程的机制</u></strong></li>
</ul>
<p>Java 中，如果用关键字 <code>synchronized</code> 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次只能有一个线程进入insert 函数，如果多个线程同时调用 insert 函数，则后来者需要排队等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> viod <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：不熟悉 Java 的同学看不懂也没关系，不会考，仅作为思维拓展。 熟悉 Java 的同学在时间充裕的情况下可以动手尝试用 synchronized 实现生产者消费者问题的“管程”</p>
<hr>
<h2 id="2-4-1-死锁的概念">2.4.1 死锁的概念</h2>
<ul>
<li><strong><u>什么是死锁</u></strong></li>
</ul>
<p>每位哲学家都在等待自己右边的人放下筷 子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_9-33-42.gif" alt=""></p>
<p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推 进的现象，就是“死锁”。 发生死锁后若无外力干涉， 这些进程都将无法向前推进。</p>
<hr>
<ul>
<li><strong><u>死锁、饥饿、死循环的区别</u></strong></li>
</ul>
<p><strong>死锁</strong>：<strong>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</strong>。</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。</p>
<p><strong>共同点</strong>：都是进程无法顺利向前推进的现象 （故意设计的死循环除 外）</p>
<table>
<thead>
<tr>
<th style="text-align:center">现象</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁</td>
<td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td>
</tr>
<tr>
<td style="text-align:center">饥饿</td>
<td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)</td>
</tr>
<tr>
<td style="text-align:center">死循环</td>
<td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者（程序员）的问题</strong>。</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><strong><u>死锁产生的必要条件</u></strong></li>
</ul>
<p>产生死锁<strong>必须同时满足</strong>一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ol>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待 这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ol>
<p><strong>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）【选择题】</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<hr>
<ul>
<li><strong><u>什么时候会发生死锁</u></strong></li>
</ul>
<ol>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资 源（CPU）的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1， 两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资 源）</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<hr>
<ul>
<li><strong><u>死锁的处理策略</u></strong></li>
</ul>
<ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<hr>
<h2 id="2-4-2-死锁的处理策略——预防死锁">2.4.2 死锁的处理策略——预防死锁</h2>
<ul>
<li><strong><u>破坏互斥条件</u></strong></li>
</ul>
<p><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>SPOOLing技术</strong>。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>
<p>【进程1还没用完打印机之前，进程2申请使用打印机会阻塞】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-24.png" alt=""></p>
<p>【使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理 了，不需要再阻塞等待】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-31-29.png" alt=""></p>
<p>该策略的<strong>缺点</strong>：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p>
<hr>
<ul>
<li><strong><u>破坏不剥夺条件</u></strong></li>
</ul>
<p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>破坏不剥夺条件：<br>
方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的<strong>优先级</strong>（比如：剥夺调度方式，就是将处理机资源强行剥 夺给优先级更高的进程使用）</p>
<p>该策略的<strong>缺点</strong>：</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ol>
<hr>
<ul>
<li><strong><u>破坏请求和保持条件</u></strong></li>
</ul>
<p><strong>请求和保持条件</strong>：进程已经<strong>保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</p>
<p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源 了。</p>
<p>该策略实现起来简单，但也有明显的<strong>缺点</strong>：<br>
有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造 成严重的资源浪费，<strong>资源利用率极低</strong>。</p>
<p>另外，该策略也有可能<strong>导致某些进程饥饿</strong>。eg:<br>
【如下图：假设A类进程结束后，又来了A类进程，这样C类进程一直的怒道资源1，发生了饥饿】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-39-42.png" alt=""></p>
<hr>
<ul>
<li><strong><u>破坏循环等待条件</u></strong></li>
</ul>
<p><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>， 同类资源（即编号相同的资源）一次申请完。</p>
<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p>eg：假设系统中共有10个资源，编号为 1, 2, …… 10</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_13-45-16.png" alt=""></p>
<p>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。 因此，不可能出现所有进程都阻塞的死锁现象<br>
【<strong>我的疑问</strong>，假设现在有P1,P2,P3,P4,P5，他们需要任意三个资源才能运行，这个时候他们几乎同时进行申请资源，第一轮P1[1]，p2[2]，p3[3]，p4[4]，p5[5]，第二轮P1[1,6]，p2[2,7]，p3[3,8]，p4[4,9]，p5[5,10]，这不是死锁了吗？】<br>
【上面的问题，首先资源不同的编号的资源不相同，错啦】<br>
【证明：反证法，假设资源编完号了（10个资源，10个进程），有以下死锁情况：(资源&lt;a，b，…，j&gt;，已经按&lt;1, 2, …,10&gt;有序编号了)<br>
P1需要a资源，但是a资源被P2占有了；<br>
P2需要b资源，但是b资源被P3占有了；<br>
…<br>
p10需要j资源，但是j资源被P1占有了。<br>
那么这里对于P1进程，拥有了j(10)，资源，但是却还申请a(1)资源，矛盾<br>
大概是这个意思。】</p>
<p>该策略的缺点： 1. 不方便增加新的设备，因为可能需要重新分配所有的编号； 2. 进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源浪费； 3. 必须按规定次序申请资源，用户编程麻烦。</p>
<hr>
<h2 id="2-4-3-死锁的处理策略——避免死锁">2.4.3 死锁的处理策略——避免死锁</h2>
<ul>
<li><strong><u>什么是安全序列</u></strong></li>
</ul>
<p>你是一位成功的银行家，手里掌握着100个亿的资金…<br>
有三个企业想找你贷款，分别是 企业B、企业A、企业T，为描述方便，简称BAT。<br>
B 表示：“大哥，我最多会跟你借70亿…”<br>
A 表示：“大哥，我最多会跟你借40亿…”<br>
T 表示：“大哥，我最多会跟你借50亿…”<br>
<strong>然而…江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了</strong></p>
<p>刚开始，BAT三个企业分别从你这儿借了 20、10、30 亿 …</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-33-04.png" alt=""></p>
<p>手里还有：40亿<br>
此时… B 还想借 30 亿，你敢借吗？ 假如答应了B的请求……</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p>
<p>手里还有：10亿<br>
只剩下10亿，如果BAT都提出再借20亿的请求，那么任何一个企业的需求都得不到满足…<br>
【借30亿是不安全的】</p>
<p>手里还有：40亿<br>
此时… A 还想借 20 亿，你敢借吗？假如答应了A的请求……</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-38-30.png" alt=""></p>
<p>手里还有：20亿<br>
可以先把20亿全部借给T，等T把钱全部还回来了，手里就会有20+30=50亿，再把这些钱全借给B，B还钱后总共有 50+20=70亿，最后再借给A【之后按T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> B <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> A的顺序借钱是OK的】</p>
<p>或者，先借给A 10亿，等A还钱了手里就 有 20+30 = 50 亿，再给 T 20亿，等T还钱 了就有 50+30 = 80 亿，最后再给 B 借…【按A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> B的顺序借钱也是OK的】</p>
<hr>
<ul>
<li><strong><u>安全序列、不安全状态、死锁的联系</u></strong></li>
</ul>
<p>给B借30亿是不安全的…之后手里只剩10亿，如果BAT都提出再借20亿的请求，那么任何一个企 业的需求都得不到满足…</p>
<p>给A借 20 亿是安全的，因为存在 T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> B <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> A 这样的<strong>安全序列</strong>。</p>
<p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>
如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>【如下解释】，不过我们在分配资源之前总是要考虑到最坏的情况。<br>
【系统也有可能重新回到安全状态】：手里还有10亿，比如A先归还了10亿，那么就有安全序列 B <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> T</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-34-03.png" alt=""></p>
<p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）<br>
因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。这也是“<strong>银行家算法</strong>”的核心思想。</p>
<hr>
<ul>
<li><strong><u>银行家算法</u></strong></li>
</ul>
<p>银行家算法是荷兰学者 Dijkstra【还提出了信号量机制】 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能 满足所有客户需要的情况。后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p>
<p><strong>核心思想</strong>：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p>思考：BAT 的例子中，只有一种类型的资源——钱，但是在计算机系统中会有多种多样的资源，应该怎么把算法拓展为多种资源的情况呢？</p>
<p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0~P4，3 种资源 R0~R2，初始数量为 (<strong>10, 5, 7</strong>)，则某一时刻的情况可表示如下：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_14-52-53.png" alt=""></p>
<p>【查看上表的情况是否安全】：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-14-26.gif" alt=""></p>
<p>依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求<br>
可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)<br>
依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求<br>
可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)<br>
依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（<strong>不包括已加入安全序列的进程</strong>）的需求……<br>
。。。<br>
以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列（P1,P3,P0,02,P4)<br>
该算法称为<strong>安全性算法</strong>。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。 实际做题时可以更快速的得到安全序列。</p>
<p><strong>实际做题（手算）时</strong>可用更快速的方法找到一个安全序列： 经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 可把 P1、P3 先加入安全序列。 (2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3) 剩下的 P0、P2、P4 都可被满足。同理，这些进程都可以加入安全序列。</p>
<p>于是，5个进程全部加入安全序列，说明此时系统<strong>处于安全状态</strong>，暂<strong>不可能发生死锁</strong>。</p>
<p>【不安全序列的例子】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-20-55.png" alt=""></p>
<p>无法找到任何一个安全序列，说明此时系统<strong>处于不安全状态</strong>，<strong>有可能发生死锁</strong>。</p>
<p>【<strong>代码实现</strong>】</p>
<p>假设<strong>系统中有 n 个进程，m 种资源</strong><br>
每个进程在运行前先声明对各种资源的最大需求数， 则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的<strong>最大需求数</strong>。不妨称为最大需求 <strong>矩阵 Max</strong>，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源 Rj。同理，系统可以用一个 n*m 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。Max – Allocation = <strong>Need 矩阵</strong>，表示各进程最多还需要多少各类资源。 另外，还要用一个<strong>长度为m的一维数组 Available</strong> 表示当前系统中还有多少可用资源。 某进程Pi向系统申请资源，可用一个长度为m的一维数组 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong> 表示本次申请的各种资源量。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-33-25.png" alt=""></p>
<p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：<br>
① 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>[j] ≤ Need[i, j] (0≤j≤m)便转向②；否则认为出错。<br>
② 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>[j] ≤ Available[j] (0≤j≤m)，便转向③ ；否则表示尚无足够资源，Pi必须等待。<br>
③ 系统试探着把资源分配给进程Pi，并修改相应的数据（<strong>并非真的分配，修改数值只是为了做预判</strong>）<br>
④ 操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统<strong>是否处于安全状态</strong>。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配资源</span></span><br><span class="line">Available = Available - Request_i;</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Request_i[j];</span><br><span class="line">Need[i, j] = Need[i, j] – Request_i[j]</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong><u>知识点与考点</u></strong></li>
</ul>
<p>数据结构：<br>
长度为 m 的一维数组 Available 表示还有多少可用资源<br>
n*m 矩阵 Max 表示各进程对资源的最大需求数<br>
n*m 矩阵 Allocation 表示已经给各进程分配了多少资源<br>
Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>
用长度为 m 的一位数组 Request 表示进程此次申请的各种资源</p>
<p>银行家算法步骤：<br>
① 检查此次申请是否超过了之前声明的最大需求数<br>
② 检查此时系统剩余的可用资源是否还能满足这次请求<br>
③ 试探着分配，更改各数据结构<br>
④ 用安全性算法检查此次分配是否会导致系统进入不安全状态</p>
<p>安全性算法步骤：<br>
检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，<br>
并把该进程持有的资源全部回收。<br>
不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
<hr>
<h2 id="2-4-4-死锁的处理策略——检测和解除">2.4.4 死锁的处理策略——检测和解除</h2>
<blockquote>
<p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很<strong>可能发生死锁</strong>。在这种情况下，系统应当提供两个算法：<br>
① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。<br>
② 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p>
</blockquote>
<ul>
<li><strong><u>死锁的检测</u></strong></li>
</ul>
<p>为了能对系统是否已发生了死锁进行检测，必须：<br>
① 用<strong>某种数据结构</strong>来保存资源的请求和分配信息；<br>
② 提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</p>
<p><strong>数据结构：资源分配图</strong></p>
<ul>
<li><strong>两种结点</strong>
<ul>
<li>进程结点<br>
对应一个进程</li>
<li>资源结点<br>
对应一类资源</li>
</ul>
</li>
<li><strong>两种边</strong>
<ul>
<li>进程结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>资源结点<br>
表示进程想申请几个资源 (每条边代表一个)</li>
<li>资源结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>进程结点<br>
表示已经为进程分配了几个资源 (每条边代表一个)</li>
</ul>
</li>
</ul>
<p>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那 么这个进程暂时是不会阻塞的，可以顺利地执行下去。 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-54-52.gif" alt=""></p>
<p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-07_15-57-00.gif" alt=""></p>
<p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong><br>
<strong>最终还连着边的那些进程就是处于死锁状态的进程</strong>。</p>
<p><strong>检测死锁的算法</strong>：<br>
1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中， P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p>
<p>2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能<strong>消去途中所有的边</strong>，则称该图是<strong>可完全简化的</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_15-50-20.png" alt=""></p>
<p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化的</strong>，那么此时系统<strong>死锁</strong></p>
<hr>
<ul>
<li><strong><u>死锁的解除</u></strong></li>
</ul>
<p>一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p>
<p>解除死锁的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
<p>如何决定“对谁动手”</p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<hr>
<h1>第三章 内存管理</h1>
<h2 id="3-1-1-内存的基础知识">3.1.1 内存的基础知识</h2>
<ul>
<li><strong><u>什么是内存？有何作用？</u></strong></li>
</ul>
<p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的速度矛盾</p>
<p>思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p>
<p>方案：给内存的存储单元编地址</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_16-10-10.png" alt=""></p>
<p>内存地址从0 开始，<strong>每个地址对应一个存储单元</strong></p>
<p>内存中也有一个一个的“小 房间”，每个小房间就是一 个“<strong>存储单元</strong>”</p>
<p>如果计算机“<strong>按字节编址</strong>”， 则<strong>每个存储单元大小</strong>为 <strong>1字节</strong>，即 1B，即 8个二进制位</p>
<p>如果<strong>字长为16位</strong>的计算机 “<strong>按字编址</strong>”，则<strong>每个存储单元大小</strong>为 <strong>1个字</strong>；每个字的大小为 16 个二进制位</p>
<hr>
<ul>
<li><strong><u>补充知识：几个常用的数量单位</u></strong></li>
</ul>
<p>一台手机/电脑 有 4GB 内存，是什么意思？<br>
是指该内存中可以存放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span></span></span></span>个字节。如果是按字节编址的 话，也就是有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30} = 2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>个“小房间”</p>
<p>补充知识：<br>
$2^{10} = 1K （千） $<br>
$2^{20} = 1M （兆，百万） $<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>=</mo><mn>1</mn><mi>G</mi><mtext>（十亿，千兆）</mtext></mrow><annotation encoding="application/x-tex">2^{30} = 1G （十亿，千兆）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal">G</span><span class="mord cjk_fallback">（十亿，千兆）</span></span></span></span></p>
<p>注：有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：指令的工作原理</u></strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH/?p=42&amp;spm_id_from=pageDriver&amp;vd_source=eca8bef44f4d5efc79f226fa688a5064">3.1_1_内存的基础知识_哔哩哔哩_bilibili</a></p>
<p>07:57-18:31</p>
<p>程序经过编译、链接 后生成的指令中指明的是逻辑地址（相对地址），即：相对于 进程的起始地址而言 的地址</p>
<p>指令使用的是逻辑地址（相对地址），那么<strong>如何装入内存</strong>无法确定。</p>
<p>接下来解决的就是<strong>如何把逻辑地址转化为最终的物理地址</strong></p>
<hr>
<ul>
<li><strong><u>装入的三种方式——绝对装入</u></strong></li>
</ul>
<p><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。</p>
<p>Eg：如果知道装入模块要从地址为100 的地方开始存放…</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-12.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_20-26-53.png" alt=""></p>
<p>绝对装入<strong>只适用于单道程序环境</strong>【此时还没有产生操作系统】。</p>
<p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p>
<p>【灵活性很低，换个电脑就无法执行了】</p>
<hr>
<ul>
<li><strong><u>装入的三种方式——可重定位装入</u></strong></li>
</ul>
<p><strong>静态重定位</strong>：又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-53-04.png" alt=""></p>
<p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。</p>
<p>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p>
<p>用于早期的<strong>多道批处理操作系统</strong></p>
<hr>
<ul>
<li><strong><u>装入的三种方式——动态运行时装入</u></strong></li>
</ul>
<p><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-57-03.png" alt=""></p>
<p>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。</p>
<p>并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
<p>用于<strong>现代操作系统</strong></p>
<hr>
<ul>
<li><strong><u>从写程序到程序运行</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_21-59-27.png" alt=""></p>
<p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<strong>翻译为机器语言</strong>）</p>
<p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p>
<p><strong>装入（装载）</strong> ：<strong>由装入程序将装入模块装入内存运行</strong></p>
<hr>
<ul>
<li><strong><u>链接的三种方式</u></strong></li>
</ul>
<p><strong>静态链接</strong>：在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）， 之后不再拆开。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-03-22.png" alt=""></p>
<p><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接的链接方式。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-13.png" alt=""></p>
<p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-05-39.png" alt=""></p>
<hr>
<h2 id="3-1-2-内存管理的概念">3.1.2 内存管理的概念</h2>
<ul>
<li><strong><u>内存空间的分配与回收</u></strong></li>
</ul>
<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-08-54.png" alt=""></p>
<p>很多位置都可以放， 那应该放在哪里？<br>
操作系统要怎么记录哪些内存区域已经被分配出去了， 哪些又还空闲？<br>
当进程运行结束之后，如何将进程占用的内存空间回收？</p>
<ol>
<li>操作系统负责<strong>内存空间的分配与回收</strong></li>
</ol>
<p>游戏 GTA 的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 4GB，但为什么这个游戏可以顺利运行呢？——虚拟技术（操作系统的虚拟性）</p>
<ol start="2">
<li>操作系统需要提供某种技术<strong>从逻辑上对内存空间进行扩充</strong></li>
</ol>
<p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</p>
<ol start="3">
<li>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></li>
</ol>
<p><strong>三种装入方式</strong>：</p>
<ul>
<li>绝对装入【单道程序阶段，此时还没产生操作系统】<br>
编译时产生绝对地址</li>
<li>可重定位装入【用于早期的多道批处理操作系统】<br>
装入时将逻辑地址转化为物理地址</li>
<li>动态运行时装入【现代操作系统】<br>
运行时将逻辑地址转化为物理地址，需设计重定位寄存器</li>
</ul>
<ol start="4">
<li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ol>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-19-44.png" alt=""></p>
<p>内存保护可采取两种方法：<br>
方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-21-03.png" alt=""></p>
<p>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定 位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_22-22-21.png" alt=""></p>
<hr>
<h2 id="3-1-3-覆盖与交换">3.1.3 覆盖与交换</h2>
<blockquote>
<p>内存空间的扩充</p>
<ul>
<li>覆盖技术</li>
<li>交换技术</li>
<li>虚拟存储技术</li>
</ul>
</blockquote>
<ul>
<li><strong><u>覆盖技术</u></strong></li>
</ul>
<p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。</p>
<p>后来人们引入了<strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong></p>
<p>覆盖技术的思想：将<strong>程序分为多个段</strong>（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。</p>
<p>内存中分为<strong>一个“固定区”</strong> 和<strong>若干个“覆盖区”</strong> 。 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>
<p>不常用的段放在“<strong>覆盖区</strong>”，<strong>需要用到时调入内存， 用不到时调出内存</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-17-36.png" alt=""></p>
<p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一 个覆盖区</p>
<p><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。<br>
<strong>缺点：对用户不透明</strong>，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。</p>
<hr>
<ul>
<li><strong><u>交换技术</u></strong></li>
</ul>
<p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-20-50.png" alt=""></p>
<p><strong>中级调度（内存调度）</strong> ，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>暂时换出外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<ol>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？</li>
</ol>
<p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节 后即可理解）。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-07_23-33-45.png" alt=""></p>
<ol start="2">
<li>什么时候应该交换？</li>
</ol>
<p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</p>
<ol start="3">
<li>应该换出哪些进程？</li>
</ol>
<p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… （<strong>注意：PCB 会常驻内存</strong>，不会被换出外存）</p>
<hr>
<h2 id="3-1-4-连续分配管理方式">3.1.4 连续分配管理方式</h2>
<h1>第四章 内存管理</h1>
<h1>第五章 输入/输出（I/O）管理</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io">ggw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ggw2021.github.io" target="_blank">ggw和xpl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">王道计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/12/%E4%BA%8C%E5%8F%89%E6%A0%91x/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="王道计算机网络"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">王道计算机网络</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1.1 操作系统的概念、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.1.2 操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 操作系统的发展与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3.1 操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">1.3.2 中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.3.3 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">1.4.1 操作系统的体系结构（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">1.4.2 操作系统的体系结构（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-text">1.5 操作系统的引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.1.2 进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.5 线程概念 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.6 线程的实现方式 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.7 线程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 调度的概念、层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机、切换与过程调度方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E9%97%B2%E9%80%9B%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.2.3 调度器和闲逛程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.4 调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%951%EF%BC%9A%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-text">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-6-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952%EF%BC%9A%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%953%EF%BC%9A%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">2.2.5 调度算法3：多级队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3.1 进程同步 进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-4-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">2.3.4 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.5 信号量机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-6-%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-text">2.3.6 用信号量机制实现：进程互斥、同步、前驱关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-7-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.7 生产者消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-8-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.3.8 多生产者-多消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-9-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.9 吸烟者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-10-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.10 读者-写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-11-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.11 哲学家进餐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-12-%E7%AE%A1%E7%A8%8B"><span class="toc-text">2.3.12 管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.4.1 死锁的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.2 死锁的处理策略——预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.3 死锁的处理策略——避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-text">2.4.4 死锁的处理策略——检测和解除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3.1.1 内存的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.2 内存管理的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-3-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.1.3 覆盖与交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.4 连续分配管理方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第五章 输入&#x2F;输出（I&#x2F;O）管理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 By ggw</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>