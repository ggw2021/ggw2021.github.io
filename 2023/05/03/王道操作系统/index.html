<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王道操作系统 | ggw和xpl的博客</title><meta name="author" content="ggw"><meta name="copyright" content="ggw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:type" content="article">
<meta property="og:title" content="王道操作系统">
<meta property="og:url" content="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ggw和xpl的博客">
<meta property="og:description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg">
<meta property="article:published_time" content="2023-05-03T11:13:08.565Z">
<meta property="article:modified_time" content="2023-05-06T05:11:45.610Z">
<meta property="article:author" content="ggw">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: ggw","link":"链接: ","source":"来源: ggw和xpl的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-06 13:11:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/C5EAC1F2A55D115DB1654F59F20A9934.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggw和xpl的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-03T11:13:08.565Z" title="发表于 2023-05-03 19:13:08">2023-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-06T05:11:45.610Z" title="更新于 2023-05-06 13:11:45">2023-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>101分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王道操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?t=3.0&amp;p=2">【王道考研操作系统】</a></p>
<p>微博大号–@王道咸鱼老师-计算机考研<br>
微博小号–@王道楼楼老师-计算机考研</p>
<h1>第一章 计算机系统概述</h1>
<h2 id="1-1-1-操作系统的概念、功能">1.1.1 操作系统的概念、功能</h2>
<ul>
<li><strong><u>大家都熟悉的操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_18-59-48.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的概念（定义）</strong></u></li>
</ul>
<p>一台电脑的诞生~<br>
Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机）<br>
Step 2：出售前安装操作系统<br>
Step 3：用户安装应用程序（eg：QQ）<br>
Step 4：使用 QQ 聊天</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-16-00.jpg" alt=""></p>
<p><strong>操作系统</strong>（Operating System， OS）</p>
<ul>
<li>是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>（<u>①操作系统是系统资源的管理者</u>）资源，并合理地组织调度计算机的工作和资源的分配；</li>
<li>以<strong>提供给用户和其他软件方便的接口和环境</strong>（<u>②向上层提供方便易用的服务</u>）；</li>
<li>它是计算机系统中最基本的<strong>系统软件</strong>（<u>③是最接近硬件的一层软件</u>）。</li>
</ul>
<p>直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-25-08.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为系统资源的管理者</strong></u>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>补充知识：执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p>
<p>用QQ和朋友视频聊天的过程：<br>
Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）【逐层打开文件夹，找到QQ.exe 这个程序（可执行文件）的存放位置】<br>
Step 2：双击打开 QQ.exe 【需要把该程序相关数据放入内存】<br>
Step 3：QQ 程序正常运行 【对应的进程被处理机（CPU）处理】<br>
Step 4：开始和朋友视频聊天 【需要将摄像头设备分配给进程】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——向上层提供方便易用的服务</strong></u></li>
</ul>
<p><strong>封装思想</strong>：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-35-16.jpg" alt=""></p>
<p><strong>GUI</strong>：图形化用户接口（Graphical User Interface） 【很多现代操作系统都提供GUI】<br>
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>
例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
<p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口<br>
Step 1：win键+R<br>
Step 2：输入cmd，按回车，打开命令解释器<br>
Step 3：尝试使用 time 命令<br>
【特点：用户说一句， 系统跟着做一句】</p>
<p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口<br>
使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。<br>
【特点：用户说一堆， 系统跟着做一堆】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-40-45.jpg" alt=""></p>
<p>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。<br>
如：写C语言“Hello world”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-45-43.jpg" alt=""><br>
系统调用类似于函数调用，是应用程 序请求操作系统服务的唯一方式。<strong>在有的教材中： 系统调用=广义指令</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-50-22.jpg" alt=""><br>
【有的教材中把命令接口和程序接口统称为“用户接口”，意思就是说狭义的用户接口不包括GUI。】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为最接近硬件的层次</strong></u></li>
</ul>
<p>需要实现<strong>对硬件机器的拓展</strong>；<br>
没有任何软件支持的计算机成为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器；<br>
通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>
<p>类比汽车： 发动机——只会转；轮胎——只会滚；<br>
在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展</p>
<p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</p>
<hr>
<h2 id="1-1-2-操作系统的特征">1.1.2 操作系统的特征</h2>
<blockquote>
<ul>
<li>并发</li>
<li>共享</li>
</ul>
<p>并发和共享是两个最基本的特征，二者互为存在条件。</p>
<ul>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>重要考点：<br>
理解并发和并行的区别<br>
并发和共享互为存在条件<br>
没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</p>
</blockquote>
<ul>
<li><u><strong>操作系统的特征——并发</strong></u></li>
</ul>
<p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。<br>
常考易混概念——<strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p>
<p>并发 VS 并行：<br>
eg：假设小渣和老渣每人有两个女朋友。任务1：和一号约会；任务2：和二号约会…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_20-10-44.jpg" alt=""></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。<br>
操作系统就是伴随着“多道程序技术”（后面介绍）而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p>
<p>注意（<strong>重要考点</strong>）：<br>
<strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行<br>
<strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行<br>
比如Intel 的第八代 i3 处理器就是 <strong>4 核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>；【即使是对于4核CPU来说，只要有4个以 上的程序需要“同时”运行，那么并发性依然是必不可少的，因此<strong>并发性是操作系统一个最基本的特性</strong>】</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——共享</strong></u></li>
</ul>
<p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：<br>
互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br>
同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——并发和共享的关系</strong></u></li>
</ul>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。<br>
<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>通过上述例子来看并发与共享的关系：<br>
使用QQ发送文件A，同时使用微信发送文件B。<br>
1.两个进程正在并发执行（并发性） 【如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义】<br>
2.需要共享地访问硬盘资源（共享性）【如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发】</p>
<p><strong>二者互为存在条件。</strong></p>
<hr>
<ul>
<li><strong><u>操作系统的特征——虚拟</u></strong></li>
</ul>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>Yo~用一个例子来理解<br>
背景知识：一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p>
<p>GTA5需要4GB的运行内存，<br>
QQ 需要256MB的内存，<br>
迅雷需要256MB的内存，<br>
网易云音乐需要256MB的内存……<br>
我的电脑：4GB内存<br>
问题：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？<br>
答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>空分复用技术</strong>” 。</p>
<p>某单核CPU的计算机中，用户打开了以下软件。。。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-18-58.jpg" alt=""><br>
问题：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>时分复用技术</strong>” 。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p>
<ul>
<li><strong>虚拟技术</strong>
<ul>
<li><strong>空分复用技术</strong>（如虚拟存储技术）</li>
<li><strong>时分复用技术</strong>（如虚拟处理器）</li>
</ul>
</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——异步</strong></u></li>
</ul>
<p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""><br>
与一、二号的约会 = 两道并发执行的程序 老渣的心 = 有限的系统资源</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p>
<hr>
<h2 id="1-2-操作系统的发展与分类">1.2 操作系统的发展与分类</h2>
<ul>
<li><strong><u>手工操作阶段</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-40-24.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>批处理阶段——单道批处理系统</u></strong></li>
</ul>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-43-53.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-48-41.jpg" alt=""></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br>
主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
<hr>
<ul>
<li><strong><u>批处理阶段——多道批处理系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-04.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-54.jpg" alt=""></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br>
主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）</p>
<hr>
<ul>
<li><strong><u>分时操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-14-13.jpg" alt=""></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。<br>
主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br>
主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
<hr>
<ul>
<li><strong><u>实时操作系统</u></strong>
<ul>
<li>硬实时系统<br>
必须在绝对严格的规定时间内完成处理<br>
如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统<br>
能接受偶尔违反时间规定<br>
如：12306火车订票系统</li>
</ul>
</li>
</ul>
<p>实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<hr>
<ul>
<li><strong><u>其他几种操作系统</u></strong></li>
</ul>
<p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
<p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
<p>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</p>
<hr>
<h2 id="1-3-1-操作系统的运行机制">1.3.1 操作系统的运行机制</h2>
<blockquote>
<p>Tips：</p>
<ol>
<li>都是高频考点，很重要</li>
<li>初学者不完全理解没关系， 放心大胆地往后学，随着后面章节的学习，理解会逐渐加深</li>
</ol>
</blockquote>
<ul>
<li><strong><u>预备知识：程序是如何运行的？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-19-00.jpg" alt=""></p>
<p>程序运行的过程其实就 是CPU执行一条一条的机器指令的过程</p>
<p>“指令”就是处理器（CPU）能识别、执行的最基本命令</p>
<p>注：很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也 称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别 开。本节中的“指令”指二进制机器指令</p>
<hr>
<ul>
<li><strong><u>内核程序 v.s. 应用程序</u></strong></li>
</ul>
<p>我们普通程序员写的程序就是“<strong>应用程序</strong>”</p>
<p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”<br>
由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong> ” 内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核） 操作系统的功能未必都在内核中，如图形化用户界面 GUI</p>
<hr>
<ul>
<li><strong><u>特权指令 v.s. 非特权指令</u></strong></li>
</ul>
<p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU 执行一条指令前就能判断出其类型</p>
<p>应用程序只能使用“非特权指令”，如： 加法指令、减法指令等</p>
<p>操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</p>
<hr>
<ul>
<li><strong><u>内核态 v.s. 用户态</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-25-21.jpg" alt=""></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 问题：如何实现CPU状态的切换？</p>
<p>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<br>
处于<strong>内核态时</strong>，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong><br>
处于<strong>用户态时</strong>，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p>
<p>拓展：CPU 中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong> ，其中有个二进制位，1表示 “内核态”，0表示“用户态”</p>
<p><strong>别名</strong>：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></p>
<hr>
<ul>
<li><strong><u>内核态、用户态 的切换</u></strong></li>
</ul>
<table>
    <tr>
        <td>
            一个故事：</br>
    ① 刚开机时，CPU 为“<b>内核态</b>”，操作系统内核程序先上CPU运行</br>
② 开机完成后，用户可以启动某个应用程序</br> 
③ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行</br>
【操作系统内核在让出CPU之前，会<b>用一条特权指令把 PSW 的标志位设置为“用户态”</b>】</br>
④ 应用程序运行在“用户态”</br> 
⑤ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…</br> 
⑥ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”</br> 
⑦ 这个非法事件会引发一个<b>中断信号</b></br>
【<b>CPU检测到中断信号后</b>，会立即<b>变为“核心态”</b>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序】</br> 
⑧ “中断”使操作系统再次夺回CPU的控制权</br> ⑨ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</br>
        </td>
    </tr>    
</table>
**内核态** $\to$ **用户态**：**执行一条特权指令**——**修改PSW**的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权 
**用户态** $\to$ **内核态**：由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权
【除了非法使用特权指令之外，还有很多事件 会触发中断信号。一个共性是，**但凡需要操作系统介入的地方，都会触发中断信号**】
<hr>
<h2 id="1-3-2-中断和异常">1.3.2 中断和异常</h2>
<ul>
<li><strong><u>中断的作用</u></strong><br>
“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
</ul>
<p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>（是整个系统的管理者），一种是<strong>应用程序</strong></p>
<p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）</p>
<p>“中断”是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径</p>
<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序<br>
没有中断机制，就不可能实现操作系统，不可能实现程序并发</p>
<hr>
<ul>
<li><strong><u>中断的类型</u></strong>
<ul>
<li><strong>内中断</strong><br>
与当前执行的指令有关， 中断信号来源于CPU内部</li>
<li><strong>外中断</strong><br>
与当前执行的指令无关， 中断信号来源于CPU外部</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><u><strong>内中断的例子</strong></u></li>
</ul>
<p>例子 1：试图在用户态下执行特权指令<br>
例子 2：执行除法指令时发现除数为 0<br>
【若当前执行的指令是非法的，则会引发一个中断信号】</p>
<p>例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<br>
【执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “<strong>系统调用”就是通过陷入指令完成的</strong>】</p>
<hr>
<ul>
<li><strong><u>外中断的例子</u></strong></li>
</ul>
<p>例子1：时钟中断——由时钟部件发来的中断信号</p>
<p>例子2：I/O中断——由输入/输出设备发来的中断信号</p>
<hr>
<ul>
<li><strong><u>中断的分类</u></strong>【广义的中断】
<ul>
<li>内中断（也称<strong>异常</strong>、例外）
<ul>
<li>陷阱、陷入（trap）【由陷入指令引发，是应用程序故意引发的】</li>
<li>故障（fault）【由错误条件引起的，可能被 内核程序修复。内核程序修 复故障后会把 CPU使用权还 给应用程序，让它继续执行 下去。如：缺页故障。】</li>
<li>终止（abort）【由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序。如： 整数除0、非法使用特权指令】</li>
</ul>
</li>
<li>外中断（也称中断）【狭义的中断】
<ul>
<li>时钟中断</li>
<li>I/O中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常“</p>
<hr>
<ul>
<li><u><strong>中断机制的基本原理</strong></u></li>
</ul>
<p>检测中断信号：</p>
<ul>
<li>内中断：CPU在<strong>执行指令时</strong>会检查是否有异常发生</li>
<li>外中断：<strong>每个指令周期末尾</strong>，CPU都会检查是否有外中断信号需要处理</li>
</ul>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-07-58.jpg" alt=""><br>
显然，中断处理程序一定是内核程序，需要运行在“内核态”</p>
<hr>
<h2 id="1-3-3-系统调用">1.3.3 系统调用</h2>
<ul>
<li><strong><u>什么是系统调用，有何作用？</u></strong></li>
</ul>
<p>知识点回顾：<br>
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
<hr>
<ul>
<li><strong><u>系统调用与库函数的区别</u></strong></li>
</ul>
<table>
    <tr>
        <td>普通应用程序</td>
        <td>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
    </tr>
    <tr>
        <td>编程语言</td>
        <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>
    </tr>
    <tr>
        <td>操作系统</td>
        <td>向上提供系统调用，使得上层程序能请求内核的服务</td>
    </tr>
    <tr>
        <td>裸机</td>
        <td></td>
    </tr>
</table>
<p>不涉及系统调用的库函数：如的“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-21-42.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>小例子：为什么系统调用是必须的？</u></strong></li>
</ul>
<p>生活场景：去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开 始工作。<br>
你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p>
<hr>
<ul>
<li><strong><u>什么功能要用到系统调用？</u></strong></li>
</ul>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<ul>
<li><strong>系统调用（按功能分类）</strong>
<ul>
<li><strong>设备管理</strong>：完成设备的 <strong>请求/释放/启动</strong> 等功能</li>
<li><strong>文件管理</strong>：完成文件的 <strong>读/写/创建/删除</strong> 等功能</li>
<li><strong>进程管理</strong>：完成进程的 <strong>创建/撤销/阻塞/唤醒</strong> 等功能</li>
<li><strong>进程通信</strong>：完成进程之间的 <strong>消息传递/信号传递</strong> 等功能</li>
<li><strong>内存管理</strong>：完成内存的 <strong>分配/回收</strong> 等功能</li>
</ul>
</li>
</ul>
<p>拓展：感兴趣的同学可以搜索“Linux 系统调用”，了解 Linux 操作系统提供了哪些系统调用</p>
<hr>
<ul>
<li><strong><u>系统调用的过程</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-36-59.png" alt=""></p>
<p>传递系统调用参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 执行陷入指令（<strong>用户态</strong>，陷入指令是非特权指令） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>  执行相应的内请求核程序处理系统调用（<strong>核心态</strong>） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 返回 应用程序<br>
注意：<br>
1.陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态<br>
2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</p>
<p>注意别名： 陷入指令 = trap 指令 = 访管指令</p>
<hr>
<h2 id="1-4-1-操作系统的体系结构（上）">1.4.1 操作系统的体系结构（上）</h2>
<ul>
<li><strong><u>操作系统的内核</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-43-27.png" alt="">·</p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分。<br>
实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-45-33.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-46-56.png" alt=""></p>
<p>注意：<br>
操作系统<strong>内核</strong>需要运行在<strong>内核态</strong><br>
操作系统的<strong>非内核</strong>功能运行在<strong>用户态</strong></p>
<p>一个故事：现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-58-30.png" alt=""></p>
<p>注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能<br>
【注意：“变态”在这里是口头表述，考试应该正规表述，例如“状态改变”】</p>
<hr>
<ul>
<li><strong><u>操作系统的体系结构</u></strong>
<ul>
<li>大内核
<ul>
<li>将操作系统的主要功能模块作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核
<ul>
<li>只把最基本功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>典型的大内核/宏内核/单内核 操作系统： Linux、UNIX<br>
典型的 微内核 操作系统： Windows NT</p>
<p>类比：<br>
操作系统的体系结构问题与企业的管理问题很相似。<br>
<strong>内核</strong>就是企业的<strong>管理层</strong>，负责一些重要的工作。只有管理层才能执行<strong>特权指令</strong>，普通员工只能执行<strong>非特权指令</strong>。<strong>用户态</strong>、<strong>核心态</strong>之间的切换相当于普通员工和管理层之间的工作交接<br>
<strong>大内核</strong>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。<br>
<strong>微内核</strong>：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p>
<hr>
<h2 id="1-4-2-操作系统的体系结构（下）">1.4.2 操作系统的体系结构（下）</h2>
<blockquote>
<ul>
<li>大内核（又名：宏内核/单内核）</li>
<li>微内核</li>
<li>分层结构（新增）</li>
<li>模块化（新增）</li>
<li>外核（新增）</li>
</ul>
<p>Tips: 一定是<strong>考简单的选择题</strong>，了解各种体系结构的<strong>特性</strong>，了解各自的<strong>优缺点</strong></p>
</blockquote>
<ul>
<li><strong><u>操作系统结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_15-55-43.png" alt=""></p>
<p>【注：加星号是作者认为更容易考的，红色星号是全新的内容，黄色星号的是老内容（大内核、微内核）】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——分层结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-00-31.png" alt=""></p>
<p>最底层是硬件，最高层是用户接口<br>
每层可调用更低一层【不能跨层调用】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——模块化</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-04-57.png" alt=""></p>
<p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，上图所示为由模块、子模块等组成的模块化操作系统结构。</p>
<hr>
<ul>
<li><strong><u>操作系统结构——外核（exokernel）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-11-27.png" alt=""></p>
<hr>
<h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2>
<blockquote>
<p>操作系统引导(boot)–开机的时候怎么让操作系统运行起来?</p>
</blockquote>
<ul>
<li><strong><u>一个刚买来的磁盘（硬盘）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-25-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>安装操作系统后，操作系统引导（开机过程）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-33-54.png" alt=""></p>
<p>【注释】<br>
根目录：顾名思义，双击C盘看到的那些东西<br>
分区表：实际上是一个数据结构，记录每个盘每个分区多大、地址范围这些信息<br>
BIOS：Basic Input/Output System<br>
ROM引导程序：ROM boot 程序</p>
<p><strong>操作系统引导</strong>:<br>
① CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序 (先进行硬件自检，再开机)<br>
② 将磁盘的第一块–主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>
③ 从活动分区 (又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序<br>
④ 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作</p>
<hr>
<ul>
<li><strong><u>例: windows 操作系统的初始化程序</u></strong></li>
</ul>
<p>注：完整的操作系统初始化程序 (即 启动管理器) 可在根目录下找到<br>
Eg：windows操作系统完整的开机初始化程序在“根目录/Windows/Boot”下</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-38-37.png" alt=""></p>
<hr>
<h2 id="1-6-虚拟机">1.6 虚拟机</h2>
<ul>
<li><strong><u>传统计算机</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-42-34.png" alt=""></p>
<hr>
<ul>
<li><strong><u>虚拟机</u></strong></li>
</ul>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统</p>
<p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-53-47.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_17-02-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>两类虚拟机管理程序（VMM）的对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对物理资源的控制权</td>
<td>直接运行在硬件上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖Host OS为其分配物理资源</td>
</tr>
<tr>
<td style="text-align:left">资源分配方式</td>
<td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td>
<td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td>性能更好</td>
<td>性能更差，需要Host OS作为“中介”</td>
</tr>
<tr>
<td style="text-align:left">可支持虚拟机的数量</td>
<td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，Host OS本身也需要使用物力资源，Host OS上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td style="text-align:left">虚拟机的可迁移性</td>
<td>更差</td>
<td>更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛</td>
</tr>
<tr>
<td style="text-align:left">运行模式</td>
<td>第一类VMM运行在最高权限级（Ring 0），可以执行最高权限指令</td>
<td>第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用</td>
</tr>
</tbody>
</table>
<hr>
<h1>第二章 进程与线程</h1>
<h2 id="2-1-1-进程的概念、组成、特征">2.1.1 进程的概念、组成、特征</h2>
<ul>
<li><strong><u>进程的概念</u></strong></li>
</ul>
<p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的 可执行文件，就是一系列的指令集合。<br>
进程（Process）：是<strong>动态的</strong>，是程序的一 次执行过程 同一个程序多 次执行会对应 多个进程</p>
<hr>
<ul>
<li><strong><u>进程的组成——PCB</u></strong></li>
</ul>
<p>思考：操作系统是这些进程的管理者，它要怎么区分各个进程？<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <strong>PID</strong>（Process ID，进程ID）</p>
<ol>
<li>操作系统要记录PID、进程所属用户ID（UID）<br>
【基本的进程描述信息，可以让操作系统区分各个进程】</li>
<li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<br>
【可用于实现操作系统对资源的管理】</li>
<li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）<br>
【可用于实现操作系统对进程的控制、调度】</li>
<li>这些信息都被保存在一个数据结构<strong>PCB</strong> （Process Control Block）中，即<strong>进程控制块</strong><br>
操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong></li>
</ol>
<p>【总结】：</p>
<ul>
<li><strong>进程控制块（PCB）</strong> ：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
<ul>
<li><strong>进程描述信息</strong>
<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><strong>进程控制和管理信息</strong>
<ul>
<li>CPU、磁盘、网络流量使用情况统计…</li>
<li>进程当前状态：就绪态 / 阻塞态 / 运行态…</li>
</ul>
</li>
<li><strong>资源分配清单</strong>
<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I/O设备</li>
</ul>
</li>
<li><strong>处理机相关信息</strong>
<ul>
<li>如PSW，PC等等各种寄存器的值（用于实现进程切换）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统对进程进行管理工作所需的信息都存在PCB中</p>
<hr>
<ul>
<li><u><strong>进程的组成——程序段、数据段</strong></u>
<ul>
<li><strong>PCB</strong>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PCB</strong> 是<strong>给操作系统用的</strong>。<br>
<strong>程序段、数据段</strong>是<strong>给进程自己用的</strong>。</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>一条高级语言的代码翻译过来可能会对应多条机器指令<br>
程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-07-33.png" alt=""></p>
<p>一个<strong>进程实体（进程映像）</strong> 由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。 <strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong> 是<strong>静态</strong>的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）</p>
<hr>
<ul>
<li><u><strong>进程的组成</strong></u>【更确切的说，应该 是“进程实体(进程 映像)的组成”】
<ul>
<li><strong>PCB</strong>【PCB 是给操作系统用的】
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【程序段、数据段是给进程自己用的， 与进程自身的运行逻辑有关】<br>
【同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）】</p>
<p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong> 引入进程实体的概念后，<br>
可把<strong>进程定义为</strong>： 进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。<br>
【一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行】</p>
<p>注意：PCB是进程存在的唯一标志！</p>
<hr>
<ul>
<li><strong><u>进程的特征</u></strong></li>
</ul>
<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<ol>
<li><strong>动态性</strong>【动态性是进程最基本的特征】<br>
进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性</strong><br>
内存中有多个实体进程，各进程可并发执行</li>
<li><strong>独立性</strong><br>
进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li><strong>异步性</strong><br>
各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li><strong>结构性</strong><br>
每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<hr>
<h2 id="2-1-2-进程的状态与转换、进程的组织">2.1.2 进程的状态与转换、进程的组织</h2>
<ul>
<li><u><strong>进程的状态——创建态、就绪态</strong></u></li>
</ul>
<p>进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<p>当进程创建完成后，便进入“<strong>就绪态</strong>”， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行</p>
<hr>
<ul>
<li><strong><u>进程的状态——运行态</u></strong></li>
</ul>
<p>系统中可能会有很多个进程都处于就绪态；</p>
<p>当CPU空闲时，操作系统就会选择一个就绪进程， 让它上处理机运行；</p>
<p>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。 CPU会执行该进程对应的程序（执行指令序列）</p>
<hr>
<ul>
<li><strong><u>进程的状态——阻塞态</u></strong></li>
</ul>
<p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p>
<p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</p>
<p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p>
<hr>
<ul>
<li><u><strong>进程的状态——终止态</strong></u></li>
</ul>
<p>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。</p>
<p>此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。</p>
<p>当终止进程的工作完成之后，这个进程就彻底消失了。</p>
<hr>
<ul>
<li><strong><u>进程状态的转换</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-37-42.png" alt=""></p>
<p><strong>注意：不能由阻塞态直接转换为运行态， 也不能由就绪态直接转换为阻塞态</strong>（因为 进入阻塞态是进程主动请求的，必然需要 进程在运行时才能发出这种请求）</p>
<hr>
<ul>
<li><strong><u>进程的状态</u></strong>
<ul>
<li><strong>三种基本状态</strong>【进程的整个生命周期 中，大部分时间都处 于三种基本状态】
<ul>
<li>运行态（Running）【单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态】<br>
占有CPU，并在CPU上运行</li>
<li>就绪态（Ready）<br>
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>
<li>阻塞态（Waiting / Blocked，又称：等待态）<br>
因等待某一事件而暂时不能运行</li>
</ul>
</li>
<li>另外两种状态
<ul>
<li>创建态（New，又称：新建态）<br>
进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（Terminated，又称：结束态）<br>
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程PCB中，会有一个变量 state 来表示进程的当前状态</strong>。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<hr>
<ul>
<li><strong><u>进程的组织——链接方式</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-03-39.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-04-35.png" alt=""></p>
<hr>
<ul>
<li><u><strong>进程的组织——索引方式</strong></u></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-05-33.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程的组织</u></strong>
<ul>
<li><strong>链接方式</strong>
<ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><strong>索引方式</strong>
<ul>
<li>根据进程状态不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数操作系统使用链接方式【</p>
<hr>
<h2 id="2-1-3-进程控制">2.1.3 进程控制</h2>
<ul>
<li><strong><u>什么是进程控制？</u></strong></li>
</ul>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<p>简化理解：反正进程控制就是要实现进程状态转换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-15-07.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现进程控制？</u></strong></li>
</ul>
<p>用“原语”实现【第一章提到了】</p>
<p>原语的执行具有“原子性”，一气呵成</p>
<p>思考：为何进程控制（状态转 换）的过程要“一气呵成”？<br>
如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</p>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…<br>
假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>
①将PCB2的 state 设为 1<br>
②将PCB2从阻塞队列放到就绪队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-22-47.png" alt=""></p>
<p>但是完成了第一步后收到中断信号，CPU处理中断去了，那么这个时候PCB2 的state=1，但是它却还在阻塞队列里。</p>
<hr>
<ul>
<li><strong><u>如何实现原语的“原子性”？</u></strong></li>
</ul>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。<br>
可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现<strong>原子性</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-28-05.png" alt=""></p>
<p>如上图：<br>
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</p>
<p>这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子 性”</p>
<p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？<br>
假设用户直接在程序开头设置关中断，在程序尾设置开中断，那么这个程序执行时将不能被打断，一直霸占资源，这是不合理的。</p>
<hr>
<ul>
<li><strong><u>进程控制相关的原语</u></strong></li>
</ul>
<ol>
<li><strong>进程的创建</strong>
<ul>
<li><strong>创建原语</strong>【操作系统创建一个进程时使用的原语】
<ul>
<li>申请空白PCB</li>
<li>为新的进程分配资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列【创建态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录<br>
分时系统中，用户登录成功，系统会为其创建一个新的进程</li>
<li>作业调度<br>
多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务<br>
用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求<br>
由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的终止</strong>
<ul>
<li><strong>撤销原语</strong>【就绪态/阻塞态/运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 终止态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 无】
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程【进程间的关系是树形结构】</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束【进程自己请求终止（exit系统调用）】</li>
<li>异常结束【整数除以0、非法使用特权指令， 然后被操作系统强行杀掉】</li>
<li>外界干预【Ctrl+Alt+delete，用户选择杀掉进程】</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>3.阻塞原语、4.唤醒原语必须成对使用</p>
<ol start="3">
<li><strong>进程的阻塞</strong>
<ul>
<li><strong>阻塞原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 阻塞态】
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li><strong>保护进程运行现场</strong>，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的唤醒</strong>
<ul>
<li><strong>唤醒原语</strong>【阻塞态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】
<ul>
<li>在事件等待队列找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生【因何事阻塞，就应由何事唤醒】</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的切换</strong>
<ul>
<li><strong>切换原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态、就绪态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 运行态】
<ul>
<li>将<strong>运行环境信息</strong>【进程上下文（Context ）】存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>新进程所需的运行环境</strong></li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>【上接：2.1.1 进程的概念、组成、特征 中的知识滚雪球】</p>
<p>CPU中会设置很多 “寄存器”，用来存放程序运行过程中所需的某些数据。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSW</td>
<td>程序状态字寄存器</td>
</tr>
<tr>
<td>PC</td>
<td>程序计数器，存放下一条指令的地址</td>
</tr>
<tr>
<td>IR</td>
<td>指令寄存器，存放当前正在执行的指令</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>其他一些必 要信息</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<table>
 <tr>
     <td>
         int x = 1;</br>
x++;</br>
…… </br></br>
         指令1: 往内存中某个地方写入变量x的值</br>
指令2: 把变量x的值放到某个寄存器中</br>
指令3: 寄存器中的数值+1</br>
指令4: 把寄存器的值写回变量x的存放位置</br>
……</br>
     </td>
    </tr>  
</table>
<p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p>
<p>思考：执行完指令3后， 另一个进程开始上CPU运行。<br>
注意：另一个进程在运行过程中也会使用各个寄存器<br>
灵魂拷问：之后还怎么切换回之前的进程？？？？</p>
<p>解决办法：在进程切换时<strong>先在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<br>
当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong></p>
<hr>
<ul>
<li><strong><u>学习技巧</u></strong></li>
</ul>
<p>进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息
<ul>
<li>a. 所有的进程控制原语一定都会修改进程状态标志</li>
<li>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>c. 某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<hr>
<h2 id="2-1-4-进程通信">2.1.4 进程通信</h2>
<ul>
<li><strong><u>什么是进程通信？</u></strong><br>
进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-27-27.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong><u>为什么进程通信需要操作系统支持？</u></strong></li>
</ul>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-30-11.png" alt=""></p>
<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<p>下面将介绍三种进程通信方式：<strong>1. 共享存储、2. 消息传递、3. 管道通信</strong></p>
<hr>
<ul>
<li><strong><u>进程通信——共享存储</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-36-25.png" alt=""></p>
<p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。<br>
各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作【后面介绍】)</p>
<p>linux中，如何实现共享内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(...)</span>	<span class="comment">// 通过 shm_open 系统调用，申请一片共享内存区</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(...)</span>	<span class="comment">// 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中(第三章内容)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>共享存储</strong>：</p>
<ul>
<li><strong>基于数据结构</strong>的共享：<br>
比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种<strong>低级通信</strong>方式</li>
<li><strong>基于存储区</strong>的共享：<br>
在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递</u></strong></li>
</ul>
<p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-44-02.png" alt=""></p>
<p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<p><strong>消息传递</strong>：</p>
<ul>
<li><strong>直接通信方式</strong><br>
消息直接挂到接收进程的消息缓冲队列上</li>
<li><strong>间接通信方式</strong><br>
消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（直接通信方式）</u></strong></li>
</ul>
<p>点名道姓的消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-55-43.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（间接通信方式）</u></strong></li>
</ul>
<p>以“信箱”作为中间实体进行消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-01-46.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——管道通信</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-47-19.png" alt=""></p>
<p>那么管道通信和进程通信又有什么区别呢？<br>
管道通信读写要求先进先出（循环队列）；而共享存储存取没有要求，都行</p>
<ol>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。 （由操作系统实现）</li>
<li>当<strong>管道写满</strong>时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当<strong>管道读空</strong>时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：1、<strong>一个管道允许多个写进程，一个读进程</strong> (2014年408真题高教社官方答案)；2、允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)。</li>
</ol>
<hr>
<ul>
<li><strong><u>王道书修正</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-58-27.png" alt=""></p>
<hr>
<h2 id="2-1-5-线程概念-多线程模型">2.1.5 线程概念 多线程模型</h2>
<ul>
<li><strong><u>什么是线程，为什么要引入线程？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_14-48-55.png" alt=""></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p>传统的进程是程序执行流的最小单位。<br>
引入线程后，线程成为了程序执行流的最小单位</p>
<p>可以把线程理解为“轻量级进程”。</p>
<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>， 也是<strong>程序执行流的最小单位</strong>。<br>
引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内 也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）</p>
<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br>
<strong>线程</strong>则作为<strong>处理机的分配单元</strong>。</p>
<hr>
<ul>
<li><strong><u>引入线程机制后，有什么变化？</u></strong></li>
</ul>
<ol>
<li><strong>资源分配、调度</strong>
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>
</ul>
</li>
<li><strong>并发性</strong>
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
</li>
<li><strong>系统开销</strong>
<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>引入线程后，并发所带来的系统开销减小</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的属性</u></strong></li>
</ul>
<ol>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块 (TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ol>
<hr>
<h2 id="2-1-6-线程的实现方式-多线程模型">2.1.6 线程的实现方式 多线程模型</h2>
<ul>
<li><strong><u>线程的实现方式——用户级线程（User-Level Thread, ULT）</u></strong></li>
</ul>
<p>历史背景：早期的操作系统（如：早期Unix）只支持进程， 不支持线程。当时的“线程”是由线程库实现的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-01-10.png" alt=""></p>
<p>eg：将下面进程描述成如下代码</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-02-37.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;	</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>	<span class="comment">// i = 0, 1, 2, 0, 1, 2...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码的角度看，线程其实就是一段代码逻辑。 上述三段代码逻辑上可以看作三个“线程”。 while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。</p>
<p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“<strong>用户级线程</strong>”就是“<strong>从用户视角看能看到的线程</strong>”</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的实现方式——内核级线程（Kernel-Level Thread, KLT”）</u></strong><br>
又称“<strong>内核支持的线程</strong>“</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p>由操作系统支持的线程，<strong>内核级线程才是处理机分配的单位</strong></p>
<p>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块）， 通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看能看到的线程</strong>”</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>
缺点：一个用户进程会占用多个内核级线程，内核级线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ol>
<hr>
<ul>
<li><strong><u>多线程模型</u></strong><br>
在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关 系，可以划分为几种多线程模型</li>
</ul>
<p><strong>重点重点重点</strong>： 操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</p>
<p><strong>一对一</strong>模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p><strong>多对一</strong>模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-06.png" alt=""></p>
<p>多对多模型：n 用户及线程映射到 m 个内核级 线程（n &gt;= m）。每个用户进程对应 m 个内核 级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-11.png" alt=""></p>
<p>可以这么理解：<br>
用户级线程是“代码逻辑”的载体<br>
内核级线程是“运行机会”的载体<br>
【<strong>内核级线程才是处理机分配的单位</strong>。例如：多核 CPU环境下，上图这个进程最多能被分配两个核。】</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU执行<br>
【内核级线程中可以运行任意一个有映射关系的用户级线程代码，如上图，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞】</p>
<hr>
<h2 id="2-1-7-线程的状态与转换">2.1.7 线程的状态与转换</h2>
<ul>
<li><strong><u>线程的状态与转换</u></strong></li>
</ul>
<p>下面与进程完全一致</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<hr>
<ul>
<li><strong><u>线程的组织与控制</u></strong></li>
</ul>
<p>类似于进程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-40-03.png" alt=""></p>
<p>组织：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-41-19.png" alt=""></p>
<hr>
<h2 id="2-2-1-调度的概念、层次">2.2.1 调度的概念、层次</h2>
<ul>
<li><strong><u>调度的概念</u></strong></li>
</ul>
<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——高级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-49-48.png" alt=""></p>
<p>作业：一个具体的任务<br>
用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>内存空间有限，有时无法将用户提交的作业全部放入内存</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。<br>
【简化理解：好几个程序需要启动，到底先启动哪个】</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——低级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-50-23.png" alt=""></p>
<p><strong>低级调度（进程调度/处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——中级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-53-15.png" alt=""></p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p>
<p><strong>中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。<br>
一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p>
<hr>
<ul>
<li><strong><u>补充知识：进程的挂起态与七状态模型</u></strong></li>
</ul>
<p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p>
<p>五状态模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>七状态模型：【看学校怎么考】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<p>注意“挂起”和“阻塞”的区别，两种 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。<br>
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<hr>
<ul>
<li><strong><u>三层调度的联系、对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>要做什么</th>
<th style="text-align:center">调度发生在…</th>
<th style="text-align:center">发生频率</th>
<th style="text-align:center">对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高级调度<br />（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向作业）</td>
<td style="text-align:center">最低</td>
<td style="text-align:center">无<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>创建态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态</td>
</tr>
<tr>
<td style="text-align:center">中级调度<br />（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向进程）</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">挂起态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态 <br />（阻塞挂起<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态）</td>
</tr>
<tr>
<td style="text-align:center">低级调度<br />（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td style="text-align:center">内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">就绪态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>运行态</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-2-2-进程调度的时机、切换与过程调度方式">2.2.2 进程调度的时机、切换与过程调度方式</h2>
<ul>
<li><strong><u>进程调度的时机</u></strong></li>
</ul>
<p><strong>进程调度</strong>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p><strong>需要进行</strong>进程调度与切换的情况：</p>
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如 等待I/O）</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p><strong>不能进行</strong>进程调度与切 换的情况：</p>
<ol>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中。<br>
【但是进程在普通临界区中是可以进行调度和切换的】</li>
<li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<p>【考题：】<br>
【对】进程在操作系统内核程序临界区中不能进行调度与切换<br>
【错】（2012年联考真题）进程处于临界区时不能进行处理机调度<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
首先要知道：<br>
临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>
临界区：访问临界资源的那段代码。<br>
<strong>内核程序临界区</strong>一般是用来<strong>访问某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成)</p>
<p>【eg:】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-24-53.png" alt=""></p>
<p>如果还没退出临界区 (还没解锁 )就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-25-07.png" alt=""></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<hr>
<ul>
<li><strong><u>进程调度的方式</u></strong></li>
</ul>
<p>有的系统中，只允许进程主动放弃处理机<br>
有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br>
【实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统】</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>
【可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统】</li>
</ul>
<hr>
<ul>
<li><strong><u>进程的切换与过程</u></strong></li>
</ul>
<p>“狭义的进程调度”与“进程切换”的区别：<br>
<strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程， 也可能是另一个进程，后一种情况就需要进程切换）<br>
<strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<hr>
<h2 id="2-2-3-调度器和闲逛程序">2.2.3 调度器和闲逛程序</h2>
<ul>
<li><strong><u>调度器/调度程序（scheduler）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<p>上图中，2和3由调度程序引起，调度程序决定:</p>
<p>让谁运行?——调度算法<br>
运行多长时间?——时间片大小</p>
<p>调度时机——什么事件会触发“调度程序” ?</p>
<ul>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li>运行<strong>进程阻塞</strong></li>
<li><strong>l/O中断</strong>发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个<strong>时钟中断</strong>或k个时钟中断会触发调度程序工作</li>
</ul>
<p>不支持内核级线程的操作系统，调度程序的处理对象是进程<br>
支持内核级线程的操作系统，调度程序的处理对象是内核线程</p>
<hr>
<ul>
<li><strong><u>闲逛进程</u></strong></li>
</ul>
<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程(idle)</p>
<p>闲逛进程的<strong>特性</strong>:</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<hr>
<h2 id="2-2-4-调度算法的评价指标">2.2.4 调度算法的评价指标</h2>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>等待时间</mtext><mo>=</mo><mtext>周转时间</mtext><mo>−</mo><mtext>运行时间</mtext></mrow><annotation encoding="application/x-tex">等待时间=周转时间-运行时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">周转时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">运行时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均等待时间</mtext><mo>=</mo><mfrac><mtext>各作业等待时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均等待时间=\frac{各作业等待时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均等待时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业等待时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</blockquote>
<ul>
<li><strong><u>CPU利用率</u></strong></li>
</ul>
<p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong></p>
<p><strong>CPU利用率</strong>：指CPU “忙碌”的时间占总时间的比例。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【有的题目还会要求计 算某种设备的利用率】</p>
<p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒， 再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中， CPU利用率、打印机利用率分别是多少？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>打印机利用率</mtext><mo>=</mo><mfrac><mn>5</mn><mn>15</mn></mfrac><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">打印机利用率=\frac{5}{15}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">打印机利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span><br>
【通常会考察多道程序并发 执行的情况，可以用“甘 特图”来辅助计算】</p>
<hr>
<ul>
<li><u><strong>系统吞吐量</strong></u></li>
</ul>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<br>
<strong>系统吞吐量</strong>：单位时间内完成作业的数量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<br>
10/100 = 0.1 道/秒</p>
<hr>
<ul>
<li><strong><u>周转时间</u></strong></li>
</ul>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br>
<strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。<br>
它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>
【对于用户来说，更关心自 己的单个作业的周转时间】</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值】</p>
<p>【思考】有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<br>
eg：等待1分钟，执行10分钟；等待10分钟，运行1分钟。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<hr>
<ul>
<li><strong><u>等待时间</u></strong></li>
</ul>
<p>计算机的用户希望自己的作业尽可能少的等待处理机<br>
<strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业在后备队列等待被服务（调度）<br>
作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候</p>
<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>
对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p>
<hr>
<ul>
<li><strong><u>响应时间</u></strong></li>
</ul>
<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>
<hr>
<h2 id="2-2-5-调度算法1：先来先服务-最短作业优先-最高响应比优先">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</h2>
<blockquote>
<p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于 作业调度 还是 进程调度？</li>
<li>抢占式？非抢占式？</li>
<li>优点和缺点</li>
<li>是否会导致<strong>饥饿</strong>【某进程/作业长期得不到服务】</li>
</ol>
</blockquote>
<ul>
<li><strong><u>先来先服务（FCFS, First Come First Serve）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li>
<li><strong>算法规则</strong><br>
按照作业/进程到达的先后顺序进行服务</li>
<li><strong>用于作业/进程调度</strong><br>
用于作业调度时，考虑的是哪个作业先到达后备队列；<br>
用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
<li><strong>是否可抢占？</strong><br>
非抢占式的算法</li>
<li><strong>优缺点</strong><br>
优点：公平、算法实现简单<br>
缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶，前面某个人要买100杯…）</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>先来先服务调度算法：按照到达的先后顺序调度，事实上就 是等待时间越久的越优先得到服务。 因此，调度顺序为：P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-52-11.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间     P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7</p>
<p>平均周转时间 = (7+9+8+11)/4 = 8.75</p>
<p>平均带权周转时间 = (1+2.25+8+2.75)/4 = 3.5</p>
<p>平均等待时间 = (0+5+7+7)/4 = 4.75</p>
<hr>
<ul>
<li><strong><u>短作业优先（SJF, Shortest Job First）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li><strong>算法规则</strong><br>
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li>
<li><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</li>
<li><strong>是否可抢占？</strong><br>
SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本</strong>——<strong>最短剩余时间优先算法</strong>（<strong>SRTN</strong>, Shortest Remaining Time Next）</li>
<li><strong>优缺点</strong><br>
优点：“最短的”平均等待时间、平均周转时间<br>
缺点：不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的， 并不一定真实，不一定能做到真正的短作业优先</li>
<li>是否会导致<strong>饥饿</strong><br>
会。如果源源不断地有短作业/进程到来，可能使长作业/进 程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不 到服务，则称为“<strong>饿死</strong>”</li>
</ol>
<p>【<strong>例题1</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>非抢占式</strong>的<strong>短作业优先</strong>调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周 转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达且运行时间最短</strong>的作业/进程。 因此，<strong>调度顺序</strong>为：P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<p>【对比FCFS算法的结果的平均周转时间8.75、平均带权周转时间3.5、平均等待时间4.75，显然SPF算法的 平均等待/周转/带权周转时间都要更低】</p>
<p>【<strong>例题2</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>抢占式</strong>的<strong>短作业优先</strong>调度算法， 计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时 间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>最短剩余时间优先</strong>算法：每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个<strong>进程完成时也需要调度</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-10-34.png" alt=""></p>
<p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_n(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表 示当前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进程剩余时间为 m。各个时刻的情况如下：<br>
0时刻（P1到达） ： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(7)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">7</span><span class="mclose">)</span></span></span></span></span><br>
2时刻（P2到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
4时刻（P3到达）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">3</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、P_2(2)、\mathbf{P_3(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span></span></span></span></span><br>
5时刻（P3完成且P4刚好到达）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">2</mn><mo stretchy="false">)</mo></mrow><mtext>、</mtext><msub><mi>P</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_2(2)}、P_4(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">2</span><span class="mclose">)</span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span><br>
7时刻（P2完成）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo><mtext>、</mtext><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">4</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">4</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">P_1(5)、\mathbf{P_4(4)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">4</span><span class="mclose">)</span></span></span></span></span><br>
11时刻（P4完成） ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{P_1(5)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">5</span><span class="mclose">)</span></span></span></span></span></p>
<p>周转时间 = 完成时间 - 到达时间    P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6</p>
<p>带权周转时间 = 周转时间/运行时间    P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5</p>
<p>等待时间 = 周转时间 – 运行时间    P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2</p>
<p>平均周转时间 = (16+5+1+6)/4 = 7</p>
<p>平均带权周转时间 = (2.28+1.25+1+1.5)/4 = 1.50</p>
<p>平均等待时间 = (9+1+0+2)/4 = 3</p>
<p>【对比非抢占式的短作业优先算法的平均周转时间8、平均带权周转时间2.56、平均等待时间4，显 然抢占式的这几个指标又要更低】</p>
<ul>
<li><strong>注意</strong>几个小细节：</li>
</ul>
<ol>
<li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</li>
<li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”
<ul>
<li>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待 时间、平均周转时间还要更少</li>
<li>应该加上一个条件“在<strong>所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最 少”；</li>
<li>或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</li>
<li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算 法）的平均等待时间、平均周转时间最少”</li>
</ul>
</li>
<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS）， SJF依然可以获得较少的平均等待时间、平均周转时间</li>
<li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li>
</ol>
<hr>
<ul>
<li><strong><u>对FCFS和SJF两种算法的思考…</u></strong></li>
</ul>
<p>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>
<p>SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p>
<p>能不能设计一个算法，即考虑到各个作业 的等待时间，也能兼顾运行时间呢？<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高响应比优先算法</strong></p>
<hr>
<ul>
<li><strong><u>高响应比优先（HRRN, Highest Response Ratio Next）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
要综合考虑作业/进程的等待时间和要求服务的时间</li>
<li><strong>算法规则</strong><br>
在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间 + 要求服务时间}{要求服务时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">等待时间</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">要求服务时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li><strong>用于作业/进程调度</strong><br>
即可用于作业调度，也可用于进程调度</li>
<li><strong>是否可抢占？</strong><br>
<strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
<li><strong>优缺点</strong><br>
综合考虑了等待时间和运行时间（要求服务时间）<br>
等待时间相同时，要求服务时间短的优先（SJF 的优点）<br>
要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br>
对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算 各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_18-50-52.png" alt=""></p>
<p><strong>高响应比优先</strong>算法：<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进 行调度，调度时<strong>计算所有就绪进程的响应比，选响应比最高的</strong>进程上处理机。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_19-07-12.png" alt=""></p>
<p>0时刻：只有 P1到达就绪队列，<strong>P1</strong>上处理机<br>
7时刻（P1主动放弃CPU）： 就绪队列中有 P2 (响应比=(5+4)/4=2.25)、 <strong>P3</strong>((3+1)/1=4)、 P4((2+4)/4=1.5)，<br>
8时刻（P3完成）： <strong>P2</strong>(2.5)、 P4(1.75)<br>
12时刻（P2完成）：就绪队列中只剩下 <strong>P4</strong></p>
<p>周转时间 = 完成时间 - 到达时间    P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11</p>
<p>带权周转时间 = 周转时间/运行时间    P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75</p>
<p>等待时间 = 周转时间 – 运行时间    P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7</p>
<p>平均周转时间 = (7+4+10+11)/4 = 8</p>
<p>平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56</p>
<p>平均等待时间 = (0+3+6+7)/4 = 4</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">考虑到等待时间&amp;运行时间？</th>
<th style="text-align:center">导致饥饿？</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FCFS</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">公平；实现简单</td>
<td style="text-align:center">对短作业不利</td>
<td style="text-align:center">等待时间√ <br />运行时间×</td>
<td style="text-align:center">不会</td>
</tr>
<tr>
<td style="text-align:center">SJF/SPF</td>
<td style="text-align:center">默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN）</td>
<td style="text-align:center">“最短的”平均等待/周转时间；</td>
<td style="text-align:center">对长作业不利，可能导致饥饿；难以做到真正的短作业优先</td>
<td style="text-align:center">等待时间× <br />运行时间√</td>
<td style="text-align:center">会</td>
</tr>
<tr>
<td style="text-align:center">HRRN</td>
<td style="text-align:center">非抢占式</td>
<td style="text-align:center">上述两种算法的权衡 折中，综合考虑的等 待时间和运行时间</td>
<td style="text-align:center"></td>
<td style="text-align:center">等待时间√ <br />运行时间√</td>
<td style="text-align:center">不会</td>
</tr>
</tbody>
</table>
<p>注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但 是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算 法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的 角色。而适合用于<strong>交互式系统</strong>的调度算法将在下个小节介绍…</p>
<p><strong>提示：一定要动手做课后习题</strong>！这些算法特性容易考小题，算法的使用常结合调度算法的评价指标在大题 中考察。</p>
<hr>
<h2 id="2-2-6-调度算法2：时间片轮转-优先级调度-多级反馈队列">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</h2>
<ul>
<li><strong><u>时间片轮转（RR, Round-Robin）</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li><strong>算法规则</strong><br>
按照各进程到达<strong>就绪队列</strong>的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度（只有作业放入内存建立了相应的进程后， 才能被分配处理机时间片）</li>
<li><strong>是否可抢占？</strong><br>
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</li>
<li><strong>优缺点</strong><br>
优点：公平；响应快，适用于<strong>分时操作系统</strong>；<br>
缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
<li>是否会导致<strong>饥饿</strong><br>
不会</li>
<li>补充<br>
时间片太大或太小分别有什么影响？【下面例题中介绍】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>时间片轮转</strong>调度算法，分析时间片大小分别是2、5时的进程运行情况。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-02-10.png" alt=""></p>
<p>时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>
<p>时间片大小为 2 （注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p>
<p>0时刻（<strong>P1(5)</strong> ）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片<br>
2时刻（<strong>P2(4)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(3)）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。 此时P2排在队头，因此让P2上处理机。（<strong>注意</strong>： 2时刻，P1<strong>下处理机</strong>，同一时刻新进程P2到达，如果在 题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>）<br>
4时刻（<strong>P1(3)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾<br>
5时刻（<strong>P3(1)</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此 暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）<br>
6时刻（<strong>P3(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P2(2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发 生调度<br>
7时刻（<strong>P2(2)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行 完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>
9时刻（<strong>P4(6)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机<br>
11时刻（<strong>P1(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机<br>
12时刻（<strong>P4(4)</strong> ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机<br>
14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>
16时刻：所有进程运行结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-10-53.png" alt=""></p>
<p>时间片大小为 5</p>
<p>0时刻（<strong>P1(5)</strong> ）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2(4)</strong> ）：P2到达，但P1时间片尚未结束，因此暂不调度<br>
4时刻（<strong>P2(4)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1)）：P3到达，但P1时间片尚未结束，因此暂不调度<br>
5时刻（<strong>P2(4)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P3(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) ）：P4到达，同时，P1运行结束。发生调度，P2上处理机。<br>
9时刻（<strong>P3(1)</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P4(6) ）：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
10时刻（<strong>P4(6)</strong> ）：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。<br>
15时刻（ ）：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。<br>
16时刻（ ）：P4运行完，主动放弃处理机。所有进程运行完。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>若按照先来先服务调度算法…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-11-23.png" alt=""></p>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且会<strong>增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。<br>
【比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应 可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调 试命令，可能需要等待9秒才能被系统响应】</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理%进程切换，从而导致实际用于进程执行的时间比例减小。可见<strong>时间片也不能太小</strong>。<br>
【一般来说，设计 时间片时要让切换进程的开销占比不超过1%】</p>
<hr>
<ul>
<li><strong><u>优先级调度算法</u></strong></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
<li><strong>算法规则</strong><br>
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li><strong>用于作业/进程调度</strong><br>
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
<li><strong>是否可抢占？</strong><br>
抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>
<li><strong>优缺点</strong><br>
优点：用优先级区分紧急程度、重要程度，适用于<strong>实时操作系统</strong>。可灵活地调整对各种作业/进程的偏好程度。<br>
缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>是否会导致<strong>饥饿</strong><br>
会</li>
<li>补充：<br>
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置<br>
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。<br>
<strong>静态优先级</strong>：创建进程时确定，之后一直不变。<br>
<strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ol>
<p>【<strong>思考</strong>】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
如何合理地设置各类进程的优先级？<br>
通常：<br>
系统进程优先级 <strong>高于</strong> 用户进程<br>
前台进程优先级 <strong>高于</strong> 后台进程<br>
操作系统更<strong>偏好 I/O型进程（或称 I/O繁忙型进程）</strong><br>
注：与I/O型进程相对的是<strong>计算型进程（或称 CPU繁忙型进程)</strong><br>
【I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话， 则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p>
<p>如果采用的是动态优先级，什么时候应该调整？<br>
可以从追求公平、提升资源利用率等角度考虑<br>
如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级<br>
如果某进程占用处理机运行了很长时间，则可适当降低其优先级<br>
如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p>
<p>【<strong>例题1</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>非抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
7时刻（P2、<strong>P3</strong>、P4）：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。<br>
8时刻（ <strong>P2</strong>、P4 ）：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机<br>
12时刻（ <strong>P4</strong> ）：P2完成，就绪队列只剩P4，P4上处理机。<br>
16时刻（ ）：P4完成，所有进程都结束</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-23-54.png" alt=""></p>
<p>【<strong>例题2</strong>】</p>
<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>抢占式</strong>的<strong>优先级</strong>调度算法，分析进程运行情况。（注：<strong>优先数</strong>越大，<strong>优先级</strong>越高）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-20-52.png" alt=""></p>
<p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>优先级最高</strong>的进程。当前进程<strong>主动放弃处理机</strong>时发生调度。另 外，当<strong>就绪队列发生改变时</strong>也需要检查是会发生抢占。</p>
<p>注：以下括号内表示当前处于就绪队列的进程<br>
0时刻（<strong>P1</strong>）：只有P1到达，P1上处理机。<br>
2时刻（<strong>P2</strong>）：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。<br>
4时刻（P1、<strong>P3</strong>）：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。<br>
5时刻（P1、<strong>P2</strong>、P4）：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列， 因此选择P2上处理机<br>
7时刻（P1、<strong>P4</strong>）：P2完成，就绪队列只剩P1、P4，P4上处理机。<br>
11时刻（<strong>P1</strong> ）：P4完成，P1上处理机<br>
16时刻（）：P1完成，所有进程均完成</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-26-59.png" alt=""></p>
<hr>
<ul>
<li><strong><u>思考</u></strong></li>
</ul>
<p>FCFS算法的优点是公平</p>
<p>SJF 算法的优点是能尽快处理完短作业， 平均等待/周转时间等参数很优秀</p>
<p>时间片轮转调度算法可以让各个进程得 到及时的响应</p>
<p>优先级调度算法可以灵活地调整各种进 程被服务的机会</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？</p>
<p><strong>多级反馈队列调度算法</strong></p>
<hr>
<ul>
<li><u><strong>多级反馈队列调度算法</strong></u></li>
</ul>
<ol>
<li><strong>算法思想</strong><br>
对其他调度算法的折中权衡</li>
<li><strong>算法规则</strong>
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
</ol>
</li>
<li><strong>用于作业/进程调度</strong><br>
用于进程调度</li>
<li><strong>是否可抢占？</strong><br>
<strong>抢占式</strong>的算法。在 k 级队列的进程运行过程中，若更上级的队列 （1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的 队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列 队尾。</li>
<li><strong>优缺点</strong><br>
对各类型进程相对公平（FCFS的优点）；<br>
每个新到达的进程都可以 很快就得到响应（RR的优点）；<br>
短进程只用较少的时间就可完成 （SPF的优点）；<br>
不必实现估计进程的运行时间（避免用户作假）；<br>
可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密 集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级）</li>
<li>是否会导致<strong>饥饿</strong><br>
会【一直来短进程的话，有可能一直在高优先级队列处理，被降级的会饥饿】</li>
</ol>
<p>【<strong>例题</strong>】各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>多级反馈队列调度算法</strong>，分析进程运行的过程。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-47-19.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_20-55-40.png" alt=""></p>
<p>P1(1) —&gt; P2(1) —&gt; P1(2) —&gt; P2(1)—&gt; P3(1)—&gt; P2(2) —&gt; P1(4) —&gt; P1(1)</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-05_22-22-51.gif" alt=""></p>
<p>设置多级就绪队列，各级队列<strong>优先级</strong>从<strong>高到低</strong>，<strong>时间片</strong>从<strong>小到大新进程</strong>到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程<strong>还未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>已经在最下级</strong>的队列，则<strong>重新放回最下级</strong>队列队尾<br>
只有第 <strong>k 级队列为空</strong>时，才会<strong>为 k+1 级</strong>队头的进程<strong>分配时间片</strong><br>
<strong>被抢占处理机</strong>的进程<strong>重新放回原队列</strong>队尾</p>
<hr>
<ul>
<li><strong><u>三种调度算法对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">可抢占？</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">导致饥饿？</th>
<th style="text-align:center">补充</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">时间片轮转</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">公平，适用于分时系统</td>
<td style="text-align:center">频繁切换有开销，不区分优先级</td>
<td style="text-align:center">不会</td>
<td style="text-align:center">时间片太大或太小有何 影响？</td>
</tr>
<tr>
<td style="text-align:center">优先级调度</td>
<td style="text-align:center">有抢占式的，也有非抢占式的。注意做题时的区</td>
<td style="text-align:center">区分优先级， 适用于实时系统</td>
<td style="text-align:center">可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center">动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？</td>
</tr>
<tr>
<td style="text-align:center">多级反馈队列</td>
<td style="text-align:center">抢占式</td>
<td style="text-align:center">平衡优秀 666</td>
<td style="text-align:center">一般不说它有缺点，不过可能导致饥饿</td>
<td style="text-align:center">会</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括 分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也 能较好地满足交互式系统的需求。因此这三种算法适合用于<strong>交互式系统</strong>。（比如UNIX使用的就是多级反馈 队列调度算法）</p>
<p><strong>提示：一定要动手做课后习题</strong></p>
<hr>
<h2 id="2-2-5-调度算法3：多级队列">2.2.5 调度算法3：多级队列</h2>
<ul>
<li><strong><u>多级队列调度算法</u></strong></li>
</ul>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-06_08-38-34.png" alt=""></p>
<p>队列之间可采取固定优先级，或时间片划分<br>
固定优先级: 高优先级空时低优先级进程才能被调度<br>
时间片划分:如三个队列分配时间50%、40%、10%</p>
<p>各队列可采用不同的调度策略，如：<br>
系统进程队列采用 优先级调度<br>
交互式队列采用 RR<br>
批处理队列采用 FCFS</p>
<hr>
<h2 id="2-3-1-进程同步-进程互斥">2.3.1 进程同步 进程互斥</h2>
<ul>
<li><strong><u>什么是进程同步</u></strong></li>
</ul>
<p>知识点回顾：进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<p>【<strong>例1</strong>】老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""></p>
<p>但是这个时候：<br>
女一号只想做老渣的初恋<br>
女二号只想交一个有恋爱经验的渣男</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>那么，老渣在并发执行这两个约会进程的时候，<br>
就必须保证“一号的指令2” 一定要在“二号的指令1”之前执行。</p>
<p>操作系统要提供“<strong>进程同步</strong>机制”来实现上述需求。</p>
<p>【<strong>例2</strong>】进程通信——管道通信</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_22-46-57.png" alt=""></p>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>读数据</strong>”的顺序来执行的。 如何解决这种异步问题，就是 “<strong>进程同步</strong>”所讨论的内容。</p>
<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<hr>
<ul>
<li><strong><u>什么是进程互斥</u></strong></li>
</ul>
<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
<p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。</p>
<ul>
<li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;		<span class="comment">// 进入区</span></span><br><span class="line">    critical section;	<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;		<span class="comment">// 退出区</span></span><br><span class="line">    remainder section; 	<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">区</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入区</td>
<td>负责检查是否可进入临界区，若可进入，则应<br />设置<strong>正在访问临界资源的标志</strong>（可理解为“上锁”），<br />以阻止其他进程同时进入临界区</td>
</tr>
<tr>
<td style="text-align:center">临界区</td>
<td><strong>访问临界资源</strong>的那段代码</td>
</tr>
<tr>
<td style="text-align:center">退出区</td>
<td>负责解除<strong>正在访问临界资源的标志</strong>（可理解为“解锁”）</td>
</tr>
<tr>
<td style="text-align:center">剩余区</td>
<td>做其他处理</td>
</tr>
</tbody>
</table>
<p>注意：<br>
<strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。<br>
<strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段。<br>
临界区也可称为“临界段”。</p>
<ul>
<li>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下<strong>原则</strong>：</li>
</ul>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<hr>
<h2 id="2-3-2-进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2>
<blockquote>
<p>学习提示：</p>
<ol>
<li>理解各个算法的思想、原理</li>
<li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li>
<li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li>
</ol>
</blockquote>
<ul>
<li><strong><u>如果没有注意进程互斥？</u></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程A、进程B在系统中并发地运行</span></span><br><span class="line">进程A： </span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程B：</span><br><span class="line">&#123;</span><br><span class="line">	其他代码；</span><br><span class="line">	使用打印机；</span><br><span class="line">	其他代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调度A上处理机运行<br>
当A在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度B让它上处理机运行<br>
进程B也在使用打印机</p>
<p>结局：A、B 的打印内容混在一起了【错误的，不希望看到的】</p>
<p>如何实现进程互斥？</p>
<hr>
<ul>
<li><strong><u>单标志法</u></strong></li>
</ul>
<p>算法思想：两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);	<span class="comment">// 1 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">// 3 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 4 剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);	<span class="comment">// 5 进入区</span></span><br><span class="line">critical section;	<span class="comment">// 6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">// 7 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// 8 剩余区</span></span><br></pre></td></tr></table></figure>
<p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。<br>
若 P1 先上处理机运行，则会一直卡在5。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。<br>
代码1不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在5。<br>
只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</p>
<p>因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>只能按 P0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> P1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。<br>
因此，<strong>单标志法</strong>存在的<strong>主要问题</strong>是：<strong>违背“空闲让进”原则</strong>。</p>
<hr>
<ul>
<li><u><strong>双标志先检查法</strong></u></li>
</ul>
<p>算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如 “flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 1 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 2 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 5 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6 3 7….的顺序执行，P0 和 P1 将会同时访问临界区。 因此，<strong>双标志先检查法</strong>的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。<br>
原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<hr>
<ul>
<li><strong><u>双标志后检查法</u></strong></li>
</ul>
<p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查” 的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">// 2 如果此时 P1 想进入临界区，P0 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 3 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 4 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 5 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">// 6 如果此时 P0 想进入临界区，P1 就一直循环等待 &quot;检查&quot;</span></span><br><span class="line">critical section;	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 8 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>若按照 1 5 2 6….的顺序执行，P0 和 P1 将都无法进入临界区<br>
因此，双标志后检查法虽然<strong>解决了“忙则等待”的问题</strong>，但是<strong>又违背了“空闲让进”和“有限等待” 原则</strong>，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。<br>
两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<hr>
<ul>
<li><strong><u>Peterson 算法</u></strong></li>
</ul>
<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;	<span class="comment">// 表示当前允许进入临界资源的进程号</span></span><br><span class="line"><span class="comment">// 【turn 变量背后的逻辑：表达“谦让”】</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2l</span>;	<span class="comment">// 表示进入临界区意愿的数组 </span></span><br><span class="line"><span class="comment">// 【理解背后的含义:“表达意愿&quot;】</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P0进程===</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">// 1 标记为 P0 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">// 2 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);	<span class="comment">// 3 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;	<span class="comment">// 4 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">// 5 访问完临界区，修改标记为 P0 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===P1进程===</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">// 6 标记为 P1 进程想要进入临界区 “上锁”</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">// 7 表示可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);	<span class="comment">// 8 &quot;检查&quot; 检查对方是否也想使用，且最后一次是不是自己“让梨”</span></span><br><span class="line">critical section;	<span class="comment">// 9 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">// 10 访问完临界区，修改标记为 P1 不想使用临界区 “解锁”</span></span><br><span class="line">remainder section;	</span><br></pre></td></tr></table></figure>
<p>动手推导： 按不同的顺序穿插 执行会发生什么？<br>
1 2 3  6 7 8…    1 6 2 3…   1 3 6 7 8…   1 6 2 7 8…</p>
<p>Peterson 算法用软件方法解决了进 程互斥问题，<strong>遵循了空闲让进、忙 则等待、有限等待 三个原则</strong>，但是 依然<strong>未遵循让权等待</strong>的原则。</p>
<p>Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<hr>
<h2 id="2-3-3-进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2>
<ul>
<li><strong><u>中断屏蔽方法</u></strong></li>
</ul>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为 止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断； <span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断； <span class="comment">// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>优点：简单、高效<br>
缺点：不适用于多处理机【多个处理机同时访问临界区】；<br>
只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令</u></strong></li>
</ul>
<p>简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令<br>
TSL 指令<strong>是用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true 表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line">	<span class="type">bool</span> old;		</span><br><span class="line">	old = *lock; 	<span class="comment">// old用来存放Lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; 	<span class="comment">// 无论之前是否已加锁，都将Lock设为true</span></span><br><span class="line">	<span class="keyword">return</span> old;		<span class="comment">// 返回Lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用 TSL 指今实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// &quot;上锁“并检查临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;	<span class="comment">// “解锁”</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。<br>
优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br>
缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>Swap指令</u></strong></li>
</ul>
<p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。<br>
Swap 指令是<strong>用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑【只是逻辑】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap 指令的作用是交换两个变量的值</span></span><br><span class="line">Swap (<span class="type">bool</span> *a，<span class="type">bool</span> *b) &#123;</span><br><span class="line">	<span class="type">bool</span> temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// Lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">    Swap (&amp;lock，&amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。</p>
<hr>
<ul>
<li><strong><u>TestAndSet指令和Swap指令的逻辑</u></strong></li>
</ul>
<ol>
<li>old记录是否已被上锁;</li>
<li>再将lock设为 true;</li>
<li>检查临界区是否已被上锁(若已上锁，则循环重复前几步)</li>
</ol>
<p>总之就是为了：<strong>检查并上锁</strong></p>
<hr>
<h2 id="2-3-4-互斥锁">2.3.4 互斥锁</h2>
<ul>
<li><strong><u>进程互斥：锁</u></strong></li>
</ul>
<p>解决临界区最简单的工具就是<strong>互斥锁 (mutex lock)</strong> 。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 <code>acquire()</code> 获得锁，而函数 <code>release()</code> 释放锁。</p>
<p>每个互斥锁有一个布尔变量 <code>available</code>，表示锁是否可用。如果锁是可用的，调用 acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻寒，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);	<span class="comment">// 忙等待</span></span><br><span class="line">	available = <span class="literal">false</span>;	<span class="comment">// 获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">	available = <span class="literal">true</span>;	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire()或release()的执行必须是<strong>原子</strong>操作，因此互斥锁通常<strong>采用硬件</strong>机制来实现。</p>
<p>互斥锁的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必约连续循环调用 acquire()。当多个进程共享同一 CPU 时，就浪费了CPU 周期。因此，互斥锁通用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong> ，如TSL指令、swap指令、单标志法</p>
<p>【<strong>特性</strong>】:</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<hr>
<h2 id="2-3-4-信号量机制">2.3.4 信号量机制</h2>
<ul>
<li><strong><u>复习回顾</u></strong></li>
</ul>
<p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题?</p>
<p>进程互斥的四种软件实现方式 (单标志法、双标志先检查、双标志后检查、Peterson算法)</p>
<p>进程互斥的三种硬件实现方式 (中断屏蔽方法、TS/TSL指令、Swap/XCHG指令)</p>
<ol>
<li>在双标志先检查法中**，进入区的“检查”、“上锁”操作无法一气呵成**，从而导致了两个进程有可能同时进入临界区的问题:</li>
<li>所有的解决方案<strong>都无法实现“让权等待“</strong></li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法–<strong>信号量机制</strong></p>
<hr>
<ul>
<li><strong><u>信号量机制</u></strong></li>
</ul>
<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p><strong>信号量</strong>其实就是一个变量 (<strong>可以是一个整数，也可以是更复杂的记录型变量</strong>)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如: 系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p><strong>一对原语</strong>: <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p>
<p>wait、signal 原语常<strong>简称为 P、V操作</strong> (来自荷兰语 proberen 和 verhogen)。因此，做题的时候<strong>常</strong>把wait(S)、signal(S) 两个操作<strong>分别写为 P(S)、V(S)</strong></p>
<hr>
<ul>
<li><strong><u>信号量机制——整型信号量</u></strong></li>
</ul>
<p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。<br>
【与普通整数变量的区别： 对信号量的操作只有三种， 即 初始化、P操作、V操作】</p>
<p>Eg ：某计算机系统中有一台打印机…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整型信号量s，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --“检查”和“上锁”一气呵成，避免了并发、异步导致的问题--</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;	<span class="comment">// wait 原语，相当于“进入区”</span></span><br><span class="line">    <span class="comment">// --存在的问题：不满足“让权等待”原则，会发生“忙等”--</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);	<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S=S<span class="number">-1</span>;			<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> s)</span> &#123;	<span class="comment">// signal 原语，相当于“退出区&quot;</span></span><br><span class="line">    S=S+<span class="number">1</span>;l				<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">进程P0:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程P1:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">进程Pn:</span><br><span class="line">...</span><br><span class="line">wait(S);		<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...	<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(s);		<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>
<p><strong><u>信号量机制——记录型信号量</u></strong></p>
<p><strong>大题、小题超高频出题点</strong></p>
</li>
</ul>
<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表 示的信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录型信号量的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;			<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>	<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过 wait 原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(s.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【如果剩余资源数不够，使用block原语使进程从</span></span><br><span class="line"><span class="comment">// 运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过 signal 原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【释放资源后，若还有别的进程在等待这种资源，则使用</span></span><br><span class="line"><span class="comment">// wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态】</span></span><br></pre></td></tr></table></figure>
<p>Eg：某计算机系统中有2台打印机…，<br>
则可在初始化信号量 S 时将 S.value 的值设为 2，队列 S.L 设置为空</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/GIF_2023-05-06_9-44-38.gif" alt=""></p>
<p>在考研题目中 wait(S)、signal(S) 也可以记为 P(S)、V(S)， 这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong> 。</p>
<p><strong>S.value 的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p>
<p>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>（当前运行的进程从<strong>运行态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待”原则&quot;</strong> ， 不会出现“忙等”现象。</p>
<p>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加1， 若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类 资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态</strong>）。</p>
<p>注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量。</p>
<hr>
<blockquote>
<p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，<strong>一个信号量对应一种资源</strong></p>
<p>信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<p>P( S ) —— 申请一个资源S，如果<strong>资源不够就阻塞等待</strong></p>
<p>V( S ) —— 释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong></p>
</blockquote>
<h1>第三章 内存管理</h1>
<h1>第四章 内存管理</h1>
<h1>第五章 输入/输出（I/O）管理</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io">ggw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ggw2021.github.io" target="_blank">ggw和xpl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">王道计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/12/%E4%BA%8C%E5%8F%89%E6%A0%91x/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="王道计算机网络"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">王道计算机网络</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1.1 操作系统的概念、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.1.2 操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 操作系统的发展与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3.1 操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">1.3.2 中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.3.3 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">1.4.1 操作系统的体系结构（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">1.4.2 操作系统的体系结构（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-text">1.5 操作系统的引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.1.2 进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.5 线程概念 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.6 线程的实现方式 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.7 线程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 调度的概念、层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机、切换与过程调度方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E9%97%B2%E9%80%9B%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.2.3 调度器和闲逛程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.4 调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%951%EF%BC%9A%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-text">2.2.5 调度算法1：先来先服务 最短作业优先 最高响应比优先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-6-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952%EF%BC%9A%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">2.2.6 调度算法2：时间片轮转 优先级调度 多级反馈队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%953%EF%BC%9A%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">2.2.5 调度算法3：多级队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3.1 进程同步 进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-4-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">2.3.4 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.4 信号量机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第五章 输入&#x2F;输出（I&#x2F;O）管理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 By ggw</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>