<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王道操作系统 | ggw和xpl的博客</title><meta name="author" content="ggw"><meta name="copyright" content="ggw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:type" content="article">
<meta property="og:title" content="王道操作系统">
<meta property="og:url" content="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ggw和xpl的博客">
<meta property="og:description" content="【王道考研操作系统】 微博大号–@王道咸鱼老师-计算机考研 微博小号–@王道楼楼老师-计算机考研 第一章 计算机系统概述 1.1.1 操作系统的概念、功能  大家都熟悉的操作系统     操作系统的概念（定义）  一台电脑的诞生~ Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机） Step 2：出售前安装操作系统 Step 3：用户安装应用程序（eg：QQ） Step">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg">
<meta property="article:published_time" content="2023-05-03T11:13:08.565Z">
<meta property="article:modified_time" content="2023-05-05T09:15:54.557Z">
<meta property="article:author" content="ggw">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg"><link rel="shortcut icon" href="/static/imgs/paipai.ico"><link rel="canonical" href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: ggw","link":"链接: ","source":"来源: ggw和xpl的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-05 17:15:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/C5EAC1F2A55D115DB1654F59F20A9934.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggw和xpl的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-03T11:13:08.565Z" title="发表于 2023-05-03 19:13:08">2023-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-05T09:15:54.557Z" title="更新于 2023-05-05 17:15:54">2023-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王道操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YE411D7nH?t=3.0&amp;p=2">【王道考研操作系统】</a></p>
<p>微博大号–@王道咸鱼老师-计算机考研<br>
微博小号–@王道楼楼老师-计算机考研</p>
<h1>第一章 计算机系统概述</h1>
<h2 id="1-1-1-操作系统的概念、功能">1.1.1 操作系统的概念、功能</h2>
<ul>
<li><strong><u>大家都熟悉的操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_18-59-48.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的概念（定义）</strong></u></li>
</ul>
<p>一台电脑的诞生~<br>
Step 1：厂家组装一台裸机（裸机是没有配置操作系统和其他软件的电子计算机）<br>
Step 2：出售前安装操作系统<br>
Step 3：用户安装应用程序（eg：QQ）<br>
Step 4：使用 QQ 聊天</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-16-00.jpg" alt=""></p>
<p><strong>操作系统</strong>（Operating System， OS）</p>
<ul>
<li>是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>（<u>①操作系统是系统资源的管理者</u>）资源，并合理地组织调度计算机的工作和资源的分配；</li>
<li>以<strong>提供给用户和其他软件方便的接口和环境</strong>（<u>②向上层提供方便易用的服务</u>）；</li>
<li>它是计算机系统中最基本的<strong>系统软件</strong>（<u>③是最接近硬件的一层软件</u>）。</li>
</ul>
<p>直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-25-08.jpg" alt=""></p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为系统资源的管理者</strong></u>
<ul>
<li>提供的功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标：
<ul>
<li>安全、高效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>补充知识：执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p>
<p>用QQ和朋友视频聊天的过程：<br>
Step 1：在各个文件夹中找到 QQ 安装的位置（如 D:/Tencent/QQ/Bin）【逐层打开文件夹，找到QQ.exe 这个程序（可执行文件）的存放位置】<br>
Step 2：双击打开 QQ.exe 【需要把该程序相关数据放入内存】<br>
Step 3：QQ 程序正常运行 【对应的进程被处理机（CPU）处理】<br>
Step 4：开始和朋友视频聊天 【需要将摄像头设备分配给进程】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——向上层提供方便易用的服务</strong></u></li>
</ul>
<p><strong>封装思想</strong>：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-35-16.jpg" alt=""></p>
<p><strong>GUI</strong>：图形化用户接口（Graphical User Interface） 【很多现代操作系统都提供GUI】<br>
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。<br>
例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p>
<p><strong>联机命令接口</strong>实例（Windows系统） 联机命令接口=<strong>交互式</strong>命令接口<br>
Step 1：win键+R<br>
Step 2：输入cmd，按回车，打开命令解释器<br>
Step 3：尝试使用 time 命令<br>
【特点：用户说一句， 系统跟着做一句】</p>
<p><strong>脱机命令接口</strong>实例（Windows系统） 脱机命令接口=<strong>批处理</strong>命令接口<br>
使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个。<br>
【特点：用户说一堆， 系统跟着做一堆】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-40-45.jpg" alt=""></p>
<p>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。<br>
如：写C语言“Hello world”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-45-43.jpg" alt=""><br>
系统调用类似于函数调用，是应用程 序请求操作系统服务的唯一方式。<strong>在有的教材中： 系统调用=广义指令</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-50-22.jpg" alt=""><br>
【有的教材中把命令接口和程序接口统称为“用户接口”，意思就是说狭义的用户接口不包括GUI。】</p>
<hr>
<ul>
<li><u><strong>操作系统的功能和目标——作为最接近硬件的层次</strong></u></li>
</ul>
<p>需要实现<strong>对硬件机器的拓展</strong>；<br>
没有任何软件支持的计算机成为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器；<br>
通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>
<p>类比汽车： 发动机——只会转；轮胎——只会滚；<br>
在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展</p>
<p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可</p>
<hr>
<h2 id="1-1-2-操作系统的特征">1.1.2 操作系统的特征</h2>
<blockquote>
<ul>
<li>并发</li>
<li>共享</li>
</ul>
<p>并发和共享是两个最基本的特征，二者互为存在条件。</p>
<ul>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>重要考点：<br>
理解并发和并行的区别<br>
并发和共享互为存在条件<br>
没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</p>
</blockquote>
<ul>
<li><u><strong>操作系统的特征——并发</strong></u></li>
</ul>
<p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。<br>
常考易混概念——<strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p>
<p>并发 VS 并行：<br>
eg：假设小渣和老渣每人有两个女朋友。任务1：和一号约会；任务2：和二号约会…<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_20-10-44.jpg" alt=""></p>
<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。<br>
操作系统就是伴随着“多道程序技术”（后面介绍）而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p>
<p>注意（<strong>重要考点</strong>）：<br>
<strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行<br>
<strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行<br>
比如Intel 的第八代 i3 处理器就是 <strong>4 核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>；【即使是对于4核CPU来说，只要有4个以 上的程序需要“同时”运行，那么并发性依然是必不可少的，因此<strong>并发性是操作系统一个最基本的特性</strong>】</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——共享</strong></u></li>
</ul>
<p><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li>
<p><strong>两种资源共享方式</strong></p>
<ul>
<li>
<p><strong>互斥共享方式</strong>：<br>
系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></p>
</li>
<li>
<p><strong>同时共享方式</strong>：</p>
<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></p>
</li>
</ul>
</li>
</ul>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
<p>生活实例：<br>
互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br>
同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——并发和共享的关系</strong></u></li>
</ul>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。<br>
<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p>通过上述例子来看并发与共享的关系：<br>
使用QQ发送文件A，同时使用微信发送文件B。<br>
1.两个进程正在并发执行（并发性） 【如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义】<br>
2.需要共享地访问硬盘资源（共享性）【如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发】</p>
<p><strong>二者互为存在条件。</strong></p>
<hr>
<ul>
<li><strong><u>操作系统的特征——虚拟</u></strong></li>
</ul>
<p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p>Yo~用一个例子来理解<br>
背景知识：一个程序<strong>需要放入内存</strong>并给它<strong>分配CPU</strong>才能执行</p>
<p>GTA5需要4GB的运行内存，<br>
QQ 需要256MB的内存，<br>
迅雷需要256MB的内存，<br>
网易云音乐需要256MB的内存……<br>
我的电脑：4GB内存<br>
问题：这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？<br>
答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>空分复用技术</strong>” 。</p>
<p>某单核CPU的计算机中，用户打开了以下软件。。。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-18-58.jpg" alt=""><br>
问题：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU 的电脑中能同时运行这么多个程序呢？ 答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有 6个CPU在同时为自己服务。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 虚拟技术中的“<strong>时分复用技术</strong>” 。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p>
<ul>
<li><strong>虚拟技术</strong>
<ul>
<li><strong>空分复用技术</strong>（如虚拟存储技术）</li>
<li><strong>时分复用技术</strong>（如虚拟处理器）</li>
</ul>
</li>
</ul>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p>
<hr>
<ul>
<li><u><strong>操作系统的特征——异步</strong></u></li>
</ul>
<p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>老渣要和两个女孩并发约会：</p>
<ul>
<li>第一道程序：
<ul>
<li>一号的指令1：老渣陪我吃饭</li>
<li>一号的指令2：老渣把心给我</li>
</ul>
</li>
<li>第二道程序：
<ul>
<li>二号的指令1：老渣把心给我</li>
<li>二号的指令2：老渣陪我吃饭</li>
</ul>
</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_21-37-13.jpg" alt=""><br>
与一、二号的约会 = 两道并发执行的程序 老渣的心 = 有限的系统资源</p>
<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</p>
<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p>
<hr>
<h2 id="1-2-操作系统的发展与分类">1.2 操作系统的发展与分类</h2>
<ul>
<li><strong><u>手工操作阶段</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-40-24.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>批处理阶段——单道批处理系统</u></strong></li>
</ul>
<p>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-43-53.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_08-48-41.jpg" alt=""></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br>
主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p>
<hr>
<ul>
<li><strong><u>批处理阶段——多道批处理系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-04.jpg" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-03-54.jpg" alt=""></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br>
主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）</p>
<hr>
<ul>
<li><strong><u>分时操作系统</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_09-14-13.jpg" alt=""></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。<br>
主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br>
主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
<hr>
<ul>
<li><strong><u>实时操作系统</u></strong>
<ul>
<li>硬实时系统<br>
必须在绝对严格的规定时间内完成处理<br>
如：导弹控制系统、自动驾驶系统</li>
<li>软实时系统<br>
能接受偶尔违反时间规定<br>
如：12306火车订票系统</li>
</ul>
</li>
</ul>
<p>实时操作系统： 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br>
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<hr>
<ul>
<li><strong><u>其他几种操作系统</u></strong></li>
</ul>
<p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）</p>
<p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>
<p>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。</p>
<hr>
<h2 id="1-3-1-操作系统的运行机制">1.3.1 操作系统的运行机制</h2>
<blockquote>
<p>Tips：</p>
<ol>
<li>都是高频考点，很重要</li>
<li>初学者不完全理解没关系， 放心大胆地往后学，随着后面章节的学习，理解会逐渐加深</li>
</ol>
</blockquote>
<ul>
<li><strong><u>预备知识：程序是如何运行的？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-19-00.jpg" alt=""></p>
<p>程序运行的过程其实就 是CPU执行一条一条的机器指令的过程</p>
<p>“指令”就是处理器（CPU）能识别、执行的最基本命令</p>
<p>注：很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也 称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别 开。本节中的“指令”指二进制机器指令</p>
<hr>
<ul>
<li><strong><u>内核程序 v.s. 应用程序</u></strong></li>
</ul>
<p>我们普通程序员写的程序就是“<strong>应用程序</strong>”</p>
<p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”<br>
由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong> ” 内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核） 操作系统的功能未必都在内核中，如图形化用户界面 GUI</p>
<hr>
<ul>
<li><strong><u>特权指令 v.s. 非特权指令</u></strong></li>
</ul>
<p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU 执行一条指令前就能判断出其类型</p>
<p>应用程序只能使用“非特权指令”，如： 加法指令、减法指令等</p>
<p>操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</p>
<hr>
<ul>
<li><strong><u>内核态 v.s. 用户态</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_10-25-21.jpg" alt=""></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 问题：如何实现CPU状态的切换？</p>
<p>CPU 有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”<br>
处于<strong>内核态时</strong>，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong><br>
处于<strong>用户态时</strong>，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p>
<p>拓展：CPU 中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong> ，其中有个二进制位，1表示 “内核态”，0表示“用户态”</p>
<p><strong>别名</strong>：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong></p>
<hr>
<ul>
<li><strong><u>内核态、用户态 的切换</u></strong></li>
</ul>
<table>
    <tr>
        <td>
            一个故事：</br>
    ① 刚开机时，CPU 为“<b>内核态</b>”，操作系统内核程序先上CPU运行</br>
② 开机完成后，用户可以启动某个应用程序</br> 
③ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行</br>
【操作系统内核在让出CPU之前，会<b>用一条特权指令把 PSW 的标志位设置为“用户态”</b>】</br>
④ 应用程序运行在“用户态”</br> 
⑤ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…</br> 
⑥ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”</br> 
⑦ 这个非法事件会引发一个<b>中断信号</b></br>
【<b>CPU检测到中断信号后</b>，会立即<b>变为“核心态”</b>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序】</br> 
⑧ “中断”使操作系统再次夺回CPU的控制权</br> ⑨ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</br>
        </td>
    </tr>    
</table>
**内核态** $\to$ **用户态**：**执行一条特权指令**——**修改PSW**的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权 
**用户态** $\to$ **内核态**：由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权
【除了非法使用特权指令之外，还有很多事件 会触发中断信号。一个共性是，**但凡需要操作系统介入的地方，都会触发中断信号**】
<hr>
<h2 id="1-3-2-中断和异常">1.3.2 中断和异常</h2>
<ul>
<li><strong><u>中断的作用</u></strong><br>
“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
</ul>
<p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>（是整个系统的管理者），一种是<strong>应用程序</strong></p>
<p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）</p>
<p>“中断”是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径</p>
<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序<br>
没有中断机制，就不可能实现操作系统，不可能实现程序并发</p>
<hr>
<ul>
<li><strong><u>中断的类型</u></strong>
<ul>
<li><strong>内中断</strong><br>
与当前执行的指令有关， 中断信号来源于CPU内部</li>
<li><strong>外中断</strong><br>
与当前执行的指令无关， 中断信号来源于CPU外部</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><u><strong>内中断的例子</strong></u></li>
</ul>
<p>例子 1：试图在用户态下执行特权指令<br>
例子 2：执行除法指令时发现除数为 0<br>
【若当前执行的指令是非法的，则会引发一个中断信号】</p>
<p>例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<br>
【执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “<strong>系统调用”就是通过陷入指令完成的</strong>】</p>
<hr>
<ul>
<li><strong><u>外中断的例子</u></strong></li>
</ul>
<p>例子1：时钟中断——由时钟部件发来的中断信号</p>
<p>例子2：I/O中断——由输入/输出设备发来的中断信号</p>
<hr>
<ul>
<li><strong><u>中断的分类</u></strong>【广义的中断】
<ul>
<li>内中断（也称<strong>异常</strong>、例外）
<ul>
<li>陷阱、陷入（trap）【由陷入指令引发，是应用程序故意引发的】</li>
<li>故障（fault）【由错误条件引起的，可能被 内核程序修复。内核程序修 复故障后会把 CPU使用权还 给应用程序，让它继续执行 下去。如：缺页故障。】</li>
<li>终止（abort）【由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序。如： 整数除0、非法使用特权指令】</li>
</ul>
</li>
<li>外中断（也称中断）【狭义的中断】
<ul>
<li>时钟中断</li>
<li>I/O中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常“</p>
<hr>
<ul>
<li><u><strong>中断机制的基本原理</strong></u></li>
</ul>
<p>检测中断信号：</p>
<ul>
<li>内中断：CPU在<strong>执行指令时</strong>会检查是否有异常发生</li>
<li>外中断：<strong>每个指令周期末尾</strong>，CPU都会检查是否有外中断信号需要处理</li>
</ul>
<p><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-07-58.jpg" alt=""><br>
显然，中断处理程序一定是内核程序，需要运行在“内核态”</p>
<hr>
<h2 id="1-3-3-系统调用">1.3.3 系统调用</h2>
<ul>
<li><strong><u>什么是系统调用，有何作用？</u></strong></li>
</ul>
<p>知识点回顾：<br>
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
<hr>
<ul>
<li><strong><u>系统调用与库函数的区别</u></strong></li>
</ul>
<table>
    <tr>
        <td>普通应用程序</td>
        <td>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
    </tr>
    <tr>
        <td>编程语言</td>
        <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>
    </tr>
    <tr>
        <td>操作系统</td>
        <td>向上提供系统调用，使得上层程序能请求内核的服务</td>
    </tr>
    <tr>
        <td>裸机</td>
        <td></td>
    </tr>
</table>
<p>不涉及系统调用的库函数：如的“取绝对值”的函数 涉及系统调用的库函数：如“创建一个新文件”的函数</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-21-42.jpg" alt=""></p>
<hr>
<ul>
<li><strong><u>小例子：为什么系统调用是必须的？</u></strong></li>
</ul>
<p>生活场景：去学校打印店打印论文，你按下了 WPS 的“打印”选项，打印机开 始工作。<br>
你的论文打印到一半时，另一位同学按下了 Word 的“打印”按钮，开始打印他自己的论文。</p>
<p>思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？</p>
<p>两个进程并发运行，打印机设备交替地收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…</p>
<p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p>
<hr>
<ul>
<li><strong><u>什么功能要用到系统调用？</u></strong></li>
</ul>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>
<ul>
<li><strong>系统调用（按功能分类）</strong>
<ul>
<li><strong>设备管理</strong>：完成设备的 <strong>请求/释放/启动</strong> 等功能</li>
<li><strong>文件管理</strong>：完成文件的 <strong>读/写/创建/删除</strong> 等功能</li>
<li><strong>进程管理</strong>：完成进程的 <strong>创建/撤销/阻塞/唤醒</strong> 等功能</li>
<li><strong>进程通信</strong>：完成进程之间的 <strong>消息传递/信号传递</strong> 等功能</li>
<li><strong>内存管理</strong>：完成内存的 <strong>分配/回收</strong> 等功能</li>
</ul>
</li>
</ul>
<p>拓展：感兴趣的同学可以搜索“Linux 系统调用”，了解 Linux 操作系统提供了哪些系统调用</p>
<hr>
<ul>
<li><strong><u>系统调用的过程</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-36-59.png" alt=""></p>
<p>传递系统调用参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 执行陷入指令（<strong>用户态</strong>，陷入指令是非特权指令） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>  执行相应的内请求核程序处理系统调用（<strong>核心态</strong>） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 返回 应用程序<br>
注意：<br>
1.陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态<br>
2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</p>
<p>注意别名： 陷入指令 = trap 指令 = 访管指令</p>
<hr>
<h2 id="1-4-1-操作系统的体系结构（上）">1.4.1 操作系统的体系结构（上）</h2>
<ul>
<li><strong><u>操作系统的内核</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-43-27.png" alt="">·</p>
<p><strong>内核</strong>是计算机上配置的底层<strong>软件</strong>，是操作系统最基本、最核心的部分。<br>
实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-45-33.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-46-56.png" alt=""></p>
<p>注意：<br>
操作系统<strong>内核</strong>需要运行在<strong>内核态</strong><br>
操作系统的<strong>非内核</strong>功能运行在<strong>用户态</strong></p>
<p>一个故事：现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_11-58-30.png" alt=""></p>
<p>注意：变态的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能<br>
【注意：“变态”在这里是口头表述，考试应该正规表述，例如“状态改变”】</p>
<hr>
<ul>
<li><strong><u>操作系统的体系结构</u></strong>
<ul>
<li>大内核
<ul>
<li>将操作系统的主要功能模块作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核
<ul>
<li>只把最基本功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>典型的大内核/宏内核/单内核 操作系统： Linux、UNIX<br>
典型的 微内核 操作系统： Windows NT</p>
<p>类比：<br>
操作系统的体系结构问题与企业的管理问题很相似。<br>
<strong>内核</strong>就是企业的<strong>管理层</strong>，负责一些重要的工作。只有管理层才能执行<strong>特权指令</strong>，普通员工只能执行<strong>非特权指令</strong>。<strong>用户态</strong>、<strong>核心态</strong>之间的切换相当于普通员工和管理层之间的工作交接<br>
<strong>大内核</strong>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。<br>
<strong>微内核</strong>：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p>
<hr>
<h2 id="1-4-2-操作系统的体系结构（下）">1.4.2 操作系统的体系结构（下）</h2>
<blockquote>
<ul>
<li>大内核（又名：宏内核/单内核）</li>
<li>微内核</li>
<li>分层结构（新增）</li>
<li>模块化（新增）</li>
<li>外核（新增）</li>
</ul>
<p>Tips: 一定是<strong>考简单的选择题</strong>，了解各种体系结构的<strong>特性</strong>，了解各自的<strong>优缺点</strong></p>
</blockquote>
<ul>
<li><strong><u>操作系统结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_15-55-43.png" alt=""></p>
<p>【注：加星号是作者认为更容易考的，红色星号是全新的内容，黄色星号的是老内容（大内核、微内核）】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——分层结构</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-00-31.png" alt=""></p>
<p>最底层是硬件，最高层是用户接口<br>
每层可调用更低一层【不能跨层调用】</p>
<hr>
<ul>
<li><strong><u>操作系统结构——模块化</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-04-57.png" alt=""></p>
<p><strong>模块化</strong>是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为<strong>模块-接口法</strong>，上图所示为由模块、子模块等组成的模块化操作系统结构。</p>
<hr>
<ul>
<li><strong><u>操作系统结构——外核（exokernel）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-11-27.png" alt=""></p>
<hr>
<h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2>
<blockquote>
<p>操作系统引导(boot)–开机的时候怎么让操作系统运行起来?</p>
</blockquote>
<ul>
<li><strong><u>一个刚买来的磁盘（硬盘）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-25-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>安装操作系统后，操作系统引导（开机过程）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-33-54.png" alt=""></p>
<p>【注释】<br>
根目录：顾名思义，双击C盘看到的那些东西<br>
分区表：实际上是一个数据结构，记录每个盘每个分区多大、地址范围这些信息<br>
BIOS：Basic Input/Output System<br>
ROM引导程序：ROM boot 程序</p>
<p><strong>操作系统引导</strong>:<br>
① CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序 (先进行硬件自检，再开机)<br>
② 将磁盘的第一块–主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>
③ 从活动分区 (又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序<br>
④ 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作</p>
<hr>
<ul>
<li><strong><u>例: windows 操作系统的初始化程序</u></strong></li>
</ul>
<p>注：完整的操作系统初始化程序 (即 启动管理器) 可在根目录下找到<br>
Eg：windows操作系统完整的开机初始化程序在“根目录/Windows/Boot”下</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-38-37.png" alt=""></p>
<hr>
<h2 id="1-6-虚拟机">1.6 虚拟机</h2>
<ul>
<li><strong><u>传统计算机</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-42-34.png" alt=""></p>
<hr>
<ul>
<li><strong><u>虚拟机</u></strong></li>
</ul>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统</p>
<p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_16-53-47.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_17-02-17.png" alt=""></p>
<hr>
<ul>
<li><strong><u>两类虚拟机管理程序（VMM）的对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对物理资源的控制权</td>
<td>直接运行在硬件上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖Host OS为其分配物理资源</td>
</tr>
<tr>
<td style="text-align:left">资源分配方式</td>
<td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td>
<td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td>性能更好</td>
<td>性能更差，需要Host OS作为“中介”</td>
</tr>
<tr>
<td style="text-align:left">可支持虚拟机的数量</td>
<td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，Host OS本身也需要使用物力资源，Host OS上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td style="text-align:left">虚拟机的可迁移性</td>
<td>更差</td>
<td>更好，只需要导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛</td>
</tr>
<tr>
<td style="text-align:left">运行模式</td>
<td>第一类VMM运行在最高权限级（Ring 0），可以执行最高权限指令</td>
<td>第二类VMM部分运行在用户态，部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用</td>
</tr>
</tbody>
</table>
<hr>
<h1>第二章 进程与线程</h1>
<h2 id="2-1-1-进程的概念、组成、特征">2.1.1 进程的概念、组成、特征</h2>
<ul>
<li><strong><u>进程的概念</u></strong></li>
</ul>
<p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的 可执行文件，就是一系列的指令集合。<br>
进程（Process）：是<strong>动态的</strong>，是程序的一 次执行过程 同一个程序多 次执行会对应 多个进程</p>
<hr>
<ul>
<li><strong><u>进程的组成——PCB</u></strong></li>
</ul>
<p>思考：操作系统是这些进程的管理者，它要怎么区分各个进程？<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> 当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <strong>PID</strong>（Process ID，进程ID）</p>
<ol>
<li>操作系统要记录PID、进程所属用户ID（UID）<br>
【基本的进程描述信息，可以让操作系统区分各个进程】</li>
<li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）<br>
【可用于实现操作系统对资源的管理】</li>
<li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）<br>
【可用于实现操作系统对进程的控制、调度】</li>
<li>这些信息都被保存在一个数据结构<strong>PCB</strong> （Process Control Block）中，即<strong>进程控制块</strong><br>
操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong></li>
</ol>
<p>【总结】：</p>
<ul>
<li><strong>进程控制块（PCB）</strong> ：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
<ul>
<li><strong>进程描述信息</strong>
<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><strong>进程控制和管理信息</strong>
<ul>
<li>CPU、磁盘、网络流量使用情况统计…</li>
<li>进程当前状态：就绪态 / 阻塞态 / 运行态…</li>
</ul>
</li>
<li><strong>资源分配清单</strong>
<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I/O设备</li>
</ul>
</li>
<li><strong>处理机相关信息</strong>
<ul>
<li>如PSW，PC等等各种寄存器的值（用于实现进程切换）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统对进程进行管理工作所需的信息都存在PCB中</p>
<hr>
<ul>
<li><u><strong>进程的组成——程序段、数据段</strong></u>
<ul>
<li><strong>PCB</strong>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PCB</strong> 是<strong>给操作系统用的</strong>。<br>
<strong>程序段、数据段</strong>是<strong>给进程自己用的</strong>。</p>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>一条高级语言的代码翻译过来可能会对应多条机器指令<br>
程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-07-33.png" alt=""></p>
<p>一个<strong>进程实体（进程映像）</strong> 由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。 <strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong> 是<strong>静态</strong>的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）</p>
<hr>
<ul>
<li><u><strong>进程的组成</strong></u>【更确切的说，应该 是“进程实体(进程 映像)的组成”】
<ul>
<li><strong>PCB</strong>【PCB 是给操作系统用的】
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li><strong>程序段</strong>
<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li><strong>数据段</strong>
<ul>
<li>运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【程序段、数据段是给进程自己用的， 与进程自身的运行逻辑有关】<br>
【同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）】</p>
<p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong> 引入进程实体的概念后，<br>
可把<strong>进程定义为</strong>： 进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。<br>
【一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行】</p>
<p>注意：PCB是进程存在的唯一标志！</p>
<hr>
<ul>
<li><strong><u>进程的特征</u></strong></li>
</ul>
<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<ol>
<li><strong>动态性</strong>【动态性是进程最基本的特征】<br>
进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性</strong><br>
内存中有多个实体进程，各进程可并发执行</li>
<li><strong>独立性</strong><br>
进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li><strong>异步性</strong><br>
各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li><strong>结构性</strong><br>
每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<hr>
<h2 id="2-1-2-进程的状态与转换、进程的组织">2.1.2 进程的状态与转换、进程的组织</h2>
<ul>
<li><u><strong>进程的状态——创建态、就绪态</strong></u></li>
</ul>
<p>进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<p>当进程创建完成后，便进入“<strong>就绪态</strong>”， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行</p>
<hr>
<ul>
<li><strong><u>进程的状态——运行态</u></strong></li>
</ul>
<p>系统中可能会有很多个进程都处于就绪态；</p>
<p>当CPU空闲时，操作系统就会选择一个就绪进程， 让它上处理机运行；</p>
<p>如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”。 CPU会执行该进程对应的程序（执行指令序列）</p>
<hr>
<ul>
<li><strong><u>进程的状态——阻塞态</u></strong></li>
</ul>
<p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p>
<p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”</p>
<p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p>
<hr>
<ul>
<li><u><strong>进程的状态——终止态</strong></u></li>
</ul>
<p>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。</p>
<p>此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。</p>
<p>当终止进程的工作完成之后，这个进程就彻底消失了。</p>
<hr>
<ul>
<li><strong><u>进程状态的转换</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_21-37-42.png" alt=""></p>
<p><strong>注意：不能由阻塞态直接转换为运行态， 也不能由就绪态直接转换为阻塞态</strong>（因为 进入阻塞态是进程主动请求的，必然需要 进程在运行时才能发出这种请求）</p>
<hr>
<ul>
<li><strong><u>进程的状态</u></strong>
<ul>
<li><strong>三种基本状态</strong>【进程的整个生命周期 中，大部分时间都处 于三种基本状态】
<ul>
<li>运行态（Running）【单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态】<br>
占有CPU，并在CPU上运行</li>
<li>就绪态（Ready）<br>
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>
<li>阻塞态（Waiting / Blocked，又称：等待态）<br>
因等待某一事件而暂时不能运行</li>
</ul>
</li>
<li>另外两种状态
<ul>
<li>创建态（New，又称：新建态）<br>
进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（Terminated，又称：结束态）<br>
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>进程PCB中，会有一个变量 state 来表示进程的当前状态</strong>。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<hr>
<ul>
<li><strong><u>进程的组织——链接方式</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-03-39.png" alt=""></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-04-35.png" alt=""></p>
<hr>
<ul>
<li><u><strong>进程的组织——索引方式</strong></u></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-05-33.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程的组织</u></strong>
<ul>
<li><strong>链接方式</strong>
<ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><strong>索引方式</strong>
<ul>
<li>根据进程状态不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大多数操作系统使用链接方式【</p>
<hr>
<h2 id="2-1-3-进程控制">2.1.3 进程控制</h2>
<ul>
<li><strong><u>什么是进程控制？</u></strong></li>
</ul>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<p>简化理解：反正进程控制就是要实现进程状态转换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-15-07.png" alt=""></p>
<hr>
<ul>
<li><strong><u>如何实现进程控制？</u></strong></li>
</ul>
<p>用“原语”实现【第一章提到了】</p>
<p>原语的执行具有“原子性”，一气呵成</p>
<p>思考：为何进程控制（状态转 换）的过程要“一气呵成”？<br>
如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作</p>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…<br>
假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：<br>
①将PCB2的 state 设为 1<br>
②将PCB2从阻塞队列放到就绪队列</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-22-47.png" alt=""></p>
<p>但是完成了第一步后收到中断信号，CPU处理中断去了，那么这个时候PCB2 的state=1，但是它却还在阻塞队列里。</p>
<hr>
<ul>
<li><strong><u>如何实现原语的“原子性”？</u></strong></li>
</ul>
<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。<br>
可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权指令</strong>实现<strong>原子性</strong></p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-04_23-28-05.png" alt=""></p>
<p>如上图：<br>
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</p>
<p>这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子 性”</p>
<p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？<br>
假设用户直接在程序开头设置关中断，在程序尾设置开中断，那么这个程序执行时将不能被打断，一直霸占资源，这是不合理的。</p>
<hr>
<ul>
<li><strong><u>进程控制相关的原语</u></strong></li>
</ul>
<ol>
<li><strong>进程的创建</strong>
<ul>
<li><strong>创建原语</strong>【操作系统创建一个进程时使用的原语】
<ul>
<li>申请空白PCB</li>
<li>为新的进程分配资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列【创建态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录<br>
分时系统中，用户登录成功，系统会为其创建一个新的进程</li>
<li>作业调度<br>
多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务<br>
用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求<br>
由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的终止</strong>
<ul>
<li><strong>撤销原语</strong>【就绪态/阻塞态/运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 终止态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 无】
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程【进程间的关系是树形结构】</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束【进程自己请求终止（exit系统调用）】</li>
<li>异常结束【整数除以0、非法使用特权指令， 然后被操作系统强行杀掉】</li>
<li>外界干预【Ctrl+Alt+delete，用户选择杀掉进程】</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>3.阻塞原语、4.唤醒原语必须成对使用</p>
<ol start="3">
<li><strong>进程的阻塞</strong>
<ul>
<li><strong>阻塞原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 阻塞态】
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li><strong>保护进程运行现场</strong>，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的唤醒</strong>
<ul>
<li><strong>唤醒原语</strong>【阻塞态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态】
<ul>
<li>在事件等待队列找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生【因何事阻塞，就应由何事唤醒】</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的切换</strong>
<ul>
<li><strong>切换原语</strong>【运行态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 就绪态、就绪态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 运行态】
<ul>
<li>将<strong>运行环境信息</strong>【进程上下文（Context ）】存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>新进程所需的运行环境</strong></li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>知识滚雪球：程序是如何运行的？</u></strong></li>
</ul>
<p>【上接：2.1.1 进程的概念、组成、特征 中的知识滚雪球】</p>
<p>CPU中会设置很多 “寄存器”，用来存放程序运行过程中所需的某些数据。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSW</td>
<td>程序状态字寄存器</td>
</tr>
<tr>
<td>PC</td>
<td>程序计数器，存放下一条指令的地址</td>
</tr>
<tr>
<td>IR</td>
<td>指令寄存器，存放当前正在执行的指令</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>其他一些必 要信息</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<table>
 <tr>
     <td>
         int x = 1;</br>
x++;</br>
…… </br></br>
         指令1: 往内存中某个地方写入变量x的值</br>
指令2: 把变量x的值放到某个寄存器中</br>
指令3: 寄存器中的数值+1</br>
指令4: 把寄存器的值写回变量x的存放位置</br>
……</br>
     </td>
    </tr>  
</table>
<p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p>
<p>思考：执行完指令3后， 另一个进程开始上CPU运行。<br>
注意：另一个进程在运行过程中也会使用各个寄存器<br>
灵魂拷问：之后还怎么切换回之前的进程？？？？</p>
<p>解决办法：在进程切换时<strong>先在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<br>
当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong></p>
<hr>
<ul>
<li><strong><u>学习技巧</u></strong></li>
</ul>
<p>进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：</p>
<ol>
<li>更新PCB中的信息
<ul>
<li>a. 所有的进程控制原语一定都会修改进程状态标志</li>
<li>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>c. 某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<hr>
<h2 id="2-1-4-进程通信">2.1.4 进程通信</h2>
<ul>
<li><strong><u>什么是进程通信？</u></strong><br>
进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-27-27.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong><u>为什么进程通信需要操作系统支持？</u></strong></li>
</ul>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-30-11.png" alt=""></p>
<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<p>下面将介绍三种进程通信方式：<strong>1. 共享存储、2. 消息传递、3. 管道通信</strong></p>
<hr>
<ul>
<li><strong><u>进程通信——共享存储</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-36-25.png" alt=""></p>
<p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。<br>
各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作【后面介绍】)</p>
<p>linux中，如何实现共享内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(...)</span>	<span class="comment">// 通过 shm_open 系统调用，申请一片共享内存区</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(...)</span>	<span class="comment">// 通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中(第三章内容)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>共享存储</strong>：</p>
<ul>
<li><strong>基于数据结构</strong>的共享：<br>
比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种<strong>低级通信</strong>方式</li>
<li><strong>基于存储区</strong>的共享：<br>
在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递</u></strong></li>
</ul>
<p>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-44-02.png" alt=""></p>
<p>消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<p><strong>消息传递</strong>：</p>
<ul>
<li><strong>直接通信方式</strong><br>
消息直接挂到接收进程的消息缓冲队列上</li>
<li><strong>间接通信方式</strong><br>
消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（直接通信方式）</u></strong></li>
</ul>
<p>点名道姓的消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_11-55-43.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——消息传递（间接通信方式）</u></strong></li>
</ul>
<p>以“信箱”作为中间实体进行消息传递</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-01-46.png" alt=""></p>
<hr>
<ul>
<li><strong><u>进程通信——管道通信</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-47-19.png" alt=""></p>
<p>那么管道通信和进程通信又有什么区别呢？<br>
管道通信读写要求先进先出（循环队列）；而共享存储存取没有要求，都行</p>
<ol>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。 （由操作系统实现）</li>
<li>当<strong>管道写满</strong>时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当<strong>管道读空</strong>时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：1、<strong>一个管道允许多个写进程，一个读进程</strong> (2014年408真题高教社官方答案)；2、允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(Linux 的方案)。</li>
</ol>
<hr>
<ul>
<li><strong><u>王道书修正</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_12-58-27.png" alt=""></p>
<hr>
<h2 id="2-1-5-线程概念-多线程模型">2.1.5 线程概念 多线程模型</h2>
<ul>
<li><strong><u>什么是线程，为什么要引入线程？</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_14-48-55.png" alt=""></p>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p>传统的进程是程序执行流的最小单位。<br>
引入线程后，线程成为了程序执行流的最小单位</p>
<p>可以把线程理解为“轻量级进程”。</p>
<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>， 也是<strong>程序执行流的最小单位</strong>。<br>
引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内 也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）</p>
<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br>
<strong>线程</strong>则作为<strong>处理机的分配单元</strong>。</p>
<hr>
<ul>
<li><strong><u>引入线程机制后，有什么变化？</u></strong></li>
</ul>
<ol>
<li><strong>资源分配、调度</strong>
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>
</ul>
</li>
<li><strong>并发性</strong>
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
</li>
<li><strong>系统开销</strong>
<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>引入线程后，并发所带来的系统开销减小</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的属性</u></strong></li>
</ul>
<ol>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块 (TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ol>
<hr>
<h2 id="2-1-6-线程的实现方式-多线程模型">2.1.6 线程的实现方式 多线程模型</h2>
<ul>
<li><strong><u>线程的实现方式——用户级线程（User-Level Thread, ULT）</u></strong></li>
</ul>
<p>历史背景：早期的操作系统（如：早期Unix）只支持进程， 不支持线程。当时的“线程”是由线程库实现的</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-01-10.png" alt=""></p>
<p>eg：将下面进程描述成如下代码</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-02-37.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;	</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; 处理视频聊天的代码 &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>	<span class="comment">// i = 0, 1, 2, 0, 1, 2...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码的角度看，线程其实就是一段代码逻辑。 上述三段代码逻辑上可以看作三个“线程”。 while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。</p>
<p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“<strong>用户级线程</strong>”就是“<strong>从用户视角看能看到的线程</strong>”</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ol>
<hr>
<ul>
<li><strong><u>线程的实现方式——内核级线程（Kernel-Level Thread, KLT”）</u></strong><br>
又称“<strong>内核支持的线程</strong>“</li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p>由操作系统支持的线程，<strong>内核级线程才是处理机分配的单位</strong></p>
<p>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</p>
<p>【问题：】<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<ol>
<li>线程的管理工作由谁来完成？</li>
<li>线程切换是否需要CPU变态？</li>
<li>操作系统是否能意识到用户级线程的存在？</li>
<li>这种线程的实现方式有什么优点和缺点？</li>
</ol>
<p>【答：】</p>
<ol>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块）， 通过TCB对线程进行管理。“<strong>内核级线程</strong>”就是“<strong>从操作系统内核视角看能看到的线程</strong>”</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>
缺点：一个用户进程会占用多个内核级线程，内核级线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ol>
<hr>
<ul>
<li><strong><u>多线程模型</u></strong><br>
在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关 系，可以划分为几种多线程模型</li>
</ul>
<p><strong>重点重点重点</strong>： 操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</p>
<p><strong>一对一</strong>模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-24-23.png" alt=""></p>
<p><strong>多对一</strong>模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-06.png" alt=""></p>
<p>多对多模型：n 用户及线程映射到 m 个内核级 线程（n &gt;= m）。每个用户进程对应 m 个内核 级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-28-11.png" alt=""></p>
<p>可以这么理解：<br>
用户级线程是“代码逻辑”的载体<br>
内核级线程是“运行机会”的载体<br>
【<strong>内核级线程才是处理机分配的单位</strong>。例如：多核 CPU环境下，上图这个进程最多能被分配两个核。】</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU执行<br>
【内核级线程中可以运行任意一个有映射关系的用户级线程代码，如上图，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞】</p>
<hr>
<h2 id="2-1-7-线程的状态与转换">2.1.7 线程的状态与转换</h2>
<ul>
<li><strong><u>线程的状态与转换</u></strong></li>
</ul>
<p>下面与进程完全一致</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<hr>
<ul>
<li><strong><u>线程的组织与控制</u></strong></li>
</ul>
<p>类似于进程</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-40-03.png" alt=""></p>
<p>组织：</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-41-19.png" alt=""></p>
<hr>
<h2 id="2-2-1-调度的概念、层次">2.2.1 调度的概念、层次</h2>
<ul>
<li><strong><u>调度的概念</u></strong></li>
</ul>
<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——高级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-49-48.png" alt=""></p>
<p>作业：一个具体的任务<br>
用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""></p>
<p>内存空间有限，有时无法将用户提交的作业全部放入内存</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span> <strong>高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。<br>
【简化理解：好几个程序需要启动，到底先启动哪个】</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——低级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-50-23.png" alt=""></p>
<p><strong>低级调度（进程调度/处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>
<hr>
<ul>
<li><strong><u>调度的三个层次——中级调度</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-53-15.png" alt=""></p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p>
<p><strong>中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。<br>
一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</p>
<hr>
<ul>
<li><strong><u>补充知识：进程的挂起态与七状态模型</u></strong></li>
</ul>
<p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong><br>
挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p>
<p>五状态模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>七状态模型：【看学校怎么考】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-00-41.png" alt=""></p>
<p>注意“挂起”和“阻塞”的区别，两种 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。<br>
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<hr>
<ul>
<li><strong><u>三层调度的联系、对比</u></strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>要做什么</th>
<th style="text-align:center">调度发生在…</th>
<th style="text-align:center">发生频率</th>
<th style="text-align:center">对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高级调度<br />（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向作业）</td>
<td style="text-align:center">最低</td>
<td style="text-align:center">无<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>创建态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态</td>
</tr>
<tr>
<td style="text-align:center">中级调度<br />（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td style="text-align:center">外存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>内存<br />（面向进程）</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">挂起态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态 <br />（阻塞挂起<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态）</td>
</tr>
<tr>
<td style="text-align:center">低级调度<br />（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td style="text-align:center">内存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>CPU</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">就绪态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>运行态</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-2-2-进程调度的时机、切换与过程调度方式">2.2.2 进程调度的时机、切换与过程调度方式</h2>
<ul>
<li><strong><u>进程调度的时机</u></strong></li>
</ul>
<p><strong>进程调度</strong>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p><strong>需要进行</strong>进程调度与切换的情况：</p>
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如 等待I/O）</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p><strong>不能进行</strong>进程调度与切 换的情况：</p>
<ol>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中。<br>
【但是进程在普通临界区中是可以进行调度和切换的】</li>
<li>在<strong>原子操作过程中</strong>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<p>【考题：】<br>
【对】进程在操作系统内核程序临界区中不能进行调度与切换<br>
【错】（2012年联考真题）进程处于临界区时不能进行处理机调度<br>
<img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-10-56.png" alt=""><br>
首先要知道：<br>
临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>
临界区：访问临界资源的那段代码。<br>
<strong>内核程序临界区</strong>一般是用来<strong>访问某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成)</p>
<p>【eg:】</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-24-53.png" alt=""></p>
<p>如果还没退出临界区 (还没解锁 )就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_16-25-07.png" alt=""></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<hr>
<ul>
<li><strong><u>进程调度的方式</u></strong></li>
</ul>
<p>有的系统中，只允许进程主动放弃处理机<br>
有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br>
【实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统】</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>
【可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统】</li>
</ul>
<hr>
<ul>
<li><strong><u>进程的切换与过程</u></strong></li>
</ul>
<p>“狭义的进程调度”与“进程切换”的区别：<br>
<strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程， 也可能是另一个进程，后一种情况就需要进程切换）<br>
<strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<hr>
<h2 id="2-2-3-调度器和闲逛程序">2.2.3 调度器和闲逛程序</h2>
<ul>
<li><strong><u>调度器/调度程序（scheduler）</u></strong></li>
</ul>
<p><img src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-05_15-36-51.png" alt=""></p>
<p>上图中，2和3由调度程序引起，调度程序决定:</p>
<p>让谁运行?——调度算法<br>
运行多长时间?——时间片大小</p>
<p>调度时机——什么事件会触发“调度程序” ?</p>
<ul>
<li><strong>创建新进程</strong></li>
<li><strong>进程退出</strong></li>
<li>运行<strong>进程阻塞</strong></li>
<li><strong>l/O中断</strong>发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li>
<li>抢占式调度策略，每个<strong>时钟中断</strong>或k个时钟中断会触发调度程序工作</li>
</ul>
<p>不支持内核级线程的操作系统，调度程序的处理对象是进程<br>
支持内核级线程的操作系统，调度程序的处理对象是内核线程</p>
<hr>
<ul>
<li><strong><u>闲逛进程</u></strong></li>
</ul>
<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程(idle)</p>
<p>闲逛进程的<strong>特性</strong>:</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<hr>
<h2 id="2-2-4-调度算法的评价指标">2.2.4 调度算法的评价指标</h2>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</blockquote>
<ul>
<li><strong><u>CPU利用率</u></strong></li>
</ul>
<p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong></p>
<p><strong>CPU利用率</strong>：指CPU “忙碌”的时间占总时间的比例。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">CPU利用率 = \frac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【有的题目还会要求计 算某种设备的利用率】</p>
<p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒， 再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中， CPU利用率、打印机利用率分别是多少？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>利用率</mtext><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU利用率=\frac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>打印机利用率</mtext><mo>=</mo><mfrac><mn>5</mn><mn>15</mn></mfrac><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">打印机利用率=\frac{5}{15}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">打印机利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span><br>
【通常会考察多道程序并发 执行的情况，可以用“甘 特图”来辅助计算】</p>
<hr>
<ul>
<li><u><strong>系统吞吐量</strong></u></li>
</ul>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<br>
<strong>系统吞吐量</strong>：单位时间内完成作业的数量</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐率</mtext><mo>=</mo><mfrac><mtext>总共完成了多少作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐率 = \frac{总共完成了多少作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<br>
10/100 = 0.1 道/秒</p>
<hr>
<ul>
<li><strong><u>周转时间</u></strong></li>
</ul>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br>
<strong>周转时间</strong>，是指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。<br>
它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（作业）周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">（作业）周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（作业）周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>
【对于用户来说，更关心自 己的单个作业的周转时间】</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间 = \frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
【对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值】</p>
<p>【思考】有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<br>
eg：等待1分钟，执行10分钟；等待10分钟，运行1分钟。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间 = \frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<hr>
<ul>
<li><strong><u>等待时间</u></strong></li>
</ul>
<p>计算机的用户希望自己的作业尽可能少的等待处理机<br>
<strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业在后备队列等待被服务（调度）<br>
作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候</p>
<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>
对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</p>
<hr>
<ul>
<li><strong><u>响应时间</u></strong></li>
</ul>
<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>
<hr>
<h1>第三章 内存管理</h1>
<h1>第四章 内存管理</h1>
<h1>第五章 输入/输出（I/O）管理</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io">ggw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://ggw2021.github.io/2023/05/03/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ggw2021.github.io" target="_blank">ggw和xpl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/os/Snipaste_2023-05-03_19-11-17.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-03-06.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" target="_blank"><img class="post-qr-code-img" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/blogs/Snipaste_2023-01-05_13-04-50.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">王道计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/12/%E4%BA%8C%E5%8F%89%E6%A0%91x/"><img class="next-cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/aandds/snipaste20230128_112429.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/03/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="王道计算机网络"><img class="cover" src="/static/imgs/loading.gif" data-original="https://cdn.staticaly.com/gh/ggw2021/images@main/courses/cn/Snipaste_2023-01-29_02-11-11.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">王道计算机网络</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1.1 操作系统的概念、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.1.2 操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 操作系统的发展与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3.1 操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">1.3.2 中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.3.3 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">1.4.1 操作系统的体系结构（上）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">1.4.2 操作系统的体系结构（下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-text">1.5 操作系统的引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.1.2 进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.5 线程概念 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.6 线程的实现方式 多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.7 线程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 调度的概念、层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机、切换与过程调度方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E9%97%B2%E9%80%9B%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.2.3 调度器和闲逛程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.4 调度算法的评价指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第五章 输入&#x2F;输出（I&#x2F;O）管理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(112, 112, 112)"><div id="footer-wrap"><div class="copyright">&copy;2023 By ggw</div><div class="footer_custom_text">都是科技与狠活啊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QvVqZWBQWj9Aq2xrw4Z8z8Pz-gzGzoHsz',
      appKey: 'COANudzj20V6IrCfAsD1Ufya',
      avatar: 'robohash',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>